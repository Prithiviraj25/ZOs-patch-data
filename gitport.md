\[ { "Wrong_code": """ # The default target of this Makefile is...
all::

```
            # Import tree-wide shared Makefile behavior and libraries
            include shared.mak

            # == Makefile defines ==
            #
            # These defines change the behavior of the Makefile itself, but have
            # no impact on what it builds:
            #
            # Define V=1 to have a more verbose compile.
            #
            # == Portability and optional library defines ==
            #
            # These defines indicate what Git can expect from the OS, what
            # libraries are available etc. Much of this is auto-detected in
            # config.mak.uname, or in configure.ac when using the optional "make
            # configure && ./configure" (see INSTALL).
            #
            # Define SHELL_PATH to a POSIX shell if your /bin/sh is broken.
            #
            # Define SANE_TOOL_PATH to a colon-separated list of paths to prepend
            # to PATH if your tools in /usr/bin are broken.
            #
            # Define SOCKLEN_T to a suitable type (such as 'size_t') if your
            # system headers do not define a socklen_t type.
            #
            # Define INLINE to a suitable substitute (such as '__inline' or '') if git
            # fails to compile with errors about undefined inline functions or similar.
            #
            # Define SNPRINTF_RETURNS_BOGUS if you are on a system which snprintf()
            # or vsnprintf() return -1 instead of number of characters which would
            # have been written to the final string if enough space had been available.
            #
            # Define FREAD_READS_DIRECTORIES if you are on a system which succeeds
            # when attempting to read from an fopen'ed directory (or even to fopen
            # it at all).
            #
            # Define OPEN_RETURNS_EINTR if your open() system call may return EINTR
            # when a signal is received (as opposed to restarting).
            #
            # Define NO_OPENSSL environment variable if you do not have OpenSSL.
            #
            # Define HAVE_ALLOCA_H if you have working alloca(3) defined in that header.
            #
            # Define HAVE_PATHS_H if you have paths.h and want to use the default PATH
            # it specifies.
            #
            # Define NO_D_TYPE_IN_DIRENT if your platform defines DT_UNKNOWN but lacks
            # d_type in struct dirent (Cygwin 1.5, fixed in Cygwin 1.7).
            #
            # Define HAVE_STRINGS_H if you have strings.h and need it for strcasecmp.
            #
            # Define NO_STRCASESTR if you don't have strcasestr.
            #
            # Define NO_MEMMEM if you don't have memmem.
            #
            # Define NO_GETPAGESIZE if you don't have getpagesize.
            #
            # Define NO_STRLCPY if you don't have strlcpy.
            #
            # Define NO_STRTOUMAX if you don't have both strtoimax and strtoumax in the
            # C library. If your compiler also does not support long long or does not have
            # strtoull, define NO_STRTOULL.
            #
            # Define NO_SETENV if you don't have setenv in the C library.
            #
            # Define NO_UNSETENV if you don't have unsetenv in the C library.
            #
            # Define NO_MKDTEMP if you don't have mkdtemp in the C library.
            #
            # Define MKDIR_WO_TRAILING_SLASH if your mkdir() can't deal with trailing slash.
            #
            # Define NO_GECOS_IN_PWENT if you don't have pw_gecos in struct passwd
            # in the C library.
            #
            # Define NO_LIBGEN_H if you don't have libgen.h.
            #
            # Define NEEDS_LIBGEN if your libgen needs -lgen when linking
            #
            # Define NO_SYS_SELECT_H if you don't have sys/select.h.
            #
            # Define NO_SYMLINK_HEAD if you never want .git/HEAD to be a symbolic link.
            # Enable it on Windows.  By default, symrefs are still used.
            #
            # Define NO_SVN_TESTS if you want to skip time-consuming SVN interoperability
            # tests.  These tests take up a significant amount of the total test time
            # but are not needed unless you plan to talk to SVN repos.
            #
            # Define NO_FINK if you are building on Darwin/Mac OS X, have Fink
            # installed in /sw, but don't want GIT to link against any libraries
            # installed there.  If defined you may specify your own (or Fink's)
            # include directories and library directories by defining CFLAGS
            # and LDFLAGS appropriately.
            #
            # Define NO_DARWIN_PORTS if you are building on Darwin/Mac OS X,
            # have DarwinPorts installed in /opt/local, but don't want GIT to
            # link against any libraries installed there.  If defined you may
            # specify your own (or DarwinPort's) include directories and
            # library directories by defining CFLAGS and LDFLAGS appropriately.
            #
            # Define NO_APPLE_COMMON_CRYPTO if you are building on Darwin/Mac OS X
            # and do not want to use Apple's CommonCrypto library.  This allows you
            # to provide your own OpenSSL library, for example from MacPorts.
            #
            # Define NEEDS_CRYPTO_WITH_SSL if you need -lcrypto when using -lssl (Darwin).
            #
            # Define NEEDS_SSL_WITH_CRYPTO if you need -lssl when using -lcrypto (Darwin).
            #
            # Define NEEDS_LIBICONV if linking with libc is not enough (Darwin).
            #
            # Define NEEDS_LIBINTL_BEFORE_LIBICONV if you need libintl before libiconv.
            #
            # Define NO_INTPTR_T if you don't have intptr_t or uintptr_t.
            #
            # Define NO_UINTMAX_T if you don't have uintmax_t.
            #
            # Define NEEDS_SOCKET if linking with libc is not enough (SunOS,
            # Patrick Mauritz).
            #
            # Define NEEDS_RESOLV if linking with -lnsl and/or -lsocket is not enough.
            # Notably on Solaris hstrerror resides in libresolv and on Solaris 7
            # inet_ntop and inet_pton additionally reside there.
            #
            # Define NO_MMAP if you want to avoid mmap.
            #
            # Define MMAP_PREVENTS_DELETE if a file that is currently mmapped cannot be
            # deleted or cannot be replaced using rename().
            #
            # Define NO_POLL_H if you don't have poll.h.
            #
            # Define NO_SYS_POLL_H if you don't have sys/poll.h.
            #
            # Define NO_POLL if you do not have or don't want to use poll().
            # This also implies NO_POLL_H and NO_SYS_POLL_H.
            #
            # Define NEEDS_SYS_PARAM_H if you need to include sys/param.h to compile,
            # *PLEASE* REPORT to git@vger.kernel.org if your platform needs this;
            # we want to know more about the issue.
            #
            # Define NO_PTHREADS if you do not have or do not want to use Pthreads.
            #
            # Define NO_PREAD if you have a problem with pread() system call (e.g.
            # cygwin1.dll before v1.5.22).
            #
            # Define NO_SETITIMER if you don't have setitimer()
            #
            # Define NO_STRUCT_ITIMERVAL if you don't have struct itimerval
            # This also implies NO_SETITIMER
            #
            # Define NO_FAST_WORKING_DIRECTORY if accessing objects in pack files is
            # generally faster on your platform than accessing the working directory.
            #
            # Define NO_TRUSTABLE_FILEMODE if your filesystem may claim to support
            # the executable mode bit, but doesn't really do so.
            #
            # Define CSPRNG_METHOD to "arc4random" if your system has arc4random and
            # arc4random_buf, "libbsd" if your system has those functions from libbsd,
            # "getrandom" if your system has getrandom, "getentropy" if your system has
            # getentropy, "rtlgenrandom" for RtlGenRandom (Windows only), or "openssl" if
            # you'd want to use the OpenSSL CSPRNG.  You may set multiple options with
            # spaces, in which case a suitable option will be chosen.  If unset or set to
            # anything else, defaults to using "/dev/urandom".
            #
            # Define NEEDS_MODE_TRANSLATION if your OS strays from the typical file type
            # bits in mode values (e.g. z/OS defines I_SFMT to 0xFF000000 as opposed to the
            # usual 0xF000).
            #
            # Define NO_IPV6 if you lack IPv6 support and getaddrinfo().
            #
            # Define NO_UNIX_SOCKETS if your system does not offer unix sockets.
            #
            # Define NO_SOCKADDR_STORAGE if your platform does not have struct
            # sockaddr_storage.
            #
            # Define NO_ICONV if your libc does not properly support iconv.
            #
            # Define OLD_ICONV if your library has an old iconv(), where the second
            # (input buffer pointer) parameter is declared with type (const char **).
            #
            # Define ICONV_OMITS_BOM if your iconv implementation does not write a
            # byte-order mark (BOM) when writing UTF-16 or UTF-32 and always writes in
            # big-endian format.
            #
            # Define NO_DEFLATE_BOUND if your zlib does not have deflateBound.
            #
            # Define NO_NORETURN if using buggy versions of gcc 4.6+ and profile feedback,
            # as the compiler can crash (https://gcc.gnu.org/bugzilla/show_bug.cgi?id=49299)
            #
            # Define USE_NSEC below if you want git to care about sub-second file mtimes
            # and ctimes. Note that you need recent glibc (at least 2.2.4) for this. On
            # Linux, kernel 2.6.11 or newer is required for reliable sub-second file times
            # on file systems with exactly 1 ns or 1 s resolution. If you intend to use Git
            # on other file systems (e.g. CEPH, CIFS, NTFS, UDF), don't enable USE_NSEC. See
            # Documentation/technical/racy-git.txt for details.
            #
            # Define USE_ST_TIMESPEC if your "struct stat" uses "st_ctimespec" instead of
            # "st_ctim"
            #
            # Define NO_NSEC if your "struct stat" does not have "st_ctim.tv_nsec"
            # available.  This automatically turns USE_NSEC off.
            #
            # Define USE_STDEV below if you want git to care about the underlying device
            # change being considered an inode change from the update-index perspective.
            #
            # Define NO_ST_BLOCKS_IN_STRUCT_STAT if your platform does not have st_blocks
            # field that counts the on-disk footprint in 512-byte blocks.
            #
            # Define USE_ASCIIDOCTOR to use Asciidoctor instead of AsciiDoc to build the
            # documentation.
            #
            # Define ASCIIDOCTOR_EXTENSIONS_LAB to point to the location of the Asciidoctor
            # Extensions Lab if you have it available.
            #
            # Define PERL_PATH to the path of your Perl binary (usually /usr/bin/perl).
            #
            # Define NO_PERL if you do not want Perl scripts or libraries at all.
            #
            # Define NO_PERL_CPAN_FALLBACKS if you do not want to install bundled
            # copies of CPAN modules that serve as a fallback in case the modules
            # are not available on the system. This option is intended for
            # distributions that want to use their packaged versions of Perl
            # modules, instead of the fallbacks shipped with Git.
            #
            # Define NO_GITWEB if you do not want to build or install
            # 'gitweb'. Note that defining NO_PERL currently has the same effect
            # on not installing gitweb, but not on whether it's built in the
            # gitweb/ directory.
            #
            # Define PYTHON_PATH to the path of your Python binary (often /usr/bin/python
            # but /usr/bin/python2.7 or /usr/bin/python3 on some platforms).
            #
            # Define NO_PYTHON if you do not want Python scripts or libraries at all.
            #
            # Define NO_TCLTK if you do not want Tcl/Tk GUI.
            #
            # The TCL_PATH variable governs the location of the Tcl interpreter
            # used to optimize git-gui for your system.  Only used if NO_TCLTK
            # is not set.  Defaults to the bare 'tclsh'.
            #
            # The TCLTK_PATH variable governs the location of the Tcl/Tk interpreter.
            # If not set it defaults to the bare 'wish'. If it is set to the empty
            # string then NO_TCLTK will be forced (this is used by configure script).
            #
            # Define INTERNAL_QSORT to use Git's implementation of qsort(), which
            # is a simplified version of the merge sort used in glibc. This is
            # recommended if Git triggers O(n^2) behavior in your platform's qsort().
            #
            # Define HAVE_ISO_QSORT_S if your platform provides a qsort_s() that's
            # compatible with the one described in C11 Annex K.
            #
            # Define UNRELIABLE_FSTAT if your system's fstat does not return the same
            # information on a not yet closed file that lstat would return for the same
            # file after it was closed.
            #
            # Define OBJECT_CREATION_USES_RENAMES if your operating systems has problems
            # when hardlinking a file to another name and unlinking the original file right
            # away (some NTFS drivers seem to zero the contents in that scenario).
            #
            # Define INSTALL_SYMLINKS if you prefer to have everything that can be
            # symlinked between bin/ and libexec/ to use relative symlinks between
            # the two. This option overrides NO_CROSS_DIRECTORY_HARDLINKS and
            # NO_INSTALL_HARDLINKS which will also use symlinking by indirection
            # within the same directory in some cases, INSTALL_SYMLINKS will
            # always symlink to the final target directly.
            #
            # Define NO_CROSS_DIRECTORY_HARDLINKS if you plan to distribute the installed
            # programs as a tar, where bin/ and libexec/ might be on different file systems.
            #
            # Define NO_INSTALL_HARDLINKS if you prefer to use either symbolic links or
            # copies to install built-in git commands e.g. git-cat-file.
            #
            # Define SKIP_DASHED_BUILT_INS if you do not need the dashed versions of the
            # built-ins to be linked/copied at all.
            #
            # Define USE_NED_ALLOCATOR if you want to replace the platforms default
            # memory allocators with the nedmalloc allocator written by Niall Douglas.
            #
            # Define OVERRIDE_STRDUP to override the libc version of strdup(3).
            # This is necessary when using a custom allocator in order to avoid
            # crashes due to allocation and free working on different 'heaps'.
            # It's defined automatically if USE_NED_ALLOCATOR is set.
            #
            # Define NO_REGEX if your C library lacks regex support with REG_STARTEND
            # feature.
            #
            # Define USE_ENHANCED_BASIC_REGULAR_EXPRESSIONS if your C library provides
            # the flag REG_ENHANCED and you'd like to use it to enable enhanced basic
            # regular expressions.
            #
            # Define HAVE_DEV_TTY if your system can open /dev/tty to interact with the
            # user.
            #
            # Define JSMIN to point to JavaScript minifier that functions as
            # a filter to have gitweb.js minified.
            #
            # Define CSSMIN to point to a CSS minifier in order to generate a minified
            # version of gitweb.css
            #
            # Define DEFAULT_PAGER to a sensible pager command (defaults to "less") if
            # you want to use something different.  The value will be interpreted by the
            # shell at runtime when it is used.
            #
            # Define DEFAULT_EDITOR to a sensible editor command (defaults to "vi") if you
            # want to use something different.  The value will be interpreted by the shell
            # if necessary when it is used.  Examples:
            #
            #   DEFAULT_EDITOR='~/bin/vi',
            #   DEFAULT_EDITOR='$GIT_FALLBACK_EDITOR',
            #   DEFAULT_EDITOR='"C:\Program Files\Vim\gvim.exe" --nofork'
            #
            # Define COMPUTE_HEADER_DEPENDENCIES to "yes" if you want dependencies on
            # header files to be automatically computed, to avoid rebuilding objects when
            # an unrelated header file changes.  Define it to "no" to use the hard-coded
            # dependency rules.  The default is "auto", which means to use computed header
            # dependencies if your compiler is detected to support it.
            #
            # Define NATIVE_CRLF if your platform uses CRLF for line endings.
            #
            # Define GIT_USER_AGENT if you want to change how git identifies itself during
            # network interactions.  The default is "git/$(GIT_VERSION)".
            #
            # Define DEFAULT_HELP_FORMAT to "man", "info" or "html"
            # (defaults to "man") if you want to have a different default when
            # "git help" is called without a parameter specifying the format.
            #
            # Define GIT_TEST_INDEX_VERSION to 2, 3 or 4 to run the test suite
            # with a different indexfile format version.  If it isn't set the index
            # file format used is index-v[23].
            #
            # Define GIT_TEST_UTF8_LOCALE to preferred utf-8 locale for testing.
            # If it isn't set, fallback to $LC_ALL, $LANG or use the first utf-8
            # locale returned by "locale -a".
            #
            # Define HAVE_CLOCK_GETTIME if your platform has clock_gettime.
            #
            # Define HAVE_CLOCK_MONOTONIC if your platform has CLOCK_MONOTONIC.
            #
            # Define HAVE_SYNC_FILE_RANGE if your platform has sync_file_range.
            #
            # Define NEEDS_LIBRT if your platform requires linking with librt (glibc version
            # before 2.17) for clock_gettime and CLOCK_MONOTONIC.
            #
            # Define HAVE_BSD_SYSCTL if your platform has a BSD-compatible sysctl function.
            #
            # Define HAVE_GETDELIM if your system has the getdelim() function.
            #
            # Define FILENO_IS_A_MACRO if fileno() is a macro, not a real function.
            #
            # Define NEED_ACCESS_ROOT_HANDLER if access() under root may success for X_OK
            # even if execution permission isn't granted for any user.
            #
            # Define PAGER_ENV to a SP separated VAR=VAL pairs to define
            # default environment variables to be passed when a pager is spawned, e.g.
            #
            #    PAGER_ENV = LESS=FRX LV=-c
            #
            # to say "export LESS=FRX (and LV=-c) if the environment variable
            # LESS (and LV) is not set, respectively".
            #
            # Define TEST_SHELL_PATH if you want to use a shell besides SHELL_PATH for
            # running the test scripts (e.g., bash has better support for "set -x"
            # tracing).
            #
            # When cross-compiling, define HOST_CPU as the canonical name of the CPU on
            # which the built Git will run (for instance "x86_64").
            #
            # Define RUNTIME_PREFIX to configure Git to resolve its ancillary tooling and
            # support files relative to the location of the runtime binary, rather than
            # hard-coding them into the binary. Git installations built with RUNTIME_PREFIX
            # can be moved to arbitrary filesystem locations. RUNTIME_PREFIX also causes
            # Perl scripts to use a modified entry point header allowing them to resolve
            # support files at runtime.
            #
            # When using RUNTIME_PREFIX, define HAVE_BSD_KERN_PROC_SYSCTL if your platform
            # supports the KERN_PROC BSD sysctl function.
            #
            # When using RUNTIME_PREFIX, define PROCFS_EXECUTABLE_PATH if your platform
            # mounts a "procfs" filesystem capable of resolving the path of the current
            # executable. If defined, this must be the canonical path for the "procfs"
            # current executable path.
            #
            # When using RUNTIME_PREFIX, define HAVE_NS_GET_EXECUTABLE_PATH if your platform
            # supports calling _NSGetExecutablePath to retrieve the path of the running
            # executable.
            #
            # When using RUNTIME_PREFIX, define HAVE_ZOS_GET_EXECUTABLE_PATH if your platform
            # supports calling __getprogramdir and getprogname to retrieve the path of the
            # running executable.
            #
            # When using RUNTIME_PREFIX, define HAVE_WPGMPTR if your platform offers
            # the global variable _wpgmptr containing the absolute path of the current
            # executable (this is the case on Windows).
            #
            # INSTALL_STRIP can be set to "-s" to strip binaries during installation,
            # if your $(INSTALL) command supports the option.
            #
            # Define GENERATE_COMPILATION_DATABASE to "yes" to generate JSON compilation
            # database entries during compilation if your compiler supports it, using the
            # `-MJ` flag. The JSON entries will be placed in the `compile_commands/`
            # directory, and the JSON compilation database 'compile_commands.json' will be
            # created at the root of the repository.
            #
            # If your platform supports a built-in fsmonitor backend, set
            # FSMONITOR_DAEMON_BACKEND to the "<name>" of the corresponding
            # `compat/fsmonitor/fsm-listen-<name>.c` and
            # `compat/fsmonitor/fsm-health-<name>.c` files
            # that implement the `fsm_listen__*()` and `fsm_health__*()` routines.
            #
            # If your platform has OS-specific ways to tell if a repo is incompatible with
            # fsmonitor (whether the hook or IPC daemon version), set FSMONITOR_OS_SETTINGS
            # to the "<name>" of the corresponding `compat/fsmonitor/fsm-settings-<name>.c`
            # that implements the `fsm_os_settings__*()` routines.
            #
            # Define LINK_FUZZ_PROGRAMS if you want `make all` to also build the fuzz test
            # programs in oss-fuzz/.
            #
            # === Optional library: libintl ===
            #
            # Define NO_GETTEXT if you don't want Git output to be translated.
            # A translated Git requires GNU libintl or another gettext implementation,
            # plus libintl-perl at runtime.
            #
            # Define USE_GETTEXT_SCHEME and set it to 'fallthrough', if you don't trust
            # the installed gettext translation of the shell scripts output.
            #
            # Define HAVE_LIBCHARSET_H if you haven't set NO_GETTEXT and you can't
            # trust the langinfo.h's nl_langinfo(CODESET) function to return the
            # current character set. GNU and Solaris have a nl_langinfo(CODESET),
            # FreeBSD can use either, but MinGW and some others need to use
            # libcharset.h's locale_charset() instead.
            #
            # Define CHARSET_LIB to the library you need to link with in order to
            # use locale_charset() function.  On some platforms this needs to set to
            # -lcharset, on others to -liconv .
            #
            # Define LIBC_CONTAINS_LIBINTL if your gettext implementation doesn't
            # need -lintl when linking.
            #
            # Define NO_MSGFMT_EXTENDED_OPTIONS if your implementation of msgfmt
            # doesn't support GNU extensions like --check and --statistics
            #
            # === Optional library: libexpat ===
            #
            # Define NO_EXPAT if you do not have expat installed.  git-http-push is
            # not built, and you cannot push using http:// and https:// transports (dumb).
            #
            # Define EXPATDIR=/foo/bar if your expat header and library files are in
            # /foo/bar/include and /foo/bar/lib directories.
            #
            # Define EXPAT_NEEDS_XMLPARSE_H if you have an old version of expat (e.g.,
            # 1.1 or 1.2) that provides xmlparse.h instead of expat.h.

            # === Optional library: libcurl ===
            #
            # Define NO_CURL if you do not have libcurl installed.  git-http-fetch and
            # git-http-push are not built, and you cannot use http:// and https://
            # transports (neither smart nor dumb).
            #
            # Define CURLDIR=/foo/bar if your curl header and library files are in
            # /foo/bar/include and /foo/bar/lib directories.
            #
            # Define CURL_CONFIG to curl's configuration program that prints information
            # about the library (e.g., its version number).  The default is 'curl-config'.
            #
            # Define CURL_LDFLAGS to specify flags that you need to link when using libcurl,
            # if you do not want to rely on the libraries provided by CURL_CONFIG.  The
            # default value is a result of `curl-config --libs`.  An example value for
            # CURL_LDFLAGS is as follows:
            #
            #     CURL_LDFLAGS=-lcurl
            #
            # === Optional library: libpcre2 ===
            #
            # Define USE_LIBPCRE if you have and want to use libpcre. Various
            # commands such as log and grep offer runtime options to use
            # Perl-compatible regular expressions instead of standard or extended
            # POSIX regular expressions.
            #
            # Only libpcre version 2 is supported. USE_LIBPCRE2 is a synonym for
            # USE_LIBPCRE, support for the old USE_LIBPCRE1 has been removed.
            #
            # Define LIBPCREDIR=/foo/bar if your PCRE header and library files are
            # in /foo/bar/include and /foo/bar/lib directories.
            #
            # == SHA-1 and SHA-256 defines ==
            #
            # === SHA-1 backend ===
            #
            # ==== Security ====
            #
            # Due to the SHAttered (https://shattered.io) attack vector on SHA-1
            # it's strongly recommended to use the sha1collisiondetection
            # counter-cryptanalysis library for SHA-1 hashing.
            #
            # If you know that you can trust the repository contents, or where
            # potential SHA-1 attacks are otherwise mitigated the other backends
            # listed in "SHA-1 implementations" are faster than
            # sha1collisiondetection.
            #
            # ==== Default SHA-1 backend ====
            #
            # If no *_SHA1 backend is picked, the first supported one listed in
            # "SHA-1 implementations" will be picked.
            #
            # ==== Options common to all SHA-1 implementations ====
            #
            # Define SHA1_MAX_BLOCK_SIZE to limit the amount of data that will be hashed
            # in one call to the platform's SHA1_Update(). e.g. APPLE_COMMON_CRYPTO
            # wants 'SHA1_MAX_BLOCK_SIZE=1024L*1024L*1024L' defined.
            #
            # ==== SHA-1 implementations ====
            #
            # Define OPENSSL_SHA1 to link to the SHA-1 routines from the OpenSSL
            # library.
            #
            # Define BLK_SHA1 to make use of optimized C SHA-1 routines bundled
            # with git (in the block-sha1/ directory).
            #
            # Define APPLE_COMMON_CRYPTO_SHA1 to use Apple's CommonCrypto for
            # SHA-1.
            #
            # Define the same Makefile knobs as above, but suffixed with _UNSAFE to
            # use the corresponding implementations for unsafe SHA-1 hashing for
            # non-cryptographic purposes.
            #
            # If don't enable any of the *_SHA1 settings in this section, Git will
            # default to its built-in sha1collisiondetection library, which is a
            # collision-detecting sha1 This is slower, but may detect attempted
            # collision attacks.
            #
            # ==== Options for the sha1collisiondetection library ====
            #
            # Define DC_SHA1_EXTERNAL if you want to build / link
            # git with the external SHA1 collision-detect library.
            # Without this option, i.e. the default behavior is to build git with its
            # own built-in code (or submodule).
            #
            # Define DC_SHA1_SUBMODULE to use the
            # sha1collisiondetection shipped as a submodule instead of the
            # non-submodule copy in sha1dc/. This is an experimental option used
            # by the git project to migrate to using sha1collisiondetection as a
            # submodule.
            #
            # === SHA-256 backend ===
            #
            # ==== Security ====
            #
            # Unlike SHA-1 the SHA-256 algorithm does not suffer from any known
            # vulnerabilities, so any implementation will do.
            #
            # ==== SHA-256 implementations ====
            #
            # Define OPENSSL_SHA256 to use the SHA-256 routines in OpenSSL.
            #
            # Define NETTLE_SHA256 to use the SHA-256 routines in libnettle.
            #
            # Define GCRYPT_SHA256 to use the SHA-256 routines in libgcrypt.
            #
            # If don't enable any of the *_SHA256 settings in this section, Git
            # will default to its built-in sha256 implementation.
            #
            # == DEVELOPER defines ==
            #
            # Define DEVELOPER to enable more compiler warnings. Compiler version
            # and family are auto detected, but could be overridden by defining
            # COMPILER_FEATURES (see config.mak.dev). You can still set
            # CFLAGS="..." in combination with DEVELOPER enables, whether that's
            # for tweaking something unrelated (e.g. optimization level), or for
            # selectively overriding something DEVELOPER or one of the DEVOPTS
            # (see just below) brings in.
            #
            # When DEVELOPER is set, DEVOPTS can be used to control compiler
            # options.  This variable contains keywords separated by
            # whitespace. The following keywords are recognized:
            #
            #    no-error:
            #
            #        suppresses the -Werror that implicitly comes with
            #        DEVELOPER=1. Useful for getting the full set of errors
            #        without immediately dying, or for logging them.
            #
            #    extra-all:
            #
            #        The DEVELOPER mode enables -Wextra with a few exceptions. By
            #        setting this flag the exceptions are removed, and all of
            #        -Wextra is used.
            #
            #    no-pedantic:
            #
            #        Disable -pedantic compilation.

            # Set our default configuration.
            #
            # Among the variables below, these:
            #   gitexecdir
            #   template_dir
            #   sysconfdir
            # can be specified as a relative path some/where/else;
            # this is interpreted as relative to $(prefix) and "git" built with
            # RUNTIME_PREFIX flag will figure out (at runtime) where they are
            # based on the path to the executable.
            # Additionally, the following will be treated as relative by "git" if they
            # begin with "$(prefix)/":
            #   mandir
            #   infodir
            #   htmldir
            #   localedir
            #   perllibdir
            # This can help installing the suite in a relocatable way.

            prefix = $(HOME)
            bindir = $(prefix)/bin
            mandir = $(prefix)/share/man
            infodir = $(prefix)/share/info
            gitexecdir = libexec/git-core
            mergetoolsdir = $(gitexecdir)/mergetools
            sharedir = $(prefix)/share
            gitwebdir = $(sharedir)/gitweb
            gitwebstaticdir = $(gitwebdir)/static
            perllibdir = $(sharedir)/perl5
            localedir = $(sharedir)/locale
            template_dir = share/git-core/templates
            htmldir = $(prefix)/share/doc/git-doc
            ETC_GITCONFIG = $(sysconfdir)/gitconfig
            ETC_GITATTRIBUTES = $(sysconfdir)/gitattributes
            lib = lib
            # DESTDIR =
            pathsep = :

            bindir_relative = $(patsubst $(prefix)/%,%,$(bindir))
            mandir_relative = $(patsubst $(prefix)/%,%,$(mandir))
            infodir_relative = $(patsubst $(prefix)/%,%,$(infodir))
            gitexecdir_relative = $(patsubst $(prefix)/%,%,$(gitexecdir))
            localedir_relative = $(patsubst $(prefix)/%,%,$(localedir))
            htmldir_relative = $(patsubst $(prefix)/%,%,$(htmldir))
            perllibdir_relative = $(patsubst $(prefix)/%,%,$(perllibdir))

            export prefix bindir sharedir sysconfdir perllibdir localedir

            # Set our default programs
            CC = cc
            AR = ar
            RM = rm -f
            DIFF = diff
            TAR = tar
            FIND = find
            INSTALL = install
            TCL_PATH = tclsh
            TCLTK_PATH = wish
            XGETTEXT = xgettext
            MSGCAT = msgcat
            MSGFMT = msgfmt
            MSGMERGE = msgmerge
            CURL_CONFIG = curl-config
            GCOV = gcov
            STRIP = strip
            SPATCH = spatch

            export TCL_PATH TCLTK_PATH

            # Set our default LIBS variables
            PTHREAD_LIBS = -lpthread

            # Guard against environment variables
            BUILTIN_OBJS =
            BUILT_INS =
            COMPAT_CFLAGS =
            COMPAT_OBJS =
            XDIFF_OBJS =
            GENERATED_H =
            EXTRA_CPPFLAGS =
            FUZZ_OBJS =
            FUZZ_PROGRAMS =
            GIT_OBJS =
            LIB_OBJS =
            SCALAR_OBJS =
            OBJECTS =
            OTHER_PROGRAMS =
            PROGRAM_OBJS =
            PROGRAMS =
            EXCLUDED_PROGRAMS =
            SCRIPT_PERL =
            SCRIPT_PYTHON =
            SCRIPT_SH =
            SCRIPT_LIB =
            TEST_BUILTINS_OBJS =
            TEST_OBJS =
            TEST_PROGRAMS_NEED_X =
            THIRD_PARTY_SOURCES =
            UNIT_TEST_PROGRAMS =
            UNIT_TEST_DIR = t/unit-tests
            UNIT_TEST_BIN = $(UNIT_TEST_DIR)/bin

            # Having this variable in your environment would break pipelines because
            # you cause "cd" to echo its destination to stdout.  It can also take
            # scripts to unexpected places.  If you like CDPATH, define it for your
            # interactive shell sessions without exporting it.
            unexport CDPATH

            SCRIPT_SH += git-difftool--helper.sh
            SCRIPT_SH += git-filter-branch.sh
            SCRIPT_SH += git-merge-octopus.sh
            SCRIPT_SH += git-merge-one-file.sh
            SCRIPT_SH += git-merge-resolve.sh
            SCRIPT_SH += git-mergetool.sh
            SCRIPT_SH += git-quiltimport.sh
            SCRIPT_SH += git-request-pull.sh
            SCRIPT_SH += git-submodule.sh
            SCRIPT_SH += git-web--browse.sh

            SCRIPT_LIB += git-mergetool--lib
            SCRIPT_LIB += git-sh-i18n
            SCRIPT_LIB += git-sh-setup

            SCRIPT_PERL += git-archimport.perl
            SCRIPT_PERL += git-cvsexportcommit.perl
            SCRIPT_PERL += git-cvsimport.perl
            SCRIPT_PERL += git-cvsserver.perl
            SCRIPT_PERL += git-send-email.perl
            SCRIPT_PERL += git-svn.perl

            SCRIPT_PYTHON += git-p4.py

            # Generated files for scripts
            SCRIPT_SH_GEN = $(patsubst %.sh,%,$(SCRIPT_SH))
            SCRIPT_PERL_GEN = $(patsubst %.perl,%,$(SCRIPT_PERL))
            SCRIPT_PYTHON_GEN = $(patsubst %.py,%,$(SCRIPT_PYTHON))

            # Individual rules to allow e.g.
            # "make -C ../.. SCRIPT_PERL=contrib/foo/bar.perl build-perl-script"
            # from subdirectories like contrib/*/
            .PHONY: build-perl-script build-sh-script build-python-script
            build-perl-script: $(SCRIPT_PERL_GEN)
            build-sh-script: $(SCRIPT_SH_GEN)
            build-python-script: $(SCRIPT_PYTHON_GEN)

            .PHONY: install-perl-script install-sh-script install-python-script
            install-sh-script: $(SCRIPT_SH_GEN)
                    $(INSTALL) $^ '$(DESTDIR_SQ)$(gitexec_instdir_SQ)'
            install-perl-script: $(SCRIPT_PERL_GEN)
                    $(INSTALL) $^ '$(DESTDIR_SQ)$(gitexec_instdir_SQ)'
            install-python-script: $(SCRIPT_PYTHON_GEN)
                    $(INSTALL) $^ '$(DESTDIR_SQ)$(gitexec_instdir_SQ)'

            .PHONY: clean-perl-script clean-sh-script clean-python-script
            clean-sh-script:
                    $(RM) $(SCRIPT_SH_GEN)
            clean-perl-script:
                    $(RM) $(SCRIPT_PERL_GEN)
            clean-python-script:
                    $(RM) $(SCRIPT_PYTHON_GEN)

            SCRIPTS = $(SCRIPT_SH_GEN) \
                    $(SCRIPT_PERL_GEN) \
                    $(SCRIPT_PYTHON_GEN) \
                    git-instaweb

            ETAGS_TARGET = TAGS

            # Empty...
            EXTRA_PROGRAMS =

            # ... and all the rest that could be moved out of bindir to gitexecdir
            PROGRAMS += $(EXTRA_PROGRAMS)

            PROGRAM_OBJS += daemon.o
            PROGRAM_OBJS += http-backend.o
            PROGRAM_OBJS += imap-send.o
            PROGRAM_OBJS += sh-i18n--envsubst.o
            PROGRAM_OBJS += shell.o
            .PHONY: program-objs
            program-objs: $(PROGRAM_OBJS)

            # Binary suffix, set to .exe for Windows builds
            X =

            PROGRAMS += $(patsubst %.o,git-%$X,$(PROGRAM_OBJS))

            TEST_BUILTINS_OBJS += test-advise.o
            TEST_BUILTINS_OBJS += test-bitmap.o
            TEST_BUILTINS_OBJS += test-bloom.o
            TEST_BUILTINS_OBJS += test-bundle-uri.o
            TEST_BUILTINS_OBJS += test-cache-tree.o
            TEST_BUILTINS_OBJS += test-chmtime.o
            TEST_BUILTINS_OBJS += test-config.o
            TEST_BUILTINS_OBJS += test-crontab.o
            TEST_BUILTINS_OBJS += test-csprng.o
            TEST_BUILTINS_OBJS += test-date.o
            TEST_BUILTINS_OBJS += test-delete-gpgsig.o
            TEST_BUILTINS_OBJS += test-delta.o
            TEST_BUILTINS_OBJS += test-dir-iterator.o
            TEST_BUILTINS_OBJS += test-drop-caches.o
            TEST_BUILTINS_OBJS += test-dump-cache-tree.o
            TEST_BUILTINS_OBJS += test-dump-fsmonitor.o
            TEST_BUILTINS_OBJS += test-dump-split-index.o
            TEST_BUILTINS_OBJS += test-dump-untracked-cache.o
            TEST_BUILTINS_OBJS += test-env-helper.o
            TEST_BUILTINS_OBJS += test-example-tap.o
            TEST_BUILTINS_OBJS += test-find-pack.o
            TEST_BUILTINS_OBJS += test-fsmonitor-client.o
            TEST_BUILTINS_OBJS += test-genrandom.o
            TEST_BUILTINS_OBJS += test-genzeros.o
            TEST_BUILTINS_OBJS += test-getcwd.o
            TEST_BUILTINS_OBJS += test-hash-speed.o
            TEST_BUILTINS_OBJS += test-hash.o
            TEST_BUILTINS_OBJS += test-hashmap.o
            TEST_BUILTINS_OBJS += test-hexdump.o
            TEST_BUILTINS_OBJS += test-json-writer.o
            TEST_BUILTINS_OBJS += test-lazy-init-name-hash.o
            TEST_BUILTINS_OBJS += test-match-trees.o
            TEST_BUILTINS_OBJS += test-mergesort.o
            TEST_BUILTINS_OBJS += test-mktemp.o
            TEST_BUILTINS_OBJS += test-online-cpus.o
            TEST_BUILTINS_OBJS += test-pack-mtimes.o
            TEST_BUILTINS_OBJS += test-parse-options.o
            TEST_BUILTINS_OBJS += test-parse-pathspec-file.o
            TEST_BUILTINS_OBJS += test-partial-clone.o
            TEST_BUILTINS_OBJS += test-path-utils.o
            TEST_BUILTINS_OBJS += test-pcre2-config.o
            TEST_BUILTINS_OBJS += test-pkt-line.o
            TEST_BUILTINS_OBJS += test-proc-receive.o
            TEST_BUILTINS_OBJS += test-progress.o
            TEST_BUILTINS_OBJS += test-reach.o
            TEST_BUILTINS_OBJS += test-read-cache.o
            TEST_BUILTINS_OBJS += test-read-graph.o
            TEST_BUILTINS_OBJS += test-read-midx.o
            TEST_BUILTINS_OBJS += test-ref-store.o
            TEST_BUILTINS_OBJS += test-reftable.o
            TEST_BUILTINS_OBJS += test-regex.o
            TEST_BUILTINS_OBJS += test-rot13-filter.o
            TEST_BUILTINS_OBJS += test-repository.o
            TEST_BUILTINS_OBJS += test-revision-walking.o
            TEST_BUILTINS_OBJS += test-run-command.o
            TEST_BUILTINS_OBJS += test-scrap-cache-tree.o
            TEST_BUILTINS_OBJS += test-serve-v2.o
            TEST_BUILTINS_OBJS += test-sha1.o
            TEST_BUILTINS_OBJS += test-sha256.o
            TEST_BUILTINS_OBJS += test-sigchain.o
            TEST_BUILTINS_OBJS += test-simple-ipc.o
            TEST_BUILTINS_OBJS += test-string-list.o
            TEST_BUILTINS_OBJS += test-submodule-config.o
            TEST_BUILTINS_OBJS += test-submodule-nested-repo-config.o
            TEST_BUILTINS_OBJS += test-submodule.o
            TEST_BUILTINS_OBJS += test-subprocess.o
            TEST_BUILTINS_OBJS += test-trace2.o
            TEST_BUILTINS_OBJS += test-truncate.o
            TEST_BUILTINS_OBJS += test-userdiff.o
            TEST_BUILTINS_OBJS += test-wildmatch.o
            TEST_BUILTINS_OBJS += test-windows-named-pipe.o
            TEST_BUILTINS_OBJS += test-write-cache.o
            TEST_BUILTINS_OBJS += test-xml-encode.o

            # Do not add more tests here unless they have extra dependencies. Add
            # them in TEST_BUILTINS_OBJS above.
            TEST_PROGRAMS_NEED_X += test-fake-ssh
            TEST_PROGRAMS_NEED_X += test-tool

            TEST_PROGRAMS = $(patsubst %,t/helper/%$X,$(TEST_PROGRAMS_NEED_X))

            # List built-in command $C whose implementation cmd_$C() is not in
            # builtin/$C.o but is linked in as part of some other command.
            BUILT_INS += $(patsubst builtin/%.o,git-%$X,$(BUILTIN_OBJS))

            BUILT_INS += git-cherry$X
            BUILT_INS += git-cherry-pick$X
            BUILT_INS += git-format-patch$X
            BUILT_INS += git-fsck-objects$X
            BUILT_INS += git-init$X
            BUILT_INS += git-maintenance$X
            BUILT_INS += git-merge-subtree$X
            BUILT_INS += git-restore$X
            BUILT_INS += git-show$X
            BUILT_INS += git-stage$X
            BUILT_INS += git-status$X
            BUILT_INS += git-switch$X
            BUILT_INS += git-version$X
            BUILT_INS += git-whatchanged$X

            # what 'all' will build but not install in gitexecdir
            OTHER_PROGRAMS += git$X
            OTHER_PROGRAMS += scalar$X

            # what test wrappers are needed and 'install' will install, in bindir
            BINDIR_PROGRAMS_NEED_X += git
            BINDIR_PROGRAMS_NEED_X += scalar
            BINDIR_PROGRAMS_NEED_X += git-receive-pack
            BINDIR_PROGRAMS_NEED_X += git-shell
            BINDIR_PROGRAMS_NEED_X += git-upload-archive
            BINDIR_PROGRAMS_NEED_X += git-upload-pack

            BINDIR_PROGRAMS_NO_X += git-cvsserver

            # Set paths to tools early so that they can be used for version tests.
            ifndef SHELL_PATH
                    SHELL_PATH = /bin/sh
            endif
            ifndef PERL_PATH
                    PERL_PATH = /usr/bin/perl
            endif
            ifndef PYTHON_PATH
                    PYTHON_PATH = /usr/bin/python
            endif

            export PERL_PATH
            export PYTHON_PATH

            TEST_SHELL_PATH = $(SHELL_PATH)

            LIB_FILE = libgit.a
            XDIFF_LIB = xdiff/lib.a
            REFTABLE_LIB = reftable/libreftable.a

            GENERATED_H += command-list.h
            GENERATED_H += config-list.h
            GENERATED_H += hook-list.h
            GENERATED_H += $(UNIT_TEST_DIR)/clar-decls.h
            GENERATED_H += $(UNIT_TEST_DIR)/clar.suite

            .PHONY: generated-hdrs
            generated-hdrs: $(GENERATED_H)

            ## Exhaustive lists of our source files, either dynamically generated,
            ## or hardcoded.
            SOURCES_CMD = ( \
                    git ls-files --deduplicate \
                            '*.[hcS]' \
                            '*.sh' \
                            ':!*[tp][0-9][0-9][0-9][0-9]*' \
                            ':!contrib' \
                            2>/dev/null || \
                    $(FIND) . \
                            \( -name .git -type d -prune \) \
                            -o \( -name '[tp][0-9][0-9][0-9][0-9]*' -prune \) \
                            -o \( -name contrib -type d -prune \) \
                            -o \( -name build -type d -prune \) \
                            -o \( -name .build -type d -prune \) \
                            -o \( -name 'trash*' -type d -prune \) \
                            -o \( -name '*.[hcS]' -type f -print \) \
                            -o \( -name '*.sh' -type f -print \) \
                            | sed -e 's|^\./||' \
                    )
            FOUND_SOURCE_FILES := $(filter-out $(GENERATED_H),$(shell $(SOURCES_CMD)))

            FOUND_C_SOURCES = $(filter %.c,$(FOUND_SOURCE_FILES))
            FOUND_H_SOURCES = $(filter %.h,$(FOUND_SOURCE_FILES))

            COCCI_SOURCES = $(filter-out $(THIRD_PARTY_SOURCES),$(FOUND_C_SOURCES))

            LIB_H = $(FOUND_H_SOURCES)

            LIB_OBJS += abspath.o
            LIB_OBJS += add-interactive.o
            LIB_OBJS += add-patch.o
            LIB_OBJS += advice.o
            LIB_OBJS += alias.o
            LIB_OBJS += alloc.o
            LIB_OBJS += apply.o
            LIB_OBJS += archive-tar.o
            LIB_OBJS += archive-zip.o
            LIB_OBJS += archive.o
            LIB_OBJS += attr.o
            LIB_OBJS += base85.o
            LIB_OBJS += bisect.o
            LIB_OBJS += blame.o
            LIB_OBJS += blob.o
            LIB_OBJS += bloom.o
            LIB_OBJS += branch.o
            LIB_OBJS += bulk-checkin.o
            LIB_OBJS += bundle-uri.o
            LIB_OBJS += bundle.o
            LIB_OBJS += cache-tree.o
            LIB_OBJS += cbtree.o
            LIB_OBJS += chdir-notify.o
            LIB_OBJS += checkout.o
            LIB_OBJS += chunk-format.o
            LIB_OBJS += color.o
            LIB_OBJS += column.o
            LIB_OBJS += combine-diff.o
            LIB_OBJS += commit-graph.o
            LIB_OBJS += commit-reach.o
            LIB_OBJS += commit.o
            LIB_OBJS += compat/nonblock.o
            LIB_OBJS += compat/obstack.o
            LIB_OBJS += compat/terminal.o
            LIB_OBJS += compat/zlib-uncompress2.o
            LIB_OBJS += config.o
            LIB_OBJS += connect.o
            LIB_OBJS += connected.o
            LIB_OBJS += convert.o
            LIB_OBJS += copy.o
            LIB_OBJS += credential.o
            LIB_OBJS += csum-file.o
            LIB_OBJS += ctype.o
            LIB_OBJS += date.o
            LIB_OBJS += decorate.o
            LIB_OBJS += delta-islands.o
            LIB_OBJS += diagnose.o
            LIB_OBJS += diff-delta.o
            LIB_OBJS += diff-merges.o
            LIB_OBJS += diff-lib.o
            LIB_OBJS += diff-no-index.o
            LIB_OBJS += diff.o
            LIB_OBJS += diffcore-break.o
            LIB_OBJS += diffcore-delta.o
            LIB_OBJS += diffcore-order.o
            LIB_OBJS += diffcore-pickaxe.o
            LIB_OBJS += diffcore-rename.o
            LIB_OBJS += diffcore-rotate.o
            LIB_OBJS += dir-iterator.o
            LIB_OBJS += dir.o
            LIB_OBJS += editor.o
            LIB_OBJS += entry.o
            LIB_OBJS += environment.o
            LIB_OBJS += ewah/bitmap.o
            LIB_OBJS += ewah/ewah_bitmap.o
            LIB_OBJS += ewah/ewah_io.o
            LIB_OBJS += ewah/ewah_rlw.o
            LIB_OBJS += exec-cmd.o
            LIB_OBJS += fetch-negotiator.o
            LIB_OBJS += fetch-pack.o
            LIB_OBJS += fmt-merge-msg.o
            LIB_OBJS += fsck.o
            LIB_OBJS += fsmonitor.o
            LIB_OBJS += fsmonitor-ipc.o
            LIB_OBJS += fsmonitor-settings.o
            LIB_OBJS += gettext.o
            LIB_OBJS += git-zlib.o
            LIB_OBJS += gpg-interface.o
            LIB_OBJS += graph.o
            LIB_OBJS += grep.o
            LIB_OBJS += hash-lookup.o
            LIB_OBJS += hashmap.o
            LIB_OBJS += help.o
            LIB_OBJS += hex.o
            LIB_OBJS += hex-ll.o
            LIB_OBJS += hook.o
            LIB_OBJS += ident.o
            LIB_OBJS += json-writer.o
            LIB_OBJS += kwset.o
            LIB_OBJS += levenshtein.o
            LIB_OBJS += line-log.o
            LIB_OBJS += line-range.o
            LIB_OBJS += linear-assignment.o
            LIB_OBJS += list-objects-filter-options.o
            LIB_OBJS += list-objects-filter.o
            LIB_OBJS += list-objects.o
            LIB_OBJS += lockfile.o
            LIB_OBJS += log-tree.o
            LIB_OBJS += loose.o
            LIB_OBJS += ls-refs.o
            LIB_OBJS += mailinfo.o
            LIB_OBJS += mailmap.o
            LIB_OBJS += match-trees.o
            LIB_OBJS += mem-pool.o
            LIB_OBJS += merge-blobs.o
            LIB_OBJS += merge-ll.o
            LIB_OBJS += merge-ort.o
            LIB_OBJS += merge-ort-wrappers.o
            LIB_OBJS += merge-recursive.o
            LIB_OBJS += merge.o
            LIB_OBJS += midx.o
            LIB_OBJS += midx-write.o
            LIB_OBJS += name-hash.o
            LIB_OBJS += negotiator/default.o
            LIB_OBJS += negotiator/noop.o
            LIB_OBJS += negotiator/skipping.o
            LIB_OBJS += notes-cache.o
            LIB_OBJS += notes-merge.o
            LIB_OBJS += notes-utils.o
            LIB_OBJS += notes.o
            LIB_OBJS += object-file-convert.o
            LIB_OBJS += object-file.o
            LIB_OBJS += object-name.o
            LIB_OBJS += object.o
            LIB_OBJS += oid-array.o
            LIB_OBJS += oidmap.o
            LIB_OBJS += oidset.o
            LIB_OBJS += oidtree.o
            LIB_OBJS += pack-bitmap-write.o
            LIB_OBJS += pack-bitmap.o
            LIB_OBJS += pack-check.o
            LIB_OBJS += pack-mtimes.o
            LIB_OBJS += pack-objects.o
            LIB_OBJS += pack-revindex.o
            LIB_OBJS += pack-write.o
            LIB_OBJS += packfile.o
            LIB_OBJS += pager.o
            LIB_OBJS += parallel-checkout.o
            LIB_OBJS += parse.o
            LIB_OBJS += parse-options-cb.o
            LIB_OBJS += parse-options.o
            LIB_OBJS += patch-delta.o
            LIB_OBJS += patch-ids.o
            LIB_OBJS += path.o
            LIB_OBJS += pathspec.o
            LIB_OBJS += pkt-line.o
            LIB_OBJS += preload-index.o
            LIB_OBJS += pretty.o
            LIB_OBJS += prio-queue.o
            LIB_OBJS += progress.o
            LIB_OBJS += promisor-remote.o
            LIB_OBJS += prompt.o
            LIB_OBJS += protocol.o
            LIB_OBJS += protocol-caps.o
            LIB_OBJS += prune-packed.o
            LIB_OBJS += pseudo-merge.o
            LIB_OBJS += quote.o
            LIB_OBJS += range-diff.o
            LIB_OBJS += reachable.o
            LIB_OBJS += read-cache.o
            LIB_OBJS += rebase-interactive.o
            LIB_OBJS += rebase.o
            LIB_OBJS += ref-filter.o
            LIB_OBJS += reflog-walk.o
            LIB_OBJS += reflog.o
            LIB_OBJS += refs.o
            LIB_OBJS += refs/debug.o
            LIB_OBJS += refs/files-backend.o
            LIB_OBJS += refs/reftable-backend.o
            LIB_OBJS += refs/iterator.o
            LIB_OBJS += refs/packed-backend.o
            LIB_OBJS += refs/ref-cache.o
            LIB_OBJS += refspec.o
            LIB_OBJS += remote.o
            LIB_OBJS += replace-object.o
            LIB_OBJS += repo-settings.o
            LIB_OBJS += repository.o
            LIB_OBJS += rerere.o
            LIB_OBJS += reset.o
            LIB_OBJS += resolve-undo.o
            LIB_OBJS += revision.o
            LIB_OBJS += run-command.o
            LIB_OBJS += send-pack.o
            LIB_OBJS += sequencer.o
            LIB_OBJS += serve.o
            LIB_OBJS += server-info.o
            LIB_OBJS += setup.o
            LIB_OBJS += shallow.o
            LIB_OBJS += sideband.o
            LIB_OBJS += sigchain.o
            LIB_OBJS += sparse-index.o
            LIB_OBJS += split-index.o
            LIB_OBJS += stable-qsort.o
            LIB_OBJS += statinfo.o
            LIB_OBJS += strbuf.o
            LIB_OBJS += streaming.o
            LIB_OBJS += string-list.o
            LIB_OBJS += strmap.o
            LIB_OBJS += strvec.o
            LIB_OBJS += sub-process.o
            LIB_OBJS += submodule-config.o
            LIB_OBJS += submodule.o
            LIB_OBJS += symlinks.o
            LIB_OBJS += tag.o
            LIB_OBJS += tempfile.o
            LIB_OBJS += thread-utils.o
            LIB_OBJS += tmp-objdir.o
            LIB_OBJS += trace.o
            LIB_OBJS += trace2.o
            LIB_OBJS += trace2/tr2_cfg.o
            LIB_OBJS += trace2/tr2_cmd_name.o
            LIB_OBJS += trace2/tr2_ctr.o
            LIB_OBJS += trace2/tr2_dst.o
            LIB_OBJS += trace2/tr2_sid.o
            LIB_OBJS += trace2/tr2_sysenv.o
            LIB_OBJS += trace2/tr2_tbuf.o
            LIB_OBJS += trace2/tr2_tgt_event.o
            LIB_OBJS += trace2/tr2_tgt_normal.o
            LIB_OBJS += trace2/tr2_tgt_perf.o
            LIB_OBJS += trace2/tr2_tls.o
            LIB_OBJS += trace2/tr2_tmr.o
            LIB_OBJS += trailer.o
            LIB_OBJS += transport-helper.o
            LIB_OBJS += transport.o
            LIB_OBJS += tree-diff.o
            LIB_OBJS += tree-walk.o
            LIB_OBJS += tree.o
            LIB_OBJS += unpack-trees.o
            LIB_OBJS += upload-pack.o
            LIB_OBJS += url.o
            LIB_OBJS += urlmatch.o
            LIB_OBJS += usage.o
            LIB_OBJS += userdiff.o
            LIB_OBJS += utf8.o
            LIB_OBJS += varint.o
            LIB_OBJS += version.o
            LIB_OBJS += versioncmp.o
            LIB_OBJS += walker.o
            LIB_OBJS += wildmatch.o
            LIB_OBJS += worktree.o
            LIB_OBJS += wrapper.o
            LIB_OBJS += write-or-die.o
            LIB_OBJS += ws.o
            LIB_OBJS += wt-status.o
            LIB_OBJS += xdiff-interface.o

            BUILTIN_OBJS += builtin/add.o
            BUILTIN_OBJS += builtin/am.o
            BUILTIN_OBJS += builtin/annotate.o
            BUILTIN_OBJS += builtin/apply.o
            BUILTIN_OBJS += builtin/archive.o
            BUILTIN_OBJS += builtin/bisect.o
            BUILTIN_OBJS += builtin/blame.o
            BUILTIN_OBJS += builtin/branch.o
            BUILTIN_OBJS += builtin/bugreport.o
            BUILTIN_OBJS += builtin/bundle.o
            BUILTIN_OBJS += builtin/cat-file.o
            BUILTIN_OBJS += builtin/check-attr.o
            BUILTIN_OBJS += builtin/check-ignore.o
            BUILTIN_OBJS += builtin/check-mailmap.o
            BUILTIN_OBJS += builtin/check-ref-format.o
            BUILTIN_OBJS += builtin/checkout--worker.o
            BUILTIN_OBJS += builtin/checkout-index.o
            BUILTIN_OBJS += builtin/checkout.o
            BUILTIN_OBJS += builtin/clean.o
            BUILTIN_OBJS += builtin/clone.o
            BUILTIN_OBJS += builtin/column.o
            BUILTIN_OBJS += builtin/commit-graph.o
            BUILTIN_OBJS += builtin/commit-tree.o
            BUILTIN_OBJS += builtin/commit.o
            BUILTIN_OBJS += builtin/config.o
            BUILTIN_OBJS += builtin/count-objects.o
            BUILTIN_OBJS += builtin/credential-cache--daemon.o
            BUILTIN_OBJS += builtin/credential-cache.o
            BUILTIN_OBJS += builtin/credential-store.o
            BUILTIN_OBJS += builtin/credential.o
            BUILTIN_OBJS += builtin/describe.o
            BUILTIN_OBJS += builtin/diagnose.o
            BUILTIN_OBJS += builtin/diff-files.o
            BUILTIN_OBJS += builtin/diff-index.o
            BUILTIN_OBJS += builtin/diff-tree.o
            BUILTIN_OBJS += builtin/diff.o
            BUILTIN_OBJS += builtin/difftool.o
            BUILTIN_OBJS += builtin/fast-export.o
            BUILTIN_OBJS += builtin/fast-import.o
            BUILTIN_OBJS += builtin/fetch-pack.o
            BUILTIN_OBJS += builtin/fetch.o
            BUILTIN_OBJS += builtin/fmt-merge-msg.o
            BUILTIN_OBJS += builtin/for-each-ref.o
            BUILTIN_OBJS += builtin/for-each-repo.o
            BUILTIN_OBJS += builtin/fsck.o
            BUILTIN_OBJS += builtin/fsmonitor--daemon.o
            BUILTIN_OBJS += builtin/gc.o
            BUILTIN_OBJS += builtin/get-tar-commit-id.o
            BUILTIN_OBJS += builtin/grep.o
            BUILTIN_OBJS += builtin/hash-object.o
            BUILTIN_OBJS += builtin/help.o
            BUILTIN_OBJS += builtin/hook.o
            BUILTIN_OBJS += builtin/index-pack.o
            BUILTIN_OBJS += builtin/init-db.o
            BUILTIN_OBJS += builtin/interpret-trailers.o
            BUILTIN_OBJS += builtin/log.o
            BUILTIN_OBJS += builtin/ls-files.o
            BUILTIN_OBJS += builtin/ls-remote.o
            BUILTIN_OBJS += builtin/ls-tree.o
            BUILTIN_OBJS += builtin/mailinfo.o
            BUILTIN_OBJS += builtin/mailsplit.o
            BUILTIN_OBJS += builtin/merge-base.o
            BUILTIN_OBJS += builtin/merge-file.o
            BUILTIN_OBJS += builtin/merge-index.o
            BUILTIN_OBJS += builtin/merge-ours.o
            BUILTIN_OBJS += builtin/merge-recursive.o
            BUILTIN_OBJS += builtin/merge-tree.o
            BUILTIN_OBJS += builtin/merge.o
            BUILTIN_OBJS += builtin/mktag.o
            BUILTIN_OBJS += builtin/mktree.o
            BUILTIN_OBJS += builtin/multi-pack-index.o
            BUILTIN_OBJS += builtin/mv.o
            BUILTIN_OBJS += builtin/name-rev.o
            BUILTIN_OBJS += builtin/notes.o
            BUILTIN_OBJS += builtin/pack-objects.o
            BUILTIN_OBJS += builtin/pack-redundant.o
            BUILTIN_OBJS += builtin/pack-refs.o
            BUILTIN_OBJS += builtin/patch-id.o
            BUILTIN_OBJS += builtin/prune-packed.o
            BUILTIN_OBJS += builtin/prune.o
            BUILTIN_OBJS += builtin/pull.o
            BUILTIN_OBJS += builtin/push.o
            BUILTIN_OBJS += builtin/range-diff.o
            BUILTIN_OBJS += builtin/read-tree.o
            BUILTIN_OBJS += builtin/rebase.o
            BUILTIN_OBJS += builtin/receive-pack.o
            BUILTIN_OBJS += builtin/reflog.o
            BUILTIN_OBJS += builtin/refs.o
            BUILTIN_OBJS += builtin/remote-ext.o
            BUILTIN_OBJS += builtin/remote-fd.o
            BUILTIN_OBJS += builtin/remote.o
            BUILTIN_OBJS += builtin/repack.o
            BUILTIN_OBJS += builtin/replace.o
            BUILTIN_OBJS += builtin/replay.o
            BUILTIN_OBJS += builtin/rerere.o
            BUILTIN_OBJS += builtin/reset.o
            BUILTIN_OBJS += builtin/rev-list.o
            BUILTIN_OBJS += builtin/rev-parse.o
            BUILTIN_OBJS += builtin/revert.o
            BUILTIN_OBJS += builtin/rm.o
            BUILTIN_OBJS += builtin/send-pack.o
            BUILTIN_OBJS += builtin/shortlog.o
            BUILTIN_OBJS += builtin/show-branch.o
            BUILTIN_OBJS += builtin/show-index.o
            BUILTIN_OBJS += builtin/show-ref.o
            BUILTIN_OBJS += builtin/sparse-checkout.o
            BUILTIN_OBJS += builtin/stash.o
            BUILTIN_OBJS += builtin/stripspace.o
            BUILTIN_OBJS += builtin/submodule--helper.o
            BUILTIN_OBJS += builtin/symbolic-ref.o
            BUILTIN_OBJS += builtin/tag.o
            BUILTIN_OBJS += builtin/unpack-file.o
            BUILTIN_OBJS += builtin/unpack-objects.o
            BUILTIN_OBJS += builtin/update-index.o
            BUILTIN_OBJS += builtin/update-ref.o
            BUILTIN_OBJS += builtin/update-server-info.o
            BUILTIN_OBJS += builtin/upload-archive.o
            BUILTIN_OBJS += builtin/upload-pack.o
            BUILTIN_OBJS += builtin/var.o
            BUILTIN_OBJS += builtin/verify-commit.o
            BUILTIN_OBJS += builtin/verify-pack.o
            BUILTIN_OBJS += builtin/verify-tag.o
            BUILTIN_OBJS += builtin/worktree.o
            BUILTIN_OBJS += builtin/write-tree.o

            # THIRD_PARTY_SOURCES is a list of patterns compatible with the
            # $(filter) and $(filter-out) family of functions. They specify source
            # files which are taken from some third-party source where we want to be
            # less strict about issues such as coding style so we don't diverge from
            # upstream unnecessarily (making merging in future changes easier).
            THIRD_PARTY_SOURCES += compat/inet_ntop.c
            THIRD_PARTY_SOURCES += compat/inet_pton.c
            THIRD_PARTY_SOURCES += compat/nedmalloc/%
            THIRD_PARTY_SOURCES += compat/obstack.%
            THIRD_PARTY_SOURCES += compat/poll/%
            THIRD_PARTY_SOURCES += compat/regex/%
            THIRD_PARTY_SOURCES += sha1collisiondetection/%
            THIRD_PARTY_SOURCES += sha1dc/%
            THIRD_PARTY_SOURCES += $(UNIT_TEST_DIR)/clar/%
            THIRD_PARTY_SOURCES += $(UNIT_TEST_DIR)/clar/clar/%

            CLAR_TEST_SUITES += u-ctype
            CLAR_TEST_SUITES += u-strvec
            CLAR_TEST_PROG = $(UNIT_TEST_BIN)/unit-tests$(X)
            CLAR_TEST_OBJS = $(patsubst %,$(UNIT_TEST_DIR)/%.o,$(CLAR_TEST_SUITES))
            CLAR_TEST_OBJS += $(UNIT_TEST_DIR)/clar/clar.o
            CLAR_TEST_OBJS += $(UNIT_TEST_DIR)/unit-test.o

            UNIT_TEST_PROGRAMS += t-example-decorate
            UNIT_TEST_PROGRAMS += t-hash
            UNIT_TEST_PROGRAMS += t-hashmap
            UNIT_TEST_PROGRAMS += t-mem-pool
            UNIT_TEST_PROGRAMS += t-oid-array
            UNIT_TEST_PROGRAMS += t-oidmap
            UNIT_TEST_PROGRAMS += t-oidtree
            UNIT_TEST_PROGRAMS += t-prio-queue
            UNIT_TEST_PROGRAMS += t-reftable-basics
            UNIT_TEST_PROGRAMS += t-reftable-block
            UNIT_TEST_PROGRAMS += t-reftable-merged
            UNIT_TEST_PROGRAMS += t-reftable-pq
            UNIT_TEST_PROGRAMS += t-reftable-reader
            UNIT_TEST_PROGRAMS += t-reftable-readwrite
            UNIT_TEST_PROGRAMS += t-reftable-record
            UNIT_TEST_PROGRAMS += t-reftable-stack
            UNIT_TEST_PROGRAMS += t-reftable-tree
            UNIT_TEST_PROGRAMS += t-strbuf
            UNIT_TEST_PROGRAMS += t-strcmp-offset
            UNIT_TEST_PROGRAMS += t-trailer
            UNIT_TEST_PROGRAMS += t-urlmatch-normalization
            UNIT_TEST_PROGS = $(patsubst %,$(UNIT_TEST_BIN)/%$X,$(UNIT_TEST_PROGRAMS))
            UNIT_TEST_OBJS += $(UNIT_TEST_DIR)/test-lib.o
            UNIT_TEST_OBJS += $(UNIT_TEST_DIR)/lib-oid.o
            UNIT_TEST_OBJS += $(UNIT_TEST_DIR)/lib-reftable.o

            # xdiff and reftable libs may in turn depend on what is in libgit.a
            GITLIBS = common-main.o $(LIB_FILE) $(XDIFF_LIB) $(REFTABLE_LIB) $(LIB_FILE)
            EXTLIBS =

            GIT_USER_AGENT = git/$(GIT_VERSION)

            ifeq ($(wildcard sha1collisiondetection/lib/sha1.h),sha1collisiondetection/lib/sha1.h)
            DC_SHA1_SUBMODULE = auto
            endif

            # Set CFLAGS, LDFLAGS and other *FLAGS variables. These might be
            # tweaked by config.* below as well as the command-line, both of
            # which'll override these defaults.
            # Older versions of GCC may require adding "-std=gnu99" at the end.
            CFLAGS = -g -O2 -Wall
            LDFLAGS =
            CC_LD_DYNPATH = -Wl,-rpath,
            BASIC_CFLAGS = -I.
            BASIC_LDFLAGS =

            # library flags
            ARFLAGS = rcs
            PTHREAD_CFLAGS =

            # For the 'sparse' target
            SPARSE_FLAGS ?= -std=gnu99
            SP_EXTRA_FLAGS =

            # For informing GIT-BUILD-OPTIONS of the SANITIZE=leak,address targets
            SANITIZE_LEAK =
            SANITIZE_ADDRESS =

            # For the 'coccicheck' target
            SPATCH_INCLUDE_FLAGS = --all-includes
            SPATCH_FLAGS =
            SPATCH_TEST_FLAGS =

            # If *.o files are present, have "coccicheck" depend on them, with
            # COMPUTE_HEADER_DEPENDENCIES this will speed up the common-case of
            # only needing to re-generate coccicheck results for the users of a
            # given API if it's changed, and not all files in the project. If
            # COMPUTE_HEADER_DEPENDENCIES=no this will be unset too.
            SPATCH_USE_O_DEPENDENCIES = YesPlease

            # Set SPATCH_CONCAT_COCCI to concatenate the contrib/cocci/*.cocci
            # files into a single contrib/cocci/ALL.cocci before running
            # "coccicheck".
            #
            # Pros:
            #
            # - Speeds up a one-shot run of "make coccicheck", as we won't have to
            #   parse *.[ch] files N times for the N *.cocci rules
            #
            # Cons:
            #
            # - Will make incremental development of *.cocci slower, as
            #   e.g. changing strbuf.cocci will re-run all *.cocci.
            #
            # - Makes error and performance analysis harder, as rules will be
            #   applied from a monolithic ALL.cocci, rather than
            #   e.g. strbuf.cocci. To work around this either undefine this, or
            #   generate a specific patch, e.g. this will always use strbuf.cocci,
            #   not ALL.cocci:
            #
            #       make contrib/coccinelle/strbuf.cocci.patch
            SPATCH_CONCAT_COCCI = YesPlease

            # Rebuild 'coccicheck' if $(SPATCH), its flags etc. change
            TRACK_SPATCH_DEFINES =
            TRACK_SPATCH_DEFINES += $(SPATCH)
            TRACK_SPATCH_DEFINES += $(SPATCH_INCLUDE_FLAGS)
            TRACK_SPATCH_DEFINES += $(SPATCH_FLAGS)
            TRACK_SPATCH_DEFINES += $(SPATCH_TEST_FLAGS)
            GIT-SPATCH-DEFINES: FORCE
                    @FLAGS='$(TRACK_SPATCH_DEFINES)'; \
                    if test x"$$FLAGS" != x"`cat GIT-SPATCH-DEFINES 2>/dev/null`" ; then \
                            echo >&2 "    * new spatch flags"; \
                            echo "$$FLAGS" >GIT-SPATCH-DEFINES; \
                    fi

            include config.mak.uname
            -include config.mak.autogen
            -include config.mak

            ifdef DEVELOPER
            include config.mak.dev
            endif

            GIT-VERSION-FILE: FORCE
                    @OLD=$$(cat $@ 2>/dev/null || :) && \
                    $(call version_gen,"$(shell pwd)",GIT-VERSION-FILE.in,$@) && \
                    NEW=$$(cat $@ 2>/dev/null || :) && \
                    if test "$$OLD" != "$$NEW"; then echo "$$NEW" >&2; fi

            # We need to set GIT_VERSION_OVERRIDE before including the version file as
            # otherwise any user-provided value for GIT_VERSION would have been overridden
            # already.
            GIT_VERSION_OVERRIDE := $(GIT_VERSION)
            -include GIT-VERSION-FILE

            # what 'all' will build and 'install' will install in gitexecdir,
            # excluding programs for built-in commands
            ALL_PROGRAMS = $(PROGRAMS) $(SCRIPTS)
            ALL_COMMANDS_TO_INSTALL = $(ALL_PROGRAMS)
            ifeq (,$(SKIP_DASHED_BUILT_INS))
            ALL_COMMANDS_TO_INSTALL += $(BUILT_INS)
            else
            # git-upload-pack, git-receive-pack and git-upload-archive are special: they
            # are _expected_ to be present in the `bin/` directory in their dashed form.
            ALL_COMMANDS_TO_INSTALL += git-receive-pack$(X)
            ALL_COMMANDS_TO_INSTALL += git-upload-archive$(X)
            ALL_COMMANDS_TO_INSTALL += git-upload-pack$(X)
            endif

            ALL_CFLAGS = $(DEVELOPER_CFLAGS) $(CPPFLAGS) $(CFLAGS) $(CFLAGS_APPEND)
            ALL_LDFLAGS = $(LDFLAGS) $(LDFLAGS_APPEND)

            ifdef SANITIZE
            SANITIZERS := $(foreach flag,$(subst $(comma),$(space),$(SANITIZE)),$(flag))
            BASIC_CFLAGS += -fsanitize=$(SANITIZE) -fno-sanitize-recover=$(SANITIZE)
            BASIC_CFLAGS += -fno-omit-frame-pointer
            ifneq ($(filter undefined,$(SANITIZERS)),)
            BASIC_CFLAGS += -DSHA1DC_FORCE_ALIGNED_ACCESS
            endif
            ifneq ($(filter leak,$(SANITIZERS)),)
            BASIC_CFLAGS += -O0
            SANITIZE_LEAK = YesCompiledWithIt
            endif
            ifneq ($(filter address,$(SANITIZERS)),)
            NO_REGEX = NeededForASAN
            SANITIZE_ADDRESS = YesCompiledWithIt
            endif
            endif

            ifndef sysconfdir
            ifeq ($(prefix),/usr)
            sysconfdir = /etc
            else
            sysconfdir = etc
            endif
            endif

            ifndef COMPUTE_HEADER_DEPENDENCIES
            COMPUTE_HEADER_DEPENDENCIES = auto
            endif

            ifeq ($(COMPUTE_HEADER_DEPENDENCIES),auto)
            dep_check = $(shell $(CC) $(ALL_CFLAGS) \
                    -Wno-pedantic \
                    -c -MF /dev/null -MQ /dev/null -MMD -MP \
                    -x c /dev/null -o /dev/null 2>&1; \
                    echo $$?)
            ifeq ($(dep_check),0)
            override COMPUTE_HEADER_DEPENDENCIES = yes
            else
            override COMPUTE_HEADER_DEPENDENCIES = no
            endif
            endif

            ifeq ($(COMPUTE_HEADER_DEPENDENCIES),yes)
            USE_COMPUTED_HEADER_DEPENDENCIES = YesPlease
            else
            ifneq ($(COMPUTE_HEADER_DEPENDENCIES),no)
            $(error please set COMPUTE_HEADER_DEPENDENCIES to yes, no, or auto \
            (not "$(COMPUTE_HEADER_DEPENDENCIES)"))
            endif
            endif

            ifndef GENERATE_COMPILATION_DATABASE
            GENERATE_COMPILATION_DATABASE = no
            endif

            ifeq ($(GENERATE_COMPILATION_DATABASE),yes)
            compdb_check = $(shell $(CC) $(ALL_CFLAGS) \
                    -Wno-pedantic \
                    -c -MJ /dev/null \
                    -x c /dev/null -o /dev/null 2>&1; \
                    echo $$?)
            ifneq ($(compdb_check),0)
            override GENERATE_COMPILATION_DATABASE = no
            $(warning GENERATE_COMPILATION_DATABASE is set to "yes", but your compiler does not \
            support generating compilation database entries)
            endif
            else
            ifneq ($(GENERATE_COMPILATION_DATABASE),no)
            $(error please set GENERATE_COMPILATION_DATABASE to "yes" or "no" \
            (not "$(GENERATE_COMPILATION_DATABASE)"))
            endif
            endif

            ifdef SANE_TOOL_PATH
            SANE_TOOL_PATH_SQ = $(subst ','\'',$(SANE_TOOL_PATH))
            BROKEN_PATH_FIX = s|^\# @BROKEN_PATH_FIX@$$|git_broken_path_fix "$(SANE_TOOL_PATH_SQ)"|
            PATH := $(SANE_TOOL_PATH):${PATH}
            else
            BROKEN_PATH_FIX = /^\# @BROKEN_PATH_FIX@$$/d
            endif

            ifeq (,$(HOST_CPU))
                    BASIC_CFLAGS += -DGIT_HOST_CPU="\"$(firstword $(subst -, ,$(uname_M)))\""
            else
                    BASIC_CFLAGS += -DGIT_HOST_CPU="\"$(HOST_CPU)\""
            endif

            ifneq (,$(INLINE))
                    BASIC_CFLAGS += -Dinline=$(INLINE)
            endif

            ifneq (,$(SOCKLEN_T))
                    BASIC_CFLAGS += -Dsocklen_t=$(SOCKLEN_T)
            endif

            ifeq ($(uname_S),Darwin)
                    ifndef NO_FINK
                            ifeq ($(shell test -d /sw/lib && echo y),y)
                                    BASIC_CFLAGS += -I/sw/include
                                    BASIC_LDFLAGS += -L/sw/lib
                            endif
                    endif
                    ifndef NO_DARWIN_PORTS
                            ifeq ($(shell test -d /opt/local/lib && echo y),y)
                                    BASIC_CFLAGS += -I/opt/local/include
                                    BASIC_LDFLAGS += -L/opt/local/lib
                            endif
                    endif
                    ifndef NO_APPLE_COMMON_CRYPTO
                            NO_OPENSSL = YesPlease
                            APPLE_COMMON_CRYPTO = YesPlease
                            COMPAT_CFLAGS += -DAPPLE_COMMON_CRYPTO
                    endif
                    PTHREAD_LIBS =
            endif

            ifdef NO_LIBGEN_H
                    COMPAT_CFLAGS += -DNO_LIBGEN_H
                    COMPAT_OBJS += compat/basename.o
            endif

            ifdef USE_LIBPCRE1
            $(error The USE_LIBPCRE1 build option has been removed, use version 2 with USE_LIBPCRE)
            endif

            USE_LIBPCRE2 ?= $(USE_LIBPCRE)

            ifneq (,$(USE_LIBPCRE2))
                    BASIC_CFLAGS += -DUSE_LIBPCRE2
                    EXTLIBS += -lpcre2-8
            endif

            ifdef LIBPCREDIR
                    BASIC_CFLAGS += -I$(LIBPCREDIR)/include
                    EXTLIBS += $(call libpath_template,$(LIBPCREDIR)/$(lib))
            endif

            ifdef HAVE_ALLOCA_H
                    BASIC_CFLAGS += -DHAVE_ALLOCA_H
            endif

            IMAP_SEND_BUILDDEPS =
            IMAP_SEND_LDFLAGS =

            ifdef NO_CURL
                    BASIC_CFLAGS += -DNO_CURL
                    REMOTE_CURL_PRIMARY =
                    REMOTE_CURL_ALIASES =
                    REMOTE_CURL_NAMES =
                    EXCLUDED_PROGRAMS += git-http-fetch git-http-push
            else
                    ifdef CURLDIR
                            # Try "-Wl,-rpath=$(CURLDIR)/$(lib)" in such a case.
                            CURL_CFLAGS = -I$(CURLDIR)/include
                            CURL_LIBCURL = $(call libpath_template,$(CURLDIR)/$(lib))
                    else
                            CURL_CFLAGS =
                            CURL_LIBCURL =
                    endif

                    ifndef CURL_LDFLAGS
                            CURL_LDFLAGS = $(eval CURL_LDFLAGS := $$(shell $$(CURL_CONFIG) --libs))$(CURL_LDFLAGS)
                    endif
                    CURL_LIBCURL += $(CURL_LDFLAGS)

                    ifndef CURL_CFLAGS
                            CURL_CFLAGS = $(eval CURL_CFLAGS := $$(shell $$(CURL_CONFIG) --cflags))$(CURL_CFLAGS)
                    endif
                    BASIC_CFLAGS += $(CURL_CFLAGS)

                    REMOTE_CURL_PRIMARY = git-remote-http$X
                    REMOTE_CURL_ALIASES = git-remote-https$X git-remote-ftp$X git-remote-ftps$X
                    REMOTE_CURL_NAMES = $(REMOTE_CURL_PRIMARY) $(REMOTE_CURL_ALIASES)
                    PROGRAM_OBJS += http-fetch.o
                    PROGRAMS += $(REMOTE_CURL_NAMES)
                    ifndef NO_EXPAT
                            PROGRAM_OBJS += http-push.o
                    endif
                    curl_check := $(shell (echo 072200; $(CURL_CONFIG) --vernum | sed -e '/^70[BC]/s/^/0/') 2>/dev/null | sort -r | sed -ne 2p)
                    ifeq "$(curl_check)" "072200"
                            USE_CURL_FOR_IMAP_SEND = YesPlease
                    endif
                    ifdef USE_CURL_FOR_IMAP_SEND
                            BASIC_CFLAGS += -DUSE_CURL_FOR_IMAP_SEND
                            IMAP_SEND_BUILDDEPS = http.o
                            IMAP_SEND_LDFLAGS += $(CURL_LIBCURL)
                    endif
                    ifndef NO_EXPAT
                            ifdef EXPATDIR
                                    BASIC_CFLAGS += -I$(EXPATDIR)/include
                                    EXPAT_LIBEXPAT = $(call libpath_template,$(EXPATDIR)/$(lib)) -lexpat
                            else
                                    EXPAT_LIBEXPAT = -lexpat
                            endif
                            ifdef EXPAT_NEEDS_XMLPARSE_H
                                    BASIC_CFLAGS += -DEXPAT_NEEDS_XMLPARSE_H
                            endif
                    endif
            endif
            IMAP_SEND_LDFLAGS += $(OPENSSL_LINK) $(OPENSSL_LIBSSL) $(LIB_4_CRYPTO)

            ifdef ZLIB_PATH
                    BASIC_CFLAGS += -I$(ZLIB_PATH)/include
                    EXTLIBS += $(call libpath_template,$(ZLIB_PATH)/$(lib))
            endif
            EXTLIBS += -lz

            ifndef NO_OPENSSL
                    OPENSSL_LIBSSL = -lssl
                    ifdef OPENSSLDIR
                            BASIC_CFLAGS += -I$(OPENSSLDIR)/include
                            OPENSSL_LINK = $(call libpath_template,$(OPENSSLDIR)/$(lib))
                    else
                            OPENSSL_LINK =
                    endif
                    ifdef NEEDS_CRYPTO_WITH_SSL
                            OPENSSL_LIBSSL += -lcrypto
                    endif
            else
                    BASIC_CFLAGS += -DNO_OPENSSL
                    OPENSSL_LIBSSL =
            endif
            ifdef NO_OPENSSL
                    LIB_4_CRYPTO =
            else
            ifdef NEEDS_SSL_WITH_CRYPTO
                    LIB_4_CRYPTO = $(OPENSSL_LINK) -lcrypto -lssl
            else
                    LIB_4_CRYPTO = $(OPENSSL_LINK) -lcrypto
            endif
            ifdef APPLE_COMMON_CRYPTO
                    LIB_4_CRYPTO += -framework Security -framework CoreFoundation
            endif
            endif
            ifndef NO_ICONV
                    ifdef NEEDS_LIBICONV
                            ifdef ICONVDIR
                                    BASIC_CFLAGS += -I$(ICONVDIR)/include
                                    ICONV_LINK = $(call libpath_template,$(ICONVDIR)/$(lib))
                            else
                                    ICONV_LINK =
                            endif
                            ifdef NEEDS_LIBINTL_BEFORE_LIBICONV
                                    ICONV_LINK += -lintl
                            endif
                            EXTLIBS += $(ICONV_LINK) -liconv
                    endif
            endif
            ifdef ICONV_OMITS_BOM
                    BASIC_CFLAGS += -DICONV_OMITS_BOM
            endif
            ifdef NEEDS_LIBGEN
                    EXTLIBS += -lgen
            endif
            ifndef NO_GETTEXT
            ifndef LIBC_CONTAINS_LIBINTL
                    EXTLIBS += -lintl
            endif
            endif
            ifdef NEEDS_SOCKET
                    EXTLIBS += -lsocket
            endif
            ifdef NEEDS_NSL
                    EXTLIBS += -lnsl
            endif
            ifdef NEEDS_RESOLV
                    EXTLIBS += -lresolv
            endif
            ifdef NO_D_TYPE_IN_DIRENT
                    BASIC_CFLAGS += -DNO_D_TYPE_IN_DIRENT
            endif
            ifdef NO_GECOS_IN_PWENT
                    BASIC_CFLAGS += -DNO_GECOS_IN_PWENT
            endif
            ifdef NO_ST_BLOCKS_IN_STRUCT_STAT
                    BASIC_CFLAGS += -DNO_ST_BLOCKS_IN_STRUCT_STAT
            endif
            ifdef USE_NSEC
                    BASIC_CFLAGS += -DUSE_NSEC
            endif
            ifdef USE_ST_TIMESPEC
                    BASIC_CFLAGS += -DUSE_ST_TIMESPEC
            endif
            ifdef NO_NORETURN
                    BASIC_CFLAGS += -DNO_NORETURN
            endif
            ifdef NO_NSEC
                    BASIC_CFLAGS += -DNO_NSEC
            endif
            ifdef SNPRINTF_RETURNS_BOGUS
                    COMPAT_CFLAGS += -DSNPRINTF_RETURNS_BOGUS
                    COMPAT_OBJS += compat/snprintf.o
            endif
            ifdef FREAD_READS_DIRECTORIES
                    COMPAT_CFLAGS += -DFREAD_READS_DIRECTORIES
                    COMPAT_OBJS += compat/fopen.o
            endif
            ifdef OPEN_RETURNS_EINTR
                    COMPAT_CFLAGS += -DOPEN_RETURNS_EINTR
                    COMPAT_OBJS += compat/open.o
            endif
            ifdef NO_SYMLINK_HEAD
                    BASIC_CFLAGS += -DNO_SYMLINK_HEAD
            endif
            ifdef NO_GETTEXT
                    BASIC_CFLAGS += -DNO_GETTEXT
                    USE_GETTEXT_SCHEME ?= fallthrough
            endif
            ifdef NO_POLL
                    NO_POLL_H = YesPlease
                    NO_SYS_POLL_H = YesPlease
                    COMPAT_CFLAGS += -DNO_POLL -Icompat/poll
                    COMPAT_OBJS += compat/poll/poll.o
            endif
            ifdef NO_STRCASESTR
                    COMPAT_CFLAGS += -DNO_STRCASESTR
                    COMPAT_OBJS += compat/strcasestr.o
            endif
            ifdef NO_STRLCPY
                    COMPAT_CFLAGS += -DNO_STRLCPY
                    COMPAT_OBJS += compat/strlcpy.o
            endif
            ifdef NO_STRTOUMAX
                    COMPAT_CFLAGS += -DNO_STRTOUMAX
                    COMPAT_OBJS += compat/strtoumax.o compat/strtoimax.o
            endif
            ifdef NO_STRTOULL
                    COMPAT_CFLAGS += -DNO_STRTOULL
            endif
            ifdef NO_SETENV
                    COMPAT_CFLAGS += -DNO_SETENV
                    COMPAT_OBJS += compat/setenv.o
            endif
            ifdef NO_MKDTEMP
                    COMPAT_CFLAGS += -DNO_MKDTEMP
                    COMPAT_OBJS += compat/mkdtemp.o
            endif
            ifdef MKDIR_WO_TRAILING_SLASH
                    COMPAT_CFLAGS += -DMKDIR_WO_TRAILING_SLASH
                    COMPAT_OBJS += compat/mkdir.o
            endif
            ifdef NO_UNSETENV
                    COMPAT_CFLAGS += -DNO_UNSETENV
                    COMPAT_OBJS += compat/unsetenv.o
            endif
            ifdef NO_SYS_SELECT_H
                    BASIC_CFLAGS += -DNO_SYS_SELECT_H
            endif
            ifdef NO_POLL_H
                    BASIC_CFLAGS += -DNO_POLL_H
            endif
            ifdef NO_SYS_POLL_H
                    BASIC_CFLAGS += -DNO_SYS_POLL_H
            endif
            ifdef NEEDS_SYS_PARAM_H
                    BASIC_CFLAGS += -DNEEDS_SYS_PARAM_H
            endif
            ifdef NO_INTTYPES_H
                    BASIC_CFLAGS += -DNO_INTTYPES_H
            endif
            ifdef NO_INITGROUPS
                    BASIC_CFLAGS += -DNO_INITGROUPS
            endif
            ifdef NO_MMAP
                    COMPAT_CFLAGS += -DNO_MMAP
                    COMPAT_OBJS += compat/mmap.o
            else
                    ifdef USE_WIN32_MMAP
                            COMPAT_CFLAGS += -DUSE_WIN32_MMAP
                            COMPAT_OBJS += compat/win32mmap.o
                    endif
            endif
            ifdef MMAP_PREVENTS_DELETE
                    BASIC_CFLAGS += -DMMAP_PREVENTS_DELETE
            endif
            ifdef OBJECT_CREATION_USES_RENAMES
                    COMPAT_CFLAGS += -DOBJECT_CREATION_MODE=1
            endif
            ifdef NO_STRUCT_ITIMERVAL
                    COMPAT_CFLAGS += -DNO_STRUCT_ITIMERVAL
                    NO_SETITIMER = YesPlease
            endif
            ifdef NO_SETITIMER
                    COMPAT_CFLAGS += -DNO_SETITIMER
            endif
            ifdef NO_PREAD
                    COMPAT_CFLAGS += -DNO_PREAD
                    COMPAT_OBJS += compat/pread.o
            endif
            ifdef NO_FAST_WORKING_DIRECTORY
                    BASIC_CFLAGS += -DNO_FAST_WORKING_DIRECTORY
            endif
            ifdef NO_TRUSTABLE_FILEMODE
                    BASIC_CFLAGS += -DNO_TRUSTABLE_FILEMODE
            endif
            ifdef NEEDS_MODE_TRANSLATION
                    COMPAT_CFLAGS += -DNEEDS_MODE_TRANSLATION
                    COMPAT_OBJS += compat/stat.o
            endif
            ifdef NO_IPV6
                    BASIC_CFLAGS += -DNO_IPV6
            endif
            ifdef NO_INTPTR_T
                    COMPAT_CFLAGS += -DNO_INTPTR_T
            endif
            ifdef NO_UINTMAX_T
                    BASIC_CFLAGS += -Duintmax_t=uint32_t
            endif
            ifdef NO_SOCKADDR_STORAGE
            ifdef NO_IPV6
                    BASIC_CFLAGS += -Dsockaddr_storage=sockaddr_in
            else
                    BASIC_CFLAGS += -Dsockaddr_storage=sockaddr_in6
            endif
            endif
            ifdef NO_INET_NTOP
                    LIB_OBJS += compat/inet_ntop.o
                    BASIC_CFLAGS += -DNO_INET_NTOP
            endif
            ifdef NO_INET_PTON
                    LIB_OBJS += compat/inet_pton.o
                    BASIC_CFLAGS += -DNO_INET_PTON
            endif
            ifdef NO_UNIX_SOCKETS
                    BASIC_CFLAGS += -DNO_UNIX_SOCKETS
            else
                    LIB_OBJS += unix-socket.o
                    LIB_OBJS += unix-stream-server.o
            endif

            # Simple IPC requires threads and platform-specific IPC support.
            # Only platforms that have both should include these source files
            # in the build.
            #
            # On Windows-based systems, Simple IPC requires threads and Windows
            # Named Pipes.  These are always available, so Simple IPC support
            # is optional.
            #
            # On Unix-based systems, Simple IPC requires pthreads and Unix
            # domain sockets.  So support is only enabled when both are present.
            #
            ifdef USE_WIN32_IPC
                    BASIC_CFLAGS += -DSUPPORTS_SIMPLE_IPC
                    LIB_OBJS += compat/simple-ipc/ipc-shared.o
                    LIB_OBJS += compat/simple-ipc/ipc-win32.o
            else
            ifndef NO_PTHREADS
            ifndef NO_UNIX_SOCKETS
                    BASIC_CFLAGS += -DSUPPORTS_SIMPLE_IPC
                    LIB_OBJS += compat/simple-ipc/ipc-shared.o
                    LIB_OBJS += compat/simple-ipc/ipc-unix-socket.o
            endif
            endif
            endif

            ifdef NO_ICONV
                    BASIC_CFLAGS += -DNO_ICONV
            endif

            ifdef OLD_ICONV
                    BASIC_CFLAGS += -DOLD_ICONV
            endif

            ifdef NO_DEFLATE_BOUND
                    BASIC_CFLAGS += -DNO_DEFLATE_BOUND
            endif

            ifdef NO_POSIX_GOODIES
                    BASIC_CFLAGS += -DNO_POSIX_GOODIES
            endif

            ifdef APPLE_COMMON_CRYPTO_SHA1
                    # Apple CommonCrypto requires chunking
                    SHA1_MAX_BLOCK_SIZE = 1024L*1024L*1024L
            endif

            ifdef PPC_SHA1
            $(error the PPC_SHA1 flag has been removed along with the PowerPC-specific SHA-1 implementation.)
            endif

            ifdef OPENSSL_SHA1
                    EXTLIBS += $(LIB_4_CRYPTO)
                    BASIC_CFLAGS += -DSHA1_OPENSSL
            else
            ifdef BLK_SHA1
                    LIB_OBJS += block-sha1/sha1.o
                    BASIC_CFLAGS += -DSHA1_BLK
            else
            ifdef APPLE_COMMON_CRYPTO_SHA1
                    COMPAT_CFLAGS += -DCOMMON_DIGEST_FOR_OPENSSL
                    BASIC_CFLAGS += -DSHA1_APPLE
            else
                    BASIC_CFLAGS += -DSHA1_DC
                    LIB_OBJS += sha1dc_git.o
            ifdef DC_SHA1_EXTERNAL
                    ifdef DC_SHA1_SUBMODULE
                            ifneq ($(DC_SHA1_SUBMODULE),auto)
            $(error Only set DC_SHA1_EXTERNAL or DC_SHA1_SUBMODULE, not both)
                            endif
                    endif
                    BASIC_CFLAGS += -DDC_SHA1_EXTERNAL
                    EXTLIBS += -lsha1detectcoll
            else
            ifdef DC_SHA1_SUBMODULE
                    LIB_OBJS += sha1collisiondetection/lib/sha1.o
                    LIB_OBJS += sha1collisiondetection/lib/ubc_check.o
                    BASIC_CFLAGS += -DDC_SHA1_SUBMODULE
            else
                    LIB_OBJS += sha1dc/sha1.o
                    LIB_OBJS += sha1dc/ubc_check.o
            endif
                    BASIC_CFLAGS += \
                            -DSHA1DC_NO_STANDARD_INCLUDES \
                            -DSHA1DC_INIT_SAFE_HASH_DEFAULT=0 \
                            -DSHA1DC_CUSTOM_INCLUDE_SHA1_C="\"git-compat-util.h\"" \
                            -DSHA1DC_CUSTOM_INCLUDE_UBC_CHECK_C="\"git-compat-util.h\""
            endif
            endif
            endif
            endif

            ifdef OPENSSL_SHA1_UNSAFE
            ifndef OPENSSL_SHA1
                    EXTLIBS += $(LIB_4_CRYPTO)
                    BASIC_CFLAGS += -DSHA1_OPENSSL_UNSAFE
            endif
            else
            ifdef BLK_SHA1_UNSAFE
            ifndef BLK_SHA1
                    LIB_OBJS += block-sha1/sha1.o
                    BASIC_CFLAGS += -DSHA1_BLK_UNSAFE
            endif
            else
            ifdef APPLE_COMMON_CRYPTO_SHA1_UNSAFE
            ifndef APPLE_COMMON_CRYPTO_SHA1
                    COMPAT_CFLAGS += -DCOMMON_DIGEST_FOR_OPENSSL
                    BASIC_CFLAGS += -DSHA1_APPLE_UNSAFE
            endif
            endif
            endif
            endif

            ifdef OPENSSL_SHA256
                    EXTLIBS += $(LIB_4_CRYPTO)
                    BASIC_CFLAGS += -DSHA256_OPENSSL
            else
            ifdef NETTLE_SHA256
                    BASIC_CFLAGS += -DSHA256_NETTLE
                    EXTLIBS += -lnettle
            else
            ifdef GCRYPT_SHA256
                    BASIC_CFLAGS += -DSHA256_GCRYPT
                    EXTLIBS += -lgcrypt
            else
                    LIB_OBJS += sha256/block/sha256.o
                    BASIC_CFLAGS += -DSHA256_BLK
            endif
            endif
            endif

            ifdef SHA1_MAX_BLOCK_SIZE
                    LIB_OBJS += compat/sha1-chunked.o
                    BASIC_CFLAGS += -DSHA1_MAX_BLOCK_SIZE="$(SHA1_MAX_BLOCK_SIZE)"
            endif
            ifdef NO_HSTRERROR
                    COMPAT_CFLAGS += -DNO_HSTRERROR
                    COMPAT_OBJS += compat/hstrerror.o
            endif
            ifdef NO_MEMMEM
                    COMPAT_CFLAGS += -DNO_MEMMEM
                    COMPAT_OBJS += compat/memmem.o
            endif
            ifdef NO_GETPAGESIZE
                    COMPAT_CFLAGS += -DNO_GETPAGESIZE
            endif
            ifdef INTERNAL_QSORT
                    COMPAT_CFLAGS += -DINTERNAL_QSORT
            endif
            ifdef HAVE_ISO_QSORT_S
                    COMPAT_CFLAGS += -DHAVE_ISO_QSORT_S
            else
                    COMPAT_OBJS += compat/qsort_s.o
            endif
            ifdef RUNTIME_PREFIX
                    COMPAT_CFLAGS += -DRUNTIME_PREFIX
            endif

            ifdef NO_PTHREADS
                    BASIC_CFLAGS += -DNO_PTHREADS
            else
                    BASIC_CFLAGS += $(PTHREAD_CFLAGS)
                    EXTLIBS += $(PTHREAD_LIBS)
            endif

            ifdef HAVE_PATHS_H
                    BASIC_CFLAGS += -DHAVE_PATHS_H
            endif

            ifdef HAVE_LIBCHARSET_H
                    BASIC_CFLAGS += -DHAVE_LIBCHARSET_H
                    EXTLIBS += $(CHARSET_LIB)
            endif

            ifdef HAVE_STRINGS_H
                    BASIC_CFLAGS += -DHAVE_STRINGS_H
            endif

            ifdef HAVE_DEV_TTY
                    BASIC_CFLAGS += -DHAVE_DEV_TTY
            endif

            ifdef DIR_HAS_BSD_GROUP_SEMANTICS
                    COMPAT_CFLAGS += -DDIR_HAS_BSD_GROUP_SEMANTICS
            endif
            ifdef UNRELIABLE_FSTAT
                    BASIC_CFLAGS += -DUNRELIABLE_FSTAT
            endif
            ifdef NO_REGEX
                    COMPAT_CFLAGS += -Icompat/regex
                    COMPAT_OBJS += compat/regex/regex.o
            else
            ifdef USE_ENHANCED_BASIC_REGULAR_EXPRESSIONS
                    COMPAT_CFLAGS += -DUSE_ENHANCED_BASIC_REGULAR_EXPRESSIONS
                    COMPAT_OBJS += compat/regcomp_enhanced.o
            endif
            endif
            ifdef NATIVE_CRLF
                    BASIC_CFLAGS += -DNATIVE_CRLF
            endif

            ifdef USE_NED_ALLOCATOR
                    COMPAT_CFLAGS += -Icompat/nedmalloc
                    COMPAT_OBJS += compat/nedmalloc/nedmalloc.o
                    OVERRIDE_STRDUP = YesPlease
            endif

            ifdef OVERRIDE_STRDUP
                    COMPAT_CFLAGS += -DOVERRIDE_STRDUP
                    COMPAT_OBJS += compat/strdup.o
            endif

            ifdef GIT_TEST_CMP_USE_COPIED_CONTEXT
                    export GIT_TEST_CMP_USE_COPIED_CONTEXT
            endif

            ifndef NO_MSGFMT_EXTENDED_OPTIONS
                    MSGFMT += --check
            endif

            ifdef HAVE_CLOCK_GETTIME
                    BASIC_CFLAGS += -DHAVE_CLOCK_GETTIME
            endif

            ifdef HAVE_CLOCK_MONOTONIC
                    BASIC_CFLAGS += -DHAVE_CLOCK_MONOTONIC
            endif

            ifdef HAVE_SYNC_FILE_RANGE
                    BASIC_CFLAGS += -DHAVE_SYNC_FILE_RANGE
            endif

            ifdef NEEDS_LIBRT
                    EXTLIBS += -lrt
            endif

            ifdef HAVE_BSD_SYSCTL
                    BASIC_CFLAGS += -DHAVE_BSD_SYSCTL
            endif

            ifdef HAVE_BSD_KERN_PROC_SYSCTL
                    BASIC_CFLAGS += -DHAVE_BSD_KERN_PROC_SYSCTL
            endif

            ifdef HAVE_GETDELIM
                    BASIC_CFLAGS += -DHAVE_GETDELIM
            endif

            ifneq ($(findstring arc4random,$(CSPRNG_METHOD)),)
                    BASIC_CFLAGS += -DHAVE_ARC4RANDOM
            endif

            ifneq ($(findstring libbsd,$(CSPRNG_METHOD)),)
                    BASIC_CFLAGS += -DHAVE_ARC4RANDOM_LIBBSD
                    EXTLIBS += -lbsd
            endif

            ifneq ($(findstring getrandom,$(CSPRNG_METHOD)),)
                    BASIC_CFLAGS += -DHAVE_GETRANDOM
            endif

            ifneq ($(findstring getentropy,$(CSPRNG_METHOD)),)
                    BASIC_CFLAGS += -DHAVE_GETENTROPY
            endif

            ifneq ($(findstring rtlgenrandom,$(CSPRNG_METHOD)),)
                    BASIC_CFLAGS += -DHAVE_RTLGENRANDOM
            endif

            ifneq ($(findstring openssl,$(CSPRNG_METHOD)),)
                    BASIC_CFLAGS += -DHAVE_OPENSSL_CSPRNG
                    EXTLIBS += -lcrypto -lssl
            endif

            ifneq ($(PROCFS_EXECUTABLE_PATH),)
                    procfs_executable_path_SQ = $(subst ','\'',$(PROCFS_EXECUTABLE_PATH))
                    BASIC_CFLAGS += '-DPROCFS_EXECUTABLE_PATH="$(procfs_executable_path_SQ)"'
            endif

            ifndef HAVE_PLATFORM_PROCINFO
                    COMPAT_OBJS += compat/stub/procinfo.o
            endif

            ifdef HAVE_NS_GET_EXECUTABLE_PATH
                    BASIC_CFLAGS += -DHAVE_NS_GET_EXECUTABLE_PATH
            endif

            ifdef HAVE_ZOS_GET_EXECUTABLE_PATH
                    BASIC_CFLAGS += -DHAVE_ZOS_GET_EXECUTABLE_PATH
            endif

            ifdef HAVE_WPGMPTR
                    BASIC_CFLAGS += -DHAVE_WPGMPTR
            endif

            ifdef FILENO_IS_A_MACRO
                    COMPAT_CFLAGS += -DFILENO_IS_A_MACRO
                    COMPAT_OBJS += compat/fileno.o
            endif

            ifdef NEED_ACCESS_ROOT_HANDLER
                    COMPAT_CFLAGS += -DNEED_ACCESS_ROOT_HANDLER
                    COMPAT_OBJS += compat/access.o
            endif

            ifdef FSMONITOR_DAEMON_BACKEND
                    COMPAT_CFLAGS += -DHAVE_FSMONITOR_DAEMON_BACKEND
                    COMPAT_OBJS += compat/fsmonitor/fsm-listen-$(FSMONITOR_DAEMON_BACKEND).o
                    COMPAT_OBJS += compat/fsmonitor/fsm-health-$(FSMONITOR_DAEMON_BACKEND).o
                    COMPAT_OBJS += compat/fsmonitor/fsm-ipc-$(FSMONITOR_DAEMON_BACKEND).o
            endif

            ifdef FSMONITOR_OS_SETTINGS
                    COMPAT_CFLAGS += -DHAVE_FSMONITOR_OS_SETTINGS
                    COMPAT_OBJS += compat/fsmonitor/fsm-settings-$(FSMONITOR_OS_SETTINGS).o
                    COMPAT_OBJS += compat/fsmonitor/fsm-path-utils-$(FSMONITOR_OS_SETTINGS).o
            endif

            ifeq ($(TCLTK_PATH),)
            NO_TCLTK = NoThanks
            endif

            ifeq ($(PERL_PATH),)
            NO_PERL = NoThanks
            endif

            ifeq ($(PYTHON_PATH),)
            NO_PYTHON = NoThanks
            endif

            ifndef PAGER_ENV
            PAGER_ENV = LESS=FRX LV=-c
            endif

            ifdef NO_INSTALL_HARDLINKS
                    export NO_INSTALL_HARDLINKS
            endif

            ### profile feedback build
            #

            # Can adjust this to be a global directory if you want to do extended
            # data gathering
            PROFILE_DIR := $(CURDIR)

            ifeq ("$(PROFILE)","GEN")
                    BASIC_CFLAGS += -fprofile-generate=$(PROFILE_DIR) -DNO_NORETURN=1
                    EXTLIBS += -lgcov
                    export CCACHE_DISABLE = t
                    V = 1
            else
            ifneq ("$(PROFILE)","")
                    BASIC_CFLAGS += -fprofile-use=$(PROFILE_DIR) -fprofile-correction -DNO_NORETURN=1
                    export CCACHE_DISABLE = t
                    V = 1
            endif
            endif

            # Shell quote (do not use $(call) to accommodate ancient setups);

            ETC_GITCONFIG_SQ = $(subst ','\'',$(ETC_GITCONFIG))
            ETC_GITATTRIBUTES_SQ = $(subst ','\'',$(ETC_GITATTRIBUTES))

            DESTDIR_SQ = $(subst ','\'',$(DESTDIR))
            NO_GETTEXT_SQ = $(subst ','\'',$(NO_GETTEXT))
            bindir_SQ = $(subst ','\'',$(bindir))
            bindir_relative_SQ = $(subst ','\'',$(bindir_relative))
            mandir_SQ = $(subst ','\'',$(mandir))
            mandir_relative_SQ = $(subst ','\'',$(mandir_relative))
            infodir_relative_SQ = $(subst ','\'',$(infodir_relative))
            perllibdir_SQ = $(subst ','\'',$(perllibdir))
            localedir_SQ = $(subst ','\'',$(localedir))
            localedir_relative_SQ = $(subst ','\'',$(localedir_relative))
            gitexecdir_SQ = $(subst ','\'',$(gitexecdir))
            gitexecdir_relative_SQ = $(subst ','\'',$(gitexecdir_relative))
            template_dir_SQ = $(subst ','\'',$(template_dir))
            htmldir_relative_SQ = $(subst ','\'',$(htmldir_relative))
            prefix_SQ = $(subst ','\'',$(prefix))
            perllibdir_relative_SQ = $(subst ','\'',$(perllibdir_relative))
            gitwebdir_SQ = $(subst ','\'',$(gitwebdir))
            gitwebstaticdir_SQ = $(subst ','\'',$(gitwebstaticdir))

            SHELL_PATH_SQ = $(subst ','\'',$(SHELL_PATH))
            TEST_SHELL_PATH_SQ = $(subst ','\'',$(TEST_SHELL_PATH))
            PERL_PATH_SQ = $(subst ','\'',$(PERL_PATH))
            PYTHON_PATH_SQ = $(subst ','\'',$(PYTHON_PATH))
            TCLTK_PATH_SQ = $(subst ','\'',$(TCLTK_PATH))
            DIFF_SQ = $(subst ','\'',$(DIFF))
            PERLLIB_EXTRA_SQ = $(subst ','\'',$(PERLLIB_EXTRA))

            # RUNTIME_PREFIX's resolution logic requires resource paths to be expressed
            # relative to each other and share an installation path.
            #
            # This is a dependency in:
            # - Git's binary RUNTIME_PREFIX logic in (see "exec_cmd.c").
            # - The runtime prefix Perl header (see
            #   "perl/header_templates/runtime_prefix.template.pl").
            ifdef RUNTIME_PREFIX

            ifneq ($(filter /%,$(firstword $(gitexecdir_relative))),)
            $(error RUNTIME_PREFIX requires a relative gitexecdir, not: $(gitexecdir))
            endif

            ifneq ($(filter /%,$(firstword $(localedir_relative))),)
            $(error RUNTIME_PREFIX requires a relative localedir, not: $(localedir))
            endif

            ifndef NO_PERL
            ifneq ($(filter /%,$(firstword $(perllibdir_relative))),)
            $(error RUNTIME_PREFIX requires a relative perllibdir, not: $(perllibdir))
            endif
            endif

            endif

            # We must filter out any object files from $(GITLIBS),
            # as it is typically used like:
            #
            #   foo: foo.o $(GITLIBS)
            #       $(CC) $(filter %.o,$^) $(LIBS)
            #
            # where we use it as a dependency. Since we also pull object files
            # from the dependency list, that would make each entry appear twice.
            LIBS = $(filter-out %.o, $(GITLIBS)) $(EXTLIBS)

            BASIC_CFLAGS += $(COMPAT_CFLAGS)
            LIB_OBJS += $(COMPAT_OBJS)

            # Quote for C

            ifdef DEFAULT_EDITOR
            DEFAULT_EDITOR_CQ = "$(subst ",\",$(subst \,\\,$(DEFAULT_EDITOR)))"
            DEFAULT_EDITOR_CQ_SQ = $(subst ','\'',$(DEFAULT_EDITOR_CQ))

            BASIC_CFLAGS += -DDEFAULT_EDITOR='$(DEFAULT_EDITOR_CQ_SQ)'
            endif

            ifdef DEFAULT_PAGER
            DEFAULT_PAGER_CQ = "$(subst ",\",$(subst \,\\,$(DEFAULT_PAGER)))"
            DEFAULT_PAGER_CQ_SQ = $(subst ','\'',$(DEFAULT_PAGER_CQ))

            BASIC_CFLAGS += -DDEFAULT_PAGER='$(DEFAULT_PAGER_CQ_SQ)'
            endif

            ifdef SHELL_PATH
            SHELL_PATH_CQ = "$(subst ",\",$(subst \,\\,$(SHELL_PATH)))"
            SHELL_PATH_CQ_SQ = $(subst ','\'',$(SHELL_PATH_CQ))

            BASIC_CFLAGS += -DSHELL_PATH='$(SHELL_PATH_CQ_SQ)'
            endif

            GIT_USER_AGENT_SQ = $(subst ','\'',$(GIT_USER_AGENT))
            GIT_USER_AGENT_CQ = "$(subst ",\",$(subst \,\\,$(GIT_USER_AGENT)))"
            GIT_USER_AGENT_CQ_SQ = $(subst ','\'',$(GIT_USER_AGENT_CQ))
            GIT-USER-AGENT: FORCE
                    @if test x'$(GIT_USER_AGENT_SQ)' != x"`cat GIT-USER-AGENT 2>/dev/null`"; then \
                            echo '$(GIT_USER_AGENT_SQ)' >GIT-USER-AGENT; \
                    fi

            ifdef DEFAULT_HELP_FORMAT
            BASIC_CFLAGS += -DDEFAULT_HELP_FORMAT='"$(DEFAULT_HELP_FORMAT)"'
            endif

            ALL_CFLAGS += $(BASIC_CFLAGS)
            ALL_LDFLAGS += $(BASIC_LDFLAGS)

            export DIFF TAR INSTALL DESTDIR SHELL_PATH


            ### Build rules

            SHELL = $(SHELL_PATH)

            all:: shell_compatibility_test

            ifeq "$(PROFILE)" "BUILD"
            all:: profile
            endif

            profile:: profile-clean
                    $(MAKE) PROFILE=GEN all
                    $(MAKE) PROFILE=GEN -j1 test
                    @if test -n "$$GIT_PERF_REPO" || test -d .git; then \
                            $(MAKE) PROFILE=GEN -j1 perf; \
                    else \
                            echo "Skipping profile of perf tests..."; \
                    fi
                    $(MAKE) PROFILE=USE all

            profile-fast: profile-clean
                    $(MAKE) PROFILE=GEN all
                    $(MAKE) PROFILE=GEN -j1 perf
                    $(MAKE) PROFILE=USE all


            all:: $(ALL_COMMANDS_TO_INSTALL) $(SCRIPT_LIB) $(OTHER_PROGRAMS) GIT-BUILD-OPTIONS
            ifneq (,$X)
                    $(QUIET_BUILT_IN)$(foreach p,$(patsubst %$X,%,$(filter %$X,$(ALL_COMMANDS_TO_INSTALL) $(OTHER_PROGRAMS))), if test ! -d '$p' && test ! '$p' -ef '$p$X'; then $(RM) '$p'; fi;)
            endif

            all::
            ifndef NO_TCLTK
                    $(QUIET_SUBDIR0)git-gui $(QUIET_SUBDIR1) gitexecdir='$(gitexec_instdir_SQ)' all
                    $(QUIET_SUBDIR0)gitk-git $(QUIET_SUBDIR1) all
            endif
                    $(QUIET_SUBDIR0)templates $(QUIET_SUBDIR1) SHELL_PATH='$(SHELL_PATH_SQ)' PERL_PATH='$(PERL_PATH_SQ)'

            # If you add a new fuzzer, please also make sure to run it in
            # ci/run-build-and-minimal-fuzzers.sh so that we make sure it still links and
            # runs in the future.
            FUZZ_OBJS += oss-fuzz/dummy-cmd-main.o
            FUZZ_OBJS += oss-fuzz/fuzz-commit-graph.o
            FUZZ_OBJS += oss-fuzz/fuzz-config.o
            FUZZ_OBJS += oss-fuzz/fuzz-credential-from-url-gently.o
            FUZZ_OBJS += oss-fuzz/fuzz-date.o
            FUZZ_OBJS += oss-fuzz/fuzz-pack-headers.o
            FUZZ_OBJS += oss-fuzz/fuzz-pack-idx.o
            FUZZ_OBJS += oss-fuzz/fuzz-parse-attr-line.o
            FUZZ_OBJS += oss-fuzz/fuzz-url-decode-mem.o
            .PHONY: fuzz-objs
            fuzz-objs: $(FUZZ_OBJS)

            # Always build fuzz objects even if not testing, to prevent bit-rot.
            all:: $(FUZZ_OBJS)

            FUZZ_PROGRAMS += $(patsubst %.o,%,$(filter-out %dummy-cmd-main.o,$(FUZZ_OBJS)))

            # Build fuzz programs when possible, even without the necessary fuzzing support,
            # to prevent bit-rot.
            ifdef LINK_FUZZ_PROGRAMS
            all:: $(FUZZ_PROGRAMS)
            endif

            please_set_SHELL_PATH_to_a_more_modern_shell:
                    @$$(:)

            shell_compatibility_test: please_set_SHELL_PATH_to_a_more_modern_shell

            strip: $(PROGRAMS) git$X
                    $(STRIP) $(STRIP_OPTS) $^

            ### Target-specific flags and dependencies

            # The generic compilation pattern rule and automatically
            # computed header dependencies (falling back to a dependency on
            # LIB_H) are enough to describe how most targets should be built,
            # but some targets are special enough to need something a little
            # different.
            #
            # - When a source file "foo.c" #includes a generated header file,
            #   we need to list that dependency for the "foo.o" target.
            #
            #   We also list it from other targets that are built from foo.c
            #   like "foo.sp" and "foo.s", even though that is easy to forget
            #   to do because the generated header is already present around
            #   after a regular build attempt.
            #
            # - Some code depends on configuration kept in makefile
            #   variables. The target-specific variable EXTRA_CPPFLAGS can
            #   be used to convey that information to the C preprocessor
            #   using -D options.
            #
            #   The "foo.o" target should have a corresponding dependency on
            #   a file that changes when the value of the makefile variable
            #   changes.  For example, targets making use of the
            #   $(GIT_VERSION) variable depend on GIT-VERSION-FILE.
            #
            #   Technically the ".sp" and ".s" targets do not need this
            #   dependency because they are force-built, but they get the
            #   same dependency for consistency. This way, you do not have to
            #   know how each target is implemented. And it means the
            #   dependencies here will not need to change if the force-build
            #   details change some day.

            git.sp git.s git.o: GIT-PREFIX
            git.sp git.s git.o: EXTRA_CPPFLAGS = \
                    '-DGIT_HTML_PATH="$(htmldir_relative_SQ)"' \
                    '-DGIT_MAN_PATH="$(mandir_relative_SQ)"' \
                    '-DGIT_INFO_PATH="$(infodir_relative_SQ)"'

            git$X: git.o GIT-LDFLAGS $(BUILTIN_OBJS) $(GITLIBS)
                    $(QUIET_LINK)$(CC) $(ALL_CFLAGS) -o $@ $(ALL_LDFLAGS) \
                            $(filter %.o,$^) $(LIBS)

            help.sp help.s help.o: command-list.h
            builtin/bugreport.sp builtin/bugreport.s builtin/bugreport.o: hook-list.h

            builtin/help.sp builtin/help.s builtin/help.o: config-list.h GIT-PREFIX
            builtin/help.sp builtin/help.s builtin/help.o: EXTRA_CPPFLAGS = \
                    '-DGIT_HTML_PATH="$(htmldir_relative_SQ)"' \
                    '-DGIT_MAN_PATH="$(mandir_relative_SQ)"' \
                    '-DGIT_INFO_PATH="$(infodir_relative_SQ)"'

            PAGER_ENV_SQ = $(subst ','\'',$(PAGER_ENV))
            PAGER_ENV_CQ = "$(subst ",\",$(subst \,\\,$(PAGER_ENV)))"
            PAGER_ENV_CQ_SQ = $(subst ','\'',$(PAGER_ENV_CQ))
            pager.sp pager.s pager.o: EXTRA_CPPFLAGS = \
                    -DPAGER_ENV='$(PAGER_ENV_CQ_SQ)'

            version-def.h: version-def.h.in GIT-VERSION-GEN GIT-VERSION-FILE GIT-USER-AGENT
                    $(QUIET_GEN)$(call version_gen,"$(shell pwd)",$<,$@)

            version.sp version.s version.o: version-def.h

            $(BUILT_INS): git$X
                    $(QUIET_BUILT_IN)$(RM) $@ && \
                    ln $< $@ 2>/dev/null || \
                    ln -s $< $@ 2>/dev/null || \
                    cp $< $@

            config-list.h: generate-configlist.sh

            config-list.h: Documentation/*config.txt Documentation/config/*.txt
                    $(QUIET_GEN)$(SHELL_PATH) ./generate-configlist.sh . $@

            command-list.h: generate-cmdlist.sh command-list.txt

            command-list.h: $(wildcard Documentation/git*.txt)
                    $(QUIET_GEN)$(SHELL_PATH) ./generate-cmdlist.sh \
                            $(patsubst %,--exclude-program %,$(EXCLUDED_PROGRAMS)) \
                            . $@

            hook-list.h: generate-hooklist.sh Documentation/githooks.txt
                    $(QUIET_GEN)$(SHELL_PATH) ./generate-hooklist.sh . $@

            SCRIPT_DEFINES = $(SHELL_PATH_SQ):$(DIFF_SQ):\
                    $(localedir_SQ):$(USE_GETTEXT_SCHEME):$(SANE_TOOL_PATH_SQ):\
                    $(gitwebdir_SQ):$(PERL_PATH_SQ):$(PAGER_ENV):\
                    $(perllibdir_SQ)
            GIT-SCRIPT-DEFINES: FORCE
                    @FLAGS='$(SCRIPT_DEFINES)'; \
                    if test x"$$FLAGS" != x"`cat $@ 2>/dev/null`" ; then \
                            echo >&2 "    * new script parameters"; \
                            echo "$$FLAGS" >$@; \
                    fi

            $(SCRIPT_SH_GEN) $(SCRIPT_LIB) : % : %.sh generate-script.sh GIT-BUILD-OPTIONS GIT-SCRIPT-DEFINES
                    $(QUIET_GEN)./generate-script.sh "$<" "$@+" ./GIT-BUILD-OPTIONS && \
                    mv $@+ $@

            git.rc: git.rc.in GIT-VERSION-GEN GIT-VERSION-FILE
                    $(QUIET_GEN)$(call version_gen,"$(shell pwd)",$<,$@)

            git.res: git.rc GIT-PREFIX
                    $(QUIET_RC)$(RC) -i $< -o $@

            # This makes sure we depend on the NO_PERL setting itself.
            $(SCRIPT_PERL_GEN): GIT-BUILD-OPTIONS

            # Used for substitution in Perl modules. Disabled when using RUNTIME_PREFIX
            # since the locale directory is injected.
            perl_localedir_SQ = $(localedir_SQ)

            ifndef NO_PERL
            PERL_HEADER_TEMPLATE = perl/header_templates/fixed_prefix.template.pl
            PERL_DEFINES =
            PERL_DEFINES += $(PERL_PATH_SQ)
            PERL_DEFINES += $(PERLLIB_EXTRA_SQ)
            PERL_DEFINES += $(perllibdir_SQ)
            PERL_DEFINES += $(RUNTIME_PREFIX)
            PERL_DEFINES += $(NO_PERL_CPAN_FALLBACKS)
            PERL_DEFINES += $(NO_GETTEXT)

            # Support Perl runtime prefix. In this mode, a different header is installed
            # into Perl scripts.
            ifdef RUNTIME_PREFIX

            PERL_HEADER_TEMPLATE = perl/header_templates/runtime_prefix.template.pl

            # Don't export a fixed $(localedir) path; it will be resolved by the Perl header
            # at runtime.
            perl_localedir_SQ =

            endif

            PERL_DEFINES += $(gitexecdir) $(perllibdir) $(localedir)

            $(SCRIPT_PERL_GEN): % : %.perl generate-perl.sh GIT-PERL-DEFINES GIT-PERL-HEADER GIT-VERSION-FILE
                    $(QUIET_GEN)$(SHELL_PATH) generate-perl.sh ./GIT-BUILD-OPTIONS ./GIT-VERSION-FILE GIT-PERL-HEADER "$<" "$@+" && \
                    mv $@+ $@

            PERL_DEFINES := $(subst $(space),:,$(PERL_DEFINES))
            GIT-PERL-DEFINES: FORCE
                    @FLAGS='$(PERL_DEFINES)'; \
                    if test x"$$FLAGS" != x"`cat $@ 2>/dev/null`" ; then \
                            echo >&2 "    * new perl-specific parameters"; \
                            echo "$$FLAGS" >$@; \
                    fi

            GIT-PERL-HEADER: $(PERL_HEADER_TEMPLATE) GIT-PERL-DEFINES Makefile
                    $(QUIET_GEN) \
                    INSTLIBDIR='$(perllibdir_SQ)' && \
                    INSTLIBDIR_EXTRA='$(PERLLIB_EXTRA_SQ)' && \
                    INSTLIBDIR="$$INSTLIBDIR$${INSTLIBDIR_EXTRA:+:$$INSTLIBDIR_EXTRA}" && \
                    sed -e 's=@PATHSEP@=$(pathsep)=g' \
                    -e "s=@INSTLIBDIR@=$$INSTLIBDIR=g" \
                    -e 's=@PERLLIBDIR_REL@=$(perllibdir_relative_SQ)=g' \
                    -e 's=@GITEXECDIR_REL@=$(gitexecdir_relative_SQ)=g' \
                    -e 's=@LOCALEDIR_REL@=$(localedir_relative_SQ)=g' \
                    $< >$@+ && \
                    mv $@+ $@

            .PHONY: perllibdir
            perllibdir:
                    @echo '$(perllibdir_SQ)'

            git-instaweb: git-instaweb.sh generate-script.sh GIT-BUILD-OPTIONS GIT-SCRIPT-DEFINES
                    $(QUIET_GEN)./generate-script.sh "$<" "$@+" ./GIT-BUILD-OPTIONS && \
                    chmod +x $@+ && \
                    mv $@+ $@
            else # NO_PERL
            $(SCRIPT_PERL_GEN) git-instaweb: % : unimplemented.sh
                    $(QUIET_GEN) \
                    sed -e '1s|#!.*/sh|#!$(SHELL_PATH_SQ)|' \
                    -e 's|@REASON@|NO_PERL=$(NO_PERL)|g' \
                    unimplemented.sh >$@+ && \
                    chmod +x $@+ && \
                    mv $@+ $@
            endif # NO_PERL

            # This makes sure we depend on the NO_PYTHON setting itself.
            $(SCRIPT_PYTHON_GEN): GIT-BUILD-OPTIONS

            ifndef NO_PYTHON
            $(SCRIPT_PYTHON_GEN): generate-python.sh
            $(SCRIPT_PYTHON_GEN): % : %.py
                    $(QUIET_GEN)$(SHELL_PATH) generate-python.sh ./GIT-BUILD-OPTIONS "$<" "$@"
            else # NO_PYTHON
            $(SCRIPT_PYTHON_GEN): % : unimplemented.sh
                    $(QUIET_GEN) \
                    sed -e '1s|#!.*/sh|#!$(SHELL_PATH_SQ)|' \
                    -e 's|@REASON@|NO_PYTHON=$(NO_PYTHON)|g' \
                    unimplemented.sh >$@+ && \
                    chmod +x $@+ && \
                    mv $@+ $@
            endif # NO_PYTHON

            CONFIGURE_RECIPE = sed -e 's/@GIT_VERSION@/$(GIT_VERSION)/g' \
                                    configure.ac >configure.ac+ && \
                            autoconf -o configure configure.ac+ && \
                            $(RM) configure.ac+

            configure: configure.ac GIT-VERSION-FILE
                    $(QUIET_GEN)$(CONFIGURE_RECIPE)

            ifdef AUTOCONFIGURED
            # We avoid depending on 'configure' here, because it gets rebuilt
            # every time GIT-VERSION-FILE is modified, only to update the embedded
            # version number string, which config.status does not care about.  We
            # do want to recheck when the platform/environment detection logic
            # changes, hence this depends on configure.ac.
            config.status: configure.ac
                    $(QUIET_GEN)$(CONFIGURE_RECIPE) && \
                    if test -f config.status; then \
                    ./config.status --recheck; \
                    else \
                    ./configure; \
                    fi
            reconfigure config.mak.autogen: config.status
                    $(QUIET_GEN)./config.status
            .PHONY: reconfigure # This is a convenience target.
            endif

            XDIFF_OBJS += xdiff/xdiffi.o
            XDIFF_OBJS += xdiff/xemit.o
            XDIFF_OBJS += xdiff/xhistogram.o
            XDIFF_OBJS += xdiff/xmerge.o
            XDIFF_OBJS += xdiff/xpatience.o
            XDIFF_OBJS += xdiff/xprepare.o
            XDIFF_OBJS += xdiff/xutils.o
            .PHONY: xdiff-objs
            xdiff-objs: $(XDIFF_OBJS)

            REFTABLE_OBJS += reftable/basics.o
            REFTABLE_OBJS += reftable/error.o
            REFTABLE_OBJS += reftable/block.o
            REFTABLE_OBJS += reftable/blocksource.o
            REFTABLE_OBJS += reftable/iter.o
            REFTABLE_OBJS += reftable/merged.o
            REFTABLE_OBJS += reftable/pq.o
            REFTABLE_OBJS += reftable/reader.o
            REFTABLE_OBJS += reftable/record.o
            REFTABLE_OBJS += reftable/stack.o
            REFTABLE_OBJS += reftable/system.o
            REFTABLE_OBJS += reftable/tree.o
            REFTABLE_OBJS += reftable/writer.o

            TEST_OBJS := $(patsubst %$X,%.o,$(TEST_PROGRAMS)) $(patsubst %,t/helper/%,$(TEST_BUILTINS_OBJS))

            .PHONY: test-objs
            test-objs: $(TEST_OBJS)

            GIT_OBJS += $(LIB_OBJS)
            GIT_OBJS += $(BUILTIN_OBJS)
            GIT_OBJS += common-main.o
            GIT_OBJS += git.o
            .PHONY: git-objs
            git-objs: $(GIT_OBJS)

            SCALAR_OBJS += scalar.o
            .PHONY: scalar-objs
            scalar-objs: $(SCALAR_OBJS)

            OBJECTS += $(GIT_OBJS)
            OBJECTS += $(SCALAR_OBJS)
            OBJECTS += $(PROGRAM_OBJS)
            OBJECTS += $(TEST_OBJS)
            OBJECTS += $(XDIFF_OBJS)
            OBJECTS += $(FUZZ_OBJS)
            OBJECTS += $(REFTABLE_OBJS) $(REFTABLE_TEST_OBJS)
            OBJECTS += $(UNIT_TEST_OBJS)
            OBJECTS += $(CLAR_TEST_OBJS)
            OBJECTS += $(patsubst %,$(UNIT_TEST_DIR)/%.o,$(UNIT_TEST_PROGRAMS))

            ifndef NO_CURL
                    OBJECTS += http.o http-walker.o remote-curl.o
            endif

            .PHONY: objects
            objects: $(OBJECTS)

            dep_files := $(foreach f,$(OBJECTS),$(dir $f).depend/$(notdir $f).d)
            dep_dirs := $(addsuffix .depend,$(sort $(dir $(OBJECTS))))

            ifeq ($(COMPUTE_HEADER_DEPENDENCIES),yes)
            $(dep_dirs):
                    @mkdir -p $@

            missing_dep_dirs := $(filter-out $(wildcard $(dep_dirs)),$(dep_dirs))
            dep_file = $(dir $@).depend/$(notdir $@).d
            dep_args = -MF $(dep_file) -MQ $@ -MMD -MP
            endif

            ifneq ($(COMPUTE_HEADER_DEPENDENCIES),yes)
            missing_dep_dirs =
            dep_args =
            endif

            compdb_dir = compile_commands

            ifeq ($(GENERATE_COMPILATION_DATABASE),yes)
            missing_compdb_dir = $(compdb_dir)
            $(missing_compdb_dir):
                    @mkdir -p $@

            compdb_file = $(compdb_dir)/$(subst /,-,$@.json)
            compdb_args = -MJ $(compdb_file)
            else
            missing_compdb_dir =
            compdb_args =
            endif

            $(OBJECTS): %.o: %.c GIT-CFLAGS $(missing_dep_dirs) $(missing_compdb_dir)
                    $(QUIET_CC)$(CC) -o $*.o -c $(dep_args) $(compdb_args) $(ALL_CFLAGS) $(EXTRA_CPPFLAGS) $<

            %.s: %.c GIT-CFLAGS FORCE
                    $(QUIET_CC)$(CC) -o $@ -S $(ALL_CFLAGS) $(EXTRA_CPPFLAGS) $<

            ifdef USE_COMPUTED_HEADER_DEPENDENCIES
            # Take advantage of gcc's on-the-fly dependency generation
            # See <https://gcc.gnu.org/gcc-3.0/features.html>.
            dep_files_present := $(wildcard $(dep_files))
            ifneq ($(dep_files_present),)
            include $(dep_files_present)
            endif
            else
            $(OBJECTS): $(LIB_H) $(GENERATED_H)
            endif

            ifeq ($(GENERATE_COMPILATION_DATABASE),yes)
            all:: compile_commands.json
            compile_commands.json:
                    $(QUIET_GEN)sed -e '1s/^/[/' -e '$$s/,$$/]/' $(compdb_dir)/*.o.json > $@+
                    @if test -s $@+; then mv $@+ $@; else $(RM) $@+; fi
            endif

            exec-cmd.sp exec-cmd.s exec-cmd.o: GIT-PREFIX
            exec-cmd.sp exec-cmd.s exec-cmd.o: EXTRA_CPPFLAGS = \
                    '-DGIT_EXEC_PATH="$(gitexecdir_SQ)"' \
                    '-DGIT_LOCALE_PATH="$(localedir_relative_SQ)"' \
                    '-DBINDIR="$(bindir_relative_SQ)"' \
                    '-DFALLBACK_RUNTIME_PREFIX="$(prefix_SQ)"'

            setup.sp setup.s setup.o: GIT-PREFIX
            setup.sp setup.s setup.o: EXTRA_CPPFLAGS = \
                    -DDEFAULT_GIT_TEMPLATE_DIR='"$(template_dir_SQ)"'

            config.sp config.s config.o: GIT-PREFIX
            config.sp config.s config.o: EXTRA_CPPFLAGS = \
                    -DETC_GITCONFIG='"$(ETC_GITCONFIG_SQ)"'

            attr.sp attr.s attr.o: GIT-PREFIX
            attr.sp attr.s attr.o: EXTRA_CPPFLAGS = \
                    -DETC_GITATTRIBUTES='"$(ETC_GITATTRIBUTES_SQ)"'

            gettext.sp gettext.s gettext.o: GIT-PREFIX
            gettext.sp gettext.s gettext.o: EXTRA_CPPFLAGS = \
                    -DGIT_LOCALE_PATH='"$(localedir_relative_SQ)"'

            http-push.sp http.sp http-walker.sp remote-curl.sp imap-send.sp: SP_EXTRA_FLAGS += \
                    -DCURL_DISABLE_TYPECHECK

            pack-revindex.sp: SP_EXTRA_FLAGS += -Wno-memcpy-max-count

            ifdef NO_EXPAT
            http-walker.sp http-walker.s http-walker.o: EXTRA_CPPFLAGS = -DNO_EXPAT
            endif

            ifdef NO_REGEX
            compat/regex/regex.sp compat/regex/regex.o: EXTRA_CPPFLAGS = \
                    -DGAWK -DNO_MBSUPPORT
            endif

            ifdef USE_NED_ALLOCATOR
            compat/nedmalloc/nedmalloc.sp compat/nedmalloc/nedmalloc.o: EXTRA_CPPFLAGS = \
                    -DNDEBUG -DREPLACE_SYSTEM_ALLOCATOR
            compat/nedmalloc/nedmalloc.sp: SP_EXTRA_FLAGS += -Wno-non-pointer-null
            endif

            headless-git.o: compat/win32/headless.c GIT-CFLAGS
                    $(QUIET_CC)$(CC) $(ALL_CFLAGS) $(COMPAT_CFLAGS) \
                            -fno-stack-protector -o $@ -c -Wall -Wwrite-strings $<

            headless-git$X: headless-git.o git.res GIT-LDFLAGS
                    $(QUIET_LINK)$(CC) $(ALL_CFLAGS) $(ALL_LDFLAGS) -mwindows -o $@ $< git.res

            git-%$X: %.o GIT-LDFLAGS $(GITLIBS)
                    $(QUIET_LINK)$(CC) $(ALL_CFLAGS) -o $@ $(ALL_LDFLAGS) $(filter %.o,$^) $(LIBS)

            git-imap-send$X: imap-send.o $(IMAP_SEND_BUILDDEPS) GIT-LDFLAGS $(GITLIBS)
                    $(QUIET_LINK)$(CC) $(ALL_CFLAGS) -o $@ $(ALL_LDFLAGS) $(filter %.o,$^) \
                            $(IMAP_SEND_LDFLAGS) $(LIBS)

            git-http-fetch$X: http.o http-walker.o http-fetch.o GIT-LDFLAGS $(GITLIBS)
                    $(QUIET_LINK)$(CC) $(ALL_CFLAGS) -o $@ $(ALL_LDFLAGS) $(filter %.o,$^) \
                            $(CURL_LIBCURL) $(LIBS)
            git-http-push$X: http.o http-push.o GIT-LDFLAGS $(GITLIBS)
                    $(QUIET_LINK)$(CC) $(ALL_CFLAGS) -o $@ $(ALL_LDFLAGS) $(filter %.o,$^) \
                            $(CURL_LIBCURL) $(EXPAT_LIBEXPAT) $(LIBS)

            $(REMOTE_CURL_ALIASES): $(REMOTE_CURL_PRIMARY)
                    $(QUIET_LNCP)$(RM) $@ && \
                    ln $< $@ 2>/dev/null || \
                    ln -s $< $@ 2>/dev/null || \
                    cp $< $@

            $(REMOTE_CURL_PRIMARY): remote-curl.o http.o http-walker.o GIT-LDFLAGS $(GITLIBS)
                    $(QUIET_LINK)$(CC) $(ALL_CFLAGS) -o $@ $(ALL_LDFLAGS) $(filter %.o,$^) \
                            $(CURL_LIBCURL) $(EXPAT_LIBEXPAT) $(LIBS)

            scalar$X: scalar.o GIT-LDFLAGS $(GITLIBS)
                    $(QUIET_LINK)$(CC) $(ALL_CFLAGS) -o $@ $(ALL_LDFLAGS) \
                            $(filter %.o,$^) $(LIBS)

            $(LIB_FILE): $(LIB_OBJS)
                    $(QUIET_AR)$(RM) $@ && $(AR) $(ARFLAGS) $@ $^

            $(XDIFF_LIB): $(XDIFF_OBJS)
                    $(QUIET_AR)$(RM) $@ && $(AR) $(ARFLAGS) $@ $^

            $(REFTABLE_LIB): $(REFTABLE_OBJS)
                    $(QUIET_AR)$(RM) $@ && $(AR) $(ARFLAGS) $@ $^

            export DEFAULT_EDITOR DEFAULT_PAGER

            Documentation/GIT-EXCLUDED-PROGRAMS: FORCE
                    @EXCLUDED='EXCLUDED_PROGRAMS := $(EXCLUDED_PROGRAMS)'; \
                    if test x"$$EXCLUDED" != \
                            x"`cat Documentation/GIT-EXCLUDED-PROGRAMS 2>/dev/null`" ; then \
                            echo >&2 "    * new documentation flags"; \
                            echo "$$EXCLUDED" >Documentation/GIT-EXCLUDED-PROGRAMS; \
                    fi

            .PHONY: doc man man-perl html info pdf
            doc: man-perl
                    $(MAKE) -C Documentation all

            man: man-perl
                    $(MAKE) -C Documentation man

            man-perl: perl/build/man/man3/Git.3pm

            html:
                    $(MAKE) -C Documentation html

            info:
                    $(MAKE) -C Documentation info

            pdf:
                    $(MAKE) -C Documentation pdf

            XGETTEXT_FLAGS = \
                    --force-po \
                    --add-comments=TRANSLATORS: \
                    --msgid-bugs-address="Git Mailing List <git@vger.kernel.org>" \
                    --package-name=Git
            XGETTEXT_FLAGS_C = $(XGETTEXT_FLAGS) --language=C \
                    --keyword=_ --keyword=N_ --keyword="Q_:1,2"
            XGETTEXT_FLAGS_SH = $(XGETTEXT_FLAGS) --language=Shell \
                    --keyword=gettextln --keyword=eval_gettextln
            XGETTEXT_FLAGS_PERL = $(XGETTEXT_FLAGS) --language=Perl \
                    --keyword=__ --keyword=N__ --keyword="__n:1,2"
            MSGMERGE_FLAGS = --add-location --backup=off --update
            LOCALIZED_C = $(sort $(FOUND_C_SOURCES) $(FOUND_H_SOURCES) $(GENERATED_H))
            LOCALIZED_SH = $(sort $(SCRIPT_SH) git-sh-setup.sh)
            LOCALIZED_PERL = $(sort $(SCRIPT_PERL))

            ifdef XGETTEXT_INCLUDE_TESTS
            LOCALIZED_C += t/t0200/test.c
            LOCALIZED_SH += t/t0200/test.sh
            LOCALIZED_PERL += t/t0200/test.perl
            endif

            ## We generate intermediate .build/pot/po/%.po files containing a
            ## extract of the translations we find in each file in the source
            ## tree. We will assemble them using msgcat to create the final
            ## "po/git.pot" file.
            LOCALIZED_ALL_GEN_PO =

            LOCALIZED_C_GEN_PO = $(LOCALIZED_C:%=.build/pot/po/%.po)
            LOCALIZED_ALL_GEN_PO += $(LOCALIZED_C_GEN_PO)

            LOCALIZED_SH_GEN_PO = $(LOCALIZED_SH:%=.build/pot/po/%.po)
            LOCALIZED_ALL_GEN_PO += $(LOCALIZED_SH_GEN_PO)

            LOCALIZED_PERL_GEN_PO = $(LOCALIZED_PERL:%=.build/pot/po/%.po)
            LOCALIZED_ALL_GEN_PO += $(LOCALIZED_PERL_GEN_PO)

            ## Gettext tools cannot work with our own custom PRItime type, so
            ## we replace PRItime with PRIuMAX.  We need to update this to
            ## PRIdMAX if we switch to a signed type later.
            $(LOCALIZED_C_GEN_PO): .build/pot/po/%.po: %
                    $(call mkdir_p_parent_template)
                    $(QUIET_XGETTEXT) \
                    if grep -q PRItime $<; then \
                            (\
                                    sed -e 's|PRItime|PRIuMAX|g' <$< \
                                            >.build/pot/po/$< && \
                                    cd .build/pot/po && \
                                    $(XGETTEXT) --omit-header \
                                            -o $(@:.build/pot/po/%=%) \
                                            $(XGETTEXT_FLAGS_C) $< && \
                                    rm $<; \
                            ); \
                    else \
                            $(XGETTEXT) --omit-header \
                                    -o $@ $(XGETTEXT_FLAGS_C) $<; \
                    fi

            $(LOCALIZED_SH_GEN_PO): .build/pot/po/%.po: %
                    $(call mkdir_p_parent_template)
                    $(QUIET_XGETTEXT)$(XGETTEXT) --omit-header \
                            -o$@ $(XGETTEXT_FLAGS_SH) $<

            $(LOCALIZED_PERL_GEN_PO): .build/pot/po/%.po: %
                    $(call mkdir_p_parent_template)
                    $(QUIET_XGETTEXT)$(XGETTEXT) --omit-header \
                            -o$@ $(XGETTEXT_FLAGS_PERL) $<

            define gen_pot_header
            $(XGETTEXT) $(XGETTEXT_FLAGS_C) \
                    -o - /dev/null | \
            sed -e 's|charset=CHARSET|charset=UTF-8|' \
            -e 's|\(Last-Translator: \)FULL NAME <.*>|\1make by the Makefile|' \
            -e 's|\(Language-Team: \)LANGUAGE <.*>|\1Git Mailing List <git@vger.kernel.org>|' \
            >$@ && \
            echo '"Plural-Forms: nplurals=INTEGER; plural=EXPRESSION;\\n"' >>$@
            endef

            .build/pot/git.header: $(LOCALIZED_ALL_GEN_PO)
                    $(call mkdir_p_parent_template)
                    $(QUIET_GEN)$(gen_pot_header)

            po/git.pot: .build/pot/git.header $(LOCALIZED_ALL_GEN_PO)
                    $(QUIET_GEN)$(MSGCAT) $^ >$@

            .PHONY: pot
            pot: po/git.pot

            define check_po_file_envvar
                    $(if $(PO_FILE), \
                            $(if $(filter po/%.po,$(PO_FILE)), , \
                                    $(error PO_FILE should match pattern: "po/%.po")), \
                            $(error PO_FILE is not defined))
            endef

            .PHONY: po-update
            po-update: po/git.pot
                    $(check_po_file_envvar)
                    @if test ! -e $(PO_FILE); then \
                            echo >&2 "error: $(PO_FILE) does not exist"; \
                            echo >&2 'To create an initial po file, use: "make po-init PO_FILE=po/XX.po"'; \
                            exit 1; \
                    fi
                    $(QUIET_MSGMERGE)$(MSGMERGE) $(MSGMERGE_FLAGS) $(PO_FILE) po/git.pot

            .PHONY: check-pot
            check-pot: $(LOCALIZED_ALL_GEN_PO)

            ### TODO FIXME: Translating everything in these files is a bad
            ### heuristic for "core", as we'll translate obscure error() messages
            ### along with commonly seen i18n messages. A better heuristic would
            ### be to e.g. use spatch to first remove error/die/warning
            ### etc. messages.
            LOCALIZED_C_CORE =
            LOCALIZED_C_CORE += builtin/checkout.c
            LOCALIZED_C_CORE += builtin/clone.c
            LOCALIZED_C_CORE += builtin/index-pack.c
            LOCALIZED_C_CORE += builtin/push.c
            LOCALIZED_C_CORE += builtin/reset.c
            LOCALIZED_C_CORE += remote.c
            LOCALIZED_C_CORE += wt-status.c

            LOCALIZED_C_CORE_GEN_PO = $(LOCALIZED_C_CORE:%=.build/pot/po/%.po)

            .build/pot/git-core.header: $(LOCALIZED_C_CORE_GEN_PO)
                    $(call mkdir_p_parent_template)
                    $(QUIET_GEN)$(gen_pot_header)

            po/git-core.pot: .build/pot/git-core.header $(LOCALIZED_C_CORE_GEN_PO)
                    $(QUIET_GEN)$(MSGCAT) $^ >$@

            .PHONY: po-init
            po-init: po/git-core.pot
                    $(check_po_file_envvar)
                    @if test -e $(PO_FILE); then \
                            echo >&2 "error: $(PO_FILE) exists already"; \
                            exit 1; \
                    fi
                    $(QUIET_MSGINIT)msginit \
                            --input=$< \
                            --output=$(PO_FILE) \
                            --no-translator \
                            --locale=$(PO_FILE:po/%.po=%)

            ## po/*.po files & their rules
            ifdef NO_GETTEXT
            POFILES :=
            MOFILES :=
            else
            POFILES := $(wildcard po/*.po)
            MOFILES := $(patsubst po/%.po,po/build/locale/%/LC_MESSAGES/git.mo,$(POFILES))

            all:: $(MOFILES)
            endif

            po/build/locale/%/LC_MESSAGES/git.mo: po/%.po
                    $(call mkdir_p_parent_template)
                    $(QUIET_MSGFMT)$(MSGFMT) -o $@ $<

            LIB_PERL := $(wildcard perl/Git.pm perl/Git/*.pm perl/Git/*/*.pm perl/Git/*/*/*.pm)
            LIB_PERL_GEN := $(patsubst perl/%.pm,perl/build/lib/%.pm,$(LIB_PERL))
            LIB_CPAN := $(wildcard perl/FromCPAN/*.pm perl/FromCPAN/*/*.pm)
            LIB_CPAN_GEN := $(patsubst perl/%.pm,perl/build/lib/%.pm,$(LIB_CPAN))

            ifndef NO_PERL
            all:: $(LIB_PERL_GEN)
            ifndef NO_PERL_CPAN_FALLBACKS
            all:: $(LIB_CPAN_GEN)
            endif
            NO_PERL_CPAN_FALLBACKS_SQ = $(subst ','\'',$(NO_PERL_CPAN_FALLBACKS))
            endif

            perl/build/lib/%.pm: perl/%.pm generate-perl.sh GIT-BUILD-OPTIONS GIT-VERSION-FILE GIT-PERL-DEFINES
                    $(call mkdir_p_parent_template)
                    $(QUIET_GEN)$(SHELL_PATH) generate-perl.sh ./GIT-BUILD-OPTIONS ./GIT-VERSION-FILE GIT-PERL-HEADER "$<" "$@"

            perl/build/man/man3/Git.3pm: perl/Git.pm
                    $(call mkdir_p_parent_template)
                    $(QUIET_GEN)pod2man $< $@

            $(ETAGS_TARGET): $(FOUND_SOURCE_FILES)
                    $(QUIET_GEN)$(RM) $@+ && \
                    echo $(FOUND_SOURCE_FILES) | xargs etags -a -o $@+ && \
                    mv $@+ $@

            tags: $(FOUND_SOURCE_FILES)
                    $(QUIET_GEN)$(RM) $@+ && \
                    echo $(FOUND_SOURCE_FILES) | xargs ctags -a -o $@+ && \
                    mv $@+ $@

            cscope.out: $(FOUND_SOURCE_FILES)
                    $(QUIET_GEN)$(RM) $@+ && \
                    echo $(FOUND_SOURCE_FILES) | xargs cscope -f$@+ -b && \
                    mv $@+ $@

            .PHONY: cscope
            cscope: cscope.out

            ### Detect prefix changes
            TRACK_PREFIX = $(bindir_SQ):$(gitexecdir_SQ):$(template_dir_SQ):$(prefix_SQ):\
                            $(localedir_SQ)

            GIT-PREFIX: FORCE
                    @FLAGS='$(TRACK_PREFIX)'; \
                    if test x"$$FLAGS" != x"`cat GIT-PREFIX 2>/dev/null`" ; then \
                            echo >&2 "    * new prefix flags"; \
                            echo "$$FLAGS" >GIT-PREFIX; \
                    fi

            TRACK_CFLAGS = $(CC):$(subst ','\'',$(ALL_CFLAGS)):$(USE_GETTEXT_SCHEME)

            GIT-CFLAGS: FORCE
                    @FLAGS='$(TRACK_CFLAGS)'; \
                    if test x"$$FLAGS" != x"`cat GIT-CFLAGS 2>/dev/null`" ; then \
                            echo >&2 "    * new build flags"; \
                            echo "$$FLAGS" >GIT-CFLAGS; \
                    fi

            TRACK_LDFLAGS = $(subst ','\'',$(ALL_LDFLAGS))

            GIT-LDFLAGS: FORCE
                    @FLAGS='$(TRACK_LDFLAGS)'; \
                    if test x"$$FLAGS" != x"`cat GIT-LDFLAGS 2>/dev/null`" ; then \
                            echo >&2 "    * new link flags"; \
                            echo "$$FLAGS" >GIT-LDFLAGS; \
                    fi

            ifdef RUNTIME_PREFIX
            RUNTIME_PREFIX_OPTION = true
            else
            RUNTIME_PREFIX_OPTION = false
            endif

            # We need to apply sq twice, once to protect from the shell
            # that runs GIT-BUILD-OPTIONS, and then again to protect it
            # and the first level quoting from the shell that runs "echo".
            GIT-BUILD-OPTIONS: FORCE
                    @sed \
                            -e "s!@BROKEN_PATH_FIX@!\'$(BROKEN_PATH_FIX)\'!" \
                            -e "s|@DIFF@|\'$(DIFF)\'|" \
                            -e "s|@FSMONITOR_DAEMON_BACKEND@|\'$(FSMONITOR_DAEMON_BACKEND)\'|" \
                            -e "s|@FSMONITOR_OS_SETTINGS@|\'$(FSMONITOR_OS_SETTINGS)\'|" \
                            -e "s|@GITWEBDIR@|\'$(gitwebdir_SQ)\'|" \
                            -e "s|@GIT_INTEROP_MAKE_OPTS@|\'$(GIT_INTEROP_MAKE_OPTS)\'|" \
                            -e "s|@GIT_PERF_LARGE_REPO@|\'$(GIT_PERF_LARGE_REPO)\'|" \
                            -e "s|@GIT_PERF_MAKE_COMMAND@|\'$(GIT_PERF_MAKE_COMMAND)\'|" \
                            -e "s|@GIT_PERF_MAKE_OPTS@|\'$(GIT_PERF_MAKE_OPTS)\'|" \
                            -e "s|@GIT_PERF_REPEAT_COUNT@|\'$(GIT_PERF_REPEAT_COUNT)\'|" \
                            -e "s|@GIT_PERF_REPO@|\'$(GIT_PERF_REPO)\'|" \
                            -e "s|@GIT_TEST_CMP@|\'$(GIT_TEST_CMP)\'|" \
                            -e "s|@GIT_TEST_CMP_USE_COPIED_CONTEXT@|\'$(GIT_TEST_CMP_USE_COPIED_CONTEXT)\'|" \
                            -e "s|@GIT_TEST_GITPERLLIB@|\'$(shell pwd)/perl/build/lib\'|" \
                            -e "s|@GIT_TEST_INDEX_VERSION@|\'$(GIT_TEST_INDEX_VERSION)\'|" \
                            -e "s|@GIT_TEST_MERGE_TOOLS_DIR@|\'$(shell pwd)/mergetools\'|" \
                            -e "s|@GIT_TEST_OPTS@|\'$(GIT_TEST_OPTS)\'|" \
                            -e "s|@GIT_TEST_PERL_FATAL_WARNINGS@|\'$(GIT_TEST_PERL_FATAL_WARNINGS)\'|" \
                            -e "s|@GIT_TEST_POPATH@|\'$(shell pwd)/po\'|" \
                            -e "s|@GIT_TEST_TEMPLATE_DIR@|\'$(shell pwd)/templates/blt\'|" \
                            -e "s|@GIT_TEST_TEXTDOMAINDIR@|\'$(shell pwd)/po/build/locale\'|" \
                            -e "s|@GIT_TEST_UTF8_LOCALE@|\'$(GIT_TEST_UTF8_LOCALE)\'|" \
                            -e "s|@LOCALEDIR@|\'$(localedir_SQ)\'|" \
                            -e "s|@NO_CURL@|\'$(NO_CURL)\'|" \
                            -e "s|@NO_EXPAT@|\'$(NO_EXPAT)\'|" \
                            -e "s|@NO_GETTEXT@|\'$(NO_GETTEXT)\'|" \
                            -e "s|@NO_GITWEB@|\'$(NO_GITWEB)\'|" \
                            -e "s|@NO_ICONV@|\'$(NO_ICONV)\'|" \
                            -e "s|@NO_PERL@|\'$(NO_PERL)\'|" \
                            -e "s|@NO_PERL_CPAN_FALLBACKS@|\'$(NO_PERL_CPAN_FALLBACKS_SQ)\'|" \
                            -e "s|@NO_PTHREADS@|\'$(NO_PTHREADS)\'|" \
                            -e "s|@NO_PYTHON@|\'$(NO_PYTHON)\'|" \
                            -e "s|@NO_REGEX@|\'$(NO_REGEX)\'|" \
                            -e "s|@NO_UNIX_SOCKETS@|\'$(NO_UNIX_SOCKETS)\'|" \
                            -e "s|@PAGER_ENV@|\'$(PAGER_ENV)\'|" \
                            -e "s|@PERL_LOCALEDIR@|\'$(perl_localedir_SQ)\'|" \
                            -e "s|@PERL_PATH@|\'$(PERL_PATH_SQ)\'|" \
                            -e "s|@PYTHON_PATH@|\'$(PYTHON_PATH_SQ)\'|" \
                            -e "s|@RUNTIME_PREFIX@|\'$(RUNTIME_PREFIX_OPTION)\'|" \
                            -e "s|@SANITIZE_ADDRESS@|\'$(SANITIZE_ADDRESS)\'|" \
                            -e "s|@SANITIZE_LEAK@|\'$(SANITIZE_LEAK)\'|" \
                            -e "s|@SHELL_PATH@|\'$(SHELL_PATH_SQ)\'|" \
                            -e "s|@TAR@|\'$(TAR)\'|" \
                            -e "s|@TEST_OUTPUT_DIRECTORY@|\'$(TEST_OUTPUT_DIRECTORY)\'|" \
                            -e "s|@TEST_SHELL_PATH@|\'$(TEST_SHELL_PATH_SQ)\'|" \
                            -e "s|@USE_GETTEXT_SCHEME@|\'$(USE_GETTEXT_SCHEME)\'|" \
                            -e "s|@USE_LIBPCRE2@|\'$(USE_LIBPCRE2)\'|" \
                            -e "s|@X@|\'$(X)\'|" \
                            GIT-BUILD-OPTIONS.in >$@+
                    @if grep -q '^[A-Z][A-Z_]*=@.*@$$' $@+; then echo "Unsubstituted build options in $@" >&2 && exit 1; fi
                    @if cmp $@+ $@ >/dev/null 2>&1; then $(RM) $@+; else mv $@+ $@; fi
                    @if test -f GIT-BUILD-DIR; then rm GIT-BUILD-DIR; fi

            ### Detect Python interpreter path changes
            ifndef NO_PYTHON
            TRACK_PYTHON = $(subst ','\'',-DPYTHON_PATH='$(PYTHON_PATH_SQ)')

            GIT-PYTHON-VARS: FORCE
                    @VARS='$(TRACK_PYTHON)'; \
                    if test x"$$VARS" != x"`cat $@ 2>/dev/null`" ; then \
                            echo >&2 "    * new Python interpreter location"; \
                            echo "$$VARS" >$@; \
                    fi
            endif

            test_bindir_programs := $(patsubst %,bin-wrappers/%,$(BINDIR_PROGRAMS_NEED_X) $(BINDIR_PROGRAMS_NO_X) $(TEST_PROGRAMS_NEED_X))

            all:: $(TEST_PROGRAMS) $(test_bindir_programs) $(UNIT_TEST_PROGS) $(CLAR_TEST_PROG)

            $(test_bindir_programs): bin-wrappers/%: bin-wrappers/wrap-for-bin.sh
                    $(QUIET_GEN)sed -e '1s|#!.*/sh|#!$(SHELL_PATH_SQ)|' \
                    -e 's|@BUILD_DIR@|$(shell pwd)|' \
                    -e 's|@GIT_TEXTDOMAINDIR@|$(shell pwd)/po/build/locale|' \
                    -e 's|@GITPERLLIB@|$(shell pwd)/perl/build/lib|' \
                    -e 's|@MERGE_TOOLS_DIR@|$(shell pwd)/mergetools|' \
                    -e 's|@TEMPLATE_DIR@|$(shell pwd)/templates/blt|' \
                    -e 's|@PROG@|$(shell pwd)/$(patsubst test-%,t/helper/test-%,$(@F))$(if $(filter-out $(BINDIR_PROGRAMS_NO_X),$(@F)),$(X),)|' < $< > $@ && \
                    chmod +x $@

            # GNU make supports exporting all variables by "export" without parameters.
            # However, the environment gets quite big, and some programs have problems
            # with that.

            export NO_SVN_TESTS
            export TEST_NO_MALLOC_CHECK

            ### Testing rules

            test: all
                    $(MAKE) -C t/ all

            perf: all
                    $(MAKE) -C t/perf/ all

            .PHONY: test perf

            .PRECIOUS: $(TEST_OBJS)

            t/helper/test-tool$X: $(patsubst %,t/helper/%,$(TEST_BUILTINS_OBJS)) $(UNIT_TEST_DIR)/test-lib.o

            t/helper/test-%$X: t/helper/test-%.o GIT-LDFLAGS $(GITLIBS)
                    $(QUIET_LINK)$(CC) $(ALL_CFLAGS) -o $@ $(ALL_LDFLAGS) $(filter %.o,$^) $(filter %.a,$^) $(LIBS)

            check-sha1:: t/helper/test-tool$X
                    t/helper/test-sha1.sh

            SP_SRC = $(filter-out $(THIRD_PARTY_SOURCES),$(patsubst %.o,%.c,$(OBJECTS)))
            SP_OBJ = $(patsubst %.c,%.sp,$(SP_SRC))

            $(SP_OBJ): %.sp: %.c %.o $(GENERATED_H)
                    $(QUIET_SP)cgcc -no-compile $(ALL_CFLAGS) $(EXTRA_CPPFLAGS) \
                            -Wsparse-error \
                            $(SPARSE_FLAGS) $(SP_EXTRA_FLAGS) $< && \
                    >$@

            .PHONY: sparse
            sparse: $(SP_OBJ)

            EXCEPT_HDRS := $(GENERATED_H) unicode-width.h compat/% xdiff/% $(UNIT_TEST_DIR)/clar/% $(UNIT_TEST_DIR)/clar/clar/%
            ifndef OPENSSL_SHA1
                    EXCEPT_HDRS += sha1/openssl.h
            endif
            ifndef OPENSSL_SHA256
                    EXCEPT_HDRS += sha256/openssl.h
            endif
            ifndef NETTLE_SHA256
                    EXCEPT_HDRS += sha256/nettle.h
            endif
            ifndef GCRYPT_SHA256
                    EXCEPT_HDRS += sha256/gcrypt.h
            endif
            CHK_HDRS = $(filter-out $(EXCEPT_HDRS),$(LIB_H))
            HCO = $(patsubst %.h,%.hco,$(CHK_HDRS))
            HCC = $(HCO:hco=hcc)

            %.hcc: %.h
                    @echo '#include "git-compat-util.h"' >$@
                    @echo '#include "$<"' >>$@

            $(HCO): %.hco: %.hcc $(GENERATED_H) FORCE
                    $(QUIET_HDR)$(CC) $(ALL_CFLAGS) -o /dev/null -c -xc $<

            .PHONY: hdr-check $(HCO)
            hdr-check: $(HCO)

            .PHONY: style
            style:
                    git clang-format --style file --diff --extensions c,h

            .PHONY: check
            check:
                    @if sparse; \
                    then \
                            echo >&2 "Use 'make sparse' instead"; \
                            $(MAKE) --no-print-directory sparse; \
                    else \
                            echo >&2 "Did you mean 'make test'?"; \
                            exit 1; \
                    fi

            COCCI_GEN_ALL = .build/contrib/coccinelle/ALL.cocci
            COCCI_GLOB = $(wildcard contrib/coccinelle/*.cocci)
            COCCI_RULES_TRACKED = $(COCCI_GLOB:%=.build/%)
            COCCI_RULES_TRACKED_NO_PENDING = $(filter-out %.pending.cocci,$(COCCI_RULES_TRACKED))
            COCCI_RULES =
            COCCI_RULES += $(COCCI_GEN_ALL)
            COCCI_RULES += $(COCCI_RULES_TRACKED)
            COCCI_NAMES =
            COCCI_NAMES += $(COCCI_RULES:.build/contrib/coccinelle/%.cocci=%)

            COCCICHECK_PENDING = $(filter %.pending.cocci,$(COCCI_RULES))
            COCCICHECK = $(filter-out $(COCCICHECK_PENDING),$(COCCI_RULES))

            COCCICHECK_PATCHES = $(COCCICHECK:%=%.patch)
            COCCICHECK_PATCHES_PENDING = $(COCCICHECK_PENDING:%=%.patch)

            COCCICHECK_PATCHES_INTREE = $(COCCICHECK_PATCHES:.build/%=%)
            COCCICHECK_PATCHES_PENDING_INTREE = $(COCCICHECK_PATCHES_PENDING:.build/%=%)

            # It's expensive to compute the many=many rules below, only eval them
            # on $(MAKECMDGOALS) that match these $(COCCI_RULES)
            COCCI_RULES_GLOB =
            COCCI_RULES_GLOB += cocci%
            COCCI_RULES_GLOB += .build/contrib/coccinelle/%
            COCCI_RULES_GLOB += $(COCCICHECK_PATCHES)
            COCCI_RULES_GLOB += $(COCCICHEC_PATCHES_PENDING)
            COCCI_RULES_GLOB += $(COCCICHECK_PATCHES_INTREE)
            COCCI_RULES_GLOB += $(COCCICHECK_PATCHES_PENDING_INTREE)
            COCCI_GOALS = $(filter $(COCCI_RULES_GLOB),$(MAKECMDGOALS))

            COCCI_TEST_RES = $(wildcard contrib/coccinelle/tests/*.res)

            $(COCCI_RULES_TRACKED): .build/% : %
                    $(call mkdir_p_parent_template)
                    $(QUIET_CP)cp $< $@

            .build/contrib/coccinelle/FOUND_H_SOURCES: $(FOUND_H_SOURCES)
                    $(call mkdir_p_parent_template)
                    $(QUIET_GEN) >$@

            $(COCCI_GEN_ALL): $(COCCI_RULES_TRACKED_NO_PENDING)
                    $(call mkdir_p_parent_template)
                    $(QUIET_SPATCH_CAT)cat $^ >$@

            ifeq ($(COMPUTE_HEADER_DEPENDENCIES),no)
            SPATCH_USE_O_DEPENDENCIES =
            endif
            define cocci-rule

            ## Rule for .build/$(1).patch/$(2); Params:
            # $(1) = e.g. ".build/contrib/coccinelle/free.cocci"
            # $(2) = e.g. "grep.c"
            # $(3) = e.g. "grep.o"
            COCCI_$(1:.build/contrib/coccinelle/%.cocci=%) += $(1).d/$(2).patch
            $(1).d/$(2).patch: GIT-SPATCH-DEFINES
            $(1).d/$(2).patch: $(if $(and $(SPATCH_USE_O_DEPENDENCIES),$(wildcard $(3))),$(3),.build/contrib/coccinelle/FOUND_H_SOURCES)
            $(1).d/$(2).patch: $(1)
            $(1).d/$(2).patch: $(1).d/%.patch : %
                    $$(call mkdir_p_parent_template)
                    $$(QUIET_SPATCH)if ! $$(SPATCH) $$(SPATCH_FLAGS) \
                            $$(SPATCH_INCLUDE_FLAGS) \
                            --sp-file $(1) --patch . $$< \
                            >$$@ 2>$$@.log; \
                    then \
                            echo "ERROR when applying '$(1)' to '$$<'; '$$@.log' follows:"; \
                            cat $$@.log; \
                            exit 1; \
                    fi
            endef

            define cocci-matrix

            $(foreach s,$(COCCI_SOURCES),$(call cocci-rule,$(c),$(s),$(s:%.c=%.o)))
            endef

            ifdef COCCI_GOALS
            $(eval $(foreach c,$(COCCI_RULES),$(call cocci-matrix,$(c))))
            endif

            define spatch-rule

            .build/contrib/coccinelle/$(1).cocci.patch: $$(COCCI_$(1))
                    $$(QUIET_SPATCH_CAT)cat $$^ >$$@ && \
                    if test -s $$@; \
                    then \
                            echo '    ' SPATCH result: $$@; \
                    fi
            contrib/coccinelle/$(1).cocci.patch: .build/contrib/coccinelle/$(1).cocci.patch
                    $$(QUIET_CP)cp $$< $$@

            endef

            ifdef COCCI_GOALS
            $(eval $(foreach n,$(COCCI_NAMES),$(call spatch-rule,$(n))))
            endif

            COCCI_TEST_RES_GEN = $(addprefix .build/,$(COCCI_TEST_RES))
            $(COCCI_TEST_RES_GEN): GIT-SPATCH-DEFINES
            $(COCCI_TEST_RES_GEN): .build/%.res : %.c
            $(COCCI_TEST_RES_GEN): .build/%.res : %.res
            ifdef SPATCH_CONCAT_COCCI
            $(COCCI_TEST_RES_GEN): .build/contrib/coccinelle/tests/%.res : $(COCCI_GEN_ALL)
            else
            $(COCCI_TEST_RES_GEN): .build/contrib/coccinelle/tests/%.res : contrib/coccinelle/%.cocci
            endif
                    $(call mkdir_p_parent_template)
                    $(QUIET_SPATCH_TEST)$(SPATCH) $(SPATCH_TEST_FLAGS) \
                            --very-quiet --no-show-diff \
                            --sp-file $< -o $@ \
                            $(@:.build/%.res=%.c) && \
                    cmp $(@:.build/%=%) $@ || \
                    git -P diff --no-index $(@:.build/%=%) $@ 2>/dev/null; \

            .PHONY: coccicheck-test
            coccicheck-test: $(COCCI_TEST_RES_GEN)

            coccicheck: coccicheck-test
            ifdef SPATCH_CONCAT_COCCI
            coccicheck: contrib/coccinelle/ALL.cocci.patch
            else
            coccicheck: $(COCCICHECK_PATCHES_INTREE)
            endif

            # See contrib/coccinelle/README
            coccicheck-pending: coccicheck-test
            coccicheck-pending: $(COCCICHECK_PATCHES_PENDING_INTREE)

            .PHONY: coccicheck coccicheck-pending

            # "Sub"-Makefiles, not really because they can't be run stand-alone,
            # only there to contain directory-specific rules and variables
            ## gitweb/Makefile inclusion:
            MAK_DIR_GITWEB = gitweb/
            include gitweb/Makefile

            .PHONY: gitweb
            gitweb: $(MAK_DIR_GITWEB_ALL)
            ifndef NO_GITWEB
            all:: gitweb
            endif

            ### Installation rules

            ifneq ($(filter /%,$(firstword $(template_dir))),)
            template_instdir = $(template_dir)
            else
            template_instdir = $(prefix)/$(template_dir)
            endif
            export template_instdir

            ifneq ($(filter /%,$(firstword $(gitexecdir))),)
            gitexec_instdir = $(gitexecdir)
            else
            gitexec_instdir = $(prefix)/$(gitexecdir)
            endif
            gitexec_instdir_SQ = $(subst ','\'',$(gitexec_instdir))
            export gitexec_instdir

            ifneq ($(filter /%,$(firstword $(mergetoolsdir))),)
            mergetools_instdir = $(mergetoolsdir)
            else
            mergetools_instdir = $(prefix)/$(mergetoolsdir)
            endif
            mergetools_instdir_SQ = $(subst ','\'',$(mergetools_instdir))

            install_bindir_xprograms := $(patsubst %,%$X,$(BINDIR_PROGRAMS_NEED_X))
            install_bindir_programs := $(install_bindir_xprograms) $(BINDIR_PROGRAMS_NO_X)

            .PHONY: profile-install profile-fast-install
            profile-install: profile
                    $(MAKE) install

            profile-fast-install: profile-fast
                    $(MAKE) install

            INSTALL_STRIP =

            install: all
                    $(INSTALL) -d -m 755 '$(DESTDIR_SQ)$(bindir_SQ)'
                    $(INSTALL) -d -m 755 '$(DESTDIR_SQ)$(gitexec_instdir_SQ)'
                    $(INSTALL) $(INSTALL_STRIP) $(PROGRAMS) '$(DESTDIR_SQ)$(gitexec_instdir_SQ)'
                    $(INSTALL) $(SCRIPTS) '$(DESTDIR_SQ)$(gitexec_instdir_SQ)'
                    $(INSTALL) -m 644 $(SCRIPT_LIB) '$(DESTDIR_SQ)$(gitexec_instdir_SQ)'
                    $(INSTALL) $(INSTALL_STRIP) $(install_bindir_xprograms) '$(DESTDIR_SQ)$(bindir_SQ)'
                    $(INSTALL) $(BINDIR_PROGRAMS_NO_X) '$(DESTDIR_SQ)$(bindir_SQ)'

            ifdef MSVC
                    # We DO NOT install the individual foo.o.pdb files because they
                    # have already been rolled up into the exe's pdb file.
                    # We DO NOT have pdb files for the builtin commands (like git-status.exe)
                    # because it is just a copy/hardlink of git.exe, rather than a unique binary.
                    $(INSTALL) $(patsubst %.exe,%.pdb,$(filter-out $(BUILT_INS),$(patsubst %,%$X,$(BINDIR_PROGRAMS_NEED_X)))) '$(DESTDIR_SQ)$(bindir_SQ)'
                    $(INSTALL) $(patsubst %.exe,%.pdb,$(filter-out $(BUILT_INS) $(REMOTE_CURL_ALIASES),$(PROGRAMS))) '$(DESTDIR_SQ)$(gitexec_instdir_SQ)'
            ifndef DEBUG
                    $(INSTALL) $(vcpkg_rel_bin)/*.dll '$(DESTDIR_SQ)$(bindir_SQ)'
                    $(INSTALL) $(vcpkg_rel_bin)/*.pdb '$(DESTDIR_SQ)$(bindir_SQ)'
            else
                    $(INSTALL) $(vcpkg_dbg_bin)/*.dll '$(DESTDIR_SQ)$(bindir_SQ)'
                    $(INSTALL) $(vcpkg_dbg_bin)/*.pdb '$(DESTDIR_SQ)$(bindir_SQ)'
            endif
            endif
                    $(MAKE) -C templates DESTDIR='$(DESTDIR_SQ)' install
                    $(INSTALL) -d -m 755 '$(DESTDIR_SQ)$(mergetools_instdir_SQ)'
                    $(INSTALL) -m 644 mergetools/* '$(DESTDIR_SQ)$(mergetools_instdir_SQ)'
            ifndef NO_GETTEXT
                    $(INSTALL) -d -m 755 '$(DESTDIR_SQ)$(localedir_SQ)'
                    (cd po/build/locale && $(TAR) cf - .) | \
                    (cd '$(DESTDIR_SQ)$(localedir_SQ)' && umask 022 && $(TAR) xof -)
            endif
            ifndef NO_PERL
                    $(INSTALL) -d -m 755 '$(DESTDIR_SQ)$(perllibdir_SQ)'
                    (cd perl/build/lib && $(TAR) cf - .) | \
                    (cd '$(DESTDIR_SQ)$(perllibdir_SQ)' && umask 022 && $(TAR) xof -)
            endif
            ifndef NO_TCLTK
                    $(MAKE) -C gitk-git install
                    $(MAKE) -C git-gui gitexecdir='$(gitexec_instdir_SQ)' install
            endif
            ifneq (,$X)
                    $(foreach p,$(patsubst %$X,%,$(filter %$X,$(ALL_COMMANDS_TO_INSTALL) $(OTHER_PROGRAMS))), test '$(DESTDIR_SQ)$(gitexec_instdir_SQ)/$p' -ef '$(DESTDIR_SQ)$(gitexec_instdir_SQ)/$p$X' || $(RM) '$(DESTDIR_SQ)$(gitexec_instdir_SQ)/$p';)
            endif

                    bindir=$$(cd '$(DESTDIR_SQ)$(bindir_SQ)' && pwd) && \
                    execdir=$$(cd '$(DESTDIR_SQ)$(gitexec_instdir_SQ)' && pwd) && \
                    destdir_from_execdir_SQ=$$(echo '$(gitexecdir_relative_SQ)' | sed -e 's|[^/][^/]*|..|g') && \
                    { test "$$bindir/" = "$$execdir/" || \
                    for p in $(OTHER_PROGRAMS) $(filter $(install_bindir_programs),$(ALL_PROGRAMS)); do \
                            $(RM) "$$execdir/$$p" && \
                            test -n "$(INSTALL_SYMLINKS)" && \
                            ln -s "$$destdir_from_execdir_SQ/$(bindir_relative_SQ)/$$p" "$$execdir/$$p" || \
                            { test -z "$(NO_INSTALL_HARDLINKS)$(NO_CROSS_DIRECTORY_HARDLINKS)" && \
                            ln "$$bindir/$$p" "$$execdir/$$p" 2>/dev/null || \
                            cp "$$bindir/$$p" "$$execdir/$$p" || exit; } \
                    done; \
                    } && \
                    for p in $(filter $(install_bindir_programs),$(BUILT_INS)); do \
                            $(RM) "$$bindir/$$p" && \
                            test -n "$(INSTALL_SYMLINKS)" && \
                            ln -s "git$X" "$$bindir/$$p" || \
                            { test -z "$(NO_INSTALL_HARDLINKS)" && \
                            ln "$$bindir/git$X" "$$bindir/$$p" 2>/dev/null || \
                            ln -s "git$X" "$$bindir/$$p" 2>/dev/null || \
                            cp "$$bindir/git$X" "$$bindir/$$p" || exit; }; \
                    done && \
                    for p in $(BUILT_INS); do \
                            $(RM) "$$execdir/$$p" && \
                            if test -z "$(SKIP_DASHED_BUILT_INS)"; \
                            then \
                                    test -n "$(INSTALL_SYMLINKS)" && \
                                    ln -s "$$destdir_from_execdir_SQ/$(bindir_relative_SQ)/git$X" "$$execdir/$$p" || \
                                    { test -z "$(NO_INSTALL_HARDLINKS)" && \
                                    ln "$$execdir/git$X" "$$execdir/$$p" 2>/dev/null || \
                                    ln -s "git$X" "$$execdir/$$p" 2>/dev/null || \
                                    cp "$$execdir/git$X" "$$execdir/$$p" || exit; }; \
                            fi \
                    done && \
                    remote_curl_aliases="$(REMOTE_CURL_ALIASES)" && \
                    for p in $$remote_curl_aliases; do \
                            $(RM) "$$execdir/$$p" && \
                            test -n "$(INSTALL_SYMLINKS)" && \
                            ln -s "git-remote-http$X" "$$execdir/$$p" || \
                            { test -z "$(NO_INSTALL_HARDLINKS)" && \
                            ln "$$execdir/git-remote-http$X" "$$execdir/$$p" 2>/dev/null || \
                            ln -s "git-remote-http$X" "$$execdir/$$p" 2>/dev/null || \
                            cp "$$execdir/git-remote-http$X" "$$execdir/$$p" || exit; } \
                    done

            .PHONY: install-doc install-man install-man-perl install-html install-info install-pdf
            .PHONY: quick-install-doc quick-install-man quick-install-html

            install-doc: install-man-perl
                    $(MAKE) -C Documentation install

            install-man: install-man-perl
                    $(MAKE) -C Documentation install-man

            install-man-perl: man-perl
                    $(INSTALL) -d -m 755 '$(DESTDIR_SQ)$(mandir_SQ)/man3'
                    (cd perl/build/man/man3 && $(TAR) cf - .) | \
                    (cd '$(DESTDIR_SQ)$(mandir_SQ)/man3' && umask 022 && $(TAR) xof -)

            install-html:
                    $(MAKE) -C Documentation install-html

            install-info:
                    $(MAKE) -C Documentation install-info

            install-pdf:
                    $(MAKE) -C Documentation install-pdf

            quick-install-doc:
                    $(MAKE) -C Documentation quick-install

            quick-install-man:
                    $(MAKE) -C Documentation quick-install-man

            quick-install-html:
                    $(MAKE) -C Documentation quick-install-html



            ### Maintainer's dist rules

            GIT_TARNAME = git-$(GIT_VERSION)
            GIT_ARCHIVE_EXTRA_FILES = \
                    --prefix=$(GIT_TARNAME)/ \
                    --add-file=configure \
                    --add-file=.dist-tmp-dir/version \
                    --prefix=$(GIT_TARNAME)/git-gui/ \
                    --add-file=.dist-tmp-dir/git-gui/version
            ifdef DC_SHA1_SUBMODULE
            GIT_ARCHIVE_EXTRA_FILES += \
                    --prefix=$(GIT_TARNAME)/sha1collisiondetection/ \
                    --add-file=sha1collisiondetection/LICENSE.txt \
                    --prefix=$(GIT_TARNAME)/sha1collisiondetection/lib/ \
                    --add-file=sha1collisiondetection/lib/sha1.c \
                    --add-file=sha1collisiondetection/lib/sha1.h \
                    --add-file=sha1collisiondetection/lib/ubc_check.c \
                    --add-file=sha1collisiondetection/lib/ubc_check.h
            endif
            dist: git-archive$(X) configure
                    @$(RM) -r .dist-tmp-dir
                    @mkdir .dist-tmp-dir
                    @echo $(GIT_VERSION) > .dist-tmp-dir/version
                    @$(MAKE) -C git-gui TARDIR=../.dist-tmp-dir/git-gui dist-version
                    ./git-archive --format=tar \
                            $(GIT_ARCHIVE_EXTRA_FILES) \
                            --prefix=$(GIT_TARNAME)/ HEAD^{tree} > $(GIT_TARNAME).tar
                    @$(RM) -r .dist-tmp-dir
                    gzip -f -9 $(GIT_TARNAME).tar

            rpm::
                    @echo >&2 "Use distro packaged sources to run rpmbuild"
                    @false
            .PHONY: rpm

            ifneq ($(INCLUDE_DLLS_IN_ARTIFACTS),)
            OTHER_PROGRAMS += $(shell echo *.dll t/helper/*.dll t/unit-tests/bin/*.dll)
            endif

            artifacts-tar:: $(ALL_COMMANDS_TO_INSTALL) $(SCRIPT_LIB) $(OTHER_PROGRAMS) \
                            GIT-BUILD-OPTIONS $(TEST_PROGRAMS) $(test_bindir_programs) \
                            $(UNIT_TEST_PROGS) $(CLAR_TEST_PROG) $(MOFILES)
                    $(QUIET_SUBDIR0)templates $(QUIET_SUBDIR1) \
                            SHELL_PATH='$(SHELL_PATH_SQ)' PERL_PATH='$(PERL_PATH_SQ)'
                    test -n "$(ARTIFACTS_DIRECTORY)"
                    mkdir -p "$(ARTIFACTS_DIRECTORY)"
                    $(TAR) czf "$(ARTIFACTS_DIRECTORY)/artifacts.tar.gz" $^ templates/blt/
            .PHONY: artifacts-tar

            htmldocs = git-htmldocs-$(GIT_VERSION)
            manpages = git-manpages-$(GIT_VERSION)
            .PHONY: dist-doc distclean
            dist-doc: git$X
                    $(RM) -r .doc-tmp-dir
                    mkdir .doc-tmp-dir
                    $(MAKE) -C Documentation WEBDOC_DEST=../.doc-tmp-dir install-webdoc
                    ./git -C .doc-tmp-dir init
                    ./git -C .doc-tmp-dir add .
                    ./git -C .doc-tmp-dir commit -m htmldocs
                    ./git -C .doc-tmp-dir archive --format=tar --prefix=./ HEAD^{tree} \
                            > $(htmldocs).tar
                    gzip -n -9 -f $(htmldocs).tar
                    :
                    $(RM) -r .doc-tmp-dir
                    mkdir -p .doc-tmp-dir/man1 .doc-tmp-dir/man5 .doc-tmp-dir/man7
                    $(MAKE) -C Documentation DESTDIR=./ \
                            man1dir=../.doc-tmp-dir/man1 \
                            man5dir=../.doc-tmp-dir/man5 \
                            man7dir=../.doc-tmp-dir/man7 \
                            install
                    ./git -C .doc-tmp-dir init
                    ./git -C .doc-tmp-dir add .
                    ./git -C .doc-tmp-dir commit -m manpages
                    ./git -C .doc-tmp-dir archive --format=tar --prefix=./ HEAD^{tree} \
                            > $(manpages).tar
                    gzip -n -9 -f $(manpages).tar
                    $(RM) -r .doc-tmp-dir

            ### Cleaning rules

            distclean: clean
                    $(RM) configure
                    $(RM) config.log config.status config.cache
                    $(RM) config.mak.autogen config.mak.append
                    $(RM) -r autom4te.cache

            profile-clean:
                    $(RM) $(addsuffix *.gcda,$(addprefix $(PROFILE_DIR)/, $(object_dirs)))
                    $(RM) $(addsuffix *.gcno,$(addprefix $(PROFILE_DIR)/, $(object_dirs)))

            cocciclean:
                    $(RM) GIT-SPATCH-DEFINES
                    $(RM) -r .build/contrib/coccinelle
                    $(RM) contrib/coccinelle/*.cocci.patch

            clean: profile-clean coverage-clean cocciclean
                    $(RM) -r .build $(UNIT_TEST_BIN)
                    $(RM) GIT-TEST-SUITES
                    $(RM) po/git.pot po/git-core.pot
                    $(RM) git.rc git.res
                    $(RM) $(OBJECTS)
                    $(RM) headless-git.o
                    $(RM) $(LIB_FILE) $(XDIFF_LIB) $(REFTABLE_LIB)
                    $(RM) $(ALL_PROGRAMS) $(SCRIPT_LIB) $(BUILT_INS) $(OTHER_PROGRAMS)
                    $(RM) $(TEST_PROGRAMS)
                    $(RM) $(FUZZ_PROGRAMS)
                    $(RM) $(SP_OBJ)
                    $(RM) $(HCC)
                    $(RM) version-def.h
                    $(RM) -r $(dep_dirs) $(compdb_dir) compile_commands.json
                    $(RM) $(test_bindir_programs)
                    $(RM) -r po/build/
                    $(RM) *.pyc *.pyo */*.pyc */*.pyo $(GENERATED_H) $(ETAGS_TARGET) tags cscope*
                    $(RM) -r .dist-tmp-dir .doc-tmp-dir
                    $(RM) $(GIT_TARNAME).tar.gz
                    $(RM) $(htmldocs).tar.gz $(manpages).tar.gz
                    $(MAKE) -C Documentation/ clean
                    $(RM) Documentation/GIT-EXCLUDED-PROGRAMS
            ifndef NO_PERL
                    $(RM) -r perl/build/
            endif
                    $(MAKE) -C templates/ clean
                    $(MAKE) -C t/ clean
            ifndef NO_TCLTK
                    $(MAKE) -C gitk-git clean
                    $(MAKE) -C git-gui clean
            endif
                    $(RM) GIT-VERSION-FILE GIT-CFLAGS GIT-LDFLAGS GIT-BUILD-OPTIONS
                    $(RM) GIT-USER-AGENT GIT-PREFIX
                    $(RM) GIT-SCRIPT-DEFINES GIT-PERL-DEFINES GIT-PERL-HEADER GIT-PYTHON-VARS
            ifdef MSVC
                    $(RM) $(patsubst %.o,%.o.pdb,$(OBJECTS))
                    $(RM) headless-git.o.pdb
                    $(RM) $(patsubst %.exe,%.pdb,$(OTHER_PROGRAMS))
                    $(RM) $(patsubst %.exe,%.iobj,$(OTHER_PROGRAMS))
                    $(RM) $(patsubst %.exe,%.ipdb,$(OTHER_PROGRAMS))
                    $(RM) $(patsubst %.exe,%.pdb,$(PROGRAMS))
                    $(RM) $(patsubst %.exe,%.iobj,$(PROGRAMS))
                    $(RM) $(patsubst %.exe,%.ipdb,$(PROGRAMS))
                    $(RM) $(patsubst %.exe,%.pdb,$(TEST_PROGRAMS))
                    $(RM) $(patsubst %.exe,%.iobj,$(TEST_PROGRAMS))
                    $(RM) $(patsubst %.exe,%.ipdb,$(TEST_PROGRAMS))
                    $(RM) compat/vcbuild/MSVC-DEFS-GEN
            endif

            .PHONY: all install profile-clean cocciclean clean strip
            .PHONY: shell_compatibility_test please_set_SHELL_PATH_to_a_more_modern_shell
            .PHONY: FORCE

            ### Check documentation
            #
            ALL_COMMANDS = $(ALL_COMMANDS_TO_INSTALL) $(SCRIPT_LIB)
            ALL_COMMANDS += git
            ALL_COMMANDS += git-citool
            ALL_COMMANDS += git-gui
            ALL_COMMANDS += gitk
            ALL_COMMANDS += gitweb
            ALL_COMMANDS += scalar

            .PHONY: check-docs
            check-docs::
                    $(MAKE) -C Documentation lint-docs

            ### Make sure built-ins do not have dups and listed in git.c
            #
            check-builtins::
                    ./check-builtins.sh

            ### Test suite coverage testing
            #
            .PHONY: coverage coverage-clean coverage-compile coverage-test coverage-report
            .PHONY: coverage-untested-functions cover_db cover_db_html
            .PHONY: coverage-clean-results

            coverage:
                    $(MAKE) coverage-test
                    $(MAKE) coverage-untested-functions

            object_dirs := $(sort $(dir $(OBJECTS)))
            coverage-clean-results:
                    $(RM) $(addsuffix *.gcov,$(object_dirs))
                    $(RM) $(addsuffix *.gcda,$(object_dirs))
                    $(RM) coverage-untested-functions
                    $(RM) -r cover_db/
                    $(RM) -r cover_db_html/
                    $(RM) coverage-test.made

            coverage-clean: coverage-clean-results
                    $(RM) $(addsuffix *.gcno,$(object_dirs))

            COVERAGE_CFLAGS = $(CFLAGS) -O0 -ftest-coverage -fprofile-arcs
            COVERAGE_LDFLAGS = $(CFLAGS)  -O0 -lgcov
            GCOVFLAGS = --preserve-paths --branch-probabilities --all-blocks

            coverage-compile:
                    $(MAKE) CFLAGS="$(COVERAGE_CFLAGS)" LDFLAGS="$(COVERAGE_LDFLAGS)" all

            coverage-test: coverage-clean-results coverage-compile
                    $(MAKE) CFLAGS="$(COVERAGE_CFLAGS)" LDFLAGS="$(COVERAGE_LDFLAGS)" \
                            DEFAULT_TEST_TARGET=test -j1 test
                    touch coverage-test.made

            coverage-test.made:
                    $(MAKE) coverage-test

            coverage-prove: coverage-clean-results coverage-compile
                    $(MAKE) CFLAGS="$(COVERAGE_CFLAGS)" LDFLAGS="$(COVERAGE_LDFLAGS)" \
                            DEFAULT_TEST_TARGET=prove GIT_PROVE_OPTS="$(GIT_PROVE_OPTS) -j1" \
                            -j1 test

            coverage-report: coverage-test.made
                    $(QUIET_GCOV)for dir in $(object_dirs); do \
                            $(GCOV) $(GCOVFLAGS) --object-directory=$$dir $$dir*.c || exit; \
                    done

            coverage-untested-functions: coverage-report
                    grep '^function.*called 0 ' *.c.gcov \
                            | sed -e 's/\([^:]*\)\.gcov: *function \([^ ]*\) called.*/\1: \2/' \
                            > coverage-untested-functions

            cover_db: coverage-report
                    gcov2perl -db cover_db *.gcov

            cover_db_html: cover_db
                    cover -report html -outputdir cover_db_html cover_db


            ### Fuzz testing
            #
            # Building fuzz targets generally requires a special set of compiler flags that
            # are not necessarily appropriate for general builds, and that vary greatly
            # depending on the compiler version used.
            #
            # An example command to build against libFuzzer from LLVM 11.0.0:
            #
            # make CC=clang FUZZ_CXX=clang++ \
            #      CFLAGS="-fsanitize=fuzzer-no-link,address" \
            #      LIB_FUZZING_ENGINE="-fsanitize=fuzzer,address" \
            #      fuzz-all
            #
            FUZZ_CXX ?= $(CC)
            FUZZ_CXXFLAGS ?= $(ALL_CFLAGS)

            .PHONY: fuzz-all
            fuzz-all: $(FUZZ_PROGRAMS)

            $(FUZZ_PROGRAMS): %: %.o oss-fuzz/dummy-cmd-main.o $(GITLIBS) GIT-LDFLAGS
                    $(QUIET_LINK)$(FUZZ_CXX) $(FUZZ_CXXFLAGS) -o $@ $(ALL_LDFLAGS) \
                            -Wl,--allow-multiple-definition \
                            $(filter %.o,$^) $(filter %.a,$^) $(LIBS) $(LIB_FUZZING_ENGINE)

            $(UNIT_TEST_PROGS): $(UNIT_TEST_BIN)/%$X: $(UNIT_TEST_DIR)/%.o $(UNIT_TEST_OBJS) \
                    $(GITLIBS) GIT-LDFLAGS
                    $(call mkdir_p_parent_template)
                    $(QUIET_LINK)$(CC) $(ALL_CFLAGS) -o $@ $(ALL_LDFLAGS) \
                            $(filter %.o,$^) $(filter %.a,$^) $(LIBS)

            GIT-TEST-SUITES: FORCE
                    @FLAGS='$(CLAR_TEST_SUITES)'; \
                    if test x"$$FLAGS" != x"`cat GIT-TEST-SUITES 2>/dev/null`" ; then \
                            echo >&2 "    * new test suites"; \
                            echo "$$FLAGS" >GIT-TEST-SUITES; \
                    fi

            $(UNIT_TEST_DIR)/clar-decls.h: $(patsubst %,$(UNIT_TEST_DIR)/%.c,$(CLAR_TEST_SUITES)) $(UNIT_TEST_DIR)/generate-clar-decls.sh GIT-TEST-SUITES
                    $(QUIET_GEN)$(SHELL_PATH) $(UNIT_TEST_DIR)/generate-clar-decls.sh "$@" $(filter %.c,$^)
            $(UNIT_TEST_DIR)/clar.suite: $(UNIT_TEST_DIR)/clar-decls.h $(UNIT_TEST_DIR)/generate-clar-suites.sh
                    $(QUIET_GEN)$(SHELL_PATH) $(UNIT_TEST_DIR)/generate-clar-suites.sh $< $(UNIT_TEST_DIR)/clar.suite
            $(UNIT_TEST_DIR)/clar/clar.o: $(UNIT_TEST_DIR)/clar.suite
            $(CLAR_TEST_OBJS): $(UNIT_TEST_DIR)/clar-decls.h
            $(CLAR_TEST_OBJS): EXTRA_CPPFLAGS = -I$(UNIT_TEST_DIR)
            $(CLAR_TEST_PROG): $(UNIT_TEST_DIR)/clar.suite $(CLAR_TEST_OBJS) $(GITLIBS) GIT-LDFLAGS
                    $(call mkdir_p_parent_template)
                    $(QUIET_LINK)$(CC) $(ALL_CFLAGS) -o $@ $(ALL_LDFLAGS) $(filter %.o,$^) $(LIBS)

            .PHONY: build-unit-tests unit-tests
            build-unit-tests: $(UNIT_TEST_PROGS) $(CLAR_TEST_PROG)
            unit-tests: $(UNIT_TEST_PROGS) $(CLAR_TEST_PROG) t/helper/test-tool$X
                    $(MAKE) -C t/ unit-tests
    """,
    "error_category":"Library linking error",
    "error":"IEW2456E 9207 SYMBOL memmem UNRESOLVED.  MEMBER COULD NOT BE INCLUDED FROM THE
                DESIGNATED CALL LIBRARY.
            IEW2456E 9207 SYMBOL strcasestr UNRESOLVED.  MEMBER COULD NOT BE INCLUDED FROM
                THE DESIGNATED CALL LIBRARY.
        IEW2456E 9207 SYMBOL __sysconf UNRESOLVED.  MEMBER COULD NOT BE INCLUDED FROM
                THE DESIGNATED CALL LIBRARY.
        IEW2456E 9207 SYMBOL __fopen_ascii UNRESOLVED.  MEMBER COULD NOT BE INCLUDED
                FROM THE DESIGNATED CALL LIBRARY.
        IEW2456E 9207 SYMBOL __readlink UNRESOLVED.  MEMBER COULD NOT BE INCLUDED FROM
                THE DESIGNATED CALL LIBRARY.
        IEW2456E 9207 SYMBOL getdelim UNRESOLVED.  MEMBER COULD NOT BE INCLUDED FROM
                THE DESIGNATED CALL LIBRARY.
        IEW2456E 9207 SYMBOL __open_ascii UNRESOLVED.  MEMBER COULD NOT BE INCLUDED
                FROM THE DESIGNATED CALL LIBRARY.
        IEW2456E 9207 SYMBOL __zoslib_malloc UNRESOLVED.  MEMBER COULD NOT BE INCLUDED
                FROM THE DESIGNATED CALL LIBRARY.
        IEW2456E 9207 SYMBOL __mkstemp_ascii UNRESOLVED.  MEMBER COULD NOT BE INCLUDED
                FROM THE DESIGNATED CALL LIBRARY.
        IEW2456E 9207 SYMBOL __pipe_ascii UNRESOLVED.  MEMBER COULD NOT BE INCLUDED
                FROM THE DESIGNATED CALL LIBRARY.
        IEW2456E 9207 SYMBOL __pthread_create_extended UNRESOLVED.  MEMBER COULD NOT BE
                INCLUDED FROM THE DESIGNATED CALL LIBRARY.
        IEW2456E 9207 SYMBOL __zoslib_free UNRESOLVED.  MEMBER COULD NOT BE INCLUDED
                FROM THE DESIGNATED CALL LIBRARY.
        IEW2456E 9207 SYMBOL __close UNRESOLVED.  MEMBER COULD NOT BE INCLUDED FROM THE
                DESIGNATED CALL LIBRARY.
        IEW2665S 40FF MODULE *NULL*  IS NON-EXECUTABLE AND WAS NOT SAVED BECAUSE
                STORENX=NEVER.
        IEW5033 The binder ended with return code 12.
        clang-14: error: linker command failed with exit code 12 (use -v to see invocation)
        make: *** [Makefile:2846: git-daemon] Error 12",


    "corrected_code":
    """
            # The default target of this Makefile is...
            all::

            # Import tree-wide shared Makefile behavior and libraries
            include shared.mak

            # == Makefile defines ==
            #
            # These defines change the behavior of the Makefile itself, but have
            # no impact on what it builds:
            #
            # Define V=1 to have a more verbose compile.
            #
            # == Portability and optional library defines ==
            #
            # These defines indicate what Git can expect from the OS, what
            # libraries are available etc. Much of this is auto-detected in
            # config.mak.uname, or in configure.ac when using the optional "make
            # configure && ./configure" (see INSTALL).
            #
            # Define SHELL_PATH to a POSIX shell if your /bin/sh is broken.
            #
            # Define SHELL_PATH_FOR_SCRIPTS to a POSIX shell if your /bin/sh is broken.
            #
            # Define SANE_TOOL_PATH to a colon-separated list of paths to prepend
            # to PATH if your tools in /usr/bin are broken.
            #
            # Define SOCKLEN_T to a suitable type (such as 'size_t') if your
            # system headers do not define a socklen_t type.
            #
            # Define INLINE to a suitable substitute (such as '__inline' or '') if git
            # fails to compile with errors about undefined inline functions or similar.
            #
            # Define SNPRINTF_RETURNS_BOGUS if you are on a system which snprintf()
            # or vsnprintf() return -1 instead of number of characters which would
            # have been written to the final string if enough space had been available.
            #
            # Define FREAD_READS_DIRECTORIES if you are on a system which succeeds
            # when attempting to read from an fopen'ed directory (or even to fopen
            # it at all).
            #
            # Define OPEN_RETURNS_EINTR if your open() system call may return EINTR
            # when a signal is received (as opposed to restarting).
            #
            # Define NO_OPENSSL environment variable if you do not have OpenSSL.
            #
            # Define HAVE_ALLOCA_H if you have working alloca(3) defined in that header.
            #
            # Define HAVE_PATHS_H if you have paths.h and want to use the default PATH
            # it specifies.
            #
            # Define NO_D_TYPE_IN_DIRENT if your platform defines DT_UNKNOWN but lacks
            # d_type in struct dirent (Cygwin 1.5, fixed in Cygwin 1.7).
            #
            # Define HAVE_STRINGS_H if you have strings.h and need it for strcasecmp.
            #
            # Define NO_STRCASESTR if you don't have strcasestr.
            #
            # Define NO_MEMMEM if you don't have memmem.
            #
            # Define NO_GETPAGESIZE if you don't have getpagesize.
            #
            # Define NO_STRLCPY if you don't have strlcpy.
            #
            # Define NO_STRTOUMAX if you don't have both strtoimax and strtoumax in the
            # C library. If your compiler also does not support long long or does not have
            # strtoull, define NO_STRTOULL.
            #
            # Define NO_SETENV if you don't have setenv in the C library.
            #
            # Define NO_UNSETENV if you don't have unsetenv in the C library.
            #
            # Define NO_MKDTEMP if you don't have mkdtemp in the C library.
            #
            # Define MKDIR_WO_TRAILING_SLASH if your mkdir() can't deal with trailing slash.
            #
            # Define NO_GECOS_IN_PWENT if you don't have pw_gecos in struct passwd
            # in the C library.
            #
            # Define NO_LIBGEN_H if you don't have libgen.h.
            #
            # Define NEEDS_LIBGEN if your libgen needs -lgen when linking
            #
            # Define NO_SYS_SELECT_H if you don't have sys/select.h.
            #
            # Define NO_SYMLINK_HEAD if you never want .git/HEAD to be a symbolic link.
            # Enable it on Windows.  By default, symrefs are still used.
            #
            # Define NO_SVN_TESTS if you want to skip time-consuming SVN interoperability
            # tests.  These tests take up a significant amount of the total test time
            # but are not needed unless you plan to talk to SVN repos.
            #
            # Define NO_FINK if you are building on Darwin/Mac OS X, have Fink
            # installed in /sw, but don't want GIT to link against any libraries
            # installed there.  If defined you may specify your own (or Fink's)
            # include directories and library directories by defining CFLAGS
            # and LDFLAGS appropriately.
            #
            # Define NO_DARWIN_PORTS if you are building on Darwin/Mac OS X,
            # have DarwinPorts installed in /opt/local, but don't want GIT to
            # link against any libraries installed there.  If defined you may
            # specify your own (or DarwinPort's) include directories and
            # library directories by defining CFLAGS and LDFLAGS appropriately.
            #
            # Define NO_APPLE_COMMON_CRYPTO if you are building on Darwin/Mac OS X
            # and do not want to use Apple's CommonCrypto library.  This allows you
            # to provide your own OpenSSL library, for example from MacPorts.
            #
            # Define NEEDS_CRYPTO_WITH_SSL if you need -lcrypto when using -lssl (Darwin).
            #
            # Define NEEDS_SSL_WITH_CRYPTO if you need -lssl when using -lcrypto (Darwin).
            #
            # Define NEEDS_LIBICONV if linking with libc is not enough (Darwin).
            #
            # Define NEEDS_LIBINTL_BEFORE_LIBICONV if you need libintl before libiconv.
            #
            # Define NO_INTPTR_T if you don't have intptr_t or uintptr_t.
            #
            # Define NO_UINTMAX_T if you don't have uintmax_t.
            #
            # Define NEEDS_SOCKET if linking with libc is not enough (SunOS,
            # Patrick Mauritz).
            #
            # Define NEEDS_RESOLV if linking with -lnsl and/or -lsocket is not enough.
            # Notably on Solaris hstrerror resides in libresolv and on Solaris 7
            # inet_ntop and inet_pton additionally reside there.
            #
            # Define NO_MMAP if you want to avoid mmap.
            #
            # Define MMAP_PREVENTS_DELETE if a file that is currently mmapped cannot be
            # deleted or cannot be replaced using rename().
            #
            # Define NO_POLL_H if you don't have poll.h.
            #
            # Define NO_SYS_POLL_H if you don't have sys/poll.h.
            #
            # Define NO_POLL if you do not have or don't want to use poll().
            # This also implies NO_POLL_H and NO_SYS_POLL_H.
            #
            # Define NEEDS_SYS_PARAM_H if you need to include sys/param.h to compile,
            # *PLEASE* REPORT to git@vger.kernel.org if your platform needs this;
            # we want to know more about the issue.
            #
            # Define NO_PTHREADS if you do not have or do not want to use Pthreads.
            #
            # Define NO_PREAD if you have a problem with pread() system call (e.g.
            # cygwin1.dll before v1.5.22).
            #
            # Define NO_SETITIMER if you don't have setitimer()
            #
            # Define NO_STRUCT_ITIMERVAL if you don't have struct itimerval
            # This also implies NO_SETITIMER
            #
            # Define NO_FAST_WORKING_DIRECTORY if accessing objects in pack files is
            # generally faster on your platform than accessing the working directory.
            #
            # Define NO_TRUSTABLE_FILEMODE if your filesystem may claim to support
            # the executable mode bit, but doesn't really do so.
            #
            # Define CSPRNG_METHOD to "arc4random" if your system has arc4random and
            # arc4random_buf, "libbsd" if your system has those functions from libbsd,
            # "getrandom" if your system has getrandom, "getentropy" if your system has
            # getentropy, "rtlgenrandom" for RtlGenRandom (Windows only), or "openssl" if
            # you'd want to use the OpenSSL CSPRNG.  You may set multiple options with
            # spaces, in which case a suitable option will be chosen.  If unset or set to
            # anything else, defaults to using "/dev/urandom".
            #
            # Define NEEDS_MODE_TRANSLATION if your OS strays from the typical file type
            # bits in mode values (e.g. z/OS defines I_SFMT to 0xFF000000 as opposed to the
            # usual 0xF000).
            #
            # Define NO_IPV6 if you lack IPv6 support and getaddrinfo().
            #
            # Define NO_UNIX_SOCKETS if your system does not offer unix sockets.
            #
            # Define NO_SOCKADDR_STORAGE if your platform does not have struct
            # sockaddr_storage.
            #
            # Define NO_ICONV if your libc does not properly support iconv.
            #
            # Define OLD_ICONV if your library has an old iconv(), where the second
            # (input buffer pointer) parameter is declared with type (const char **).
            #
            # Define ICONV_OMITS_BOM if your iconv implementation does not write a
            # byte-order mark (BOM) when writing UTF-16 or UTF-32 and always writes in
            # big-endian format.
            #
            # Define NO_DEFLATE_BOUND if your zlib does not have deflateBound.
            #
            # Define NO_NORETURN if using buggy versions of gcc 4.6+ and profile feedback,
            # as the compiler can crash (https://gcc.gnu.org/bugzilla/show_bug.cgi?id=49299)
            #
            # Define USE_NSEC below if you want git to care about sub-second file mtimes
            # and ctimes. Note that you need recent glibc (at least 2.2.4) for this. On
            # Linux, kernel 2.6.11 or newer is required for reliable sub-second file times
            # on file systems with exactly 1 ns or 1 s resolution. If you intend to use Git
            # on other file systems (e.g. CEPH, CIFS, NTFS, UDF), don't enable USE_NSEC. See
            # Documentation/technical/racy-git.txt for details.
            #
            # Define USE_ST_TIMESPEC if your "struct stat" uses "st_ctimespec" instead of
            # "st_ctim"
            #
            # Define NO_NSEC if your "struct stat" does not have "st_ctim.tv_nsec"
            # available.  This automatically turns USE_NSEC off.
            #
            # Define USE_STDEV below if you want git to care about the underlying device
            # change being considered an inode change from the update-index perspective.
            #
            # Define NO_ST_BLOCKS_IN_STRUCT_STAT if your platform does not have st_blocks
            # field that counts the on-disk footprint in 512-byte blocks.
            #
            # Define USE_ASCIIDOCTOR to use Asciidoctor instead of AsciiDoc to build the
            # documentation.
            #
            # Define ASCIIDOCTOR_EXTENSIONS_LAB to point to the location of the Asciidoctor
            # Extensions Lab if you have it available.
            #
            # Define PERL_PATH to the path of your Perl binary (usually /usr/bin/perl).
            #
            # Define PERL_PATH_FOR_SCRIPTS to a Perl binary if your /usr/bin/perl is broken.
            #
            # Define NO_PERL if you do not want Perl scripts or libraries at all.
            #
            # Define NO_PERL_CPAN_FALLBACKS if you do not want to install bundled
            # copies of CPAN modules that serve as a fallback in case the modules
            # are not available on the system. This option is intended for
            # distributions that want to use their packaged versions of Perl
            # modules, instead of the fallbacks shipped with Git.
            #
            # Define NO_GITWEB if you do not want to build or install
            # 'gitweb'. Note that defining NO_PERL currently has the same effect
            # on not installing gitweb, but not on whether it's built in the
            # gitweb/ directory.
            #
            # Define PYTHON_PATH to the path of your Python binary (often /usr/bin/python
            # but /usr/bin/python2.7 or /usr/bin/python3 on some platforms).
            #
            # Define NO_PYTHON if you do not want Python scripts or libraries at all.
            #
            # Define NO_TCLTK if you do not want Tcl/Tk GUI.
            #
            # The TCL_PATH variable governs the location of the Tcl interpreter
            # used to optimize git-gui for your system.  Only used if NO_TCLTK
            # is not set.  Defaults to the bare 'tclsh'.
            #
            # The TCLTK_PATH variable governs the location of the Tcl/Tk interpreter.
            # If not set it defaults to the bare 'wish'. If it is set to the empty
            # string then NO_TCLTK will be forced (this is used by configure script).
            #
            # Define INTERNAL_QSORT to use Git's implementation of qsort(), which
            # is a simplified version of the merge sort used in glibc. This is
            # recommended if Git triggers O(n^2) behavior in your platform's qsort().
            #
            # Define HAVE_ISO_QSORT_S if your platform provides a qsort_s() that's
            # compatible with the one described in C11 Annex K.
            #
            # Define UNRELIABLE_FSTAT if your system's fstat does not return the same
            # information on a not yet closed file that lstat would return for the same
            # file after it was closed.
            #
            # Define OBJECT_CREATION_USES_RENAMES if your operating systems has problems
            # when hardlinking a file to another name and unlinking the original file right
            # away (some NTFS drivers seem to zero the contents in that scenario).
            #
            # Define INSTALL_SYMLINKS if you prefer to have everything that can be
            # symlinked between bin/ and libexec/ to use relative symlinks between
            # the two. This option overrides NO_CROSS_DIRECTORY_HARDLINKS and
            # NO_INSTALL_HARDLINKS which will also use symlinking by indirection
            # within the same directory in some cases, INSTALL_SYMLINKS will
            # always symlink to the final target directly.
            #
            # Define NO_CROSS_DIRECTORY_HARDLINKS if you plan to distribute the installed
            # programs as a tar, where bin/ and libexec/ might be on different file systems.
            #
            # Define NO_INSTALL_HARDLINKS if you prefer to use either symbolic links or
            # copies to install built-in git commands e.g. git-cat-file.
            #
            # Define SKIP_DASHED_BUILT_INS if you do not need the dashed versions of the
            # built-ins to be linked/copied at all.
            #
            # Define USE_NED_ALLOCATOR if you want to replace the platforms default
            # memory allocators with the nedmalloc allocator written by Niall Douglas.
            #
            # Define OVERRIDE_STRDUP to override the libc version of strdup(3).
            # This is necessary when using a custom allocator in order to avoid
            # crashes due to allocation and free working on different 'heaps'.
            # It's defined automatically if USE_NED_ALLOCATOR is set.
            #
            # Define NO_REGEX if your C library lacks regex support with REG_STARTEND
            # feature.
            #
            # Define USE_ENHANCED_BASIC_REGULAR_EXPRESSIONS if your C library provides
            # the flag REG_ENHANCED and you'd like to use it to enable enhanced basic
            # regular expressions.
            #
            # Define HAVE_DEV_TTY if your system can open /dev/tty to interact with the
            # user.
            #
            # Define JSMIN to point to JavaScript minifier that functions as
            # a filter to have gitweb.js minified.
            #
            # Define CSSMIN to point to a CSS minifier in order to generate a minified
            # version of gitweb.css
            #
            # Define DEFAULT_PAGER to a sensible pager command (defaults to "less") if
            # you want to use something different.  The value will be interpreted by the
            # shell at runtime when it is used.
            #
            # Define DEFAULT_EDITOR to a sensible editor command (defaults to "vi") if you
            # want to use something different.  The value will be interpreted by the shell
            # if necessary when it is used.  Examples:
            #
            #   DEFAULT_EDITOR='~/bin/vi',
            #   DEFAULT_EDITOR='$GIT_FALLBACK_EDITOR',
            #   DEFAULT_EDITOR='"C:\Program Files\Vim\gvim.exe" --nofork'
            #
            # Define COMPUTE_HEADER_DEPENDENCIES to "yes" if you want dependencies on
            # header files to be automatically computed, to avoid rebuilding objects when
            # an unrelated header file changes.  Define it to "no" to use the hard-coded
            # dependency rules.  The default is "auto", which means to use computed header
            # dependencies if your compiler is detected to support it.
            #
            # Define NATIVE_CRLF if your platform uses CRLF for line endings.
            #
            # Define GIT_USER_AGENT if you want to change how git identifies itself during
            # network interactions.  The default is "git/$(GIT_VERSION)".
            #
            # Define DEFAULT_HELP_FORMAT to "man", "info" or "html"
            # (defaults to "man") if you want to have a different default when
            # "git help" is called without a parameter specifying the format.
            #
            # Define GIT_TEST_INDEX_VERSION to 2, 3 or 4 to run the test suite
            # with a different indexfile format version.  If it isn't set the index
            # file format used is index-v[23].
            #
            # Define GIT_TEST_UTF8_LOCALE to preferred utf-8 locale for testing.
            # If it isn't set, fallback to $LC_ALL, $LANG or use the first utf-8
            # locale returned by "locale -a".
            #
            # Define HAVE_CLOCK_GETTIME if your platform has clock_gettime.
            #
            # Define HAVE_CLOCK_MONOTONIC if your platform has CLOCK_MONOTONIC.
            #
            # Define HAVE_SYNC_FILE_RANGE if your platform has sync_file_range.
            #
            # Define NEEDS_LIBRT if your platform requires linking with librt (glibc version
            # before 2.17) for clock_gettime and CLOCK_MONOTONIC.
            #
            # Define HAVE_BSD_SYSCTL if your platform has a BSD-compatible sysctl function.
            #
            # Define HAVE_GETDELIM if your system has the getdelim() function.
            #
            # Define FILENO_IS_A_MACRO if fileno() is a macro, not a real function.
            #
            # Define NEED_ACCESS_ROOT_HANDLER if access() under root may success for X_OK
            # even if execution permission isn't granted for any user.
            #
            # Define PAGER_ENV to a SP separated VAR=VAL pairs to define
            # default environment variables to be passed when a pager is spawned, e.g.
            #
            #    PAGER_ENV = LESS=FRX LV=-c
            #
            # to say "export LESS=FRX (and LV=-c) if the environment variable
            # LESS (and LV) is not set, respectively".
            #
            # Define TEST_SHELL_PATH if you want to use a shell besides SHELL_PATH for
            # running the test scripts (e.g., bash has better support for "set -x"
            # tracing).
            #
            # When cross-compiling, define HOST_CPU as the canonical name of the CPU on
            # which the built Git will run (for instance "x86_64").
            #
            # Define RUNTIME_PREFIX to configure Git to resolve its ancillary tooling and
            # support files relative to the location of the runtime binary, rather than
            # hard-coding them into the binary. Git installations built with RUNTIME_PREFIX
            # can be moved to arbitrary filesystem locations. RUNTIME_PREFIX also causes
            # Perl scripts to use a modified entry point header allowing them to resolve
            # support files at runtime.
            #
            # When using RUNTIME_PREFIX, define HAVE_BSD_KERN_PROC_SYSCTL if your platform
            # supports the KERN_PROC BSD sysctl function.
            #
            # When using RUNTIME_PREFIX, define PROCFS_EXECUTABLE_PATH if your platform
            # mounts a "procfs" filesystem capable of resolving the path of the current
            # executable. If defined, this must be the canonical path for the "procfs"
            # current executable path.
            #
            # When using RUNTIME_PREFIX, define HAVE_NS_GET_EXECUTABLE_PATH if your platform
            # supports calling _NSGetExecutablePath to retrieve the path of the running
            # executable.
            #
            # When using RUNTIME_PREFIX, define HAVE_ZOS_GET_EXECUTABLE_PATH if your platform
            # supports calling __getprogramdir and getprogname to retrieve the path of the
            # running executable.
            #
            # When using RUNTIME_PREFIX, define HAVE_WPGMPTR if your platform offers
            # the global variable _wpgmptr containing the absolute path of the current
            # executable (this is the case on Windows).
            #
            # INSTALL_STRIP can be set to "-s" to strip binaries during installation,
            # if your $(INSTALL) command supports the option.
            #
            # Define GENERATE_COMPILATION_DATABASE to "yes" to generate JSON compilation
            # database entries during compilation if your compiler supports it, using the
            # `-MJ` flag. The JSON entries will be placed in the `compile_commands/`
            # directory, and the JSON compilation database 'compile_commands.json' will be
            # created at the root of the repository.
            #
            # If your platform supports a built-in fsmonitor backend, set
            # FSMONITOR_DAEMON_BACKEND to the "<name>" of the corresponding
            # `compat/fsmonitor/fsm-listen-<name>.c` and
            # `compat/fsmonitor/fsm-health-<name>.c` files
            # that implement the `fsm_listen__*()` and `fsm_health__*()` routines.
            #
            # If your platform has OS-specific ways to tell if a repo is incompatible with
            # fsmonitor (whether the hook or IPC daemon version), set FSMONITOR_OS_SETTINGS
            # to the "<name>" of the corresponding `compat/fsmonitor/fsm-settings-<name>.c`
            # that implements the `fsm_os_settings__*()` routines.
            #
            # Define LINK_FUZZ_PROGRAMS if you want `make all` to also build the fuzz test
            # programs in oss-fuzz/.
            #
            # === Optional library: libintl ===
            #
            # Define NO_GETTEXT if you don't want Git output to be translated.
            # A translated Git requires GNU libintl or another gettext implementation,
            # plus libintl-perl at runtime.
            #
            # Define USE_GETTEXT_SCHEME and set it to 'fallthrough', if you don't trust
            # the installed gettext translation of the shell scripts output.
            #
            # Define HAVE_LIBCHARSET_H if you haven't set NO_GETTEXT and you can't
            # trust the langinfo.h's nl_langinfo(CODESET) function to return the
            # current character set. GNU and Solaris have a nl_langinfo(CODESET),
            # FreeBSD can use either, but MinGW and some others need to use
            # libcharset.h's locale_charset() instead.
            #
            # Define CHARSET_LIB to the library you need to link with in order to
            # use locale_charset() function.  On some platforms this needs to set to
            # -lcharset, on others to -liconv .
            #
            # Define LIBC_CONTAINS_LIBINTL if your gettext implementation doesn't
            # need -lintl when linking.
            #
            # Define NO_MSGFMT_EXTENDED_OPTIONS if your implementation of msgfmt
            # doesn't support GNU extensions like --check and --statistics
            #
            # === Optional library: libexpat ===
            #
            # Define NO_EXPAT if you do not have expat installed.  git-http-push is
            # not built, and you cannot push using http:// and https:// transports (dumb).
            #
            # Define EXPATDIR=/foo/bar if your expat header and library files are in
            # /foo/bar/include and /foo/bar/lib directories.
            #
            # Define EXPAT_NEEDS_XMLPARSE_H if you have an old version of expat (e.g.,
            # 1.1 or 1.2) that provides xmlparse.h instead of expat.h.

            # === Optional library: libcurl ===
            #
            # Define NO_CURL if you do not have libcurl installed.  git-http-fetch and
            # git-http-push are not built, and you cannot use http:// and https://
            # transports (neither smart nor dumb).
            #
            # Define CURLDIR=/foo/bar if your curl header and library files are in
            # /foo/bar/include and /foo/bar/lib directories.
            #
            # Define CURL_CONFIG to curl's configuration program that prints information
            # about the library (e.g., its version number).  The default is 'curl-config'.
            #
            # Define CURL_LDFLAGS to specify flags that you need to link when using libcurl,
            # if you do not want to rely on the libraries provided by CURL_CONFIG.  The
            # default value is a result of `curl-config --libs`.  An example value for
            # CURL_LDFLAGS is as follows:
            #
            #     CURL_LDFLAGS=-lcurl
            #
            # === Optional library: libpcre2 ===
            #
            # Define USE_LIBPCRE if you have and want to use libpcre. Various
            # commands such as log and grep offer runtime options to use
            # Perl-compatible regular expressions instead of standard or extended
            # POSIX regular expressions.
            #
            # Only libpcre version 2 is supported. USE_LIBPCRE2 is a synonym for
            # USE_LIBPCRE, support for the old USE_LIBPCRE1 has been removed.
            #
            # Define LIBPCREDIR=/foo/bar if your PCRE header and library files are
            # in /foo/bar/include and /foo/bar/lib directories.
            #
            # == SHA-1 and SHA-256 defines ==
            #
            # === SHA-1 backend ===
            #
            # ==== Security ====
            #
            # Due to the SHAttered (https://shattered.io) attack vector on SHA-1
            # it's strongly recommended to use the sha1collisiondetection
            # counter-cryptanalysis library for SHA-1 hashing.
            #
            # If you know that you can trust the repository contents, or where
            # potential SHA-1 attacks are otherwise mitigated the other backends
            # listed in "SHA-1 implementations" are faster than
            # sha1collisiondetection.
            #
            # ==== Default SHA-1 backend ====
            #
            # If no *_SHA1 backend is picked, the first supported one listed in
            # "SHA-1 implementations" will be picked.
            #
            # ==== Options common to all SHA-1 implementations ====
            #
            # Define SHA1_MAX_BLOCK_SIZE to limit the amount of data that will be hashed
            # in one call to the platform's SHA1_Update(). e.g. APPLE_COMMON_CRYPTO
            # wants 'SHA1_MAX_BLOCK_SIZE=1024L*1024L*1024L' defined.
            #
            # ==== SHA-1 implementations ====
            #
            # Define OPENSSL_SHA1 to link to the SHA-1 routines from the OpenSSL
            # library.
            #
            # Define BLK_SHA1 to make use of optimized C SHA-1 routines bundled
            # with git (in the block-sha1/ directory).
            #
            # Define APPLE_COMMON_CRYPTO_SHA1 to use Apple's CommonCrypto for
            # SHA-1.
            #
            # Define the same Makefile knobs as above, but suffixed with _UNSAFE to
            # use the corresponding implementations for unsafe SHA-1 hashing for
            # non-cryptographic purposes.
            #
            # If don't enable any of the *_SHA1 settings in this section, Git will
            # default to its built-in sha1collisiondetection library, which is a
            # collision-detecting sha1 This is slower, but may detect attempted
            # collision attacks.
            #
            # ==== Options for the sha1collisiondetection library ====
            #
            # Define DC_SHA1_EXTERNAL if you want to build / link
            # git with the external SHA1 collision-detect library.
            # Without this option, i.e. the default behavior is to build git with its
            # own built-in code (or submodule).
            #
            # Define DC_SHA1_SUBMODULE to use the
            # sha1collisiondetection shipped as a submodule instead of the
            # non-submodule copy in sha1dc/. This is an experimental option used
            # by the git project to migrate to using sha1collisiondetection as a
            # submodule.
            #
            # === SHA-256 backend ===
            #
            # ==== Security ====
            #
            # Unlike SHA-1 the SHA-256 algorithm does not suffer from any known
            # vulnerabilities, so any implementation will do.
            #
            # ==== SHA-256 implementations ====
            #
            # Define OPENSSL_SHA256 to use the SHA-256 routines in OpenSSL.
            #
            # Define NETTLE_SHA256 to use the SHA-256 routines in libnettle.
            #
            # Define GCRYPT_SHA256 to use the SHA-256 routines in libgcrypt.
            #
            # If don't enable any of the *_SHA256 settings in this section, Git
            # will default to its built-in sha256 implementation.
            #
            # == DEVELOPER defines ==
            #
            # Define DEVELOPER to enable more compiler warnings. Compiler version
            # and family are auto detected, but could be overridden by defining
            # COMPILER_FEATURES (see config.mak.dev). You can still set
            # CFLAGS="..." in combination with DEVELOPER enables, whether that's
            # for tweaking something unrelated (e.g. optimization level), or for
            # selectively overriding something DEVELOPER or one of the DEVOPTS
            # (see just below) brings in.
            #
            # When DEVELOPER is set, DEVOPTS can be used to control compiler
            # options.  This variable contains keywords separated by
            # whitespace. The following keywords are recognized:
            #
            #    no-error:
            #
            #        suppresses the -Werror that implicitly comes with
            #        DEVELOPER=1. Useful for getting the full set of errors
            #        without immediately dying, or for logging them.
            #
            #    extra-all:
            #
            #        The DEVELOPER mode enables -Wextra with a few exceptions. By
            #        setting this flag the exceptions are removed, and all of
            #        -Wextra is used.
            #
            #    no-pedantic:
            #
            #        Disable -pedantic compilation.

            # Set our default configuration.
            #
            # Among the variables below, these:
            #   gitexecdir
            #   template_dir
            #   sysconfdir
            # can be specified as a relative path some/where/else;
            # this is interpreted as relative to $(prefix) and "git" built with
            # RUNTIME_PREFIX flag will figure out (at runtime) where they are
            # based on the path to the executable.
            # Additionally, the following will be treated as relative by "git" if they
            # begin with "$(prefix)/":
            #   mandir
            #   infodir
            #   htmldir
            #   localedir
            #   perllibdir
            # This can help installing the suite in a relocatable way.

            prefix = $(HOME)
            bindir = $(prefix)/bin
            mandir = $(prefix)/share/man
            infodir = $(prefix)/share/info
            gitexecdir = libexec/git-core
            mergetoolsdir = $(gitexecdir)/mergetools
            sharedir = $(prefix)/share
            gitwebdir = $(sharedir)/gitweb
            gitwebstaticdir = $(gitwebdir)/static
            perllibdir = $(sharedir)/perl5
            localedir = $(sharedir)/locale
            template_dir = share/git-core/templates
            htmldir = $(prefix)/share/doc/git-doc
            ETC_GITCONFIG = $(sysconfdir)/gitconfig
            ETC_GITATTRIBUTES = $(sysconfdir)/gitattributes
            lib = lib
            # DESTDIR =
            pathsep = :

            bindir_relative = $(patsubst $(prefix)/%,%,$(bindir))
            mandir_relative = $(patsubst $(prefix)/%,%,$(mandir))
            infodir_relative = $(patsubst $(prefix)/%,%,$(infodir))
            gitexecdir_relative = $(patsubst $(prefix)/%,%,$(gitexecdir))
            localedir_relative = $(patsubst $(prefix)/%,%,$(localedir))
            htmldir_relative = $(patsubst $(prefix)/%,%,$(htmldir))
            perllibdir_relative = $(patsubst $(prefix)/%,%,$(perllibdir))

            export prefix bindir sharedir sysconfdir perllibdir localedir

            # Set our default programs
            CC = cc
            AR = ar
            RM = rm -f
            DIFF = diff
            TAR = tar
            FIND = find
            INSTALL = install
            TCL_PATH = tclsh
            TCLTK_PATH = wish
            XGETTEXT = xgettext
            MSGCAT = msgcat
            MSGFMT = msgfmt
            MSGMERGE = msgmerge
            CURL_CONFIG = curl-config
            GCOV = gcov
            STRIP = strip
            SPATCH = spatch

            export TCL_PATH TCLTK_PATH

            # Set our default LIBS variables
            PTHREAD_LIBS = -lpthread

            # Guard against environment variables
            BUILTIN_OBJS =
            BUILT_INS =
            COMPAT_CFLAGS =
            COMPAT_OBJS =
            XDIFF_OBJS =
            GENERATED_H =
            EXTRA_CPPFLAGS =
            FUZZ_OBJS =
            FUZZ_PROGRAMS =
            GIT_OBJS =
            LIB_OBJS =
            SCALAR_OBJS =
            OBJECTS =
            OTHER_PROGRAMS =
            PROGRAM_OBJS =
            PROGRAMS =
            EXCLUDED_PROGRAMS =
            SCRIPT_PERL =
            SCRIPT_PYTHON =
            SCRIPT_SH =
            SCRIPT_LIB =
            TEST_BUILTINS_OBJS =
            TEST_OBJS =
            TEST_PROGRAMS_NEED_X =
            THIRD_PARTY_SOURCES =
            UNIT_TEST_PROGRAMS =
            UNIT_TEST_DIR = t/unit-tests
            UNIT_TEST_BIN = $(UNIT_TEST_DIR)/bin

            # Having this variable in your environment would break pipelines because
            # you cause "cd" to echo its destination to stdout.  It can also take
            # scripts to unexpected places.  If you like CDPATH, define it for your
            # interactive shell sessions without exporting it.
            unexport CDPATH

            SCRIPT_SH += git-difftool--helper.sh
            SCRIPT_SH += git-filter-branch.sh
            SCRIPT_SH += git-merge-octopus.sh
            SCRIPT_SH += git-merge-one-file.sh
            SCRIPT_SH += git-merge-resolve.sh
            SCRIPT_SH += git-mergetool.sh
            SCRIPT_SH += git-quiltimport.sh
            SCRIPT_SH += git-request-pull.sh
            SCRIPT_SH += git-submodule.sh
            SCRIPT_SH += git-web--browse.sh

            SCRIPT_LIB += git-mergetool--lib
            SCRIPT_LIB += git-sh-i18n
            SCRIPT_LIB += git-sh-setup

            SCRIPT_PERL += git-archimport.perl
            SCRIPT_PERL += git-cvsexportcommit.perl
            SCRIPT_PERL += git-cvsimport.perl
            SCRIPT_PERL += git-cvsserver.perl
            SCRIPT_PERL += git-send-email.perl
            SCRIPT_PERL += git-svn.perl

            SCRIPT_PYTHON += git-p4.py

            # Generated files for scripts
            SCRIPT_SH_GEN = $(patsubst %.sh,%,$(SCRIPT_SH))
            SCRIPT_PERL_GEN = $(patsubst %.perl,%,$(SCRIPT_PERL))
            SCRIPT_PYTHON_GEN = $(patsubst %.py,%,$(SCRIPT_PYTHON))

            # Individual rules to allow e.g.
            # "make -C ../.. SCRIPT_PERL=contrib/foo/bar.perl build-perl-script"
            # from subdirectories like contrib/*/
            .PHONY: build-perl-script build-sh-script build-python-script
            build-perl-script: $(SCRIPT_PERL_GEN)
            build-sh-script: $(SCRIPT_SH_GEN)
            build-python-script: $(SCRIPT_PYTHON_GEN)

            .PHONY: install-perl-script install-sh-script install-python-script
            install-sh-script: $(SCRIPT_SH_GEN)
                    $(INSTALL) $^ '$(DESTDIR_SQ)$(gitexec_instdir_SQ)'
            install-perl-script: $(SCRIPT_PERL_GEN)
                    $(INSTALL) $^ '$(DESTDIR_SQ)$(gitexec_instdir_SQ)'
            install-python-script: $(SCRIPT_PYTHON_GEN)
                    $(INSTALL) $^ '$(DESTDIR_SQ)$(gitexec_instdir_SQ)'

            .PHONY: clean-perl-script clean-sh-script clean-python-script
            clean-sh-script:
                    $(RM) $(SCRIPT_SH_GEN)
            clean-perl-script:
                    $(RM) $(SCRIPT_PERL_GEN)
            clean-python-script:
                    $(RM) $(SCRIPT_PYTHON_GEN)

            SCRIPTS = $(SCRIPT_SH_GEN) \
                    $(SCRIPT_PERL_GEN) \
                    $(SCRIPT_PYTHON_GEN) \
                    git-instaweb

            ETAGS_TARGET = TAGS

            # Empty...
            EXTRA_PROGRAMS =

            # ... and all the rest that could be moved out of bindir to gitexecdir
            PROGRAMS += $(EXTRA_PROGRAMS)

            PROGRAM_OBJS += daemon.o
            PROGRAM_OBJS += http-backend.o
            PROGRAM_OBJS += imap-send.o
            PROGRAM_OBJS += sh-i18n--envsubst.o
            PROGRAM_OBJS += shell.o
            .PHONY: program-objs
            program-objs: $(PROGRAM_OBJS)

            # Binary suffix, set to .exe for Windows builds
            X =

            PROGRAMS += $(patsubst %.o,git-%$X,$(PROGRAM_OBJS))

            TEST_BUILTINS_OBJS += test-advise.o
            TEST_BUILTINS_OBJS += test-bitmap.o
            TEST_BUILTINS_OBJS += test-bloom.o
            TEST_BUILTINS_OBJS += test-bundle-uri.o
            TEST_BUILTINS_OBJS += test-cache-tree.o
            TEST_BUILTINS_OBJS += test-chmtime.o
            TEST_BUILTINS_OBJS += test-config.o
            TEST_BUILTINS_OBJS += test-crontab.o
            TEST_BUILTINS_OBJS += test-csprng.o
            TEST_BUILTINS_OBJS += test-date.o
            TEST_BUILTINS_OBJS += test-delete-gpgsig.o
            TEST_BUILTINS_OBJS += test-delta.o
            TEST_BUILTINS_OBJS += test-dir-iterator.o
            TEST_BUILTINS_OBJS += test-drop-caches.o
            TEST_BUILTINS_OBJS += test-dump-cache-tree.o
            TEST_BUILTINS_OBJS += test-dump-fsmonitor.o
            TEST_BUILTINS_OBJS += test-dump-split-index.o
            TEST_BUILTINS_OBJS += test-dump-untracked-cache.o
            TEST_BUILTINS_OBJS += test-env-helper.o
            TEST_BUILTINS_OBJS += test-example-tap.o
            TEST_BUILTINS_OBJS += test-find-pack.o
            TEST_BUILTINS_OBJS += test-fsmonitor-client.o
            TEST_BUILTINS_OBJS += test-genrandom.o
            TEST_BUILTINS_OBJS += test-genzeros.o
            TEST_BUILTINS_OBJS += test-getcwd.o
            TEST_BUILTINS_OBJS += test-hash-speed.o
            TEST_BUILTINS_OBJS += test-hash.o
            TEST_BUILTINS_OBJS += test-hashmap.o
            TEST_BUILTINS_OBJS += test-hexdump.o
            TEST_BUILTINS_OBJS += test-json-writer.o
            TEST_BUILTINS_OBJS += test-lazy-init-name-hash.o
            TEST_BUILTINS_OBJS += test-match-trees.o
            TEST_BUILTINS_OBJS += test-mergesort.o
            TEST_BUILTINS_OBJS += test-mktemp.o
            TEST_BUILTINS_OBJS += test-online-cpus.o
            TEST_BUILTINS_OBJS += test-pack-mtimes.o
            TEST_BUILTINS_OBJS += test-parse-options.o
            TEST_BUILTINS_OBJS += test-parse-pathspec-file.o
            TEST_BUILTINS_OBJS += test-partial-clone.o
            TEST_BUILTINS_OBJS += test-path-utils.o
            TEST_BUILTINS_OBJS += test-pcre2-config.o
            TEST_BUILTINS_OBJS += test-pkt-line.o
            TEST_BUILTINS_OBJS += test-proc-receive.o
            TEST_BUILTINS_OBJS += test-progress.o
            TEST_BUILTINS_OBJS += test-reach.o
            TEST_BUILTINS_OBJS += test-read-cache.o
            TEST_BUILTINS_OBJS += test-read-graph.o
            TEST_BUILTINS_OBJS += test-read-midx.o
            TEST_BUILTINS_OBJS += test-ref-store.o
            TEST_BUILTINS_OBJS += test-reftable.o
            TEST_BUILTINS_OBJS += test-regex.o
            TEST_BUILTINS_OBJS += test-rot13-filter.o
            TEST_BUILTINS_OBJS += test-repository.o
            TEST_BUILTINS_OBJS += test-revision-walking.o
            TEST_BUILTINS_OBJS += test-run-command.o
            TEST_BUILTINS_OBJS += test-scrap-cache-tree.o
            TEST_BUILTINS_OBJS += test-serve-v2.o
            TEST_BUILTINS_OBJS += test-sha1.o
            TEST_BUILTINS_OBJS += test-sha256.o
            TEST_BUILTINS_OBJS += test-sigchain.o
            TEST_BUILTINS_OBJS += test-simple-ipc.o
            TEST_BUILTINS_OBJS += test-string-list.o
            TEST_BUILTINS_OBJS += test-submodule-config.o
            TEST_BUILTINS_OBJS += test-submodule-nested-repo-config.o
            TEST_BUILTINS_OBJS += test-submodule.o
            TEST_BUILTINS_OBJS += test-subprocess.o
            TEST_BUILTINS_OBJS += test-trace2.o
            TEST_BUILTINS_OBJS += test-truncate.o
            TEST_BUILTINS_OBJS += test-userdiff.o
            TEST_BUILTINS_OBJS += test-wildmatch.o
            TEST_BUILTINS_OBJS += test-windows-named-pipe.o
            TEST_BUILTINS_OBJS += test-write-cache.o
            TEST_BUILTINS_OBJS += test-xml-encode.o

            # Do not add more tests here unless they have extra dependencies. Add
            # them in TEST_BUILTINS_OBJS above.
            TEST_PROGRAMS_NEED_X += test-fake-ssh
            TEST_PROGRAMS_NEED_X += test-tool

            TEST_PROGRAMS = $(patsubst %,t/helper/%$X,$(TEST_PROGRAMS_NEED_X))

            # List built-in command $C whose implementation cmd_$C() is not in
            # builtin/$C.o but is linked in as part of some other command.
            BUILT_INS += $(patsubst builtin/%.o,git-%$X,$(BUILTIN_OBJS))

            BUILT_INS += git-cherry$X
            BUILT_INS += git-cherry-pick$X
            BUILT_INS += git-format-patch$X
            BUILT_INS += git-fsck-objects$X
            BUILT_INS += git-init$X
            BUILT_INS += git-maintenance$X
            BUILT_INS += git-merge-subtree$X
            BUILT_INS += git-restore$X
            BUILT_INS += git-show$X
            BUILT_INS += git-stage$X
            BUILT_INS += git-status$X
            BUILT_INS += git-switch$X
            BUILT_INS += git-version$X
            BUILT_INS += git-whatchanged$X

            # what 'all' will build but not install in gitexecdir
            OTHER_PROGRAMS += git$X
            OTHER_PROGRAMS += scalar$X

            # what test wrappers are needed and 'install' will install, in bindir
            BINDIR_PROGRAMS_NEED_X += git
            BINDIR_PROGRAMS_NEED_X += scalar
            BINDIR_PROGRAMS_NEED_X += git-receive-pack
            BINDIR_PROGRAMS_NEED_X += git-shell
            BINDIR_PROGRAMS_NEED_X += git-upload-archive
            BINDIR_PROGRAMS_NEED_X += git-upload-pack

            BINDIR_PROGRAMS_NO_X += git-cvsserver

            # Set paths to tools early so that they can be used for version tests.
            ifndef SHELL_PATH
                    SHELL_PATH = /bin/sh
            endif
            ifndef SHELL_PATH_FOR_SCRIPTS
                    SHELL_PATH_FOR_SCRIPTS = /bin/sh
            endif
            ifndef PERL_PATH
                    PERL_PATH = /usr/bin/perl
            endif
            ifndef PERL_PATH_FOR_SCRIPTS
                    PERL_PATH_FOR_SCRIPTS = /usr/bin/perl
            endif
            ifndef PYTHON_PATH
                    PYTHON_PATH = /usr/bin/python
            endif

            export PERL_PATH
            export PYTHON_PATH
            export PERL_PATH_FOR_SCRIPTS

            TEST_SHELL_PATH = $(SHELL_PATH)

            LIB_FILE = libgit.a
            XDIFF_LIB = xdiff/lib.a
            REFTABLE_LIB = reftable/libreftable.a

            GENERATED_H += command-list.h
            GENERATED_H += config-list.h
            GENERATED_H += hook-list.h
            GENERATED_H += $(UNIT_TEST_DIR)/clar-decls.h
            GENERATED_H += $(UNIT_TEST_DIR)/clar.suite

            .PHONY: generated-hdrs
            generated-hdrs: $(GENERATED_H)

            ## Exhaustive lists of our source files, either dynamically generated,
            ## or hardcoded.
            SOURCES_CMD = ( \
                    git ls-files --deduplicate \
                            '*.[hcS]' \
                            '*.sh' \
                            ':!*[tp][0-9][0-9][0-9][0-9]*' \
                            ':!contrib' \
                            2>/dev/null || \
                    $(FIND) . \
                            \( -name .git -type d -prune \) \
                            -o \( -name '[tp][0-9][0-9][0-9][0-9]*' -prune \) \
                            -o \( -name contrib -type d -prune \) \
                            -o \( -name build -type d -prune \) \
                            -o \( -name .build -type d -prune \) \
                            -o \( -name 'trash*' -type d -prune \) \
                            -o \( -name '*.[hcS]' -type f -print \) \
                            -o \( -name '*.sh' -type f -print \) \
                            | sed -e 's|^\./||' \
                    )
            FOUND_SOURCE_FILES := $(filter-out $(GENERATED_H),$(shell $(SOURCES_CMD)))

            FOUND_C_SOURCES = $(filter %.c,$(FOUND_SOURCE_FILES))
            FOUND_H_SOURCES = $(filter %.h,$(FOUND_SOURCE_FILES))

            COCCI_SOURCES = $(filter-out $(THIRD_PARTY_SOURCES),$(FOUND_C_SOURCES))

            LIB_H = $(FOUND_H_SOURCES)

            LIB_OBJS += abspath.o
            LIB_OBJS += add-interactive.o
            LIB_OBJS += add-patch.o
            LIB_OBJS += advice.o
            LIB_OBJS += alias.o
            LIB_OBJS += alloc.o
            LIB_OBJS += apply.o
            LIB_OBJS += archive-tar.o
            LIB_OBJS += archive-zip.o
            LIB_OBJS += archive.o
            LIB_OBJS += attr.o
            LIB_OBJS += base85.o
            LIB_OBJS += bisect.o
            LIB_OBJS += blame.o
            LIB_OBJS += blob.o
            LIB_OBJS += bloom.o
            LIB_OBJS += branch.o
            LIB_OBJS += bulk-checkin.o
            LIB_OBJS += bundle-uri.o
            LIB_OBJS += bundle.o
            LIB_OBJS += cache-tree.o
            LIB_OBJS += cbtree.o
            LIB_OBJS += chdir-notify.o
            LIB_OBJS += checkout.o
            LIB_OBJS += chunk-format.o
            LIB_OBJS += color.o
            LIB_OBJS += column.o
            LIB_OBJS += combine-diff.o
            LIB_OBJS += commit-graph.o
            LIB_OBJS += commit-reach.o
            LIB_OBJS += commit.o
            LIB_OBJS += compat/nonblock.o
            LIB_OBJS += compat/obstack.o
            LIB_OBJS += compat/terminal.o
            LIB_OBJS += compat/zlib-uncompress2.o
            LIB_OBJS += config.o
            LIB_OBJS += connect.o
            LIB_OBJS += connected.o
            LIB_OBJS += convert.o
            LIB_OBJS += copy.o
            LIB_OBJS += credential.o
            LIB_OBJS += csum-file.o
            LIB_OBJS += ctype.o
            LIB_OBJS += date.o
            LIB_OBJS += decorate.o
            LIB_OBJS += delta-islands.o
            LIB_OBJS += diagnose.o
            LIB_OBJS += diff-delta.o
            LIB_OBJS += diff-merges.o
            LIB_OBJS += diff-lib.o
            LIB_OBJS += diff-no-index.o
            LIB_OBJS += diff.o
            LIB_OBJS += diffcore-break.o
            LIB_OBJS += diffcore-delta.o
            LIB_OBJS += diffcore-order.o
            LIB_OBJS += diffcore-pickaxe.o
            LIB_OBJS += diffcore-rename.o
            LIB_OBJS += diffcore-rotate.o
            LIB_OBJS += dir-iterator.o
            LIB_OBJS += dir.o
            LIB_OBJS += editor.o
            LIB_OBJS += entry.o
            LIB_OBJS += environment.o
            LIB_OBJS += ewah/bitmap.o
            LIB_OBJS += ewah/ewah_bitmap.o
            LIB_OBJS += ewah/ewah_io.o
            LIB_OBJS += ewah/ewah_rlw.o
            LIB_OBJS += exec-cmd.o
            LIB_OBJS += fetch-negotiator.o
            LIB_OBJS += fetch-pack.o
            LIB_OBJS += fmt-merge-msg.o
            LIB_OBJS += fsck.o
            LIB_OBJS += fsmonitor.o
            LIB_OBJS += fsmonitor-ipc.o
            LIB_OBJS += fsmonitor-settings.o
            LIB_OBJS += gettext.o
            LIB_OBJS += git-zlib.o
            LIB_OBJS += gpg-interface.o
            LIB_OBJS += graph.o
            LIB_OBJS += grep.o
            LIB_OBJS += hash-lookup.o
            LIB_OBJS += hashmap.o
            LIB_OBJS += help.o
            LIB_OBJS += hex.o
            LIB_OBJS += hex-ll.o
            LIB_OBJS += hook.o
            LIB_OBJS += ident.o
            LIB_OBJS += json-writer.o
            LIB_OBJS += kwset.o
            LIB_OBJS += levenshtein.o
            LIB_OBJS += line-log.o
            LIB_OBJS += line-range.o
            LIB_OBJS += linear-assignment.o
            LIB_OBJS += list-objects-filter-options.o
            LIB_OBJS += list-objects-filter.o
            LIB_OBJS += list-objects.o
            LIB_OBJS += lockfile.o
            LIB_OBJS += log-tree.o
            LIB_OBJS += loose.o
            LIB_OBJS += ls-refs.o
            LIB_OBJS += mailinfo.o
            LIB_OBJS += mailmap.o
            LIB_OBJS += match-trees.o
            LIB_OBJS += mem-pool.o
            LIB_OBJS += merge-blobs.o
            LIB_OBJS += merge-ll.o
            LIB_OBJS += merge-ort.o
            LIB_OBJS += merge-ort-wrappers.o
            LIB_OBJS += merge-recursive.o
            LIB_OBJS += merge.o
            LIB_OBJS += midx.o
            LIB_OBJS += midx-write.o
            LIB_OBJS += name-hash.o
            LIB_OBJS += negotiator/default.o
            LIB_OBJS += negotiator/noop.o
            LIB_OBJS += negotiator/skipping.o
            LIB_OBJS += notes-cache.o
            LIB_OBJS += notes-merge.o
            LIB_OBJS += notes-utils.o
            LIB_OBJS += notes.o
            LIB_OBJS += object-file-convert.o
            LIB_OBJS += object-file.o
            LIB_OBJS += object-name.o
            LIB_OBJS += object.o
            LIB_OBJS += oid-array.o
            LIB_OBJS += oidmap.o
            LIB_OBJS += oidset.o
            LIB_OBJS += oidtree.o
            LIB_OBJS += pack-bitmap-write.o
            LIB_OBJS += pack-bitmap.o
            LIB_OBJS += pack-check.o
            LIB_OBJS += pack-mtimes.o
            LIB_OBJS += pack-objects.o
            LIB_OBJS += pack-revindex.o
            LIB_OBJS += pack-write.o
            LIB_OBJS += packfile.o
            LIB_OBJS += pager.o
            LIB_OBJS += parallel-checkout.o
            LIB_OBJS += parse.o
            LIB_OBJS += parse-options-cb.o
            LIB_OBJS += parse-options.o
            LIB_OBJS += patch-delta.o
            LIB_OBJS += patch-ids.o
            LIB_OBJS += path.o
            LIB_OBJS += pathspec.o
            LIB_OBJS += pkt-line.o
            LIB_OBJS += preload-index.o
            LIB_OBJS += pretty.o
            LIB_OBJS += prio-queue.o
            LIB_OBJS += progress.o
            LIB_OBJS += promisor-remote.o
            LIB_OBJS += prompt.o
            LIB_OBJS += protocol.o
            LIB_OBJS += protocol-caps.o
            LIB_OBJS += prune-packed.o
            LIB_OBJS += pseudo-merge.o
            LIB_OBJS += quote.o
            LIB_OBJS += range-diff.o
            LIB_OBJS += reachable.o
            LIB_OBJS += read-cache.o
            LIB_OBJS += rebase-interactive.o
            LIB_OBJS += rebase.o
            LIB_OBJS += ref-filter.o
            LIB_OBJS += reflog-walk.o
            LIB_OBJS += reflog.o
            LIB_OBJS += refs.o
            LIB_OBJS += refs/debug.o
            LIB_OBJS += refs/files-backend.o
            LIB_OBJS += refs/reftable-backend.o
            LIB_OBJS += refs/iterator.o
            LIB_OBJS += refs/packed-backend.o
            LIB_OBJS += refs/ref-cache.o
            LIB_OBJS += refspec.o
            LIB_OBJS += remote.o
            LIB_OBJS += replace-object.o
            LIB_OBJS += repo-settings.o
            LIB_OBJS += repository.o
            LIB_OBJS += rerere.o
            LIB_OBJS += reset.o
            LIB_OBJS += resolve-undo.o
            LIB_OBJS += revision.o
            LIB_OBJS += run-command.o
            LIB_OBJS += send-pack.o
            LIB_OBJS += sequencer.o
            LIB_OBJS += serve.o
            LIB_OBJS += server-info.o
            LIB_OBJS += setup.o
            LIB_OBJS += shallow.o
            LIB_OBJS += sideband.o
            LIB_OBJS += sigchain.o
            LIB_OBJS += sparse-index.o
            LIB_OBJS += split-index.o
            LIB_OBJS += stable-qsort.o
            LIB_OBJS += statinfo.o
            LIB_OBJS += strbuf.o
            LIB_OBJS += streaming.o
            LIB_OBJS += string-list.o
            LIB_OBJS += strmap.o
            LIB_OBJS += strvec.o
            LIB_OBJS += sub-process.o
            LIB_OBJS += submodule-config.o
            LIB_OBJS += submodule.o
            LIB_OBJS += symlinks.o
            LIB_OBJS += tag.o
            LIB_OBJS += tempfile.o
            LIB_OBJS += thread-utils.o
            LIB_OBJS += tmp-objdir.o
            LIB_OBJS += trace.o
            LIB_OBJS += trace2.o
            LIB_OBJS += trace2/tr2_cfg.o
            LIB_OBJS += trace2/tr2_cmd_name.o
            LIB_OBJS += trace2/tr2_ctr.o
            LIB_OBJS += trace2/tr2_dst.o
            LIB_OBJS += trace2/tr2_sid.o
            LIB_OBJS += trace2/tr2_sysenv.o
            LIB_OBJS += trace2/tr2_tbuf.o
            LIB_OBJS += trace2/tr2_tgt_event.o
            LIB_OBJS += trace2/tr2_tgt_normal.o
            LIB_OBJS += trace2/tr2_tgt_perf.o
            LIB_OBJS += trace2/tr2_tls.o
            LIB_OBJS += trace2/tr2_tmr.o
            LIB_OBJS += trailer.o
            LIB_OBJS += transport-helper.o
            LIB_OBJS += transport.o
            LIB_OBJS += tree-diff.o
            LIB_OBJS += tree-walk.o
            LIB_OBJS += tree.o
            LIB_OBJS += unpack-trees.o
            LIB_OBJS += upload-pack.o
            LIB_OBJS += url.o
            LIB_OBJS += urlmatch.o
            LIB_OBJS += usage.o
            LIB_OBJS += userdiff.o
            LIB_OBJS += utf8.o
            LIB_OBJS += varint.o
            LIB_OBJS += version.o
            LIB_OBJS += versioncmp.o
            LIB_OBJS += walker.o
            LIB_OBJS += wildmatch.o
            LIB_OBJS += worktree.o
            LIB_OBJS += wrapper.o
            LIB_OBJS += write-or-die.o
            LIB_OBJS += ws.o
            LIB_OBJS += wt-status.o
            LIB_OBJS += xdiff-interface.o

            BUILTIN_OBJS += builtin/add.o
            BUILTIN_OBJS += builtin/am.o
            BUILTIN_OBJS += builtin/annotate.o
            BUILTIN_OBJS += builtin/apply.o
            BUILTIN_OBJS += builtin/archive.o
            BUILTIN_OBJS += builtin/bisect.o
            BUILTIN_OBJS += builtin/blame.o
            BUILTIN_OBJS += builtin/branch.o
            BUILTIN_OBJS += builtin/bugreport.o
            BUILTIN_OBJS += builtin/bundle.o
            BUILTIN_OBJS += builtin/cat-file.o
            BUILTIN_OBJS += builtin/check-attr.o
            BUILTIN_OBJS += builtin/check-ignore.o
            BUILTIN_OBJS += builtin/check-mailmap.o
            BUILTIN_OBJS += builtin/check-ref-format.o
            BUILTIN_OBJS += builtin/checkout--worker.o
            BUILTIN_OBJS += builtin/checkout-index.o
            BUILTIN_OBJS += builtin/checkout.o
            BUILTIN_OBJS += builtin/clean.o
            BUILTIN_OBJS += builtin/clone.o
            BUILTIN_OBJS += builtin/column.o
            BUILTIN_OBJS += builtin/commit-graph.o
            BUILTIN_OBJS += builtin/commit-tree.o
            BUILTIN_OBJS += builtin/commit.o
            BUILTIN_OBJS += builtin/config.o
            BUILTIN_OBJS += builtin/count-objects.o
            BUILTIN_OBJS += builtin/credential-cache--daemon.o
            BUILTIN_OBJS += builtin/credential-cache.o
            BUILTIN_OBJS += builtin/credential-store.o
            BUILTIN_OBJS += builtin/credential.o
            BUILTIN_OBJS += builtin/describe.o
            BUILTIN_OBJS += builtin/diagnose.o
            BUILTIN_OBJS += builtin/diff-files.o
            BUILTIN_OBJS += builtin/diff-index.o
            BUILTIN_OBJS += builtin/diff-tree.o
            BUILTIN_OBJS += builtin/diff.o
            BUILTIN_OBJS += builtin/difftool.o
            BUILTIN_OBJS += builtin/fast-export.o
            BUILTIN_OBJS += builtin/fast-import.o
            BUILTIN_OBJS += builtin/fetch-pack.o
            BUILTIN_OBJS += builtin/fetch.o
            BUILTIN_OBJS += builtin/fmt-merge-msg.o
            BUILTIN_OBJS += builtin/for-each-ref.o
            BUILTIN_OBJS += builtin/for-each-repo.o
            BUILTIN_OBJS += builtin/fsck.o
            BUILTIN_OBJS += builtin/fsmonitor--daemon.o
            BUILTIN_OBJS += builtin/gc.o
            BUILTIN_OBJS += builtin/get-tar-commit-id.o
            BUILTIN_OBJS += builtin/grep.o
            BUILTIN_OBJS += builtin/hash-object.o
            BUILTIN_OBJS += builtin/help.o
            BUILTIN_OBJS += builtin/hook.o
            BUILTIN_OBJS += builtin/index-pack.o
            BUILTIN_OBJS += builtin/init-db.o
            BUILTIN_OBJS += builtin/interpret-trailers.o
            BUILTIN_OBJS += builtin/log.o
            BUILTIN_OBJS += builtin/ls-files.o
            BUILTIN_OBJS += builtin/ls-remote.o
            BUILTIN_OBJS += builtin/ls-tree.o
            BUILTIN_OBJS += builtin/mailinfo.o
            BUILTIN_OBJS += builtin/mailsplit.o
            BUILTIN_OBJS += builtin/merge-base.o
            BUILTIN_OBJS += builtin/merge-file.o
            BUILTIN_OBJS += builtin/merge-index.o
            BUILTIN_OBJS += builtin/merge-ours.o
            BUILTIN_OBJS += builtin/merge-recursive.o
            BUILTIN_OBJS += builtin/merge-tree.o
            BUILTIN_OBJS += builtin/merge.o
            BUILTIN_OBJS += builtin/mktag.o
            BUILTIN_OBJS += builtin/mktree.o
            BUILTIN_OBJS += builtin/multi-pack-index.o
            BUILTIN_OBJS += builtin/mv.o
            BUILTIN_OBJS += builtin/name-rev.o
            BUILTIN_OBJS += builtin/notes.o
            BUILTIN_OBJS += builtin/pack-objects.o
            BUILTIN_OBJS += builtin/pack-redundant.o
            BUILTIN_OBJS += builtin/pack-refs.o
            BUILTIN_OBJS += builtin/patch-id.o
            BUILTIN_OBJS += builtin/prune-packed.o
            BUILTIN_OBJS += builtin/prune.o
            BUILTIN_OBJS += builtin/pull.o
            BUILTIN_OBJS += builtin/push.o
            BUILTIN_OBJS += builtin/range-diff.o
            BUILTIN_OBJS += builtin/read-tree.o
            BUILTIN_OBJS += builtin/rebase.o
            BUILTIN_OBJS += builtin/receive-pack.o
            BUILTIN_OBJS += builtin/reflog.o
            BUILTIN_OBJS += builtin/refs.o
            BUILTIN_OBJS += builtin/remote-ext.o
            BUILTIN_OBJS += builtin/remote-fd.o
            BUILTIN_OBJS += builtin/remote.o
            BUILTIN_OBJS += builtin/repack.o
            BUILTIN_OBJS += builtin/replace.o
            BUILTIN_OBJS += builtin/replay.o
            BUILTIN_OBJS += builtin/rerere.o
            BUILTIN_OBJS += builtin/reset.o
            BUILTIN_OBJS += builtin/rev-list.o
            BUILTIN_OBJS += builtin/rev-parse.o
            BUILTIN_OBJS += builtin/revert.o
            BUILTIN_OBJS += builtin/rm.o
            BUILTIN_OBJS += builtin/send-pack.o
            BUILTIN_OBJS += builtin/shortlog.o
            BUILTIN_OBJS += builtin/show-branch.o
            BUILTIN_OBJS += builtin/show-index.o
            BUILTIN_OBJS += builtin/show-ref.o
            BUILTIN_OBJS += builtin/sparse-checkout.o
            BUILTIN_OBJS += builtin/stash.o
            BUILTIN_OBJS += builtin/stripspace.o
            BUILTIN_OBJS += builtin/submodule--helper.o
            BUILTIN_OBJS += builtin/symbolic-ref.o
            BUILTIN_OBJS += builtin/tag.o
            BUILTIN_OBJS += builtin/unpack-file.o
            BUILTIN_OBJS += builtin/unpack-objects.o
            BUILTIN_OBJS += builtin/update-index.o
            BUILTIN_OBJS += builtin/update-ref.o
            BUILTIN_OBJS += builtin/update-server-info.o
            BUILTIN_OBJS += builtin/upload-archive.o
            BUILTIN_OBJS += builtin/upload-pack.o
            BUILTIN_OBJS += builtin/var.o
            BUILTIN_OBJS += builtin/verify-commit.o
            BUILTIN_OBJS += builtin/verify-pack.o
            BUILTIN_OBJS += builtin/verify-tag.o
            BUILTIN_OBJS += builtin/worktree.o
            BUILTIN_OBJS += builtin/write-tree.o

            # THIRD_PARTY_SOURCES is a list of patterns compatible with the
            # $(filter) and $(filter-out) family of functions. They specify source
            # files which are taken from some third-party source where we want to be
            # less strict about issues such as coding style so we don't diverge from
            # upstream unnecessarily (making merging in future changes easier).
            THIRD_PARTY_SOURCES += compat/inet_ntop.c
            THIRD_PARTY_SOURCES += compat/inet_pton.c
            THIRD_PARTY_SOURCES += compat/nedmalloc/%
            THIRD_PARTY_SOURCES += compat/obstack.%
            THIRD_PARTY_SOURCES += compat/poll/%
            THIRD_PARTY_SOURCES += compat/regex/%
            THIRD_PARTY_SOURCES += sha1collisiondetection/%
            THIRD_PARTY_SOURCES += sha1dc/%
            THIRD_PARTY_SOURCES += $(UNIT_TEST_DIR)/clar/%
            THIRD_PARTY_SOURCES += $(UNIT_TEST_DIR)/clar/clar/%

            CLAR_TEST_SUITES += u-ctype
            CLAR_TEST_SUITES += u-strvec
            CLAR_TEST_PROG = $(UNIT_TEST_BIN)/unit-tests$(X)
            CLAR_TEST_OBJS = $(patsubst %,$(UNIT_TEST_DIR)/%.o,$(CLAR_TEST_SUITES))
            CLAR_TEST_OBJS += $(UNIT_TEST_DIR)/clar/clar.o
            CLAR_TEST_OBJS += $(UNIT_TEST_DIR)/unit-test.o

            UNIT_TEST_PROGRAMS += t-example-decorate
            UNIT_TEST_PROGRAMS += t-hash
            UNIT_TEST_PROGRAMS += t-hashmap
            UNIT_TEST_PROGRAMS += t-mem-pool
            UNIT_TEST_PROGRAMS += t-oid-array
            UNIT_TEST_PROGRAMS += t-oidmap
            UNIT_TEST_PROGRAMS += t-oidtree
            UNIT_TEST_PROGRAMS += t-prio-queue
            UNIT_TEST_PROGRAMS += t-reftable-basics
            UNIT_TEST_PROGRAMS += t-reftable-block
            UNIT_TEST_PROGRAMS += t-reftable-merged
            UNIT_TEST_PROGRAMS += t-reftable-pq
            UNIT_TEST_PROGRAMS += t-reftable-reader
            UNIT_TEST_PROGRAMS += t-reftable-readwrite
            UNIT_TEST_PROGRAMS += t-reftable-record
            UNIT_TEST_PROGRAMS += t-reftable-stack
            UNIT_TEST_PROGRAMS += t-reftable-tree
            UNIT_TEST_PROGRAMS += t-strbuf
            UNIT_TEST_PROGRAMS += t-strcmp-offset
            UNIT_TEST_PROGRAMS += t-trailer
            UNIT_TEST_PROGRAMS += t-urlmatch-normalization
            UNIT_TEST_PROGS = $(patsubst %,$(UNIT_TEST_BIN)/%$X,$(UNIT_TEST_PROGRAMS))
            UNIT_TEST_OBJS += $(UNIT_TEST_DIR)/test-lib.o
            UNIT_TEST_OBJS += $(UNIT_TEST_DIR)/lib-oid.o
            UNIT_TEST_OBJS += $(UNIT_TEST_DIR)/lib-reftable.o

            # xdiff and reftable libs may in turn depend on what is in libgit.a
            GITLIBS = common-main.o $(LIB_FILE) $(XDIFF_LIB) $(REFTABLE_LIB) $(LIB_FILE)
            EXTLIBS = $(ZOPEN_EXTRA_LIBS)

            GIT_USER_AGENT = git/$(GIT_VERSION)

            ifeq ($(wildcard sha1collisiondetection/lib/sha1.h),sha1collisiondetection/lib/sha1.h)
            DC_SHA1_SUBMODULE = auto
            endif

            # Set CFLAGS, LDFLAGS and other *FLAGS variables. These might be
            # tweaked by config.* below as well as the command-line, both of
            # which'll override these defaults.
            # Older versions of GCC may require adding "-std=gnu99" at the end.
            CFLAGS = -g -O2 -Wall
            LDFLAGS =
            CC_LD_DYNPATH = -Wl,-rpath,
            BASIC_CFLAGS = -I.
            BASIC_LDFLAGS =

            # library flags
            ARFLAGS = rcs
            PTHREAD_CFLAGS =

            # For the 'sparse' target
            SPARSE_FLAGS ?= -std=gnu99
            SP_EXTRA_FLAGS =

            # For informing GIT-BUILD-OPTIONS of the SANITIZE=leak,address targets
            SANITIZE_LEAK =
            SANITIZE_ADDRESS =

            # For the 'coccicheck' target
            SPATCH_INCLUDE_FLAGS = --all-includes
            SPATCH_FLAGS =
            SPATCH_TEST_FLAGS =

            # If *.o files are present, have "coccicheck" depend on them, with
            # COMPUTE_HEADER_DEPENDENCIES this will speed up the common-case of
            # only needing to re-generate coccicheck results for the users of a
            # given API if it's changed, and not all files in the project. If
            # COMPUTE_HEADER_DEPENDENCIES=no this will be unset too.
            SPATCH_USE_O_DEPENDENCIES = YesPlease

            # Set SPATCH_CONCAT_COCCI to concatenate the contrib/cocci/*.cocci
            # files into a single contrib/cocci/ALL.cocci before running
            # "coccicheck".
            #
            # Pros:
            #
            # - Speeds up a one-shot run of "make coccicheck", as we won't have to
            #   parse *.[ch] files N times for the N *.cocci rules
            #
            # Cons:
            #
            # - Will make incremental development of *.cocci slower, as
            #   e.g. changing strbuf.cocci will re-run all *.cocci.
            #
            # - Makes error and performance analysis harder, as rules will be
            #   applied from a monolithic ALL.cocci, rather than
            #   e.g. strbuf.cocci. To work around this either undefine this, or
            #   generate a specific patch, e.g. this will always use strbuf.cocci,
            #   not ALL.cocci:
            #
            #       make contrib/coccinelle/strbuf.cocci.patch
            SPATCH_CONCAT_COCCI = YesPlease

            # Rebuild 'coccicheck' if $(SPATCH), its flags etc. change
            TRACK_SPATCH_DEFINES =
            TRACK_SPATCH_DEFINES += $(SPATCH)
            TRACK_SPATCH_DEFINES += $(SPATCH_INCLUDE_FLAGS)
            TRACK_SPATCH_DEFINES += $(SPATCH_FLAGS)
            TRACK_SPATCH_DEFINES += $(SPATCH_TEST_FLAGS)
            GIT-SPATCH-DEFINES: FORCE
                    @FLAGS='$(TRACK_SPATCH_DEFINES)'; \
                    if test x"$$FLAGS" != x"`cat GIT-SPATCH-DEFINES 2>/dev/null`" ; then \
                            echo >&2 "    * new spatch flags"; \
                            echo "$$FLAGS" >GIT-SPATCH-DEFINES; \
                    fi

            include config.mak.uname
            -include config.mak.autogen
            -include config.mak

            ifdef DEVELOPER
            include config.mak.dev
            endif

            GIT-VERSION-FILE: FORCE
                    @OLD=$$(cat $@ 2>/dev/null || :) && \
                    $(call version_gen,"$(shell pwd)",GIT-VERSION-FILE.in,$@) && \
                    NEW=$$(cat $@ 2>/dev/null || :) && \
                    if test "$$OLD" != "$$NEW"; then echo "$$NEW" >&2; fi

            # We need to set GIT_VERSION_OVERRIDE before including the version file as
            # otherwise any user-provided value for GIT_VERSION would have been overridden
            # already.
            GIT_VERSION_OVERRIDE := $(GIT_VERSION)
            -include GIT-VERSION-FILE

            # what 'all' will build and 'install' will install in gitexecdir,
            # excluding programs for built-in commands
            ALL_PROGRAMS = $(PROGRAMS) $(SCRIPTS)
            ALL_COMMANDS_TO_INSTALL = $(ALL_PROGRAMS)
            ifeq (,$(SKIP_DASHED_BUILT_INS))
            ALL_COMMANDS_TO_INSTALL += $(BUILT_INS)
            else
            # git-upload-pack, git-receive-pack and git-upload-archive are special: they
            # are _expected_ to be present in the `bin/` directory in their dashed form.
            ALL_COMMANDS_TO_INSTALL += git-receive-pack$(X)
            ALL_COMMANDS_TO_INSTALL += git-upload-archive$(X)
            ALL_COMMANDS_TO_INSTALL += git-upload-pack$(X)
            endif

            ALL_CFLAGS = $(DEVELOPER_CFLAGS) $(CPPFLAGS) $(CFLAGS) $(CFLAGS_APPEND)
            ALL_LDFLAGS = $(LDFLAGS) $(LDFLAGS_APPEND)

            ifdef SANITIZE
            SANITIZERS := $(foreach flag,$(subst $(comma),$(space),$(SANITIZE)),$(flag))
            BASIC_CFLAGS += -fsanitize=$(SANITIZE) -fno-sanitize-recover=$(SANITIZE)
            BASIC_CFLAGS += -fno-omit-frame-pointer
            ifneq ($(filter undefined,$(SANITIZERS)),)
            BASIC_CFLAGS += -DSHA1DC_FORCE_ALIGNED_ACCESS
            endif
            ifneq ($(filter leak,$(SANITIZERS)),)
            BASIC_CFLAGS += -O0
            SANITIZE_LEAK = YesCompiledWithIt
            endif
            ifneq ($(filter address,$(SANITIZERS)),)
            NO_REGEX = NeededForASAN
            SANITIZE_ADDRESS = YesCompiledWithIt
            endif
            endif

            ifndef sysconfdir
            ifeq ($(prefix),/usr)
            sysconfdir = /etc
            else
            sysconfdir = etc
            endif
            endif

            ifndef COMPUTE_HEADER_DEPENDENCIES
            COMPUTE_HEADER_DEPENDENCIES = auto
            endif

            ifeq ($(COMPUTE_HEADER_DEPENDENCIES),auto)
            dep_check = $(shell $(CC) $(ALL_CFLAGS) \
                    -Wno-pedantic \
                    -c -MF /dev/null -MQ /dev/null -MMD -MP \
                    -x c /dev/null -o /dev/null 2>&1; \
                    echo $$?)
            ifeq ($(dep_check),0)
            override COMPUTE_HEADER_DEPENDENCIES = yes
            else
            override COMPUTE_HEADER_DEPENDENCIES = no
            endif
            endif

            ifeq ($(COMPUTE_HEADER_DEPENDENCIES),yes)
            USE_COMPUTED_HEADER_DEPENDENCIES = YesPlease
            else
            ifneq ($(COMPUTE_HEADER_DEPENDENCIES),no)
            $(error please set COMPUTE_HEADER_DEPENDENCIES to yes, no, or auto \
            (not "$(COMPUTE_HEADER_DEPENDENCIES)"))
            endif
            endif

            ifndef GENERATE_COMPILATION_DATABASE
            GENERATE_COMPILATION_DATABASE = no
            endif

            ifeq ($(GENERATE_COMPILATION_DATABASE),yes)
            compdb_check = $(shell $(CC) $(ALL_CFLAGS) \
                    -Wno-pedantic \
                    -c -MJ /dev/null \
                    -x c /dev/null -o /dev/null 2>&1; \
                    echo $$?)
            ifneq ($(compdb_check),0)
            override GENERATE_COMPILATION_DATABASE = no
            $(warning GENERATE_COMPILATION_DATABASE is set to "yes", but your compiler does not \
            support generating compilation database entries)
            endif
            else
            ifneq ($(GENERATE_COMPILATION_DATABASE),no)
            $(error please set GENERATE_COMPILATION_DATABASE to "yes" or "no" \
            (not "$(GENERATE_COMPILATION_DATABASE)"))
            endif
            endif

            ifdef SANE_TOOL_PATH
            SANE_TOOL_PATH_SQ = $(subst ','\'',$(SANE_TOOL_PATH))
            BROKEN_PATH_FIX = s|^\# @BROKEN_PATH_FIX@$$|git_broken_path_fix "$(SANE_TOOL_PATH_SQ)"|
            PATH := $(SANE_TOOL_PATH):${PATH}
            else
            BROKEN_PATH_FIX = /^\# @BROKEN_PATH_FIX@$$/d
            endif

            ifeq (,$(HOST_CPU))
                    BASIC_CFLAGS += -DGIT_HOST_CPU="\"$(firstword $(subst -, ,$(uname_M)))\""
            else
                    BASIC_CFLAGS += -DGIT_HOST_CPU="\"$(HOST_CPU)\""
            endif

            ifneq (,$(INLINE))
                    BASIC_CFLAGS += -Dinline=$(INLINE)
            endif

            ifneq (,$(SOCKLEN_T))
                    BASIC_CFLAGS += -Dsocklen_t=$(SOCKLEN_T)
            endif

            ifeq ($(uname_S),Darwin)
                    ifndef NO_FINK
                            ifeq ($(shell test -d /sw/lib && echo y),y)
                                    BASIC_CFLAGS += -I/sw/include
                                    BASIC_LDFLAGS += -L/sw/lib
                            endif
                    endif
                    ifndef NO_DARWIN_PORTS
                            ifeq ($(shell test -d /opt/local/lib && echo y),y)
                                    BASIC_CFLAGS += -I/opt/local/include
                                    BASIC_LDFLAGS += -L/opt/local/lib
                            endif
                    endif
                    ifndef NO_APPLE_COMMON_CRYPTO
                            NO_OPENSSL = YesPlease
                            APPLE_COMMON_CRYPTO = YesPlease
                            COMPAT_CFLAGS += -DAPPLE_COMMON_CRYPTO
                    endif
                    PTHREAD_LIBS =
            endif

            ifdef NO_LIBGEN_H
                    COMPAT_CFLAGS += -DNO_LIBGEN_H
                    COMPAT_OBJS += compat/basename.o
            endif

            ifdef USE_LIBPCRE1
            $(error The USE_LIBPCRE1 build option has been removed, use version 2 with USE_LIBPCRE)
            endif

            USE_LIBPCRE2 ?= $(USE_LIBPCRE)

            ifneq (,$(USE_LIBPCRE2))
                    BASIC_CFLAGS += -DUSE_LIBPCRE2
                    EXTLIBS += -lpcre2-8
            endif

            ifdef LIBPCREDIR
                    BASIC_CFLAGS += -I$(LIBPCREDIR)/include
                    EXTLIBS += $(call libpath_template,$(LIBPCREDIR)/$(lib))
            endif

            ifdef HAVE_ALLOCA_H
                    BASIC_CFLAGS += -DHAVE_ALLOCA_H
            endif

            IMAP_SEND_BUILDDEPS =
            IMAP_SEND_LDFLAGS =

            ifdef NO_CURL
                    BASIC_CFLAGS += -DNO_CURL
                    REMOTE_CURL_PRIMARY =
                    REMOTE_CURL_ALIASES =
                    REMOTE_CURL_NAMES =
                    EXCLUDED_PROGRAMS += git-http-fetch git-http-push
            else
                    ifdef CURLDIR
                            # Try "-Wl,-rpath=$(CURLDIR)/$(lib)" in such a case.
                            CURL_CFLAGS = -I$(CURLDIR)/include
                            CURL_LIBCURL = $(call libpath_template,$(CURLDIR)/$(lib))
                    else
                            CURL_CFLAGS =
                            CURL_LIBCURL =
                    endif

                    ifndef CURL_LDFLAGS
                            CURL_LDFLAGS = $(eval CURL_LDFLAGS := $$(shell $$(CURL_CONFIG) --libs))$(CURL_LDFLAGS)
                    endif
                    CURL_LIBCURL += $(CURL_LDFLAGS)

                    ifndef CURL_CFLAGS
                            CURL_CFLAGS = $(eval CURL_CFLAGS := $$(shell $$(CURL_CONFIG) --cflags))$(CURL_CFLAGS)
                    endif
                    BASIC_CFLAGS += $(CURL_CFLAGS)

                    REMOTE_CURL_PRIMARY = git-remote-http$X
                    REMOTE_CURL_ALIASES = git-remote-https$X git-remote-ftp$X git-remote-ftps$X
                    REMOTE_CURL_NAMES = $(REMOTE_CURL_PRIMARY) $(REMOTE_CURL_ALIASES)
                    PROGRAM_OBJS += http-fetch.o
                    PROGRAMS += $(REMOTE_CURL_NAMES)
                    ifndef NO_EXPAT
                            PROGRAM_OBJS += http-push.o
                    endif
                    curl_check := $(shell (echo 072200; $(CURL_CONFIG) --vernum | sed -e '/^70[BC]/s/^/0/') 2>/dev/null | sort -r | sed -ne 2p)
                    ifeq "$(curl_check)" "072200"
                            USE_CURL_FOR_IMAP_SEND = YesPlease
                    endif
                    ifdef USE_CURL_FOR_IMAP_SEND
                            BASIC_CFLAGS += -DUSE_CURL_FOR_IMAP_SEND
                            IMAP_SEND_BUILDDEPS = http.o
                            IMAP_SEND_LDFLAGS += $(CURL_LIBCURL)
                    endif
                    ifndef NO_EXPAT
                            ifdef EXPATDIR
                                    BASIC_CFLAGS += -I$(EXPATDIR)/include
                                    EXPAT_LIBEXPAT = $(call libpath_template,$(EXPATDIR)/$(lib)) -lexpat
                            else
                                    EXPAT_LIBEXPAT = -lexpat
                            endif
                            ifdef EXPAT_NEEDS_XMLPARSE_H
                                    BASIC_CFLAGS += -DEXPAT_NEEDS_XMLPARSE_H
                            endif
                    endif
            endif
            IMAP_SEND_LDFLAGS += $(OPENSSL_LINK) $(OPENSSL_LIBSSL) $(LIB_4_CRYPTO)

            ifdef ZLIB_PATH
                    BASIC_CFLAGS += -I$(ZLIB_PATH)/include
                    EXTLIBS += $(call libpath_template,$(ZLIB_PATH)/$(lib))
            endif
            EXTLIBS += -lz

            ifndef NO_OPENSSL
                    OPENSSL_LIBSSL = -lssl
                    ifdef OPENSSLDIR
                            BASIC_CFLAGS += -I$(OPENSSLDIR)/include
                            OPENSSL_LINK = $(call libpath_template,$(OPENSSLDIR)/$(lib))
                    else
                            OPENSSL_LINK =
                    endif
                    ifdef NEEDS_CRYPTO_WITH_SSL
                            OPENSSL_LIBSSL += -lcrypto
                    endif
            else
                    BASIC_CFLAGS += -DNO_OPENSSL
                    OPENSSL_LIBSSL =
            endif
            ifdef NO_OPENSSL
                    LIB_4_CRYPTO =
            else
            ifdef NEEDS_SSL_WITH_CRYPTO
                    LIB_4_CRYPTO = $(OPENSSL_LINK) -lcrypto -lssl
            else
                    LIB_4_CRYPTO = $(OPENSSL_LINK) -lcrypto
            endif
            ifdef APPLE_COMMON_CRYPTO
                    LIB_4_CRYPTO += -framework Security -framework CoreFoundation
            endif
            endif
            ifndef NO_ICONV
                    ifdef NEEDS_LIBICONV
                            ifdef ICONVDIR
                                    BASIC_CFLAGS += -I$(ICONVDIR)/include
                                    ICONV_LINK = $(call libpath_template,$(ICONVDIR)/$(lib))
                            else
                                    ICONV_LINK =
                            endif
                            ifdef NEEDS_LIBINTL_BEFORE_LIBICONV
                                    ICONV_LINK += -lintl
                            endif
                            EXTLIBS += $(ICONV_LINK) -liconv
                    endif
            endif
            ifdef ICONV_OMITS_BOM
                    BASIC_CFLAGS += -DICONV_OMITS_BOM
            endif
            ifdef NEEDS_LIBGEN
                    EXTLIBS += -lgen
            endif
            ifndef NO_GETTEXT
            ifndef LIBC_CONTAINS_LIBINTL
                    EXTLIBS += -lintl
            endif
            endif
            ifdef NEEDS_SOCKET
                    EXTLIBS += -lsocket
            endif
            ifdef NEEDS_NSL
                    EXTLIBS += -lnsl
            endif
            ifdef NEEDS_RESOLV
                    EXTLIBS += -lresolv
            endif
            ifdef NO_D_TYPE_IN_DIRENT
                    BASIC_CFLAGS += -DNO_D_TYPE_IN_DIRENT
            endif
            ifdef NO_GECOS_IN_PWENT
                    BASIC_CFLAGS += -DNO_GECOS_IN_PWENT
            endif
            ifdef NO_ST_BLOCKS_IN_STRUCT_STAT
                    BASIC_CFLAGS += -DNO_ST_BLOCKS_IN_STRUCT_STAT
            endif
            ifdef USE_NSEC
                    BASIC_CFLAGS += -DUSE_NSEC
            endif
            ifdef USE_ST_TIMESPEC
                    BASIC_CFLAGS += -DUSE_ST_TIMESPEC
            endif
            ifdef NO_NORETURN
                    BASIC_CFLAGS += -DNO_NORETURN
            endif
            ifdef NO_NSEC
                    BASIC_CFLAGS += -DNO_NSEC
            endif
            ifdef SNPRINTF_RETURNS_BOGUS
                    COMPAT_CFLAGS += -DSNPRINTF_RETURNS_BOGUS
                    COMPAT_OBJS += compat/snprintf.o
            endif
            ifdef FREAD_READS_DIRECTORIES
                    COMPAT_CFLAGS += -DFREAD_READS_DIRECTORIES
                    COMPAT_OBJS += compat/fopen.o
            endif
            ifdef OPEN_RETURNS_EINTR
                    COMPAT_CFLAGS += -DOPEN_RETURNS_EINTR
                    COMPAT_OBJS += compat/open.o
            endif
            ifdef NO_SYMLINK_HEAD
                    BASIC_CFLAGS += -DNO_SYMLINK_HEAD
            endif
            ifdef NO_GETTEXT
                    BASIC_CFLAGS += -DNO_GETTEXT
                    USE_GETTEXT_SCHEME ?= fallthrough
            endif
            ifdef NO_POLL
                    NO_POLL_H = YesPlease
                    NO_SYS_POLL_H = YesPlease
                    COMPAT_CFLAGS += -DNO_POLL -Icompat/poll
                    COMPAT_OBJS += compat/poll/poll.o
            endif
            ifdef NO_STRCASESTR
                    COMPAT_CFLAGS += -DNO_STRCASESTR
                    COMPAT_OBJS += compat/strcasestr.o
            endif
            ifdef NO_STRLCPY
                    COMPAT_CFLAGS += -DNO_STRLCPY
                    COMPAT_OBJS += compat/strlcpy.o
            endif
            ifdef NO_STRTOUMAX
                    COMPAT_CFLAGS += -DNO_STRTOUMAX
                    COMPAT_OBJS += compat/strtoumax.o compat/strtoimax.o
            endif
            ifdef NO_STRTOULL
                    COMPAT_CFLAGS += -DNO_STRTOULL
            endif
            ifdef NO_SETENV
                    COMPAT_CFLAGS += -DNO_SETENV
                    COMPAT_OBJS += compat/setenv.o
            endif
            ifdef NO_MKDTEMP
                    COMPAT_CFLAGS += -DNO_MKDTEMP
                    COMPAT_OBJS += compat/mkdtemp.o
            endif
            ifdef MKDIR_WO_TRAILING_SLASH
                    COMPAT_CFLAGS += -DMKDIR_WO_TRAILING_SLASH
                    COMPAT_OBJS += compat/mkdir.o
            endif
            ifdef NO_UNSETENV
                    COMPAT_CFLAGS += -DNO_UNSETENV
                    COMPAT_OBJS += compat/unsetenv.o
            endif
            ifdef NO_SYS_SELECT_H
                    BASIC_CFLAGS += -DNO_SYS_SELECT_H
            endif
            ifdef NO_POLL_H
                    BASIC_CFLAGS += -DNO_POLL_H
            endif
            ifdef NO_SYS_POLL_H
                    BASIC_CFLAGS += -DNO_SYS_POLL_H
            endif
            ifdef NEEDS_SYS_PARAM_H
                    BASIC_CFLAGS += -DNEEDS_SYS_PARAM_H
            endif
            ifdef NO_INTTYPES_H
                    BASIC_CFLAGS += -DNO_INTTYPES_H
            endif
            ifdef NO_INITGROUPS
                    BASIC_CFLAGS += -DNO_INITGROUPS
            endif
            ifdef NO_MMAP
                    COMPAT_CFLAGS += -DNO_MMAP
                    COMPAT_OBJS += compat/mmap.o
            else
                    ifdef USE_WIN32_MMAP
                            COMPAT_CFLAGS += -DUSE_WIN32_MMAP
                            COMPAT_OBJS += compat/win32mmap.o
                    endif
            endif
            ifdef MMAP_PREVENTS_DELETE
                    BASIC_CFLAGS += -DMMAP_PREVENTS_DELETE
            endif
            ifdef OBJECT_CREATION_USES_RENAMES
                    COMPAT_CFLAGS += -DOBJECT_CREATION_MODE=1
            endif
            ifdef NO_STRUCT_ITIMERVAL
                    COMPAT_CFLAGS += -DNO_STRUCT_ITIMERVAL
                    NO_SETITIMER = YesPlease
            endif
            ifdef NO_SETITIMER
                    COMPAT_CFLAGS += -DNO_SETITIMER
            endif
            ifdef NO_PREAD
                    COMPAT_CFLAGS += -DNO_PREAD
                    COMPAT_OBJS += compat/pread.o
            endif
            ifdef NO_FAST_WORKING_DIRECTORY
                    BASIC_CFLAGS += -DNO_FAST_WORKING_DIRECTORY
            endif
            ifdef NO_TRUSTABLE_FILEMODE
                    BASIC_CFLAGS += -DNO_TRUSTABLE_FILEMODE
            endif
            ifdef NEEDS_MODE_TRANSLATION
                    COMPAT_CFLAGS += -DNEEDS_MODE_TRANSLATION
                    COMPAT_OBJS += compat/stat.o
            endif
            ifdef NO_IPV6
                    BASIC_CFLAGS += -DNO_IPV6
            endif
            ifdef NO_INTPTR_T
                    COMPAT_CFLAGS += -DNO_INTPTR_T
            endif
            ifdef NO_UINTMAX_T
                    BASIC_CFLAGS += -Duintmax_t=uint32_t
            endif
            ifdef NO_SOCKADDR_STORAGE
            ifdef NO_IPV6
                    BASIC_CFLAGS += -Dsockaddr_storage=sockaddr_in
            else
                    BASIC_CFLAGS += -Dsockaddr_storage=sockaddr_in6
            endif
            endif
            ifdef NO_INET_NTOP
                    LIB_OBJS += compat/inet_ntop.o
                    BASIC_CFLAGS += -DNO_INET_NTOP
            endif
            ifdef NO_INET_PTON
                    LIB_OBJS += compat/inet_pton.o
                    BASIC_CFLAGS += -DNO_INET_PTON
            endif
            ifdef NO_UNIX_SOCKETS
                    BASIC_CFLAGS += -DNO_UNIX_SOCKETS
            else
                    LIB_OBJS += unix-socket.o
                    LIB_OBJS += unix-stream-server.o
            endif

            # Simple IPC requires threads and platform-specific IPC support.
            # Only platforms that have both should include these source files
            # in the build.
            #
            # On Windows-based systems, Simple IPC requires threads and Windows
            # Named Pipes.  These are always available, so Simple IPC support
            # is optional.
            #
            # On Unix-based systems, Simple IPC requires pthreads and Unix
            # domain sockets.  So support is only enabled when both are present.
            #
            ifdef USE_WIN32_IPC
                    BASIC_CFLAGS += -DSUPPORTS_SIMPLE_IPC
                    LIB_OBJS += compat/simple-ipc/ipc-shared.o
                    LIB_OBJS += compat/simple-ipc/ipc-win32.o
            else
            ifndef NO_PTHREADS
            ifndef NO_UNIX_SOCKETS
                    BASIC_CFLAGS += -DSUPPORTS_SIMPLE_IPC
                    LIB_OBJS += compat/simple-ipc/ipc-shared.o
                    LIB_OBJS += compat/simple-ipc/ipc-unix-socket.o
            endif
            endif
            endif

            ifdef NO_ICONV
                    BASIC_CFLAGS += -DNO_ICONV
            endif

            ifdef OLD_ICONV
                    BASIC_CFLAGS += -DOLD_ICONV
            endif

            ifdef NO_DEFLATE_BOUND
                    BASIC_CFLAGS += -DNO_DEFLATE_BOUND
            endif

            ifdef NO_POSIX_GOODIES
                    BASIC_CFLAGS += -DNO_POSIX_GOODIES
            endif

            ifdef APPLE_COMMON_CRYPTO_SHA1
                    # Apple CommonCrypto requires chunking
                    SHA1_MAX_BLOCK_SIZE = 1024L*1024L*1024L
            endif

            ifdef PPC_SHA1
            $(error the PPC_SHA1 flag has been removed along with the PowerPC-specific SHA-1 implementation.)
            endif

            ifdef OPENSSL_SHA1
                    EXTLIBS += $(LIB_4_CRYPTO)
                    BASIC_CFLAGS += -DSHA1_OPENSSL
            else
            ifdef BLK_SHA1
                    LIB_OBJS += block-sha1/sha1.o
                    BASIC_CFLAGS += -DSHA1_BLK
            else
            ifdef APPLE_COMMON_CRYPTO_SHA1
                    COMPAT_CFLAGS += -DCOMMON_DIGEST_FOR_OPENSSL
                    BASIC_CFLAGS += -DSHA1_APPLE
            else
                    BASIC_CFLAGS += -DSHA1_DC
                    LIB_OBJS += sha1dc_git.o
            ifdef DC_SHA1_EXTERNAL
                    ifdef DC_SHA1_SUBMODULE
                            ifneq ($(DC_SHA1_SUBMODULE),auto)
            $(error Only set DC_SHA1_EXTERNAL or DC_SHA1_SUBMODULE, not both)
                            endif
                    endif
                    BASIC_CFLAGS += -DDC_SHA1_EXTERNAL
                    EXTLIBS += -lsha1detectcoll
            else
            ifdef DC_SHA1_SUBMODULE
                    LIB_OBJS += sha1collisiondetection/lib/sha1.o
                    LIB_OBJS += sha1collisiondetection/lib/ubc_check.o
                    BASIC_CFLAGS += -DDC_SHA1_SUBMODULE
            else
                    LIB_OBJS += sha1dc/sha1.o
                    LIB_OBJS += sha1dc/ubc_check.o
            endif
                    BASIC_CFLAGS += \
                            -DSHA1DC_NO_STANDARD_INCLUDES \
                            -DSHA1DC_INIT_SAFE_HASH_DEFAULT=0 \
                            -DSHA1DC_CUSTOM_INCLUDE_SHA1_C="\"git-compat-util.h\"" \
                            -DSHA1DC_CUSTOM_INCLUDE_UBC_CHECK_C="\"git-compat-util.h\""
            endif
            endif
            endif
            endif

            ifdef OPENSSL_SHA1_UNSAFE
            ifndef OPENSSL_SHA1
                    EXTLIBS += $(LIB_4_CRYPTO)
                    BASIC_CFLAGS += -DSHA1_OPENSSL_UNSAFE
            endif
            else
            ifdef BLK_SHA1_UNSAFE
            ifndef BLK_SHA1
                    LIB_OBJS += block-sha1/sha1.o
                    BASIC_CFLAGS += -DSHA1_BLK_UNSAFE
            endif
            else
            ifdef APPLE_COMMON_CRYPTO_SHA1_UNSAFE
            ifndef APPLE_COMMON_CRYPTO_SHA1
                    COMPAT_CFLAGS += -DCOMMON_DIGEST_FOR_OPENSSL
                    BASIC_CFLAGS += -DSHA1_APPLE_UNSAFE
            endif
            endif
            endif
            endif

            ifdef OPENSSL_SHA256
                    EXTLIBS += $(LIB_4_CRYPTO)
                    BASIC_CFLAGS += -DSHA256_OPENSSL
            else
            ifdef NETTLE_SHA256
                    BASIC_CFLAGS += -DSHA256_NETTLE
                    EXTLIBS += -lnettle
            else
            ifdef GCRYPT_SHA256
                    BASIC_CFLAGS += -DSHA256_GCRYPT
                    EXTLIBS += -lgcrypt
            else
                    LIB_OBJS += sha256/block/sha256.o
                    BASIC_CFLAGS += -DSHA256_BLK
            endif
            endif
            endif

            ifdef SHA1_MAX_BLOCK_SIZE
                    LIB_OBJS += compat/sha1-chunked.o
                    BASIC_CFLAGS += -DSHA1_MAX_BLOCK_SIZE="$(SHA1_MAX_BLOCK_SIZE)"
            endif
            ifdef NO_HSTRERROR
                    COMPAT_CFLAGS += -DNO_HSTRERROR
                    COMPAT_OBJS += compat/hstrerror.o
            endif
            ifdef NO_MEMMEM
                    COMPAT_CFLAGS += -DNO_MEMMEM
                    COMPAT_OBJS += compat/memmem.o
            endif
            ifdef NO_GETPAGESIZE
                    COMPAT_CFLAGS += -DNO_GETPAGESIZE
            endif
            ifdef INTERNAL_QSORT
                    COMPAT_CFLAGS += -DINTERNAL_QSORT
            endif
            ifdef HAVE_ISO_QSORT_S
                    COMPAT_CFLAGS += -DHAVE_ISO_QSORT_S
            else
                    COMPAT_OBJS += compat/qsort_s.o
            endif
            ifdef RUNTIME_PREFIX
                    COMPAT_CFLAGS += -DRUNTIME_PREFIX
            endif

            ifdef NO_PTHREADS
                    BASIC_CFLAGS += -DNO_PTHREADS
            else
                    BASIC_CFLAGS += $(PTHREAD_CFLAGS)
                    EXTLIBS += $(PTHREAD_LIBS)
            endif

            ifdef HAVE_PATHS_H
                    BASIC_CFLAGS += -DHAVE_PATHS_H
            endif

            ifdef HAVE_LIBCHARSET_H
                    BASIC_CFLAGS += -DHAVE_LIBCHARSET_H
                    EXTLIBS += $(CHARSET_LIB)
            endif

            ifdef HAVE_STRINGS_H
                    BASIC_CFLAGS += -DHAVE_STRINGS_H
            endif

            ifdef HAVE_DEV_TTY
                    BASIC_CFLAGS += -DHAVE_DEV_TTY
            endif

            ifdef DIR_HAS_BSD_GROUP_SEMANTICS
                    COMPAT_CFLAGS += -DDIR_HAS_BSD_GROUP_SEMANTICS
            endif
            ifdef UNRELIABLE_FSTAT
                    BASIC_CFLAGS += -DUNRELIABLE_FSTAT
            endif
            ifdef NO_REGEX
                    COMPAT_CFLAGS += -Icompat/regex
                    COMPAT_OBJS += compat/regex/regex.o
            else
            ifdef USE_ENHANCED_BASIC_REGULAR_EXPRESSIONS
                    COMPAT_CFLAGS += -DUSE_ENHANCED_BASIC_REGULAR_EXPRESSIONS
                    COMPAT_OBJS += compat/regcomp_enhanced.o
            endif
            endif
            ifdef NATIVE_CRLF
                    BASIC_CFLAGS += -DNATIVE_CRLF
            endif

            ifdef USE_NED_ALLOCATOR
                    COMPAT_CFLAGS += -Icompat/nedmalloc
                    COMPAT_OBJS += compat/nedmalloc/nedmalloc.o
                    OVERRIDE_STRDUP = YesPlease
            endif

            ifdef OVERRIDE_STRDUP
                    COMPAT_CFLAGS += -DOVERRIDE_STRDUP
                    COMPAT_OBJS += compat/strdup.o
            endif

            ifdef GIT_TEST_CMP_USE_COPIED_CONTEXT
                    export GIT_TEST_CMP_USE_COPIED_CONTEXT
            endif

            ifndef NO_MSGFMT_EXTENDED_OPTIONS
                    MSGFMT += --check
            endif

            ifdef HAVE_CLOCK_GETTIME
                    BASIC_CFLAGS += -DHAVE_CLOCK_GETTIME
            endif

            ifdef HAVE_CLOCK_MONOTONIC
                    BASIC_CFLAGS += -DHAVE_CLOCK_MONOTONIC
            endif

            ifdef HAVE_SYNC_FILE_RANGE
                    BASIC_CFLAGS += -DHAVE_SYNC_FILE_RANGE
            endif

            ifdef NEEDS_LIBRT
                    EXTLIBS += -lrt
            endif

            ifdef HAVE_BSD_SYSCTL
                    BASIC_CFLAGS += -DHAVE_BSD_SYSCTL
            endif

            ifdef HAVE_BSD_KERN_PROC_SYSCTL
                    BASIC_CFLAGS += -DHAVE_BSD_KERN_PROC_SYSCTL
            endif

            ifdef HAVE_GETDELIM
                    BASIC_CFLAGS += -DHAVE_GETDELIM
            endif

            ifneq ($(findstring arc4random,$(CSPRNG_METHOD)),)
                    BASIC_CFLAGS += -DHAVE_ARC4RANDOM
            endif

            ifneq ($(findstring libbsd,$(CSPRNG_METHOD)),)
                    BASIC_CFLAGS += -DHAVE_ARC4RANDOM_LIBBSD
                    EXTLIBS += -lbsd
            endif

            ifneq ($(findstring getrandom,$(CSPRNG_METHOD)),)
                    BASIC_CFLAGS += -DHAVE_GETRANDOM
            endif

            ifneq ($(findstring getentropy,$(CSPRNG_METHOD)),)
                    BASIC_CFLAGS += -DHAVE_GETENTROPY
            endif

            ifneq ($(findstring rtlgenrandom,$(CSPRNG_METHOD)),)
                    BASIC_CFLAGS += -DHAVE_RTLGENRANDOM
            endif

            ifneq ($(findstring openssl,$(CSPRNG_METHOD)),)
                    BASIC_CFLAGS += -DHAVE_OPENSSL_CSPRNG
                    EXTLIBS += -lcrypto -lssl
            endif

            ifneq ($(PROCFS_EXECUTABLE_PATH),)
                    procfs_executable_path_SQ = $(subst ','\'',$(PROCFS_EXECUTABLE_PATH))
                    BASIC_CFLAGS += '-DPROCFS_EXECUTABLE_PATH="$(procfs_executable_path_SQ)"'
            endif

            ifndef HAVE_PLATFORM_PROCINFO
                    COMPAT_OBJS += compat/stub/procinfo.o
            endif

            ifdef HAVE_NS_GET_EXECUTABLE_PATH
                    BASIC_CFLAGS += -DHAVE_NS_GET_EXECUTABLE_PATH
            endif

            ifdef HAVE_ZOS_GET_EXECUTABLE_PATH
                    BASIC_CFLAGS += -DHAVE_ZOS_GET_EXECUTABLE_PATH
            endif

            ifdef HAVE_WPGMPTR
                    BASIC_CFLAGS += -DHAVE_WPGMPTR
            endif

            ifdef FILENO_IS_A_MACRO
                    COMPAT_CFLAGS += -DFILENO_IS_A_MACRO
                    COMPAT_OBJS += compat/fileno.o
            endif

            ifdef NEED_ACCESS_ROOT_HANDLER
                    COMPAT_CFLAGS += -DNEED_ACCESS_ROOT_HANDLER
                    COMPAT_OBJS += compat/access.o
            endif

            ifdef FSMONITOR_DAEMON_BACKEND
                    COMPAT_CFLAGS += -DHAVE_FSMONITOR_DAEMON_BACKEND
                    COMPAT_OBJS += compat/fsmonitor/fsm-listen-$(FSMONITOR_DAEMON_BACKEND).o
                    COMPAT_OBJS += compat/fsmonitor/fsm-health-$(FSMONITOR_DAEMON_BACKEND).o
                    COMPAT_OBJS += compat/fsmonitor/fsm-ipc-$(FSMONITOR_DAEMON_BACKEND).o
            endif

            ifdef FSMONITOR_OS_SETTINGS
                    COMPAT_CFLAGS += -DHAVE_FSMONITOR_OS_SETTINGS
                    COMPAT_OBJS += compat/fsmonitor/fsm-settings-$(FSMONITOR_OS_SETTINGS).o
                    COMPAT_OBJS += compat/fsmonitor/fsm-path-utils-$(FSMONITOR_OS_SETTINGS).o
            endif

            ifeq ($(TCLTK_PATH),)
            NO_TCLTK = NoThanks
            endif

            ifeq ($(PERL_PATH),)
            NO_PERL = NoThanks
            endif

            ifeq ($(PYTHON_PATH),)
            NO_PYTHON = NoThanks
            endif

            ifndef PAGER_ENV
            PAGER_ENV = LESS=FRX LV=-c
            endif

            ifdef NO_INSTALL_HARDLINKS
                    export NO_INSTALL_HARDLINKS
            endif

            ### profile feedback build
            #

            # Can adjust this to be a global directory if you want to do extended
            # data gathering
            PROFILE_DIR := $(CURDIR)

            ifeq ("$(PROFILE)","GEN")
                    BASIC_CFLAGS += -fprofile-generate=$(PROFILE_DIR) -DNO_NORETURN=1
                    EXTLIBS += -lgcov
                    export CCACHE_DISABLE = t
                    V = 1
            else
            ifneq ("$(PROFILE)","")
                    BASIC_CFLAGS += -fprofile-use=$(PROFILE_DIR) -fprofile-correction -DNO_NORETURN=1
                    export CCACHE_DISABLE = t
                    V = 1
            endif
            endif

            # Shell quote (do not use $(call) to accommodate ancient setups);

            ETC_GITCONFIG_SQ = $(subst ','\'',$(ETC_GITCONFIG))
            ETC_GITATTRIBUTES_SQ = $(subst ','\'',$(ETC_GITATTRIBUTES))

            DESTDIR_SQ = $(subst ','\'',$(DESTDIR))
            NO_GETTEXT_SQ = $(subst ','\'',$(NO_GETTEXT))
            bindir_SQ = $(subst ','\'',$(bindir))
            bindir_relative_SQ = $(subst ','\'',$(bindir_relative))
            mandir_SQ = $(subst ','\'',$(mandir))
            mandir_relative_SQ = $(subst ','\'',$(mandir_relative))
            infodir_relative_SQ = $(subst ','\'',$(infodir_relative))
            perllibdir_SQ = $(subst ','\'',$(perllibdir))
            localedir_SQ = $(subst ','\'',$(localedir))
            localedir_relative_SQ = $(subst ','\'',$(localedir_relative))
            gitexecdir_SQ = $(subst ','\'',$(gitexecdir))
            gitexecdir_relative_SQ = $(subst ','\'',$(gitexecdir_relative))
            template_dir_SQ = $(subst ','\'',$(template_dir))
            htmldir_relative_SQ = $(subst ','\'',$(htmldir_relative))
            prefix_SQ = $(subst ','\'',$(prefix))
            perllibdir_relative_SQ = $(subst ','\'',$(perllibdir_relative))
            gitwebdir_SQ = $(subst ','\'',$(gitwebdir))
            gitwebstaticdir_SQ = $(subst ','\'',$(gitwebstaticdir))

            SHELL_PATH_SQ = $(subst ','\'',$(SHELL_PATH_FOR_SCRIPTS))
            TEST_SHELL_PATH_SQ = $(subst ','\'',$(TEST_SHELL_PATH))
            PERL_PATH_SQ = $(subst ','\'',$(PERL_PATH))
            PERL_PATH_FOR_SCRIPTS_SQ = $(subst ','\'',$(PERL_PATH_FOR_SCRIPTS))
            PYTHON_PATH_SQ = $(subst ','\'',$(PYTHON_PATH))
            TCLTK_PATH_SQ = $(subst ','\'',$(TCLTK_PATH))
            DIFF_SQ = $(subst ','\'',$(DIFF))
            PERLLIB_EXTRA_SQ = $(subst ','\'',$(PERLLIB_EXTRA))

            # RUNTIME_PREFIX's resolution logic requires resource paths to be expressed
            # relative to each other and share an installation path.
            #
            # This is a dependency in:
            # - Git's binary RUNTIME_PREFIX logic in (see "exec_cmd.c").
            # - The runtime prefix Perl header (see
            #   "perl/header_templates/runtime_prefix.template.pl").
            ifdef RUNTIME_PREFIX

            ifneq ($(filter /%,$(firstword $(gitexecdir_relative))),)
            $(error RUNTIME_PREFIX requires a relative gitexecdir, not: $(gitexecdir))
            endif

            ifneq ($(filter /%,$(firstword $(localedir_relative))),)
            $(error RUNTIME_PREFIX requires a relative localedir, not: $(localedir))
            endif

            ifndef NO_PERL
            ifneq ($(filter /%,$(firstword $(perllibdir_relative))),)
            $(error RUNTIME_PREFIX requires a relative perllibdir, not: $(perllibdir))
            endif
            endif

            endif

            # We must filter out any object files from $(GITLIBS),
            # as it is typically used like:
            #
            #   foo: foo.o $(GITLIBS)
            #       $(CC) $(filter %.o,$^) $(LIBS)
            #
            # where we use it as a dependency. Since we also pull object files
            # from the dependency list, that would make each entry appear twice.
            LIBS = $(filter-out %.o, $(GITLIBS)) $(EXTLIBS)

            BASIC_CFLAGS += $(COMPAT_CFLAGS)
            LIB_OBJS += $(COMPAT_OBJS)

            # Quote for C

            ifdef DEFAULT_EDITOR
            DEFAULT_EDITOR_CQ = "$(subst ",\",$(subst \,\\,$(DEFAULT_EDITOR)))"
            DEFAULT_EDITOR_CQ_SQ = $(subst ','\'',$(DEFAULT_EDITOR_CQ))

            BASIC_CFLAGS += -DDEFAULT_EDITOR='$(DEFAULT_EDITOR_CQ_SQ)'
            endif

            ifdef DEFAULT_PAGER
            DEFAULT_PAGER_CQ = "$(subst ",\",$(subst \,\\,$(DEFAULT_PAGER)))"
            DEFAULT_PAGER_CQ_SQ = $(subst ','\'',$(DEFAULT_PAGER_CQ))

            BASIC_CFLAGS += -DDEFAULT_PAGER='$(DEFAULT_PAGER_CQ_SQ)'
            endif

            ifdef SHELL_PATH
            SHELL_PATH_CQ = "$(subst ",\",$(subst \,\\,$(SHELL_PATH)))"
            SHELL_PATH_CQ_SQ = $(subst ','\'',$(SHELL_PATH_CQ))

            BASIC_CFLAGS += -DSHELL_PATH='$(SHELL_PATH_CQ_SQ)'
            endif

            GIT_USER_AGENT_SQ = $(subst ','\'',$(GIT_USER_AGENT))
            GIT_USER_AGENT_CQ = "$(subst ",\",$(subst \,\\,$(GIT_USER_AGENT)))"
            GIT_USER_AGENT_CQ_SQ = $(subst ','\'',$(GIT_USER_AGENT_CQ))
            GIT-USER-AGENT: FORCE
                    @if test x'$(GIT_USER_AGENT_SQ)' != x"`cat GIT-USER-AGENT 2>/dev/null`"; then \
                            echo '$(GIT_USER_AGENT_SQ)' >GIT-USER-AGENT; \
                    fi

            ifdef DEFAULT_HELP_FORMAT
            BASIC_CFLAGS += -DDEFAULT_HELP_FORMAT='"$(DEFAULT_HELP_FORMAT)"'
            endif

            ALL_CFLAGS += $(BASIC_CFLAGS)
            ALL_LDFLAGS += $(BASIC_LDFLAGS)

            export DIFF TAR INSTALL DESTDIR SHELL_PATH


            ### Build rules

            SHELL = $(SHELL_PATH)

            all:: shell_compatibility_test

            ifeq "$(PROFILE)" "BUILD"
            all:: profile
            endif

            profile:: profile-clean
                    $(MAKE) PROFILE=GEN all
                    $(MAKE) PROFILE=GEN -j1 test
                    @if test -n "$$GIT_PERF_REPO" || test -d .git; then \
                            $(MAKE) PROFILE=GEN -j1 perf; \
                    else \
                            echo "Skipping profile of perf tests..."; \
                    fi
                    $(MAKE) PROFILE=USE all

            profile-fast: profile-clean
                    $(MAKE) PROFILE=GEN all
                    $(MAKE) PROFILE=GEN -j1 perf
                    $(MAKE) PROFILE=USE all


            all:: $(ALL_COMMANDS_TO_INSTALL) $(SCRIPT_LIB) $(OTHER_PROGRAMS) GIT-BUILD-OPTIONS
            ifneq (,$X)
                    $(QUIET_BUILT_IN)$(foreach p,$(patsubst %$X,%,$(filter %$X,$(ALL_COMMANDS_TO_INSTALL) $(OTHER_PROGRAMS))), if test ! -d '$p' && test ! '$p' -ef '$p$X'; then $(RM) '$p'; fi;)
            endif

            all::
            ifndef NO_TCLTK
                    $(QUIET_SUBDIR0)git-gui $(QUIET_SUBDIR1) gitexecdir='$(gitexec_instdir_SQ)' all
                    $(QUIET_SUBDIR0)gitk-git $(QUIET_SUBDIR1) all
            endif
                    $(QUIET_SUBDIR0)templates $(QUIET_SUBDIR1) SHELL_PATH='$(SHELL_PATH_SQ)' PERL_PATH='$(PERL_PATH_SQ)'

            # If you add a new fuzzer, please also make sure to run it in
            # ci/run-build-and-minimal-fuzzers.sh so that we make sure it still links and
            # runs in the future.
            FUZZ_OBJS += oss-fuzz/dummy-cmd-main.o
            FUZZ_OBJS += oss-fuzz/fuzz-commit-graph.o
            FUZZ_OBJS += oss-fuzz/fuzz-config.o
            FUZZ_OBJS += oss-fuzz/fuzz-credential-from-url-gently.o
            FUZZ_OBJS += oss-fuzz/fuzz-date.o
            FUZZ_OBJS += oss-fuzz/fuzz-pack-headers.o
            FUZZ_OBJS += oss-fuzz/fuzz-pack-idx.o
            FUZZ_OBJS += oss-fuzz/fuzz-parse-attr-line.o
            FUZZ_OBJS += oss-fuzz/fuzz-url-decode-mem.o
            .PHONY: fuzz-objs
            fuzz-objs: $(FUZZ_OBJS)

            # Always build fuzz objects even if not testing, to prevent bit-rot.
            all:: $(FUZZ_OBJS)

            FUZZ_PROGRAMS += $(patsubst %.o,%,$(filter-out %dummy-cmd-main.o,$(FUZZ_OBJS)))

            # Build fuzz programs when possible, even without the necessary fuzzing support,
            # to prevent bit-rot.
            ifdef LINK_FUZZ_PROGRAMS
            all:: $(FUZZ_PROGRAMS)
            endif

            please_set_SHELL_PATH_to_a_more_modern_shell:
                    @$$(:)

            shell_compatibility_test: please_set_SHELL_PATH_to_a_more_modern_shell

            strip: $(PROGRAMS) git$X
                    $(STRIP) $(STRIP_OPTS) $^

            ### Target-specific flags and dependencies

            # The generic compilation pattern rule and automatically
            # computed header dependencies (falling back to a dependency on
            # LIB_H) are enough to describe how most targets should be built,
            # but some targets are special enough to need something a little
            # different.
            #
            # - When a source file "foo.c" #includes a generated header file,
            #   we need to list that dependency for the "foo.o" target.
            #
            #   We also list it from other targets that are built from foo.c
            #   like "foo.sp" and "foo.s", even though that is easy to forget
            #   to do because the generated header is already present around
            #   after a regular build attempt.
            #
            # - Some code depends on configuration kept in makefile
            #   variables. The target-specific variable EXTRA_CPPFLAGS can
            #   be used to convey that information to the C preprocessor
            #   using -D options.
            #
            #   The "foo.o" target should have a corresponding dependency on
            #   a file that changes when the value of the makefile variable
            #   changes.  For example, targets making use of the
            #   $(GIT_VERSION) variable depend on GIT-VERSION-FILE.
            #
            #   Technically the ".sp" and ".s" targets do not need this
            #   dependency because they are force-built, but they get the
            #   same dependency for consistency. This way, you do not have to
            #   know how each target is implemented. And it means the
            #   dependencies here will not need to change if the force-build
            #   details change some day.

            git.sp git.s git.o: GIT-PREFIX
            git.sp git.s git.o: EXTRA_CPPFLAGS = \
                    '-DGIT_HTML_PATH="$(htmldir_relative_SQ)"' \
                    '-DGIT_MAN_PATH="$(mandir_relative_SQ)"' \
                    '-DGIT_INFO_PATH="$(infodir_relative_SQ)"'

            git$X: git.o GIT-LDFLAGS $(BUILTIN_OBJS) $(GITLIBS)
                    $(QUIET_LINK)$(CC) $(ALL_CFLAGS) -o $@ $(ALL_LDFLAGS) \
                            $(filter %.o,$^) $(LIBS)

            help.sp help.s help.o: command-list.h
            builtin/bugreport.sp builtin/bugreport.s builtin/bugreport.o: hook-list.h

            builtin/help.sp builtin/help.s builtin/help.o: config-list.h GIT-PREFIX
            builtin/help.sp builtin/help.s builtin/help.o: EXTRA_CPPFLAGS = \
                    '-DGIT_HTML_PATH="$(htmldir_relative_SQ)"' \
                    '-DGIT_MAN_PATH="$(mandir_relative_SQ)"' \
                    '-DGIT_INFO_PATH="$(infodir_relative_SQ)"'

            PAGER_ENV_SQ = $(subst ','\'',$(PAGER_ENV))
            PAGER_ENV_CQ = "$(subst ",\",$(subst \,\\,$(PAGER_ENV)))"
            PAGER_ENV_CQ_SQ = $(subst ','\'',$(PAGER_ENV_CQ))
            pager.sp pager.s pager.o: EXTRA_CPPFLAGS = \
                    -DPAGER_ENV='$(PAGER_ENV_CQ_SQ)'

            version-def.h: version-def.h.in GIT-VERSION-GEN GIT-VERSION-FILE GIT-USER-AGENT
                    $(QUIET_GEN)$(call version_gen,"$(shell pwd)",$<,$@)

            version.sp version.s version.o: version-def.h

            $(BUILT_INS): git$X
                    $(QUIET_BUILT_IN)$(RM) $@ && \
                    ln $< $@ 2>/dev/null || \
                    ln -s $< $@ 2>/dev/null || \
                    cp $< $@

            config-list.h: generate-configlist.sh

            config-list.h: Documentation/*config.txt Documentation/config/*.txt
                    $(QUIET_GEN)$(SHELL_PATH) ./generate-configlist.sh . $@

            command-list.h: generate-cmdlist.sh command-list.txt

            command-list.h: $(wildcard Documentation/git*.txt)
                    $(QUIET_GEN)$(SHELL_PATH) ./generate-cmdlist.sh \
                            $(patsubst %,--exclude-program %,$(EXCLUDED_PROGRAMS)) \
                            . $@

            hook-list.h: generate-hooklist.sh Documentation/githooks.txt
                    $(QUIET_GEN)$(SHELL_PATH) ./generate-hooklist.sh . $@

            SCRIPT_DEFINES = $(SHELL_PATH_SQ):$(DIFF_SQ):\
                    $(localedir_SQ):$(USE_GETTEXT_SCHEME):$(SANE_TOOL_PATH_SQ):\
                    $(gitwebdir_SQ):$(PERL_PATH_FOR_SCRIPTS_SQ):$(PAGER_ENV):\
                    $(perllibdir_SQ)
            GIT-SCRIPT-DEFINES: FORCE
                    @FLAGS='$(SCRIPT_DEFINES)'; \
                    if test x"$$FLAGS" != x"`cat $@ 2>/dev/null`" ; then \
                            echo >&2 "    * new script parameters"; \
                            echo "$$FLAGS" >$@; \
                    fi

            $(SCRIPT_SH_GEN) $(SCRIPT_LIB) : % : %.sh generate-script.sh GIT-BUILD-OPTIONS GIT-SCRIPT-DEFINES
                    $(QUIET_GEN)./generate-script.sh "$<" "$@+" ./GIT-BUILD-OPTIONS && \
                    mv $@+ $@

            git.rc: git.rc.in GIT-VERSION-GEN GIT-VERSION-FILE
                    $(QUIET_GEN)$(call version_gen,"$(shell pwd)",$<,$@)

            git.res: git.rc GIT-PREFIX
                    $(QUIET_RC)$(RC) -i $< -o $@

            # This makes sure we depend on the NO_PERL setting itself.
            $(SCRIPT_PERL_GEN): GIT-BUILD-OPTIONS

            # Used for substitution in Perl modules. Disabled when using RUNTIME_PREFIX
            # since the locale directory is injected.
            perl_localedir_SQ = $(localedir_SQ)

            ifndef NO_PERL
            PERL_HEADER_TEMPLATE = perl/header_templates/fixed_prefix.template.pl
            PERL_DEFINES =
            PERL_DEFINES += $(PERL_PATH_SQ)
            PERL_DEFINES += $(PERLLIB_EXTRA_SQ)
            PERL_DEFINES += $(perllibdir_SQ)
            PERL_DEFINES += $(RUNTIME_PREFIX)
            PERL_DEFINES += $(NO_PERL_CPAN_FALLBACKS)
            PERL_DEFINES += $(NO_GETTEXT)

            # Support Perl runtime prefix. In this mode, a different header is installed
            # into Perl scripts.
            ifdef RUNTIME_PREFIX

            PERL_HEADER_TEMPLATE = perl/header_templates/runtime_prefix.template.pl

            # Don't export a fixed $(localedir) path; it will be resolved by the Perl header
            # at runtime.
            perl_localedir_SQ =

            endif

            PERL_DEFINES += $(gitexecdir) $(perllibdir) $(localedir)

            $(SCRIPT_PERL_GEN): % : %.perl generate-perl.sh GIT-PERL-DEFINES GIT-PERL-HEADER GIT-VERSION-FILE
                    $(QUIET_GEN)$(SHELL_PATH) generate-perl.sh ./GIT-BUILD-OPTIONS ./GIT-VERSION-FILE GIT-PERL-HEADER "$<" "$@+" && \
                    mv $@+ $@

            PERL_DEFINES := $(subst $(space),:,$(PERL_DEFINES))
            GIT-PERL-DEFINES: FORCE
                    @FLAGS='$(PERL_DEFINES)'; \
                    if test x"$$FLAGS" != x"`cat $@ 2>/dev/null`" ; then \
                            echo >&2 "    * new perl-specific parameters"; \
                            echo "$$FLAGS" >$@; \
                    fi

            GIT-PERL-HEADER: $(PERL_HEADER_TEMPLATE) GIT-PERL-DEFINES Makefile
                    $(QUIET_GEN) \
                    INSTLIBDIR='$(perllibdir_SQ)' && \
                    INSTLIBDIR_EXTRA='$(PERLLIB_EXTRA_SQ)' && \
                    INSTLIBDIR="$$INSTLIBDIR$${INSTLIBDIR_EXTRA:+:$$INSTLIBDIR_EXTRA}" && \
                    sed -e 's=@PATHSEP@=$(pathsep)=g' \
                    -e "s=@INSTLIBDIR@=$$INSTLIBDIR=g" \
                    -e 's=@PERLLIBDIR_REL@=$(perllibdir_relative_SQ)=g' \
                    -e 's=@GITEXECDIR_REL@=$(gitexecdir_relative_SQ)=g' \
                    -e 's=@LOCALEDIR_REL@=$(localedir_relative_SQ)=g' \
                    $< >$@+ && \
                    mv $@+ $@

            .PHONY: perllibdir
            perllibdir:
                    @echo '$(perllibdir_SQ)'

            git-instaweb: git-instaweb.sh generate-script.sh GIT-BUILD-OPTIONS GIT-SCRIPT-DEFINES
                    $(QUIET_GEN)./generate-script.sh "$<" "$@+" ./GIT-BUILD-OPTIONS && \
                    chmod +x $@+ && \
                    mv $@+ $@
            else # NO_PERL
            $(SCRIPT_PERL_GEN) git-instaweb: % : unimplemented.sh
                    $(QUIET_GEN) \
                    sed -e '1s|#!.*/sh|#!$(SHELL_PATH_SQ)|' \
                    -e 's|@REASON@|NO_PERL=$(NO_PERL)|g' \
                    unimplemented.sh >$@+ && \
                    chmod +x $@+ && \
                    mv $@+ $@
            endif # NO_PERL

            # This makes sure we depend on the NO_PYTHON setting itself.
            $(SCRIPT_PYTHON_GEN): GIT-BUILD-OPTIONS

            ifndef NO_PYTHON
            $(SCRIPT_PYTHON_GEN): generate-python.sh
            $(SCRIPT_PYTHON_GEN): % : %.py
                    $(QUIET_GEN)$(SHELL_PATH) generate-python.sh ./GIT-BUILD-OPTIONS "$<" "$@"
            else # NO_PYTHON
            $(SCRIPT_PYTHON_GEN): % : unimplemented.sh
                    $(QUIET_GEN) \
                    sed -e '1s|#!.*/sh|#!$(SHELL_PATH_SQ)|' \
                    -e 's|@REASON@|NO_PYTHON=$(NO_PYTHON)|g' \
                    unimplemented.sh >$@+ && \
                    chmod +x $@+ && \
                    mv $@+ $@
            endif # NO_PYTHON

            CONFIGURE_RECIPE = sed -e 's/@GIT_VERSION@/$(GIT_VERSION)/g' \
                                    configure.ac >configure.ac+ && \
                            autoconf -o configure configure.ac+ && \
                            $(RM) configure.ac+

            configure: configure.ac GIT-VERSION-FILE
                    $(QUIET_GEN)$(CONFIGURE_RECIPE)

            ifdef AUTOCONFIGURED
            # We avoid depending on 'configure' here, because it gets rebuilt
            # every time GIT-VERSION-FILE is modified, only to update the embedded
            # version number string, which config.status does not care about.  We
            # do want to recheck when the platform/environment detection logic
            # changes, hence this depends on configure.ac.
            config.status: configure.ac
                    $(QUIET_GEN)$(CONFIGURE_RECIPE) && \
                    if test -f config.status; then \
                    ./config.status --recheck; \
                    else \
                    ./configure; \
                    fi
            reconfigure config.mak.autogen: config.status
                    $(QUIET_GEN)./config.status
            .PHONY: reconfigure # This is a convenience target.
            endif

            XDIFF_OBJS += xdiff/xdiffi.o
            XDIFF_OBJS += xdiff/xemit.o
            XDIFF_OBJS += xdiff/xhistogram.o
            XDIFF_OBJS += xdiff/xmerge.o
            XDIFF_OBJS += xdiff/xpatience.o
            XDIFF_OBJS += xdiff/xprepare.o
            XDIFF_OBJS += xdiff/xutils.o
            .PHONY: xdiff-objs
            xdiff-objs: $(XDIFF_OBJS)

            REFTABLE_OBJS += reftable/basics.o
            REFTABLE_OBJS += reftable/error.o
            REFTABLE_OBJS += reftable/block.o
            REFTABLE_OBJS += reftable/blocksource.o
            REFTABLE_OBJS += reftable/iter.o
            REFTABLE_OBJS += reftable/merged.o
            REFTABLE_OBJS += reftable/pq.o
            REFTABLE_OBJS += reftable/reader.o
            REFTABLE_OBJS += reftable/record.o
            REFTABLE_OBJS += reftable/stack.o
            REFTABLE_OBJS += reftable/system.o
            REFTABLE_OBJS += reftable/tree.o
            REFTABLE_OBJS += reftable/writer.o

            TEST_OBJS := $(patsubst %$X,%.o,$(TEST_PROGRAMS)) $(patsubst %,t/helper/%,$(TEST_BUILTINS_OBJS))

            .PHONY: test-objs
            test-objs: $(TEST_OBJS)

            GIT_OBJS += $(LIB_OBJS)
            GIT_OBJS += $(BUILTIN_OBJS)
            GIT_OBJS += common-main.o
            GIT_OBJS += git.o
            .PHONY: git-objs
            git-objs: $(GIT_OBJS)

            SCALAR_OBJS += scalar.o
            .PHONY: scalar-objs
            scalar-objs: $(SCALAR_OBJS)

            OBJECTS += $(GIT_OBJS)
            OBJECTS += $(SCALAR_OBJS)
            OBJECTS += $(PROGRAM_OBJS)
            OBJECTS += $(TEST_OBJS)
            OBJECTS += $(XDIFF_OBJS)
            OBJECTS += $(FUZZ_OBJS)
            OBJECTS += $(REFTABLE_OBJS) $(REFTABLE_TEST_OBJS)
            OBJECTS += $(UNIT_TEST_OBJS)
            OBJECTS += $(CLAR_TEST_OBJS)
            OBJECTS += $(patsubst %,$(UNIT_TEST_DIR)/%.o,$(UNIT_TEST_PROGRAMS))

            ifndef NO_CURL
                    OBJECTS += http.o http-walker.o remote-curl.o
            endif

            .PHONY: objects
            objects: $(OBJECTS)

            dep_files := $(foreach f,$(OBJECTS),$(dir $f).depend/$(notdir $f).d)
            dep_dirs := $(addsuffix .depend,$(sort $(dir $(OBJECTS))))

            ifeq ($(COMPUTE_HEADER_DEPENDENCIES),yes)
            $(dep_dirs):
                    @mkdir -p $@

            missing_dep_dirs := $(filter-out $(wildcard $(dep_dirs)),$(dep_dirs))
            dep_file = $(dir $@).depend/$(notdir $@).d
            dep_args = -MF $(dep_file) -MQ $@ -MMD -MP
            endif

            ifneq ($(COMPUTE_HEADER_DEPENDENCIES),yes)
            missing_dep_dirs =
            dep_args =
            endif

            compdb_dir = compile_commands

            ifeq ($(GENERATE_COMPILATION_DATABASE),yes)
            missing_compdb_dir = $(compdb_dir)
            $(missing_compdb_dir):
                    @mkdir -p $@

            compdb_file = $(compdb_dir)/$(subst /,-,$@.json)
            compdb_args = -MJ $(compdb_file)
            else
            missing_compdb_dir =
            compdb_args =
            endif

            $(OBJECTS): %.o: %.c GIT-CFLAGS $(missing_dep_dirs) $(missing_compdb_dir)
                    $(QUIET_CC)$(CC) -o $*.o -c $(dep_args) $(compdb_args) $(ALL_CFLAGS) $(EXTRA_CPPFLAGS) $<

            %.s: %.c GIT-CFLAGS FORCE
                    $(QUIET_CC)$(CC) -o $@ -S $(ALL_CFLAGS) $(EXTRA_CPPFLAGS) $<

            ifdef USE_COMPUTED_HEADER_DEPENDENCIES
            # Take advantage of gcc's on-the-fly dependency generation
            # See <https://gcc.gnu.org/gcc-3.0/features.html>.
            dep_files_present := $(wildcard $(dep_files))
            ifneq ($(dep_files_present),)
            include $(dep_files_present)
            endif
            else
            $(OBJECTS): $(LIB_H) $(GENERATED_H)
            endif

            ifeq ($(GENERATE_COMPILATION_DATABASE),yes)
            all:: compile_commands.json
            compile_commands.json:
                    $(QUIET_GEN)sed -e '1s/^/[/' -e '$$s/,$$/]/' $(compdb_dir)/*.o.json > $@+
                    @if test -s $@+; then mv $@+ $@; else $(RM) $@+; fi
            endif

            exec-cmd.sp exec-cmd.s exec-cmd.o: GIT-PREFIX
            exec-cmd.sp exec-cmd.s exec-cmd.o: EXTRA_CPPFLAGS = \
                    '-DGIT_EXEC_PATH="$(gitexecdir_relative_SQ)"' \
                    '-DGIT_LOCALE_PATH="$(localedir_relative_SQ)"' \
                    '-DBINDIR="$(bindir_relative_SQ)"' \
                    '-DFALLBACK_RUNTIME_PREFIX="$(prefix_SQ)"'

            setup.sp setup.s setup.o: GIT-PREFIX
            setup.sp setup.s setup.o: EXTRA_CPPFLAGS = \
                    -DDEFAULT_GIT_TEMPLATE_DIR='"$(template_dir_SQ)"'

            config.sp config.s config.o: GIT-PREFIX
            config.sp config.s config.o: EXTRA_CPPFLAGS = \
                    -DETC_GITCONFIG='"$(ETC_GITCONFIG_SQ)"'

            attr.sp attr.s attr.o: GIT-PREFIX
            attr.sp attr.s attr.o: EXTRA_CPPFLAGS = \
                    -DETC_GITATTRIBUTES='"$(ETC_GITATTRIBUTES_SQ)"'

            gettext.sp gettext.s gettext.o: GIT-PREFIX
            gettext.sp gettext.s gettext.o: EXTRA_CPPFLAGS = \
                    -DGIT_LOCALE_PATH='"$(localedir_relative_SQ)"'

            http-push.sp http.sp http-walker.sp remote-curl.sp imap-send.sp: SP_EXTRA_FLAGS += \
                    -DCURL_DISABLE_TYPECHECK

            pack-revindex.sp: SP_EXTRA_FLAGS += -Wno-memcpy-max-count

            ifdef NO_EXPAT
            http-walker.sp http-walker.s http-walker.o: EXTRA_CPPFLAGS = -DNO_EXPAT
            endif

            ifdef NO_REGEX
            compat/regex/regex.sp compat/regex/regex.o: EXTRA_CPPFLAGS = \
                    -DGAWK -DNO_MBSUPPORT
            endif

            ifdef USE_NED_ALLOCATOR
            compat/nedmalloc/nedmalloc.sp compat/nedmalloc/nedmalloc.o: EXTRA_CPPFLAGS = \
                    -DNDEBUG -DREPLACE_SYSTEM_ALLOCATOR
            compat/nedmalloc/nedmalloc.sp: SP_EXTRA_FLAGS += -Wno-non-pointer-null
            endif

            headless-git.o: compat/win32/headless.c GIT-CFLAGS
                    $(QUIET_CC)$(CC) $(ALL_CFLAGS) $(COMPAT_CFLAGS) \
                            -fno-stack-protector -o $@ -c -Wall -Wwrite-strings $<

            headless-git$X: headless-git.o git.res GIT-LDFLAGS
                    $(QUIET_LINK)$(CC) $(ALL_CFLAGS) $(ALL_LDFLAGS) -mwindows -o $@ $< git.res

            git-%$X: %.o GIT-LDFLAGS $(GITLIBS)
                    $(QUIET_LINK)$(CC) $(ALL_CFLAGS) -o $@ $(ALL_LDFLAGS) $(filter %.o,$^) $(LIBS)

            git-imap-send$X: imap-send.o $(IMAP_SEND_BUILDDEPS) GIT-LDFLAGS $(GITLIBS)
                    $(QUIET_LINK)$(CC) $(ALL_CFLAGS) -o $@ $(ALL_LDFLAGS) $(filter %.o,$^) \
                            $(IMAP_SEND_LDFLAGS) $(LIBS)

            git-http-fetch$X: http.o http-walker.o http-fetch.o GIT-LDFLAGS $(GITLIBS)
                    $(QUIET_LINK)$(CC) $(ALL_CFLAGS) -o $@ $(ALL_LDFLAGS) $(filter %.o,$^) \
                            $(CURL_LIBCURL) $(LIBS)
            git-http-push$X: http.o http-push.o GIT-LDFLAGS $(GITLIBS)
                    $(QUIET_LINK)$(CC) $(ALL_CFLAGS) -o $@ $(ALL_LDFLAGS) $(filter %.o,$^) \
                            $(CURL_LIBCURL) $(EXPAT_LIBEXPAT) $(LIBS)

            $(REMOTE_CURL_ALIASES): $(REMOTE_CURL_PRIMARY)
                    $(QUIET_LNCP)$(RM) $@ && \
                    ln $< $@ 2>/dev/null || \
                    ln -s $< $@ 2>/dev/null || \
                    cp $< $@

            $(REMOTE_CURL_PRIMARY): remote-curl.o http.o http-walker.o GIT-LDFLAGS $(GITLIBS)
                    $(QUIET_LINK)$(CC) $(ALL_CFLAGS) -o $@ $(ALL_LDFLAGS) $(filter %.o,$^) \
                            $(CURL_LIBCURL) $(EXPAT_LIBEXPAT) $(LIBS)

            scalar$X: scalar.o GIT-LDFLAGS $(GITLIBS)
                    $(QUIET_LINK)$(CC) $(ALL_CFLAGS) -o $@ $(ALL_LDFLAGS) \
                            $(filter %.o,$^) $(LIBS)

            $(LIB_FILE): $(LIB_OBJS)
                    $(QUIET_AR)$(RM) $@ && $(AR) $(ARFLAGS) $@ $^

            $(XDIFF_LIB): $(XDIFF_OBJS)
                    $(QUIET_AR)$(RM) $@ && $(AR) $(ARFLAGS) $@ $^

            $(REFTABLE_LIB): $(REFTABLE_OBJS)
                    $(QUIET_AR)$(RM) $@ && $(AR) $(ARFLAGS) $@ $^

            export DEFAULT_EDITOR DEFAULT_PAGER

            Documentation/GIT-EXCLUDED-PROGRAMS: FORCE
                    @EXCLUDED='EXCLUDED_PROGRAMS := $(EXCLUDED_PROGRAMS)'; \
                    if test x"$$EXCLUDED" != \
                            x"`cat Documentation/GIT-EXCLUDED-PROGRAMS 2>/dev/null`" ; then \
                            echo >&2 "    * new documentation flags"; \
                            echo "$$EXCLUDED" >Documentation/GIT-EXCLUDED-PROGRAMS; \
                    fi

            .PHONY: doc man man-perl html info pdf
            doc: man-perl
                    $(MAKE) -C Documentation all

            man: man-perl
                    $(MAKE) -C Documentation man

            man-perl: perl/build/man/man3/Git.3pm

            html:
                    $(MAKE) -C Documentation html

            info:
                    $(MAKE) -C Documentation info

            pdf:
                    $(MAKE) -C Documentation pdf

            XGETTEXT_FLAGS = \
                    --force-po \
                    --add-comments=TRANSLATORS: \
                    --msgid-bugs-address="Git Mailing List <git@vger.kernel.org>" \
                    --package-name=Git
            XGETTEXT_FLAGS_C = $(XGETTEXT_FLAGS) --language=C \
                    --keyword=_ --keyword=N_ --keyword="Q_:1,2"
            XGETTEXT_FLAGS_SH = $(XGETTEXT_FLAGS) --language=Shell \
                    --keyword=gettextln --keyword=eval_gettextln
            XGETTEXT_FLAGS_PERL = $(XGETTEXT_FLAGS) --language=Perl \
                    --keyword=__ --keyword=N__ --keyword="__n:1,2"
            MSGMERGE_FLAGS = --add-location --backup=off --update
            LOCALIZED_C = $(sort $(FOUND_C_SOURCES) $(FOUND_H_SOURCES) $(GENERATED_H))
            LOCALIZED_SH = $(sort $(SCRIPT_SH) git-sh-setup.sh)
            LOCALIZED_PERL = $(sort $(SCRIPT_PERL))

            ifdef XGETTEXT_INCLUDE_TESTS
            LOCALIZED_C += t/t0200/test.c
            LOCALIZED_SH += t/t0200/test.sh
            LOCALIZED_PERL += t/t0200/test.perl
            endif

            ## We generate intermediate .build/pot/po/%.po files containing a
            ## extract of the translations we find in each file in the source
            ## tree. We will assemble them using msgcat to create the final
            ## "po/git.pot" file.
            LOCALIZED_ALL_GEN_PO =

            LOCALIZED_C_GEN_PO = $(LOCALIZED_C:%=.build/pot/po/%.po)
            LOCALIZED_ALL_GEN_PO += $(LOCALIZED_C_GEN_PO)

            LOCALIZED_SH_GEN_PO = $(LOCALIZED_SH:%=.build/pot/po/%.po)
            LOCALIZED_ALL_GEN_PO += $(LOCALIZED_SH_GEN_PO)

            LOCALIZED_PERL_GEN_PO = $(LOCALIZED_PERL:%=.build/pot/po/%.po)
            LOCALIZED_ALL_GEN_PO += $(LOCALIZED_PERL_GEN_PO)

            ## Gettext tools cannot work with our own custom PRItime type, so
            ## we replace PRItime with PRIuMAX.  We need to update this to
            ## PRIdMAX if we switch to a signed type later.
            $(LOCALIZED_C_GEN_PO): .build/pot/po/%.po: %
                    $(call mkdir_p_parent_template)
                    $(QUIET_XGETTEXT) \
                    if grep -q PRItime $<; then \
                            (\
                                    sed -e 's|PRItime|PRIuMAX|g' <$< \
                                            >.build/pot/po/$< && \
                                    cd .build/pot/po && \
                                    $(XGETTEXT) --omit-header \
                                            -o $(@:.build/pot/po/%=%) \
                                            $(XGETTEXT_FLAGS_C) $< && \
                                    rm $<; \
                            ); \
                    else \
                            $(XGETTEXT) --omit-header \
                                    -o $@ $(XGETTEXT_FLAGS_C) $<; \
                    fi

            $(LOCALIZED_SH_GEN_PO): .build/pot/po/%.po: %
                    $(call mkdir_p_parent_template)
                    $(QUIET_XGETTEXT)$(XGETTEXT) --omit-header \
                            -o$@ $(XGETTEXT_FLAGS_SH) $<

            $(LOCALIZED_PERL_GEN_PO): .build/pot/po/%.po: %
                    $(call mkdir_p_parent_template)
                    $(QUIET_XGETTEXT)$(XGETTEXT) --omit-header \
                            -o$@ $(XGETTEXT_FLAGS_PERL) $<

            define gen_pot_header
            $(XGETTEXT) $(XGETTEXT_FLAGS_C) \
                    -o - /dev/null | \
            sed -e 's|charset=CHARSET|charset=UTF-8|' \
            -e 's|\(Last-Translator: \)FULL NAME <.*>|\1make by the Makefile|' \
            -e 's|\(Language-Team: \)LANGUAGE <.*>|\1Git Mailing List <git@vger.kernel.org>|' \
            >$@ && \
            echo '"Plural-Forms: nplurals=INTEGER; plural=EXPRESSION;\\n"' >>$@
            endef

            .build/pot/git.header: $(LOCALIZED_ALL_GEN_PO)
                    $(call mkdir_p_parent_template)
                    $(QUIET_GEN)$(gen_pot_header)

            po/git.pot: .build/pot/git.header $(LOCALIZED_ALL_GEN_PO)
                    $(QUIET_GEN)$(MSGCAT) $^ >$@

            .PHONY: pot
            pot: po/git.pot

            define check_po_file_envvar
                    $(if $(PO_FILE), \
                            $(if $(filter po/%.po,$(PO_FILE)), , \
                                    $(error PO_FILE should match pattern: "po/%.po")), \
                            $(error PO_FILE is not defined))
            endef

            .PHONY: po-update
            po-update: po/git.pot
                    $(check_po_file_envvar)
                    @if test ! -e $(PO_FILE); then \
                            echo >&2 "error: $(PO_FILE) does not exist"; \
                            echo >&2 'To create an initial po file, use: "make po-init PO_FILE=po/XX.po"'; \
                            exit 1; \
                    fi
                    $(QUIET_MSGMERGE)$(MSGMERGE) $(MSGMERGE_FLAGS) $(PO_FILE) po/git.pot

            .PHONY: check-pot
            check-pot: $(LOCALIZED_ALL_GEN_PO)

            ### TODO FIXME: Translating everything in these files is a bad
            ### heuristic for "core", as we'll translate obscure error() messages
            ### along with commonly seen i18n messages. A better heuristic would
            ### be to e.g. use spatch to first remove error/die/warning
            ### etc. messages.
            LOCALIZED_C_CORE =
            LOCALIZED_C_CORE += builtin/checkout.c
            LOCALIZED_C_CORE += builtin/clone.c
            LOCALIZED_C_CORE += builtin/index-pack.c
            LOCALIZED_C_CORE += builtin/push.c
            LOCALIZED_C_CORE += builtin/reset.c
            LOCALIZED_C_CORE += remote.c
            LOCALIZED_C_CORE += wt-status.c

            LOCALIZED_C_CORE_GEN_PO = $(LOCALIZED_C_CORE:%=.build/pot/po/%.po)

            .build/pot/git-core.header: $(LOCALIZED_C_CORE_GEN_PO)
                    $(call mkdir_p_parent_template)
                    $(QUIET_GEN)$(gen_pot_header)

            po/git-core.pot: .build/pot/git-core.header $(LOCALIZED_C_CORE_GEN_PO)
                    $(QUIET_GEN)$(MSGCAT) $^ >$@

            .PHONY: po-init
            po-init: po/git-core.pot
                    $(check_po_file_envvar)
                    @if test -e $(PO_FILE); then \
                            echo >&2 "error: $(PO_FILE) exists already"; \
                            exit 1; \
                    fi
                    $(QUIET_MSGINIT)msginit \
                            --input=$< \
                            --output=$(PO_FILE) \
                            --no-translator \
                            --locale=$(PO_FILE:po/%.po=%)

            ## po/*.po files & their rules
            ifdef NO_GETTEXT
            POFILES :=
            MOFILES :=
            else
            POFILES := $(wildcard po/*.po)
            MOFILES := $(patsubst po/%.po,po/build/locale/%/LC_MESSAGES/git.mo,$(POFILES))

            all:: $(MOFILES)
            endif

            po/build/locale/%/LC_MESSAGES/git.mo: po/%.po
                    $(call mkdir_p_parent_template)
                    $(QUIET_MSGFMT)$(MSGFMT) -o $@ $<

            LIB_PERL := $(wildcard perl/Git.pm perl/Git/*.pm perl/Git/*/*.pm perl/Git/*/*/*.pm)
            LIB_PERL_GEN := $(patsubst perl/%.pm,perl/build/lib/%.pm,$(LIB_PERL))
            LIB_CPAN := $(wildcard perl/FromCPAN/*.pm perl/FromCPAN/*/*.pm)
            LIB_CPAN_GEN := $(patsubst perl/%.pm,perl/build/lib/%.pm,$(LIB_CPAN))

            ifndef NO_PERL
            all:: $(LIB_PERL_GEN)
            ifndef NO_PERL_CPAN_FALLBACKS
            all:: $(LIB_CPAN_GEN)
            endif
            NO_PERL_CPAN_FALLBACKS_SQ = $(subst ','\'',$(NO_PERL_CPAN_FALLBACKS))
            endif

            perl/build/lib/%.pm: perl/%.pm generate-perl.sh GIT-BUILD-OPTIONS GIT-VERSION-FILE GIT-PERL-DEFINES
                    $(call mkdir_p_parent_template)
                    $(QUIET_GEN)$(SHELL_PATH) generate-perl.sh ./GIT-BUILD-OPTIONS ./GIT-VERSION-FILE GIT-PERL-HEADER "$<" "$@"

            perl/build/man/man3/Git.3pm: perl/Git.pm
                    $(call mkdir_p_parent_template)
                    $(QUIET_GEN)pod2man $< $@

            $(ETAGS_TARGET): $(FOUND_SOURCE_FILES)
                    $(QUIET_GEN)$(RM) $@+ && \
                    echo $(FOUND_SOURCE_FILES) | xargs etags -a -o $@+ && \
                    mv $@+ $@

            tags: $(FOUND_SOURCE_FILES)
                    $(QUIET_GEN)$(RM) $@+ && \
                    echo $(FOUND_SOURCE_FILES) | xargs ctags -a -o $@+ && \
                    mv $@+ $@

            cscope.out: $(FOUND_SOURCE_FILES)
                    $(QUIET_GEN)$(RM) $@+ && \
                    echo $(FOUND_SOURCE_FILES) | xargs cscope -f$@+ -b && \
                    mv $@+ $@

            .PHONY: cscope
            cscope: cscope.out

            ### Detect prefix changes
            TRACK_PREFIX = $(bindir_SQ):$(gitexecdir_SQ):$(template_dir_SQ):$(prefix_SQ):\
                            $(localedir_SQ)

            GIT-PREFIX: FORCE
                    @FLAGS='$(TRACK_PREFIX)'; \
                    if test x"$$FLAGS" != x"`cat GIT-PREFIX 2>/dev/null`" ; then \
                            echo >&2 "    * new prefix flags"; \
                            echo "$$FLAGS" >GIT-PREFIX; \
                    fi

            TRACK_CFLAGS = $(CC):$(subst ','\'',$(ALL_CFLAGS)):$(USE_GETTEXT_SCHEME)

            GIT-CFLAGS: FORCE
                    @FLAGS='$(TRACK_CFLAGS)'; \
                    if test x"$$FLAGS" != x"`cat GIT-CFLAGS 2>/dev/null`" ; then \
                            echo >&2 "    * new build flags"; \
                            echo "$$FLAGS" >GIT-CFLAGS; \
                    fi

            TRACK_LDFLAGS = $(subst ','\'',$(ALL_LDFLAGS))

            GIT-LDFLAGS: FORCE
                    @FLAGS='$(TRACK_LDFLAGS)'; \
                    if test x"$$FLAGS" != x"`cat GIT-LDFLAGS 2>/dev/null`" ; then \
                            echo >&2 "    * new link flags"; \
                            echo "$$FLAGS" >GIT-LDFLAGS; \
                    fi

            ifdef RUNTIME_PREFIX
            RUNTIME_PREFIX_OPTION = true
            else
            RUNTIME_PREFIX_OPTION = false
            endif

            # We need to apply sq twice, once to protect from the shell
            # that runs GIT-BUILD-OPTIONS, and then again to protect it
            # and the first level quoting from the shell that runs "echo".
            GIT-BUILD-OPTIONS: FORCE
                    @sed \
                            -e "s!@BROKEN_PATH_FIX@!\'$(BROKEN_PATH_FIX)\'!" \
                            -e "s|@DIFF@|\'$(DIFF)\'|" \
                            -e "s|@FSMONITOR_DAEMON_BACKEND@|\'$(FSMONITOR_DAEMON_BACKEND)\'|" \
                            -e "s|@FSMONITOR_OS_SETTINGS@|\'$(FSMONITOR_OS_SETTINGS)\'|" \
                            -e "s|@GITWEBDIR@|\'$(gitwebdir_SQ)\'|" \
                            -e "s|@GIT_INTEROP_MAKE_OPTS@|\'$(GIT_INTEROP_MAKE_OPTS)\'|" \
                            -e "s|@GIT_PERF_LARGE_REPO@|\'$(GIT_PERF_LARGE_REPO)\'|" \
                            -e "s|@GIT_PERF_MAKE_COMMAND@|\'$(GIT_PERF_MAKE_COMMAND)\'|" \
                            -e "s|@GIT_PERF_MAKE_OPTS@|\'$(GIT_PERF_MAKE_OPTS)\'|" \
                            -e "s|@GIT_PERF_REPEAT_COUNT@|\'$(GIT_PERF_REPEAT_COUNT)\'|" \
                            -e "s|@GIT_PERF_REPO@|\'$(GIT_PERF_REPO)\'|" \
                            -e "s|@GIT_TEST_CMP@|\'$(GIT_TEST_CMP)\'|" \
                            -e "s|@GIT_TEST_CMP_USE_COPIED_CONTEXT@|\'$(GIT_TEST_CMP_USE_COPIED_CONTEXT)\'|" \
                            -e "s|@GIT_TEST_GITPERLLIB@|\'$(shell pwd)/perl/build/lib\'|" \
                            -e "s|@GIT_TEST_INDEX_VERSION@|\'$(GIT_TEST_INDEX_VERSION)\'|" \
                            -e "s|@GIT_TEST_MERGE_TOOLS_DIR@|\'$(shell pwd)/mergetools\'|" \
                            -e "s|@GIT_TEST_OPTS@|\'$(GIT_TEST_OPTS)\'|" \
                            -e "s|@GIT_TEST_PERL_FATAL_WARNINGS@|\'$(GIT_TEST_PERL_FATAL_WARNINGS)\'|" \
                            -e "s|@GIT_TEST_POPATH@|\'$(shell pwd)/po\'|" \
                            -e "s|@GIT_TEST_TEMPLATE_DIR@|\'$(shell pwd)/templates/blt\'|" \
                            -e "s|@GIT_TEST_TEXTDOMAINDIR@|\'$(shell pwd)/po/build/locale\'|" \
                            -e "s|@GIT_TEST_UTF8_LOCALE@|\'$(GIT_TEST_UTF8_LOCALE)\'|" \
                            -e "s|@LOCALEDIR@|\'$(localedir_SQ)\'|" \
                            -e "s|@NO_CURL@|\'$(NO_CURL)\'|" \
                            -e "s|@NO_EXPAT@|\'$(NO_EXPAT)\'|" \
                            -e "s|@NO_GETTEXT@|\'$(NO_GETTEXT)\'|" \
                            -e "s|@NO_GITWEB@|\'$(NO_GITWEB)\'|" \
                            -e "s|@NO_ICONV@|\'$(NO_ICONV)\'|" \
                            -e "s|@NO_PERL@|\'$(NO_PERL)\'|" \
                            -e "s|@NO_PERL_CPAN_FALLBACKS@|\'$(NO_PERL_CPAN_FALLBACKS_SQ)\'|" \
                            -e "s|@NO_PTHREADS@|\'$(NO_PTHREADS)\'|" \
                            -e "s|@NO_PYTHON@|\'$(NO_PYTHON)\'|" \
                            -e "s|@NO_REGEX@|\'$(NO_REGEX)\'|" \
                            -e "s|@NO_UNIX_SOCKETS@|\'$(NO_UNIX_SOCKETS)\'|" \
                            -e "s|@PAGER_ENV@|\'$(PAGER_ENV)\'|" \
                            -e "s|@PERL_LOCALEDIR@|\'$(perl_localedir_SQ)\'|" \
                            -e "s|@PERL_PATH@|\'$(PERL_PATH_SQ)\'|" \
                            -e "s|@PYTHON_PATH@|\'$(PYTHON_PATH_SQ)\'|" \
                            -e "s|@RUNTIME_PREFIX@|\'$(RUNTIME_PREFIX_OPTION)\'|" \
                            -e "s|@SANITIZE_ADDRESS@|\'$(SANITIZE_ADDRESS)\'|" \
                            -e "s|@SANITIZE_LEAK@|\'$(SANITIZE_LEAK)\'|" \
                            -e "s|@SHELL_PATH@|\'$(SHELL_PATH_SQ)\'|" \
                            -e "s|@TAR@|\'$(TAR)\'|" \
                            -e "s|@TEST_OUTPUT_DIRECTORY@|\'$(TEST_OUTPUT_DIRECTORY)\'|" \
                            -e "s|@TEST_SHELL_PATH@|\'$(TEST_SHELL_PATH_SQ)\'|" \
                            -e "s|@USE_GETTEXT_SCHEME@|\'$(USE_GETTEXT_SCHEME)\'|" \
                            -e "s|@USE_LIBPCRE2@|\'$(USE_LIBPCRE2)\'|" \
                            -e "s|@X@|\'$(X)\'|" \
                            GIT-BUILD-OPTIONS.in >$@+
                    @if grep -q '^[A-Z][A-Z_]*=@.*@$$' $@+; then echo "Unsubstituted build options in $@" >&2 && exit 1; fi
                    @if cmp $@+ $@ >/dev/null 2>&1; then $(RM) $@+; else mv $@+ $@; fi
                    @if test -f GIT-BUILD-DIR; then rm GIT-BUILD-DIR; fi

            ### Detect Python interpreter path changes
            ifndef NO_PYTHON
            TRACK_PYTHON = $(subst ','\'',-DPYTHON_PATH='$(PYTHON_PATH_SQ)')

            GIT-PYTHON-VARS: FORCE
                    @VARS='$(TRACK_PYTHON)'; \
                    if test x"$$VARS" != x"`cat $@ 2>/dev/null`" ; then \
                            echo >&2 "    * new Python interpreter location"; \
                            echo "$$VARS" >$@; \
                    fi
            endif

            test_bindir_programs := $(patsubst %,bin-wrappers/%,$(BINDIR_PROGRAMS_NEED_X) $(BINDIR_PROGRAMS_NO_X) $(TEST_PROGRAMS_NEED_X))

            all:: $(TEST_PROGRAMS) $(test_bindir_programs) $(UNIT_TEST_PROGS) $(CLAR_TEST_PROG)

            $(test_bindir_programs): bin-wrappers/%: bin-wrappers/wrap-for-bin.sh
                    $(QUIET_GEN)sed -e '1s|#!.*/sh|#!$(SHELL_PATH_SQ)|' \
                    -e 's|@BUILD_DIR@|$(shell pwd)|' \
                    -e 's|@GIT_TEXTDOMAINDIR@|$(shell pwd)/po/build/locale|' \
                    -e 's|@GITPERLLIB@|$(shell pwd)/perl/build/lib|' \
                    -e 's|@MERGE_TOOLS_DIR@|$(shell pwd)/mergetools|' \
                    -e 's|@TEMPLATE_DIR@|$(shell pwd)/templates/blt|' \
                    -e 's|@PROG@|$(shell pwd)/$(patsubst test-%,t/helper/test-%,$(@F))$(if $(filter-out $(BINDIR_PROGRAMS_NO_X),$(@F)),$(X),)|' < $< > $@ && \
                    chmod +x $@

            # GNU make supports exporting all variables by "export" without parameters.
            # However, the environment gets quite big, and some programs have problems
            # with that.

            export NO_SVN_TESTS
            export TEST_NO_MALLOC_CHECK

            ### Testing rules

            test: all
                    $(MAKE) -C t/ all

            perf: all
                    $(MAKE) -C t/perf/ all

            .PHONY: test perf

            .PRECIOUS: $(TEST_OBJS)

            t/helper/test-tool$X: $(patsubst %,t/helper/%,$(TEST_BUILTINS_OBJS)) $(UNIT_TEST_DIR)/test-lib.o

            t/helper/test-%$X: t/helper/test-%.o GIT-LDFLAGS $(GITLIBS)
                    $(QUIET_LINK)$(CC) $(ALL_CFLAGS) -o $@ $(ALL_LDFLAGS) $(filter %.o,$^) $(filter %.a,$^) $(LIBS)

            check-sha1:: t/helper/test-tool$X
                    t/helper/test-sha1.sh

            SP_SRC = $(filter-out $(THIRD_PARTY_SOURCES),$(patsubst %.o,%.c,$(OBJECTS)))
            SP_OBJ = $(patsubst %.c,%.sp,$(SP_SRC))

            $(SP_OBJ): %.sp: %.c %.o $(GENERATED_H)
                    $(QUIET_SP)cgcc -no-compile $(ALL_CFLAGS) $(EXTRA_CPPFLAGS) \
                            -Wsparse-error \
                            $(SPARSE_FLAGS) $(SP_EXTRA_FLAGS) $< && \
                    >$@

            .PHONY: sparse
            sparse: $(SP_OBJ)

            EXCEPT_HDRS := $(GENERATED_H) unicode-width.h compat/% xdiff/% $(UNIT_TEST_DIR)/clar/% $(UNIT_TEST_DIR)/clar/clar/%
            ifndef OPENSSL_SHA1
                    EXCEPT_HDRS += sha1/openssl.h
            endif
            ifndef OPENSSL_SHA256
                    EXCEPT_HDRS += sha256/openssl.h
            endif
            ifndef NETTLE_SHA256
                    EXCEPT_HDRS += sha256/nettle.h
            endif
            ifndef GCRYPT_SHA256
                    EXCEPT_HDRS += sha256/gcrypt.h
            endif
            CHK_HDRS = $(filter-out $(EXCEPT_HDRS),$(LIB_H))
            HCO = $(patsubst %.h,%.hco,$(CHK_HDRS))
            HCC = $(HCO:hco=hcc)

            %.hcc: %.h
                    @echo '#include "git-compat-util.h"' >$@
                    @echo '#include "$<"' >>$@

            $(HCO): %.hco: %.hcc $(GENERATED_H) FORCE
                    $(QUIET_HDR)$(CC) $(ALL_CFLAGS) -o /dev/null -c -xc $<

            .PHONY: hdr-check $(HCO)
            hdr-check: $(HCO)

            .PHONY: style
            style:
                    git clang-format --style file --diff --extensions c,h

            .PHONY: check
            check:
                    @if sparse; \
                    then \
                            echo >&2 "Use 'make sparse' instead"; \
                            $(MAKE) --no-print-directory sparse; \
                    else \
                            echo >&2 "Did you mean 'make test'?"; \
                            exit 1; \
                    fi

            COCCI_GEN_ALL = .build/contrib/coccinelle/ALL.cocci
            COCCI_GLOB = $(wildcard contrib/coccinelle/*.cocci)
            COCCI_RULES_TRACKED = $(COCCI_GLOB:%=.build/%)
            COCCI_RULES_TRACKED_NO_PENDING = $(filter-out %.pending.cocci,$(COCCI_RULES_TRACKED))
            COCCI_RULES =
            COCCI_RULES += $(COCCI_GEN_ALL)
            COCCI_RULES += $(COCCI_RULES_TRACKED)
            COCCI_NAMES =
            COCCI_NAMES += $(COCCI_RULES:.build/contrib/coccinelle/%.cocci=%)

            COCCICHECK_PENDING = $(filter %.pending.cocci,$(COCCI_RULES))
            COCCICHECK = $(filter-out $(COCCICHECK_PENDING),$(COCCI_RULES))

            COCCICHECK_PATCHES = $(COCCICHECK:%=%.patch)
            COCCICHECK_PATCHES_PENDING = $(COCCICHECK_PENDING:%=%.patch)

            COCCICHECK_PATCHES_INTREE = $(COCCICHECK_PATCHES:.build/%=%)
            COCCICHECK_PATCHES_PENDING_INTREE = $(COCCICHECK_PATCHES_PENDING:.build/%=%)

            # It's expensive to compute the many=many rules below, only eval them
            # on $(MAKECMDGOALS) that match these $(COCCI_RULES)
            COCCI_RULES_GLOB =
            COCCI_RULES_GLOB += cocci%
            COCCI_RULES_GLOB += .build/contrib/coccinelle/%
            COCCI_RULES_GLOB += $(COCCICHECK_PATCHES)
            COCCI_RULES_GLOB += $(COCCICHEC_PATCHES_PENDING)
            COCCI_RULES_GLOB += $(COCCICHECK_PATCHES_INTREE)
            COCCI_RULES_GLOB += $(COCCICHECK_PATCHES_PENDING_INTREE)
            COCCI_GOALS = $(filter $(COCCI_RULES_GLOB),$(MAKECMDGOALS))

            COCCI_TEST_RES = $(wildcard contrib/coccinelle/tests/*.res)

            $(COCCI_RULES_TRACKED): .build/% : %
                    $(call mkdir_p_parent_template)
                    $(QUIET_CP)cp $< $@

            .build/contrib/coccinelle/FOUND_H_SOURCES: $(FOUND_H_SOURCES)
                    $(call mkdir_p_parent_template)
                    $(QUIET_GEN) >$@

            $(COCCI_GEN_ALL): $(COCCI_RULES_TRACKED_NO_PENDING)
                    $(call mkdir_p_parent_template)
                    $(QUIET_SPATCH_CAT)cat $^ >$@

            ifeq ($(COMPUTE_HEADER_DEPENDENCIES),no)
            SPATCH_USE_O_DEPENDENCIES =
            endif
            define cocci-rule

            ## Rule for .build/$(1).patch/$(2); Params:
            # $(1) = e.g. ".build/contrib/coccinelle/free.cocci"
            # $(2) = e.g. "grep.c"
            # $(3) = e.g. "grep.o"
            COCCI_$(1:.build/contrib/coccinelle/%.cocci=%) += $(1).d/$(2).patch
            $(1).d/$(2).patch: GIT-SPATCH-DEFINES
            $(1).d/$(2).patch: $(if $(and $(SPATCH_USE_O_DEPENDENCIES),$(wildcard $(3))),$(3),.build/contrib/coccinelle/FOUND_H_SOURCES)
            $(1).d/$(2).patch: $(1)
            $(1).d/$(2).patch: $(1).d/%.patch : %
                    $$(call mkdir_p_parent_template)
                    $$(QUIET_SPATCH)if ! $$(SPATCH) $$(SPATCH_FLAGS) \
                            $$(SPATCH_INCLUDE_FLAGS) \
                            --sp-file $(1) --patch . $$< \
                            >$$@ 2>$$@.log; \
                    then \
                            echo "ERROR when applying '$(1)' to '$$<'; '$$@.log' follows:"; \
                            cat $$@.log; \
                            exit 1; \
                    fi
            endef

            define cocci-matrix

            $(foreach s,$(COCCI_SOURCES),$(call cocci-rule,$(c),$(s),$(s:%.c=%.o)))
            endef

            ifdef COCCI_GOALS
            $(eval $(foreach c,$(COCCI_RULES),$(call cocci-matrix,$(c))))
            endif

            define spatch-rule

            .build/contrib/coccinelle/$(1).cocci.patch: $$(COCCI_$(1))
                    $$(QUIET_SPATCH_CAT)cat $$^ >$$@ && \
                    if test -s $$@; \
                    then \
                            echo '    ' SPATCH result: $$@; \
                    fi
            contrib/coccinelle/$(1).cocci.patch: .build/contrib/coccinelle/$(1).cocci.patch
                    $$(QUIET_CP)cp $$< $$@

            endef

            ifdef COCCI_GOALS
            $(eval $(foreach n,$(COCCI_NAMES),$(call spatch-rule,$(n))))
            endif

            COCCI_TEST_RES_GEN = $(addprefix .build/,$(COCCI_TEST_RES))
            $(COCCI_TEST_RES_GEN): GIT-SPATCH-DEFINES
            $(COCCI_TEST_RES_GEN): .build/%.res : %.c
            $(COCCI_TEST_RES_GEN): .build/%.res : %.res
            ifdef SPATCH_CONCAT_COCCI
            $(COCCI_TEST_RES_GEN): .build/contrib/coccinelle/tests/%.res : $(COCCI_GEN_ALL)
            else
            $(COCCI_TEST_RES_GEN): .build/contrib/coccinelle/tests/%.res : contrib/coccinelle/%.cocci
            endif
                    $(call mkdir_p_parent_template)
                    $(QUIET_SPATCH_TEST)$(SPATCH) $(SPATCH_TEST_FLAGS) \
                            --very-quiet --no-show-diff \
                            --sp-file $< -o $@ \
                            $(@:.build/%.res=%.c) && \
                    cmp $(@:.build/%=%) $@ || \
                    git -P diff --no-index $(@:.build/%=%) $@ 2>/dev/null; \

            .PHONY: coccicheck-test
            coccicheck-test: $(COCCI_TEST_RES_GEN)

            coccicheck: coccicheck-test
            ifdef SPATCH_CONCAT_COCCI
            coccicheck: contrib/coccinelle/ALL.cocci.patch
            else
            coccicheck: $(COCCICHECK_PATCHES_INTREE)
            endif

            # See contrib/coccinelle/README
            coccicheck-pending: coccicheck-test
            coccicheck-pending: $(COCCICHECK_PATCHES_PENDING_INTREE)

            .PHONY: coccicheck coccicheck-pending

            # "Sub"-Makefiles, not really because they can't be run stand-alone,
            # only there to contain directory-specific rules and variables
            ## gitweb/Makefile inclusion:
            MAK_DIR_GITWEB = gitweb/
            include gitweb/Makefile

            .PHONY: gitweb
            gitweb: $(MAK_DIR_GITWEB_ALL)
            ifndef NO_GITWEB
            all:: gitweb
            endif

            ### Installation rules

            ifneq ($(filter /%,$(firstword $(template_dir))),)
            template_instdir = $(template_dir)
            else
            template_instdir = $(prefix)/$(template_dir)
            endif
            export template_instdir

            ifneq ($(filter /%,$(firstword $(gitexecdir))),)
            gitexec_instdir = $(gitexecdir)
            else
            gitexec_instdir = $(prefix)/$(gitexecdir)
            endif
            gitexec_instdir_SQ = $(subst ','\'',$(gitexec_instdir))
            export gitexec_instdir

            ifneq ($(filter /%,$(firstword $(mergetoolsdir))),)
            mergetools_instdir = $(mergetoolsdir)
            else
            mergetools_instdir = $(prefix)/$(mergetoolsdir)
            endif
            mergetools_instdir_SQ = $(subst ','\'',$(mergetools_instdir))

            install_bindir_xprograms := $(patsubst %,%$X,$(BINDIR_PROGRAMS_NEED_X))
            install_bindir_programs := $(install_bindir_xprograms) $(BINDIR_PROGRAMS_NO_X)

            .PHONY: profile-install profile-fast-install
            profile-install: profile
                    $(MAKE) install

            profile-fast-install: profile-fast
                    $(MAKE) install

            INSTALL_STRIP =

            install: all
                    $(INSTALL) -d -m 755 '$(DESTDIR_SQ)$(bindir_SQ)'
                    $(INSTALL) -d -m 755 '$(DESTDIR_SQ)$(gitexec_instdir_SQ)'
                    $(INSTALL) $(INSTALL_STRIP) $(PROGRAMS) '$(DESTDIR_SQ)$(gitexec_instdir_SQ)'
                    $(INSTALL) $(SCRIPTS) '$(DESTDIR_SQ)$(gitexec_instdir_SQ)'
                    $(INSTALL) -m 644 $(SCRIPT_LIB) '$(DESTDIR_SQ)$(gitexec_instdir_SQ)'
                    $(INSTALL) $(INSTALL_STRIP) $(install_bindir_xprograms) '$(DESTDIR_SQ)$(bindir_SQ)'
                    $(INSTALL) $(BINDIR_PROGRAMS_NO_X) '$(DESTDIR_SQ)$(bindir_SQ)'

            ifdef MSVC
                    # We DO NOT install the individual foo.o.pdb files because they
                    # have already been rolled up into the exe's pdb file.
                    # We DO NOT have pdb files for the builtin commands (like git-status.exe)
                    # because it is just a copy/hardlink of git.exe, rather than a unique binary.
                    $(INSTALL) $(patsubst %.exe,%.pdb,$(filter-out $(BUILT_INS),$(patsubst %,%$X,$(BINDIR_PROGRAMS_NEED_X)))) '$(DESTDIR_SQ)$(bindir_SQ)'
                    $(INSTALL) $(patsubst %.exe,%.pdb,$(filter-out $(BUILT_INS) $(REMOTE_CURL_ALIASES),$(PROGRAMS))) '$(DESTDIR_SQ)$(gitexec_instdir_SQ)'
            ifndef DEBUG
                    $(INSTALL) $(vcpkg_rel_bin)/*.dll '$(DESTDIR_SQ)$(bindir_SQ)'
                    $(INSTALL) $(vcpkg_rel_bin)/*.pdb '$(DESTDIR_SQ)$(bindir_SQ)'
            else
                    $(INSTALL) $(vcpkg_dbg_bin)/*.dll '$(DESTDIR_SQ)$(bindir_SQ)'
                    $(INSTALL) $(vcpkg_dbg_bin)/*.pdb '$(DESTDIR_SQ)$(bindir_SQ)'
            endif
            endif
                    $(MAKE) -C templates DESTDIR='$(DESTDIR_SQ)' install
                    $(INSTALL) -d -m 755 '$(DESTDIR_SQ)$(mergetools_instdir_SQ)'
                    $(INSTALL) -m 644 mergetools/* '$(DESTDIR_SQ)$(mergetools_instdir_SQ)'
            ifndef NO_GETTEXT
                    $(INSTALL) -d -m 755 '$(DESTDIR_SQ)$(localedir_SQ)'
                    (cd po/build/locale && $(TAR) cf - .) | \
                    (cd '$(DESTDIR_SQ)$(localedir_SQ)' && umask 022 && $(TAR) xof -)
            endif
            ifndef NO_PERL
                    $(INSTALL) -d -m 755 '$(DESTDIR_SQ)$(perllibdir_SQ)'
                    (cd perl/build/lib && $(TAR) cf - .) | \
                    (cd '$(DESTDIR_SQ)$(perllibdir_SQ)' && umask 022 && $(TAR) xof -)
            endif
            ifndef NO_TCLTK
                    $(MAKE) -C gitk-git install
                    $(MAKE) -C git-gui gitexecdir='$(gitexec_instdir_SQ)' install
            endif
            ifneq (,$X)
                    $(foreach p,$(patsubst %$X,%,$(filter %$X,$(ALL_COMMANDS_TO_INSTALL) $(OTHER_PROGRAMS))), test '$(DESTDIR_SQ)$(gitexec_instdir_SQ)/$p' -ef '$(DESTDIR_SQ)$(gitexec_instdir_SQ)/$p$X' || $(RM) '$(DESTDIR_SQ)$(gitexec_instdir_SQ)/$p';)
            endif

                    bindir=$$(cd '$(DESTDIR_SQ)$(bindir_SQ)' && pwd) && \
                    execdir=$$(cd '$(DESTDIR_SQ)$(gitexec_instdir_SQ)' && pwd) && \
                    destdir_from_execdir_SQ=$$(echo '$(gitexecdir_relative_SQ)' | sed -e 's|[^/][^/]*|..|g') && \
                    { test "$$bindir/" = "$$execdir/" || \
                    for p in $(OTHER_PROGRAMS) $(filter $(install_bindir_programs),$(ALL_PROGRAMS)); do \
                            $(RM) "$$execdir/$$p" && \
                            test -n "$(INSTALL_SYMLINKS)" && \
                            ln -s "$$destdir_from_execdir_SQ/$(bindir_relative_SQ)/$$p" "$$execdir/$$p" || \
                            { test -z "$(NO_INSTALL_HARDLINKS)$(NO_CROSS_DIRECTORY_HARDLINKS)" && \
                            ln "$$bindir/$$p" "$$execdir/$$p" 2>/dev/null || \
                            cp "$$bindir/$$p" "$$execdir/$$p" || exit; } \
                    done; \
                    } && \
                    for p in $(filter $(install_bindir_programs),$(BUILT_INS)); do \
                            $(RM) "$$bindir/$$p" && \
                            test -n "$(INSTALL_SYMLINKS)" && \
                            ln -s "git$X" "$$bindir/$$p" || \
                            { test -z "$(NO_INSTALL_HARDLINKS)" && \
                            ln "$$bindir/git$X" "$$bindir/$$p" 2>/dev/null || \
                            ln -s "git$X" "$$bindir/$$p" 2>/dev/null || \
                            cp "$$bindir/git$X" "$$bindir/$$p" || exit; }; \
                    done && \
                    for p in $(BUILT_INS); do \
                            $(RM) "$$execdir/$$p" && \
                            if test -z "$(SKIP_DASHED_BUILT_INS)"; \
                            then \
                                    test -n "$(INSTALL_SYMLINKS)" && \
                                    ln -s "$$destdir_from_execdir_SQ/$(bindir_relative_SQ)/git$X" "$$execdir/$$p" || \
                                    { test -z "$(NO_INSTALL_HARDLINKS)" && \
                                    ln "$$execdir/git$X" "$$execdir/$$p" 2>/dev/null || \
                                    ln -s "git$X" "$$execdir/$$p" 2>/dev/null || \
                                    cp "$$execdir/git$X" "$$execdir/$$p" || exit; }; \
                            fi \
                    done && \
                    remote_curl_aliases="$(REMOTE_CURL_ALIASES)" && \
                    for p in $$remote_curl_aliases; do \
                            $(RM) "$$execdir/$$p" && \
                            test -n "$(INSTALL_SYMLINKS)" && \
                            ln -s "git-remote-http$X" "$$execdir/$$p" || \
                            { test -z "$(NO_INSTALL_HARDLINKS)" && \
                            ln "$$execdir/git-remote-http$X" "$$execdir/$$p" 2>/dev/null || \
                            ln -s "git-remote-http$X" "$$execdir/$$p" 2>/dev/null || \
                            cp "$$execdir/git-remote-http$X" "$$execdir/$$p" || exit; } \
                    done

            .PHONY: install-doc install-man install-man-perl install-html install-info install-pdf
            .PHONY: quick-install-doc quick-install-man quick-install-html

            install-doc: install-man-perl
                    $(MAKE) -C Documentation install

            install-man: install-man-perl
                    $(MAKE) -C Documentation install-man

            install-man-perl: man-perl
                    $(INSTALL) -d -m 755 '$(DESTDIR_SQ)$(mandir_SQ)/man3'
                    (cd perl/build/man/man3 && $(TAR) cf - .) | \
                    (cd '$(DESTDIR_SQ)$(mandir_SQ)/man3' && umask 022 && $(TAR) xof -)

            install-html:
                    $(MAKE) -C Documentation install-html

            install-info:
                    $(MAKE) -C Documentation install-info

            install-pdf:
                    $(MAKE) -C Documentation install-pdf

            quick-install-doc:
                    $(MAKE) -C Documentation quick-install

            quick-install-man:
                    $(MAKE) -C Documentation quick-install-man

            quick-install-html:
                    $(MAKE) -C Documentation quick-install-html



            ### Maintainer's dist rules

            GIT_TARNAME = git-$(GIT_VERSION)
            GIT_ARCHIVE_EXTRA_FILES = \
                    --prefix=$(GIT_TARNAME)/ \
                    --add-file=configure \
                    --add-file=.dist-tmp-dir/version \
                    --prefix=$(GIT_TARNAME)/git-gui/ \
                    --add-file=.dist-tmp-dir/git-gui/version
            ifdef DC_SHA1_SUBMODULE
            GIT_ARCHIVE_EXTRA_FILES += \
                    --prefix=$(GIT_TARNAME)/sha1collisiondetection/ \
                    --add-file=sha1collisiondetection/LICENSE.txt \
                    --prefix=$(GIT_TARNAME)/sha1collisiondetection/lib/ \
                    --add-file=sha1collisiondetection/lib/sha1.c \
                    --add-file=sha1collisiondetection/lib/sha1.h \
                    --add-file=sha1collisiondetection/lib/ubc_check.c \
                    --add-file=sha1collisiondetection/lib/ubc_check.h
            endif
            dist: git-archive$(X) configure
                    @$(RM) -r .dist-tmp-dir
                    @mkdir .dist-tmp-dir
                    @echo $(GIT_VERSION) > .dist-tmp-dir/version
                    @$(MAKE) -C git-gui TARDIR=../.dist-tmp-dir/git-gui dist-version
                    ./git-archive --format=tar \
                            $(GIT_ARCHIVE_EXTRA_FILES) \
                            --prefix=$(GIT_TARNAME)/ HEAD^{tree} > $(GIT_TARNAME).tar
                    @$(RM) -r .dist-tmp-dir
                    gzip -f -9 $(GIT_TARNAME).tar

            rpm::
                    @echo >&2 "Use distro packaged sources to run rpmbuild"
                    @false
            .PHONY: rpm

            ifneq ($(INCLUDE_DLLS_IN_ARTIFACTS),)
            OTHER_PROGRAMS += $(shell echo *.dll t/helper/*.dll t/unit-tests/bin/*.dll)
            endif

            artifacts-tar:: $(ALL_COMMANDS_TO_INSTALL) $(SCRIPT_LIB) $(OTHER_PROGRAMS) \
                            GIT-BUILD-OPTIONS $(TEST_PROGRAMS) $(test_bindir_programs) \
                            $(UNIT_TEST_PROGS) $(CLAR_TEST_PROG) $(MOFILES)
                    $(QUIET_SUBDIR0)templates $(QUIET_SUBDIR1) \
                            SHELL_PATH='$(SHELL_PATH_SQ)' PERL_PATH='$(PERL_PATH_SQ)'
                    test -n "$(ARTIFACTS_DIRECTORY)"
                    mkdir -p "$(ARTIFACTS_DIRECTORY)"
                    $(TAR) czf "$(ARTIFACTS_DIRECTORY)/artifacts.tar.gz" $^ templates/blt/
            .PHONY: artifacts-tar

            htmldocs = git-htmldocs-$(GIT_VERSION)
            manpages = git-manpages-$(GIT_VERSION)
            .PHONY: dist-doc distclean
            dist-doc: git$X
                    $(RM) -r .doc-tmp-dir
                    mkdir .doc-tmp-dir
                    $(MAKE) -C Documentation WEBDOC_DEST=../.doc-tmp-dir install-webdoc
                    ./git -C .doc-tmp-dir init
                    ./git -C .doc-tmp-dir add .
                    ./git -C .doc-tmp-dir commit -m htmldocs
                    ./git -C .doc-tmp-dir archive --format=tar --prefix=./ HEAD^{tree} \
                            > $(htmldocs).tar
                    gzip -n -9 -f $(htmldocs).tar
                    :
                    $(RM) -r .doc-tmp-dir
                    mkdir -p .doc-tmp-dir/man1 .doc-tmp-dir/man5 .doc-tmp-dir/man7
                    $(MAKE) -C Documentation DESTDIR=./ \
                            man1dir=../.doc-tmp-dir/man1 \
                            man5dir=../.doc-tmp-dir/man5 \
                            man7dir=../.doc-tmp-dir/man7 \
                            install
                    ./git -C .doc-tmp-dir init
                    ./git -C .doc-tmp-dir add .
                    ./git -C .doc-tmp-dir commit -m manpages
                    ./git -C .doc-tmp-dir archive --format=tar --prefix=./ HEAD^{tree} \
                            > $(manpages).tar
                    gzip -n -9 -f $(manpages).tar
                    $(RM) -r .doc-tmp-dir

            ### Cleaning rules

            distclean: clean
                    $(RM) configure
                    $(RM) config.log config.status config.cache
                    $(RM) config.mak.autogen config.mak.append
                    $(RM) -r autom4te.cache

            profile-clean:
                    $(RM) $(addsuffix *.gcda,$(addprefix $(PROFILE_DIR)/, $(object_dirs)))
                    $(RM) $(addsuffix *.gcno,$(addprefix $(PROFILE_DIR)/, $(object_dirs)))

            cocciclean:
                    $(RM) GIT-SPATCH-DEFINES
                    $(RM) -r .build/contrib/coccinelle
                    $(RM) contrib/coccinelle/*.cocci.patch

            clean: profile-clean coverage-clean cocciclean
                    $(RM) -r .build $(UNIT_TEST_BIN)
                    $(RM) GIT-TEST-SUITES
                    $(RM) po/git.pot po/git-core.pot
                    $(RM) git.rc git.res
                    $(RM) $(OBJECTS)
                    $(RM) headless-git.o
                    $(RM) $(LIB_FILE) $(XDIFF_LIB) $(REFTABLE_LIB)
                    $(RM) $(ALL_PROGRAMS) $(SCRIPT_LIB) $(BUILT_INS) $(OTHER_PROGRAMS)
                    $(RM) $(TEST_PROGRAMS)
                    $(RM) $(FUZZ_PROGRAMS)
                    $(RM) $(SP_OBJ)
                    $(RM) $(HCC)
                    $(RM) version-def.h
                    $(RM) -r $(dep_dirs) $(compdb_dir) compile_commands.json
                    $(RM) $(test_bindir_programs)
                    $(RM) -r po/build/
                    $(RM) *.pyc *.pyo */*.pyc */*.pyo $(GENERATED_H) $(ETAGS_TARGET) tags cscope*
                    $(RM) -r .dist-tmp-dir .doc-tmp-dir
                    $(RM) $(GIT_TARNAME).tar.gz
                    $(RM) $(htmldocs).tar.gz $(manpages).tar.gz
                    $(MAKE) -C Documentation/ clean
                    $(RM) Documentation/GIT-EXCLUDED-PROGRAMS
            ifndef NO_PERL
                    $(RM) -r perl/build/
            endif
                    $(MAKE) -C templates/ clean
                    $(MAKE) -C t/ clean
            ifndef NO_TCLTK
                    $(MAKE) -C gitk-git clean
                    $(MAKE) -C git-gui clean
            endif
                    $(RM) GIT-VERSION-FILE GIT-CFLAGS GIT-LDFLAGS GIT-BUILD-OPTIONS
                    $(RM) GIT-USER-AGENT GIT-PREFIX
                    $(RM) GIT-SCRIPT-DEFINES GIT-PERL-DEFINES GIT-PERL-HEADER GIT-PYTHON-VARS
            ifdef MSVC
                    $(RM) $(patsubst %.o,%.o.pdb,$(OBJECTS))
                    $(RM) headless-git.o.pdb
                    $(RM) $(patsubst %.exe,%.pdb,$(OTHER_PROGRAMS))
                    $(RM) $(patsubst %.exe,%.iobj,$(OTHER_PROGRAMS))
                    $(RM) $(patsubst %.exe,%.ipdb,$(OTHER_PROGRAMS))
                    $(RM) $(patsubst %.exe,%.pdb,$(PROGRAMS))
                    $(RM) $(patsubst %.exe,%.iobj,$(PROGRAMS))
                    $(RM) $(patsubst %.exe,%.ipdb,$(PROGRAMS))
                    $(RM) $(patsubst %.exe,%.pdb,$(TEST_PROGRAMS))
                    $(RM) $(patsubst %.exe,%.iobj,$(TEST_PROGRAMS))
                    $(RM) $(patsubst %.exe,%.ipdb,$(TEST_PROGRAMS))
                    $(RM) compat/vcbuild/MSVC-DEFS-GEN
            endif

            .PHONY: all install profile-clean cocciclean clean strip
            .PHONY: shell_compatibility_test please_set_SHELL_PATH_to_a_more_modern_shell
            .PHONY: FORCE

            ### Check documentation
            #
            ALL_COMMANDS = $(ALL_COMMANDS_TO_INSTALL) $(SCRIPT_LIB)
            ALL_COMMANDS += git
            ALL_COMMANDS += git-citool
            ALL_COMMANDS += git-gui
            ALL_COMMANDS += gitk
            ALL_COMMANDS += gitweb
            ALL_COMMANDS += scalar

            .PHONY: check-docs
            check-docs::
                    $(MAKE) -C Documentation lint-docs

            ### Make sure built-ins do not have dups and listed in git.c
            #
            check-builtins::
                    ./check-builtins.sh

            ### Test suite coverage testing
            #
            .PHONY: coverage coverage-clean coverage-compile coverage-test coverage-report
            .PHONY: coverage-untested-functions cover_db cover_db_html
            .PHONY: coverage-clean-results

            coverage:
                    $(MAKE) coverage-test
                    $(MAKE) coverage-untested-functions

            object_dirs := $(sort $(dir $(OBJECTS)))
            coverage-clean-results:
                    $(RM) $(addsuffix *.gcov,$(object_dirs))
                    $(RM) $(addsuffix *.gcda,$(object_dirs))
                    $(RM) coverage-untested-functions
                    $(RM) -r cover_db/
                    $(RM) -r cover_db_html/
                    $(RM) coverage-test.made

            coverage-clean: coverage-clean-results
                    $(RM) $(addsuffix *.gcno,$(object_dirs))

            COVERAGE_CFLAGS = $(CFLAGS) -O0 -ftest-coverage -fprofile-arcs
            COVERAGE_LDFLAGS = $(CFLAGS)  -O0 -lgcov
            GCOVFLAGS = --preserve-paths --branch-probabilities --all-blocks

            coverage-compile:
                    $(MAKE) CFLAGS="$(COVERAGE_CFLAGS)" LDFLAGS="$(COVERAGE_LDFLAGS)" all

            coverage-test: coverage-clean-results coverage-compile
                    $(MAKE) CFLAGS="$(COVERAGE_CFLAGS)" LDFLAGS="$(COVERAGE_LDFLAGS)" \
                            DEFAULT_TEST_TARGET=test -j1 test
                    touch coverage-test.made

            coverage-test.made:
                    $(MAKE) coverage-test

            coverage-prove: coverage-clean-results coverage-compile
                    $(MAKE) CFLAGS="$(COVERAGE_CFLAGS)" LDFLAGS="$(COVERAGE_LDFLAGS)" \
                            DEFAULT_TEST_TARGET=prove GIT_PROVE_OPTS="$(GIT_PROVE_OPTS) -j1" \
                            -j1 test

            coverage-report: coverage-test.made
                    $(QUIET_GCOV)for dir in $(object_dirs); do \
                            $(GCOV) $(GCOVFLAGS) --object-directory=$$dir $$dir*.c || exit; \
                    done

            coverage-untested-functions: coverage-report
                    grep '^function.*called 0 ' *.c.gcov \
                            | sed -e 's/\([^:]*\)\.gcov: *function \([^ ]*\) called.*/\1: \2/' \
                            > coverage-untested-functions

            cover_db: coverage-report
                    gcov2perl -db cover_db *.gcov

            cover_db_html: cover_db
                    cover -report html -outputdir cover_db_html cover_db


            ### Fuzz testing
            #
            # Building fuzz targets generally requires a special set of compiler flags that
            # are not necessarily appropriate for general builds, and that vary greatly
            # depending on the compiler version used.
            #
            # An example command to build against libFuzzer from LLVM 11.0.0:
            #
            # make CC=clang FUZZ_CXX=clang++ \
            #      CFLAGS="-fsanitize=fuzzer-no-link,address" \
            #      LIB_FUZZING_ENGINE="-fsanitize=fuzzer,address" \
            #      fuzz-all
            #
            FUZZ_CXX ?= $(CC)
            FUZZ_CXXFLAGS ?= $(ALL_CFLAGS)

            .PHONY: fuzz-all
            fuzz-all: $(FUZZ_PROGRAMS)

            $(FUZZ_PROGRAMS): %: %.o oss-fuzz/dummy-cmd-main.o $(GITLIBS) GIT-LDFLAGS
                    $(QUIET_LINK)$(FUZZ_CXX) $(FUZZ_CXXFLAGS) -o $@ $(ALL_LDFLAGS) \
                            -Wl,--allow-multiple-definition \
                            $(filter %.o,$^) $(filter %.a,$^) $(LIBS) $(LIB_FUZZING_ENGINE)

            $(UNIT_TEST_PROGS): $(UNIT_TEST_BIN)/%$X: $(UNIT_TEST_DIR)/%.o $(UNIT_TEST_OBJS) \
                    $(GITLIBS) GIT-LDFLAGS
                    $(call mkdir_p_parent_template)
                    $(QUIET_LINK)$(CC) $(ALL_CFLAGS) -o $@ $(ALL_LDFLAGS) \
                            $(filter %.o,$^) $(filter %.a,$^) $(LIBS)

            GIT-TEST-SUITES: FORCE
                    @FLAGS='$(CLAR_TEST_SUITES)'; \
                    if test x"$$FLAGS" != x"`cat GIT-TEST-SUITES 2>/dev/null`" ; then \
                            echo >&2 "    * new test suites"; \
                            echo "$$FLAGS" >GIT-TEST-SUITES; \
                    fi

            $(UNIT_TEST_DIR)/clar-decls.h: $(patsubst %,$(UNIT_TEST_DIR)/%.c,$(CLAR_TEST_SUITES)) $(UNIT_TEST_DIR)/generate-clar-decls.sh GIT-TEST-SUITES
                    $(QUIET_GEN)$(SHELL_PATH) $(UNIT_TEST_DIR)/generate-clar-decls.sh "$@" $(filter %.c,$^)
            $(UNIT_TEST_DIR)/clar.suite: $(UNIT_TEST_DIR)/clar-decls.h $(UNIT_TEST_DIR)/generate-clar-suites.sh
                    $(QUIET_GEN)$(SHELL_PATH) $(UNIT_TEST_DIR)/generate-clar-suites.sh $< $(UNIT_TEST_DIR)/clar.suite
            $(UNIT_TEST_DIR)/clar/clar.o: $(UNIT_TEST_DIR)/clar.suite
            $(CLAR_TEST_OBJS): $(UNIT_TEST_DIR)/clar-decls.h
            $(CLAR_TEST_OBJS): EXTRA_CPPFLAGS = -I$(UNIT_TEST_DIR)
            $(CLAR_TEST_PROG): $(UNIT_TEST_DIR)/clar.suite $(CLAR_TEST_OBJS) $(GITLIBS) GIT-LDFLAGS
                    $(call mkdir_p_parent_template)
                    $(QUIET_LINK)$(CC) $(ALL_CFLAGS) -o $@ $(ALL_LDFLAGS) $(filter %.o,$^) $(LIBS)

            .PHONY: build-unit-tests unit-tests
            build-unit-tests: $(UNIT_TEST_PROGS) $(CLAR_TEST_PROG)
            unit-tests: $(UNIT_TEST_PROGS) $(CLAR_TEST_PROG) t/helper/test-tool$X
                    $(MAKE) -C t/ unit-tests
    """,

    "Patch":
    """
    diff --git a/Makefile b/Makefile
    index 97e8385b66..08ab16ee92 100644
    --- a/Makefile
    +++ b/Makefile
    @@ -20,6 +20,8 @@ include shared.mak
     #
     # Define SHELL_PATH to a POSIX shell if your /bin/sh is broken.
     #
    +# Define SHELL_PATH_FOR_SCRIPTS to a POSIX shell if your /bin/sh is broken.
    +#
     # Define SANE_TOOL_PATH to a colon-separated list of paths to prepend
     # to PATH if your tools in /usr/bin are broken.
     #
    @@ -215,6 +217,8 @@ include shared.mak
     #
     # Define PERL_PATH to the path of your Perl binary (usually /usr/bin/perl).
     #
    +# Define PERL_PATH_FOR_SCRIPTS to a Perl binary if your /usr/bin/perl is broken.
    +#
     # Define NO_PERL if you do not want Perl scripts or libraries at all.
     #
     # Define NO_PERL_CPAN_FALLBACKS if you do not want to install bundled
    @@ -896,15 +900,22 @@ BINDIR_PROGRAMS_NO_X += git-cvsserver
     ifndef SHELL_PATH
         SHELL_PATH = /bin/sh
     endif
    +ifndef SHELL_PATH_FOR_SCRIPTS
    +   SHELL_PATH_FOR_SCRIPTS = /bin/sh
    +endif
     ifndef PERL_PATH
         PERL_PATH = /usr/bin/perl
     endif
    +ifndef PERL_PATH_FOR_SCRIPTS
    +   PERL_PATH_FOR_SCRIPTS = /usr/bin/perl
    +endif
     ifndef PYTHON_PATH
         PYTHON_PATH = /usr/bin/python
     endif

     export PERL_PATH
     export PYTHON_PATH
    +export PERL_PATH_FOR_SCRIPTS

     TEST_SHELL_PATH = $(SHELL_PATH)

    @@ -1372,7 +1383,7 @@ UNIT_TEST_OBJS += $(UNIT_TEST_DIR)/lib-reftable.o

     # xdiff and reftable libs may in turn depend on what is in libgit.a
     GITLIBS = common-main.o $(LIB_FILE) $(XDIFF_LIB) $(REFTABLE_LIB) $(LIB_FILE)
    -EXTLIBS =
    +EXTLIBS = $(ZOPEN_EXTRA_LIBS)

     GIT_USER_AGENT = git/$(GIT_VERSION)

    @@ -2298,9 +2309,10 @@ perllibdir_relative_SQ = $(subst ','\'',$(perllibdir_relative))
     gitwebdir_SQ = $(subst ','\'',$(gitwebdir))
     gitwebstaticdir_SQ = $(subst ','\'',$(gitwebstaticdir))

    -SHELL_PATH_SQ = $(subst ','\'',$(SHELL_PATH))
    +SHELL_PATH_SQ = $(subst ','\'',$(SHELL_PATH_FOR_SCRIPTS))
     TEST_SHELL_PATH_SQ = $(subst ','\'',$(TEST_SHELL_PATH))
     PERL_PATH_SQ = $(subst ','\'',$(PERL_PATH))
    +PERL_PATH_FOR_SCRIPTS_SQ = $(subst ','\'',$(PERL_PATH_FOR_SCRIPTS))
     PYTHON_PATH_SQ = $(subst ','\'',$(PYTHON_PATH))
     TCLTK_PATH_SQ = $(subst ','\'',$(TCLTK_PATH))
     DIFF_SQ = $(subst ','\'',$(DIFF))
    @@ -2543,7 +2555,7 @@ hook-list.h: generate-hooklist.sh Documentation/githooks.txt

     SCRIPT_DEFINES = $(SHELL_PATH_SQ):$(DIFF_SQ):\
         $(localedir_SQ):$(USE_GETTEXT_SCHEME):$(SANE_TOOL_PATH_SQ):\
    -   $(gitwebdir_SQ):$(PERL_PATH_SQ):$(PAGER_ENV):\
    +   $(gitwebdir_SQ):$(PERL_PATH_FOR_SCRIPTS_SQ):$(PAGER_ENV):\
         $(perllibdir_SQ)
     GIT-SCRIPT-DEFINES: FORCE
         @FLAGS='$(SCRIPT_DEFINES)'; \
    @@ -2794,7 +2806,7 @@ endif

     exec-cmd.sp exec-cmd.s exec-cmd.o: GIT-PREFIX
     exec-cmd.sp exec-cmd.s exec-cmd.o: EXTRA_CPPFLAGS = \
    -   '-DGIT_EXEC_PATH="$(gitexecdir_SQ)"' \
    +   '-DGIT_EXEC_PATH="$(gitexecdir_relative_SQ)"' \
         '-DGIT_LOCALE_PATH="$(localedir_relative_SQ)"' \
         '-DBINDIR="$(bindir_relative_SQ)"' \
         '-DFALLBACK_RUNTIME_PREFIX="$(prefix_SQ)"'
    """,




},
{
    "wrongcode":
    """
                            /*
            * Copyright (c) 2006 Franck Bui-Huu
            * Copyright (c) 2006 Rene Scharfe
            */
            #include "builtin.h"
            #include "archive.h"
            #include "gettext.h"
            #include "transport.h"
            #include "parse-options.h"
            #include "pkt-line.h"

            static void create_output_file(const char *output_file)
            {
                    int output_fd = xopen(output_file, O_CREAT | O_WRONLY | O_TRUNC, 0666);
                    if (output_fd != 1) {
                            if (dup2(output_fd, 1) < 0)
                                    die_errno(_("could not redirect output"));
                            else
                                    close(output_fd);
                    }
            }

            static int run_remote_archiver(int argc, const char **argv,
                                    const char *remote, const char *exec,
                                    const char *name_hint)
            {
                    int fd[2], i, rv;
                    struct transport *transport;
                    struct remote *_remote;
                    struct packet_reader reader;

                    _remote = remote_get(remote);
                    transport = transport_get(_remote, _remote->url.v[0]);
                    transport_connect(transport, "git-upload-archive", exec, fd);

                    /*
                    * Inject a fake --format field at the beginning of the
                    * arguments, with the format inferred from our output
                    * filename. This way explicit --format options can override
                    * it.
                    */
                    if (name_hint) {
                            const char *format = archive_format_from_filename(name_hint);
                            if (format)
                                    packet_write_fmt(fd[1], "argument --format=%s\n", format);
                    }
                    for (i = 1; i < argc; i++)
                            packet_write_fmt(fd[1], "argument %s\n", argv[i]);
                    packet_flush(fd[1]);

                    packet_reader_init(&reader, fd[0], NULL, 0,
                                    PACKET_READ_CHOMP_NEWLINE |
                                    PACKET_READ_DIE_ON_ERR_PACKET);

                    if (packet_reader_read(&reader) != PACKET_READ_NORMAL)
                            die(_("git archive: expected ACK/NAK, got a flush packet"));
                    if (strcmp(reader.line, "ACK")) {
                            if (starts_with(reader.line, "NACK "))
                                    die(_("git archive: NACK %s"), reader.line + 5);
                            die(_("git archive: protocol error"));
                    }

                    if (packet_reader_read(&reader) != PACKET_READ_FLUSH)
                            die(_("git archive: expected a flush"));

                    /* Now, start reading from fd[0] and spit it out to stdout */
                    rv = recv_sideband("archive", fd[0], 1);
                    rv |= transport_disconnect(transport);

                    return !!rv;
            }

            #define PARSE_OPT_KEEP_ALL ( PARSE_OPT_KEEP_DASHDASH |  \
                                    PARSE_OPT_KEEP_ARGV0 |     \
                                    PARSE_OPT_KEEP_UNKNOWN_OPT |       \
                                    PARSE_OPT_NO_INTERNAL_HELP )

            int cmd_archive(int argc,
                            const char **argv,
                            const char *prefix,
                            struct repository *repo)
            {
                    const char *exec = "git-upload-archive";
                    char *output = NULL;
                    const char *remote = NULL;
                    struct option local_opts[] = {
                            OPT_FILENAME('o', "output", &output,
                                    N_("write the archive to this file")),
                            OPT_STRING(0, "remote", &remote, N_("repo"),
                                    N_("retrieve the archive from remote repository <repo>")),
                            OPT_STRING(0, "exec", &exec, N_("command"),
                                    N_("path to the remote git-upload-archive command")),
                            OPT_END()
                    };
                    int ret;

                    argc = parse_options(argc, argv, prefix, local_opts, NULL,
                                    PARSE_OPT_KEEP_ALL);

                    init_archivers();

                    if (output)
                            create_output_file(output);

                    if (remote) {
                            ret = run_remote_archiver(argc, argv, remote, exec, output);
                            goto out;
                    }

                    setvbuf(stderr, NULL, _IOLBF, BUFSIZ);

                    ret = write_archive(argc, argv, prefix, repo, output, 0);

            out:
                    free(output);
                    return ret;

    """,
    "error":"This patch addresses a file encoding/tagging issue that occurs when running Git on IBM z/OS. Specifically:

    On z/OS, files can have metadata indicating their encoding (e.g., ASCII, EBCDIC, or binary).
    If a file is not tagged as binary, applications may misinterpret its contents, leading to data corruption or errors when reading the file.
    By calling setbinaryfd(), this patch ensures that archive files are correctly tagged as binary, avoiding potential issues with misinterpreted file formats.
    ",
    "error_category":"Functionality-patches",

    "Corrected_code":
    """
            /*
            * Copyright (c) 2006 Franck Bui-Huu
            * Copyright (c) 2006 Rene Scharfe
            */
            #include "builtin.h"
            #include "archive.h"
            #include "gettext.h"
            #include "transport.h"
            #include "parse-options.h"
            #include "pkt-line.h"

            static void create_output_file(const char *output_file)
            {
                    int output_fd = xopen(output_file, O_CREAT | O_WRONLY | O_TRUNC, 0666);
            #ifdef __MVS__
            #if (__CHARSET_LIB == 1)
                    if (setbinaryfd(output_fd))
                            die_errno(_("could not tag archive file '%s'"), output_file);
            #endif
            #endif
                    if (output_fd != 1) {
                            if (dup2(output_fd, 1) < 0)
                                    die_errno(_("could not redirect output"));
                            else
                                    close(output_fd);
                    }
            }

            static int run_remote_archiver(int argc, const char **argv,
                                    const char *remote, const char *exec,
                                    const char *name_hint)
            {
                    int fd[2], i, rv;
                    struct transport *transport;
                    struct remote *_remote;
                    struct packet_reader reader;

                    _remote = remote_get(remote);
                    transport = transport_get(_remote, _remote->url.v[0]);
                    transport_connect(transport, "git-upload-archive", exec, fd);

                    /*
                    * Inject a fake --format field at the beginning of the
                    * arguments, with the format inferred from our output
                    * filename. This way explicit --format options can override
                    * it.
                    */
                    if (name_hint) {
                            const char *format = archive_format_from_filename(name_hint);
                            if (format)
                                    packet_write_fmt(fd[1], "argument --format=%s\n", format);
                    }
                    for (i = 1; i < argc; i++)
                            packet_write_fmt(fd[1], "argument %s\n", argv[i]);
                    packet_flush(fd[1]);

                    packet_reader_init(&reader, fd[0], NULL, 0,
                                    PACKET_READ_CHOMP_NEWLINE |
                                    PACKET_READ_DIE_ON_ERR_PACKET);

                    if (packet_reader_read(&reader) != PACKET_READ_NORMAL)
                            die(_("git archive: expected ACK/NAK, got a flush packet"));
                    if (strcmp(reader.line, "ACK")) {
                            if (starts_with(reader.line, "NACK "))
                                    die(_("git archive: NACK %s"), reader.line + 5);
                            die(_("git archive: protocol error"));
                    }

                    if (packet_reader_read(&reader) != PACKET_READ_FLUSH)
                            die(_("git archive: expected a flush"));

                    /* Now, start reading from fd[0] and spit it out to stdout */
                    rv = recv_sideband("archive", fd[0], 1);
                    rv |= transport_disconnect(transport);

                    return !!rv;
            }

            #define PARSE_OPT_KEEP_ALL ( PARSE_OPT_KEEP_DASHDASH |  \
                                    PARSE_OPT_KEEP_ARGV0 |     \
                                    PARSE_OPT_KEEP_UNKNOWN_OPT |       \
                                    PARSE_OPT_NO_INTERNAL_HELP )

            int cmd_archive(int argc,
                            const char **argv,
                            const char *prefix,
                            struct repository *repo)
            {
                    const char *exec = "git-upload-archive";
                    char *output = NULL;
                    const char *remote = NULL;
                    struct option local_opts[] = {
                            OPT_FILENAME('o', "output", &output,
                                    N_("write the archive to this file")),
                            OPT_STRING(0, "remote", &remote, N_("repo"),
                                    N_("retrieve the archive from remote repository <repo>")),
                            OPT_STRING(0, "exec", &exec, N_("command"),
                                    N_("path to the remote git-upload-archive command")),
                            OPT_END()
                    };
                    int ret;

                    argc = parse_options(argc, argv, prefix, local_opts, NULL,
                                    PARSE_OPT_KEEP_ALL);

                    init_archivers();

                    if (output)
                            create_output_file(output);

                    if (remote) {
                            ret = run_remote_archiver(argc, argv, remote, exec, output);
                            goto out;
                    }

                    setvbuf(stderr, NULL, _IOLBF, BUFSIZ);

                    ret = write_archive(argc, argv, prefix, repo, output, 0);

            out:
                    free(output);
                    return ret;
            }

    """,
    "patche":
    """

            diff --git a/builtin/archive.c b/builtin/archive.c
            index f094390..536b717 100644
            --- a/builtin/archive.c
            +++ b/builtin/archive.c
            @@ -13,6 +13,12 @@
            static void create_output_file(const char *output_file)
            {
                    int output_fd = xopen(output_file, O_CREAT | O_WRONLY | O_TRUNC, 0666);
            +#ifdef __MVS__
            + #if (__CHARSET_LIB == 1)
            +        if (setbinaryfd(output_fd))
            +       die_errno(_("could not tag archive file '%s'"), output_file);
            + #endif
            +#endif
                    if (output_fd != 1) {
                            if (dup2(output_fd, 1) < 0)
                                    die_errno(_("could not redirect output"));
            """,

  },


{
    "wrongcode":
    """
    #define USE_THE_REPOSITORY_VARIABLE
    #define DISABLE_SIGN_COMPARE_WARNINGS

    #include "git-compat-util.h"
    #include "refs.h"
    #include "object-store-ll.h"
    #include "cache-tree.h"
    #include "mergesort.h"
    #include "commit.h"
    #include "convert.h"
    #include "diff.h"
    #include "diffcore.h"
    #include "gettext.h"
    #include "hex.h"
    #include "path.h"
    #include "read-cache.h"
    #include "revision.h"
    #include "setup.h"
    #include "tag.h"
    #include "trace2.h"
    #include "blame.h"
    #include "alloc.h"
    #include "commit-slab.h"
    #include "bloom.h"
    #include "commit-graph.h"

    define_commit_slab(blame_suspects, struct blame_origin *);
    static struct blame_suspects blame_suspects;

    struct blame_origin *get_blame_suspects(struct commit *commit)
    {
            struct blame_origin **result;

            result = blame_suspects_peek(&blame_suspects, commit);

            return result ? *result : NULL;
    }

    static void set_blame_suspects(struct commit *commit, struct blame_origin *origin)
    {
            *blame_suspects_at(&blame_suspects, commit) = origin;
    }

    void blame_origin_decref(struct blame_origin *o)
    {
            if (o && --o->refcnt <= 0) {
                    struct blame_origin *p, *l = NULL;
                    if (o->previous)
                            blame_origin_decref(o->previous);
                    free(o->file.ptr);
                    /* Should be present exactly once in commit chain */
                    for (p = get_blame_suspects(o->commit); p; l = p, p = p->next) {
                            if (p == o) {
                                    if (l)
                                            l->next = p->next;
                                    else
                                            set_blame_suspects(o->commit, p->next);
                                    free(o);
                                    return;
                            }
                    }
                    die("internal error in blame_origin_decref");
            }
    }

    /*
    * Given a commit and a path in it, create a new origin structure.
    * The callers that add blame to the scoreboard should use
    * get_origin() to obtain shared, refcounted copy instead of calling
    * this function directly.
    */
    static struct blame_origin *make_origin(struct commit *commit, const char *path)
    {
            struct blame_origin *o;
            FLEX_ALLOC_STR(o, path, path);
            o->commit = commit;
            o->refcnt = 1;
            o->next = get_blame_suspects(commit);
            set_blame_suspects(commit, o);
            return o;
    }

    /*
    * Locate an existing origin or create a new one.
    * This moves the origin to front position in the commit util list.
    */
    static struct blame_origin *get_origin(struct commit *commit, const char *path)
    {
            struct blame_origin *o, *l;

            for (o = get_blame_suspects(commit), l = NULL; o; l = o, o = o->next) {
                    if (!strcmp(o->path, path)) {
                            /* bump to front */
                            if (l) {
                                    l->next = o->next;
                                    o->next = get_blame_suspects(commit);
                                    set_blame_suspects(commit, o);
                            }
                            return blame_origin_incref(o);
                    }
            }
            return make_origin(commit, path);
    }



    static void verify_working_tree_path(struct repository *r,
                                    struct commit *work_tree, const char *path)
    {
            struct commit_list *parents;
            int pos;

            for (parents = work_tree->parents; parents; parents = parents->next) {
                    const struct object_id *commit_oid = &parents->item->object.oid;
                    struct object_id blob_oid;
                    unsigned short mode;

                    if (!get_tree_entry(r, commit_oid, path, &blob_oid, &mode) &&
                    oid_object_info(r, &blob_oid, NULL) == OBJ_BLOB)
                            return;
            }

            pos = index_name_pos(r->index, path, strlen(path));
            if (pos >= 0)
                    ; /* path is in the index */
            else if (-1 - pos < r->index->cache_nr &&
                    !strcmp(r->index->cache[-1 - pos]->name, path))
                    ; /* path is in the index, unmerged */
            else
                    die("no such path '%s' in HEAD", path);
    }

    static struct commit_list **append_parent(struct repository *r,
                                            struct commit_list **tail,
                                            const struct object_id *oid)
    {
            struct commit *parent;

            parent = lookup_commit_reference(r, oid);
            if (!parent)
                    die("no such commit %s", oid_to_hex(oid));
            return &commit_list_insert(parent, tail)->next;
    }

    static void append_merge_parents(struct repository *r,
                                    struct commit_list **tail)
    {
            int merge_head;
            struct strbuf line = STRBUF_INIT;

            merge_head = open(git_path_merge_head(r), O_RDONLY);
            if (merge_head < 0) {
                    if (errno == ENOENT)
                            return;
                    die("cannot open '%s' for reading",
                    git_path_merge_head(r));
            }

            while (!strbuf_getwholeline_fd(&line, merge_head, '\n')) {
                    struct object_id oid;
                    if (get_oid_hex(line.buf, &oid))
                            die("unknown line in '%s': %s",
                            git_path_merge_head(r), line.buf);
                    tail = append_parent(r, tail, &oid);
            }
            close(merge_head);
            strbuf_release(&line);
    }

    /*
    * This isn't as simple as passing sb->buf and sb->len, because we
    * want to transfer ownership of the buffer to the commit (so we
    * must use detach).
    */
    static void set_commit_buffer_from_strbuf(struct repository *r,
                                            struct commit *c,
                                            struct strbuf *sb)
    {
            size_t len;
            void *buf = strbuf_detach(sb, &len);
            set_commit_buffer(r, c, buf, len);
    }

    /*
    * Prepare a dummy commit that represents the work tree (or staged) item.
    * Note that annotating work tree item never works in the reverse.
    */
    static struct commit *fake_working_tree_commit(struct repository *r,
                                            struct diff_options *opt,
                                            const char *path,
                                            const char *contents_from,
                                            struct object_id *oid)
    {
            struct commit *commit;
            struct blame_origin *origin;
            struct commit_list **parent_tail, *parent;
            struct strbuf buf = STRBUF_INIT;
            const char *ident;
            time_t now;
            int len;
            struct cache_entry *ce;
            unsigned mode;
            struct strbuf msg = STRBUF_INIT;

            repo_read_index(r);
            time(&now);
            commit = alloc_commit_node(r);
            commit->object.parsed = 1;
            commit->date = now;
            parent_tail = &commit->parents;

            parent_tail = append_parent(r, parent_tail, oid);
            append_merge_parents(r, parent_tail);
            verify_working_tree_path(r, commit, path);

            origin = make_origin(commit, path);

            if (contents_from)
                    ident = fmt_ident("External file (--contents)", "external.file",
                                    WANT_BLANK_IDENT, NULL, 0);
            else
                    ident = fmt_ident("Not Committed Yet", "not.committed.yet",
                                    WANT_BLANK_IDENT, NULL, 0);
            strbuf_addstr(&msg, "tree 0000000000000000000000000000000000000000\n");
            for (parent = commit->parents; parent; parent = parent->next)
                    strbuf_addf(&msg, "parent %s\n",
                            oid_to_hex(&parent->item->object.oid));
            strbuf_addf(&msg,
                    "author %s\n"
                    "committer %s\n\n"
                    "Version of %s from %s\n",
                    ident, ident, path,
                    (!contents_from ? path :
                    (!strcmp(contents_from, "-") ? "standard input" : contents_from)));
            set_commit_buffer_from_strbuf(r, commit, &msg);

            if (!contents_from || strcmp("-", contents_from)) {
                    struct stat st;
                    const char *read_from;
                    char *buf_ptr;
                    unsigned long buf_len;

                    if (contents_from) {
                            if (stat(contents_from, &st) < 0)
                                    die_errno("Cannot stat '%s'", contents_from);
                            read_from = contents_from;
                    }
                    else {
                            if (lstat(path, &st) < 0)
                                    die_errno("Cannot lstat '%s'", path);
                            read_from = path;
                    }
                    mode = canon_mode(st.st_mode);

                    switch (st.st_mode & S_IFMT) {
                    case S_IFREG:
                            if (opt->flags.allow_textconv &&
                            textconv_object(r, read_from, mode, null_oid(), 0, &buf_ptr, &buf_len))
                                    strbuf_attach(&buf, buf_ptr, buf_len, buf_len + 1);
                            else if (strbuf_read_file(&buf, read_from, st.st_size) != st.st_size)
                                    die_errno("cannot open or read '%s'", read_from);
                            break;
                    case S_IFLNK:
                            if (strbuf_readlink(&buf, read_from, st.st_size) < 0)
                                    die_errno("cannot readlink '%s'", read_from);
                            break;
                    default:
                            die("unsupported file type %s", read_from);
                    }
            }
            else {
                    /* Reading from stdin */
                    mode = 0;
                    if (strbuf_read(&buf, 0, 0) < 0)
                            die_errno("failed to read from stdin");
            }
            convert_to_git(r->index, path, buf.buf, buf.len, &buf, 0);
            origin->file.ptr = buf.buf;
            origin->file.size = buf.len;
            pretend_object_file(buf.buf, buf.len, OBJ_BLOB, &origin->blob_oid);

            /*
            * Read the current index, replace the path entry with
            * origin->blob_sha1 without mucking with its mode or type
            * bits; we are not going to write this index out -- we just
            * want to run "diff-index --cached".
            */
            discard_index(r->index);
            repo_read_index(r);

            len = strlen(path);
            if (!mode) {
                    int pos = index_name_pos(r->index, path, len);
                    if (0 <= pos)
                            mode = r->index->cache[pos]->ce_mode;
                    else
                            /* Let's not bother reading from HEAD tree */
                            mode = S_IFREG | 0644;
            }
            ce = make_empty_cache_entry(r->index, len);
            oidcpy(&ce->oid, &origin->blob_oid);
            memcpy(ce->name, path, len);
            ce->ce_flags = create_ce_flags(0);
            ce->ce_namelen = len;
            ce->ce_mode = create_ce_mode(mode);
            add_index_entry(r->index, ce,
                            ADD_CACHE_OK_TO_ADD | ADD_CACHE_OK_TO_REPLACE);

            cache_tree_invalidate_path(r->index, path);

            return commit;
    }



    static int diff_hunks(mmfile_t *file_a, mmfile_t *file_b,
                    xdl_emit_hunk_consume_func_t hunk_func, void *cb_data, int xdl_opts)
    {
            xpparam_t xpp = {0};
            xdemitconf_t xecfg = {0};
            xdemitcb_t ecb = {NULL};

            xpp.flags = xdl_opts;
            xecfg.hunk_func = hunk_func;
            ecb.priv = cb_data;
            return xdi_diff(file_a, file_b, &xpp, &xecfg, &ecb);
    }

    static const char *get_next_line(const char *start, const char *end)
    {
            const char *nl = memchr(start, '\n', end - start);

            return nl ? nl + 1 : end;
    }

    static int find_line_starts(int **line_starts, const char *buf,
                            unsigned long len)
    {
            const char *end = buf + len;
            const char *p;
            int *lineno;
            int num = 0;

            for (p = buf; p < end; p = get_next_line(p, end))
                    num++;

            ALLOC_ARRAY(*line_starts, num + 1);
            lineno = *line_starts;

            for (p = buf; p < end; p = get_next_line(p, end))
                    *lineno++ = p - buf;

            *lineno = len;

            return num;
    }

    struct fingerprint_entry;

    /* A fingerprint is intended to loosely represent a string, such that two
    * fingerprints can be quickly compared to give an indication of the similarity
    * of the strings that they represent.
    *
    * A fingerprint is represented as a multiset of the lower-cased byte pairs in
    * the string that it represents. Whitespace is added at each end of the
    * string. Whitespace pairs are ignored. Whitespace is converted to '\0'.
    * For example, the string "Darth   Radar" will be converted to the following
    * fingerprint:
    * {"\0d", "da", "da", "ar", "ar", "rt", "th", "h\0", "\0r", "ra", "ad", "r\0"}
    *
    * The similarity between two fingerprints is the size of the intersection of
    * their multisets, including repeated elements. See fingerprint_similarity for
    * examples.
    *
    * For ease of implementation, the fingerprint is implemented as a map
    * of byte pairs to the count of that byte pair in the string, instead of
    * allowing repeated elements in a set.
    */
    struct fingerprint {
            struct hashmap map;
            /* As we know the maximum number of entries in advance, it's
            * convenient to store the entries in a single array instead of having
            * the hashmap manage the memory.
            */
            struct fingerprint_entry *entries;
    };

    /* A byte pair in a fingerprint. Stores the number of times the byte pair
    * occurs in the string that the fingerprint represents.
    */
    struct fingerprint_entry {
            /* The hashmap entry - the hash represents the byte pair in its
            * entirety so we don't need to store the byte pair separately.
            */
            struct hashmap_entry entry;
            /* The number of times the byte pair occurs in the string that the
            * fingerprint represents.
            */
            int count;
    };

    /* See `struct fingerprint` for an explanation of what a fingerprint is.
    * \param result the fingerprint of the string is stored here. This must be
    *               freed later using free_fingerprint.
    * \param line_begin the start of the string
    * \param line_end the end of the string
    */
    static void get_fingerprint(struct fingerprint *result,
                            const char *line_begin,
                            const char *line_end)
    {
            unsigned int hash, c0 = 0, c1;
            const char *p;
            int max_map_entry_count = 1 + line_end - line_begin;
            struct fingerprint_entry *entry = xcalloc(max_map_entry_count,
                    sizeof(struct fingerprint_entry));
            struct fingerprint_entry *found_entry;

            hashmap_init(&result->map, NULL, NULL, max_map_entry_count);
            result->entries = entry;
            for (p = line_begin; p <= line_end; ++p, c0 = c1) {
                    /* Always terminate the string with whitespace.
                    * Normalise whitespace to 0, and normalise letters to
                    * lower case. This won't work for multibyte characters but at
                    * worst will match some unrelated characters.
                    */
                    if ((p == line_end) || isspace(*p))
                            c1 = 0;
                    else
                            c1 = tolower(*p);
                    hash = c0 | (c1 << 8);
                    /* Ignore whitespace pairs */
                    if (hash == 0)
                            continue;
                    hashmap_entry_init(&entry->entry, hash);

                    found_entry = hashmap_get_entry(&result->map, entry,
                                                    /* member name */ entry, NULL);
                    if (found_entry) {
                            found_entry->count += 1;
                    } else {
                            entry->count = 1;
                            hashmap_add(&result->map, &entry->entry);
                            ++entry;
                    }
            }
    }

    static void free_fingerprint(struct fingerprint *f)
    {
            hashmap_clear(&f->map);
            free(f->entries);
    }

    /* Calculates the similarity between two fingerprints as the size of the
    * intersection of their multisets, including repeated elements. See
    * `struct fingerprint` for an explanation of the fingerprint representation.
    * The similarity between "cat mat" and "father rather" is 2 because "at" is
    * present twice in both strings while the similarity between "tim" and "mit"
    * is 0.
    */
    static int fingerprint_similarity(struct fingerprint *a, struct fingerprint *b)
    {
            int intersection = 0;
            struct hashmap_iter iter;
            const struct fingerprint_entry *entry_a, *entry_b;

            hashmap_for_each_entry(&b->map, &iter, entry_b,
                                    entry /* member name */) {
                    entry_a = hashmap_get_entry(&a->map, entry_b, entry, NULL);
                    if (entry_a) {
                            intersection += entry_a->count < entry_b->count ?
                                            entry_a->count : entry_b->count;
                    }
            }
            return intersection;
    }

    /* Subtracts byte-pair elements in B from A, modifying A in place.
    */
    static void fingerprint_subtract(struct fingerprint *a, struct fingerprint *b)
    {
            struct hashmap_iter iter;
            struct fingerprint_entry *entry_a;
            const struct fingerprint_entry *entry_b;

            hashmap_iter_init(&b->map, &iter);

            hashmap_for_each_entry(&b->map, &iter, entry_b,
                                    entry /* member name */) {
                    entry_a = hashmap_get_entry(&a->map, entry_b, entry, NULL);
                    if (entry_a) {
                            if (entry_a->count <= entry_b->count)
                                    hashmap_remove(&a->map, &entry_b->entry, NULL);
                            else
                                    entry_a->count -= entry_b->count;
                    }
            }
    }

    /* Calculate fingerprints for a series of lines.
    * Puts the fingerprints in the fingerprints array, which must have been
    * preallocated to allow storing line_count elements.
    */
    static void get_line_fingerprints(struct fingerprint *fingerprints,
                                    const char *content, const int *line_starts,
                                    long first_line, long line_count)
    {
            int i;
            const char *linestart, *lineend;

            line_starts += first_line;
            for (i = 0; i < line_count; ++i) {
                    linestart = content + line_starts[i];
                    lineend = content + line_starts[i + 1];
                    get_fingerprint(fingerprints + i, linestart, lineend);
            }
    }

    static void free_line_fingerprints(struct fingerprint *fingerprints,
                                    int nr_fingerprints)
    {
            int i;

            for (i = 0; i < nr_fingerprints; i++)
                    free_fingerprint(&fingerprints[i]);
    }

    /* This contains the data necessary to linearly map a line number in one half
    * of a diff chunk to the line in the other half of the diff chunk that is
    * closest in terms of its position as a fraction of the length of the chunk.
    */
    struct line_number_mapping {
            int destination_start, destination_length,
                    source_start, source_length;
    };

    /* Given a line number in one range, offset and scale it to map it onto the
    * other range.
    * Essentially this mapping is a simple linear equation but the calculation is
    * more complicated to allow performing it with integer operations.
    * Another complication is that if a line could map onto many lines in the
    * destination range then we want to choose the line at the center of those
    * possibilities.
    * Example: if the chunk is 2 lines long in A and 10 lines long in B then the
    * first 5 lines in B will map onto the first line in the A chunk, while the
    * last 5 lines will all map onto the second line in the A chunk.
    * Example: if the chunk is 10 lines long in A and 2 lines long in B then line
    * 0 in B will map onto line 2 in A, and line 1 in B will map onto line 7 in A.
    */
    static int map_line_number(int line_number,
            const struct line_number_mapping *mapping)
    {
            return ((line_number - mapping->source_start) * 2 + 1) *
            mapping->destination_length /
            (mapping->source_length * 2) +
            mapping->destination_start;
    }

    /* Get a pointer to the element storing the similarity between a line in A
    * and a line in B.
    *
    * The similarities are stored in a 2-dimensional array. Each "row" in the
    * array contains the similarities for a line in B. The similarities stored in
    * a row are the similarities between the line in B and the nearby lines in A.
    * To keep the length of each row the same, it is padded out with values of -1
    * where the search range extends beyond the lines in A.
    * For example, if max_search_distance_a is 2 and the two sides of a diff chunk
    * look like this:
    * a | m
    * b | n
    * c | o
    * d | p
    * e | q
    * Then the similarity array will contain:
    * [-1, -1, am, bm, cm,
    *  -1, an, bn, cn, dn,
    *  ao, bo, co, do, eo,
    *  bp, cp, dp, ep, -1,
    *  cq, dq, eq, -1, -1]
    * Where similarities are denoted either by -1 for invalid, or the
    * concatenation of the two lines in the diff being compared.
    *
    * \param similarities array of similarities between lines in A and B
    * \param line_a the index of the line in A, in the same frame of reference as
    *      closest_line_a.
    * \param local_line_b the index of the line in B, relative to the first line
    *                     in B that similarities represents.
    * \param closest_line_a the index of the line in A that is deemed to be
    *                       closest to local_line_b. This must be in the same
    *                       frame of reference as line_a. This value defines
    *                       where similarities is centered for the line in B.
    * \param max_search_distance_a maximum distance in lines from the closest line
    *                              in A for other lines in A for which
    *                              similarities may be calculated.
    */
    static int *get_similarity(int *similarities,
                            int line_a, int local_line_b,
                            int closest_line_a, int max_search_distance_a)
    {
            assert(abs(line_a - closest_line_a) <=
            max_search_distance_a);
            return similarities + line_a - closest_line_a +
            max_search_distance_a +
            local_line_b * (max_search_distance_a * 2 + 1);
    }

    #define CERTAIN_NOTHING_MATCHES -2
    #define CERTAINTY_NOT_CALCULATED -1

    /* Given a line in B, first calculate its similarities with nearby lines in A
    * if not already calculated, then identify the most similar and second most
    * similar lines. The "certainty" is calculated based on those two
    * similarities.
    *
    * \param start_a the index of the first line of the chunk in A
    * \param length_a the length in lines of the chunk in A
    * \param local_line_b the index of the line in B, relative to the first line
    *                     in the chunk.
    * \param fingerprints_a array of fingerprints for the chunk in A
    * \param fingerprints_b array of fingerprints for the chunk in B
    * \param similarities 2-dimensional array of similarities between lines in A
    *                     and B. See get_similarity() for more details.
    * \param certainties array of values indicating how strongly a line in B is
    *                    matched with some line in A.
    * \param second_best_result array of absolute indices in A for the second
    *                           closest match of a line in B.
    * \param result array of absolute indices in A for the closest match of a line
    *               in B.
    * \param max_search_distance_a maximum distance in lines from the closest line
    *                              in A for other lines in A for which
    *                              similarities may be calculated.
    * \param map_line_number_in_b_to_a parameter to map_line_number().
    */
    static void find_best_line_matches(
            int start_a,
            int length_a,
            int start_b,
            int local_line_b,
            struct fingerprint *fingerprints_a,
            struct fingerprint *fingerprints_b,
            int *similarities,
            int *certainties,
            int *second_best_result,
            int *result,
            const int max_search_distance_a,
            const struct line_number_mapping *map_line_number_in_b_to_a)
    {

            int i, search_start, search_end, closest_local_line_a, *similarity,
                    best_similarity = 0, second_best_similarity = 0,
                    best_similarity_index = 0, second_best_similarity_index = 0;

            /* certainty has already been calculated so no need to redo the work */
            if (certainties[local_line_b] != CERTAINTY_NOT_CALCULATED)
                    return;

            closest_local_line_a = map_line_number(
                    local_line_b + start_b, map_line_number_in_b_to_a) - start_a;

            search_start = closest_local_line_a - max_search_distance_a;
            if (search_start < 0)
                    search_start = 0;

            search_end = closest_local_line_a + max_search_distance_a + 1;
            if (search_end > length_a)
                    search_end = length_a;

            for (i = search_start; i < search_end; ++i) {
                    similarity = get_similarity(similarities,
                                            i, local_line_b,
                                            closest_local_line_a,
                                            max_search_distance_a);
                    if (*similarity == -1) {
                            /* This value will never exceed 10 but assert just in
                            * case
                            */
                            assert(abs(i - closest_local_line_a) < 1000);
                            /* scale the similarity by (1000 - distance from
                            * closest line) to act as a tie break between lines
                            * that otherwise are equally similar.
                            */
                            *similarity = fingerprint_similarity(
                                    fingerprints_b + local_line_b,
                                    fingerprints_a + i) *
                                    (1000 - abs(i - closest_local_line_a));
                    }
                    if (*similarity > best_similarity) {
                            second_best_similarity = best_similarity;
                            second_best_similarity_index = best_similarity_index;
                            best_similarity = *similarity;
                            best_similarity_index = i;
                    } else if (*similarity > second_best_similarity) {
                            second_best_similarity = *similarity;
                            second_best_similarity_index = i;
                    }
            }

            if (best_similarity == 0) {
                    /* this line definitely doesn't match with anything. Mark it
                    * with this special value so it doesn't get invalidated and
                    * won't be recalculated.
                    */
                    certainties[local_line_b] = CERTAIN_NOTHING_MATCHES;
                    result[local_line_b] = -1;
            } else {
                    /* Calculate the certainty with which this line matches.
                    * If the line matches well with two lines then that reduces
                    * the certainty. However we still want to prioritise matching
                    * a line that matches very well with two lines over matching a
                    * line that matches poorly with one line, hence doubling
                    * best_similarity.
                    * This means that if we have
                    * line X that matches only one line with a score of 3,
                    * line Y that matches two lines equally with a score of 5,
                    * and line Z that matches only one line with a score or 2,
                    * then the lines in order of certainty are X, Y, Z.
                    */
                    certainties[local_line_b] = best_similarity * 2 -
                            second_best_similarity;

                    /* We keep both the best and second best results to allow us to
                    * check at a later stage of the matching process whether the
                    * result needs to be invalidated.
                    */
                    result[local_line_b] = start_a + best_similarity_index;
                    second_best_result[local_line_b] =
                            start_a + second_best_similarity_index;
            }
    }

    /*
    * This finds the line that we can match with the most confidence, and
    * uses it as a partition. It then calls itself on the lines on either side of
    * that partition. In this way we avoid lines appearing out of order, and
    * retain a sensible line ordering.
    * \param start_a index of the first line in A with which lines in B may be
    *                compared.
    * \param start_b index of the first line in B for which matching should be
    *                done.
    * \param length_a number of lines in A with which lines in B may be compared.
    * \param length_b number of lines in B for which matching should be done.
    * \param fingerprints_a mutable array of fingerprints in A. The first element
    *                       corresponds to the line at start_a.
    * \param fingerprints_b array of fingerprints in B. The first element
    *                       corresponds to the line at start_b.
    * \param similarities 2-dimensional array of similarities between lines in A
    *                     and B. See get_similarity() for more details.
    * \param certainties array of values indicating how strongly a line in B is
    *                    matched with some line in A.
    * \param second_best_result array of absolute indices in A for the second
    *                           closest match of a line in B.
    * \param result array of absolute indices in A for the closest match of a line
    *               in B.
    * \param max_search_distance_a maximum distance in lines from the closest line
    *                            in A for other lines in A for which
    *                            similarities may be calculated.
    * \param max_search_distance_b an upper bound on the greatest possible
    *                            distance between lines in B such that they will
    *                              both be compared with the same line in A
    *                            according to max_search_distance_a.
    * \param map_line_number_in_b_to_a parameter to map_line_number().
    */
    static void fuzzy_find_matching_lines_recurse(
            int start_a, int start_b,
            int length_a, int length_b,
            struct fingerprint *fingerprints_a,
            struct fingerprint *fingerprints_b,
            int *similarities,
            int *certainties,
            int *second_best_result,
            int *result,
            int max_search_distance_a,
            int max_search_distance_b,
            const struct line_number_mapping *map_line_number_in_b_to_a)
    {
            int i, invalidate_min, invalidate_max, offset_b,
                    second_half_start_a, second_half_start_b,
                    second_half_length_a, second_half_length_b,
                    most_certain_line_a, most_certain_local_line_b = -1,
                    most_certain_line_certainty = -1,
                    closest_local_line_a;

            for (i = 0; i < length_b; ++i) {
                    find_best_line_matches(start_a,
                                    length_a,
                                    start_b,
                                    i,
                                    fingerprints_a,
                                    fingerprints_b,
                                    similarities,
                                    certainties,
                                    second_best_result,
                                    result,
                                    max_search_distance_a,
                                    map_line_number_in_b_to_a);

                    if (certainties[i] > most_certain_line_certainty) {
                            most_certain_line_certainty = certainties[i];
                            most_certain_local_line_b = i;
                    }
            }

            /* No matches. */
            if (most_certain_local_line_b == -1)
                    return;

            most_certain_line_a = result[most_certain_local_line_b];

            /*
            * Subtract the most certain line's fingerprint in B from the matched
            * fingerprint in A. This means that other lines in B can't also match
            * the same parts of the line in A.
            */
            fingerprint_subtract(fingerprints_a + most_certain_line_a - start_a,
                            fingerprints_b + most_certain_local_line_b);

            /* Invalidate results that may be affected by the choice of most
            * certain line.
            */
            invalidate_min = most_certain_local_line_b - max_search_distance_b;
            invalidate_max = most_certain_local_line_b + max_search_distance_b + 1;
            if (invalidate_min < 0)
                    invalidate_min = 0;
            if (invalidate_max > length_b)
                    invalidate_max = length_b;

            /* As the fingerprint in A has changed, discard previously calculated
            * similarity values with that fingerprint.
            */
            for (i = invalidate_min; i < invalidate_max; ++i) {
                    closest_local_line_a = map_line_number(
                            i + start_b, map_line_number_in_b_to_a) - start_a;

                    /* Check that the lines in A and B are close enough that there
                    * is a similarity value for them.
                    */
                    if (abs(most_certain_line_a - start_a - closest_local_line_a) >
                            max_search_distance_a) {
                            continue;
                    }

                    *get_similarity(similarities, most_certain_line_a - start_a,
                                    i, closest_local_line_a,
                                    max_search_distance_a) = -1;
            }

            /* More invalidating of results that may be affected by the choice of
            * most certain line.
            * Discard the matches for lines in B that are currently matched with a
            * line in A such that their ordering contradicts the ordering imposed
            * by the choice of most certain line.
            */
            for (i = most_certain_local_line_b - 1; i >= invalidate_min; --i) {
                    /* In this loop we discard results for lines in B that are
                    * before most-certain-line-B but are matched with a line in A
                    * that is after most-certain-line-A.
                    */
                    if (certainties[i] >= 0 &&
                    (result[i] >= most_certain_line_a ||
                    second_best_result[i] >= most_certain_line_a)) {
                            certainties[i] = CERTAINTY_NOT_CALCULATED;
                    }
            }
            for (i = most_certain_local_line_b + 1; i < invalidate_max; ++i) {
                    /* In this loop we discard results for lines in B that are
                    * after most-certain-line-B but are matched with a line in A
                    * that is before most-certain-line-A.
                    */
                    if (certainties[i] >= 0 &&
                    (result[i] <= most_certain_line_a ||
                    second_best_result[i] <= most_certain_line_a)) {
                            certainties[i] = CERTAINTY_NOT_CALCULATED;
                    }
            }

            /* Repeat the matching process for lines before the most certain line.
            */
            if (most_certain_local_line_b > 0) {
                    fuzzy_find_matching_lines_recurse(
                            start_a, start_b,
                            most_certain_line_a + 1 - start_a,
                            most_certain_local_line_b,
                            fingerprints_a, fingerprints_b, similarities,
                            certainties, second_best_result, result,
                            max_search_distance_a,
                            max_search_distance_b,
                            map_line_number_in_b_to_a);
            }
            /* Repeat the matching process for lines after the most certain line.
            */
            if (most_certain_local_line_b + 1 < length_b) {
                    second_half_start_a = most_certain_line_a;
                    offset_b = most_certain_local_line_b + 1;
                    second_half_start_b = start_b + offset_b;
                    second_half_length_a =
                            length_a + start_a - second_half_start_a;
                    second_half_length_b =
                            length_b + start_b - second_half_start_b;
                    fuzzy_find_matching_lines_recurse(
                            second_half_start_a, second_half_start_b,
                            second_half_length_a, second_half_length_b,
                            fingerprints_a + second_half_start_a - start_a,
                            fingerprints_b + offset_b,
                            similarities +
                                    offset_b * (max_search_distance_a * 2 + 1),
                            certainties + offset_b,
                            second_best_result + offset_b, result + offset_b,
                            max_search_distance_a,
                            max_search_distance_b,
                            map_line_number_in_b_to_a);
            }
    }

    /* Find the lines in the parent line range that most closely match the lines in
    * the target line range. This is accomplished by matching fingerprints in each
    * blame_origin, and choosing the best matches that preserve the line ordering.
    * See struct fingerprint for details of fingerprint matching, and
    * fuzzy_find_matching_lines_recurse for details of preserving line ordering.
    *
    * The performance is believed to be O(n log n) in the typical case and O(n^2)
    * in a pathological case, where n is the number of lines in the target range.
    */
    static int *fuzzy_find_matching_lines(struct blame_origin *parent,
                                    struct blame_origin *target,
                                    int tlno, int parent_slno, int same,
                                    int parent_len)
    {
            /* We use the terminology "A" for the left hand side of the diff AKA
            * parent, and "B" for the right hand side of the diff AKA target. */
            int start_a = parent_slno;
            int length_a = parent_len;
            int start_b = tlno;
            int length_b = same - tlno;

            struct line_number_mapping map_line_number_in_b_to_a = {
                    start_a, length_a, start_b, length_b
            };

            struct fingerprint *fingerprints_a = parent->fingerprints;
            struct fingerprint *fingerprints_b = target->fingerprints;

            int i, *result, *second_best_result,
                    *certainties, *similarities, similarity_count;

            /*
            * max_search_distance_a means that given a line in B, compare it to
            * the line in A that is closest to its position, and the lines in A
            * that are no greater than max_search_distance_a lines away from the
            * closest line in A.
            *
            * max_search_distance_b is an upper bound on the greatest possible
            * distance between lines in B such that they will both be compared
            * with the same line in A according to max_search_distance_a.
            */
            int max_search_distance_a = 10, max_search_distance_b;

            if (length_a <= 0)
                    return NULL;

            if (max_search_distance_a >= length_a)
                    max_search_distance_a = length_a ? length_a - 1 : 0;

            max_search_distance_b = ((2 * max_search_distance_a + 1) * length_b
                                    - 1) / length_a;

            CALLOC_ARRAY(result, length_b);
            CALLOC_ARRAY(second_best_result, length_b);
            CALLOC_ARRAY(certainties, length_b);

            /* See get_similarity() for details of similarities. */
            similarity_count = length_b * (max_search_distance_a * 2 + 1);
            CALLOC_ARRAY(similarities, similarity_count);

            for (i = 0; i < length_b; ++i) {
                    result[i] = -1;
                    second_best_result[i] = -1;
                    certainties[i] = CERTAINTY_NOT_CALCULATED;
            }

            for (i = 0; i < similarity_count; ++i)
                    similarities[i] = -1;

            fuzzy_find_matching_lines_recurse(start_a, start_b,
                                            length_a, length_b,
                                            fingerprints_a + start_a,
                                            fingerprints_b + start_b,
                                            similarities,
                                            certainties,
                                            second_best_result,
                                            result,
                                            max_search_distance_a,
                                            max_search_distance_b,
                                            &map_line_number_in_b_to_a);

            free(similarities);
            free(certainties);
            free(second_best_result);

            return result;
    }

    static void fill_origin_fingerprints(struct blame_origin *o)
    {
            int *line_starts;

            if (o->fingerprints)
                    return;
            o->num_lines = find_line_starts(&line_starts, o->file.ptr,
                                            o->file.size);
            CALLOC_ARRAY(o->fingerprints, o->num_lines);
            get_line_fingerprints(o->fingerprints, o->file.ptr, line_starts,
                            0, o->num_lines);
            free(line_starts);
    }

    static void drop_origin_fingerprints(struct blame_origin *o)
    {
            if (o->fingerprints) {
                    free_line_fingerprints(o->fingerprints, o->num_lines);
                    o->num_lines = 0;
                    FREE_AND_NULL(o->fingerprints);
            }
    }

    /*
    * Given an origin, prepare mmfile_t structure to be used by the
    * diff machinery
    */
    static void fill_origin_blob(struct diff_options *opt,
                            struct blame_origin *o, mmfile_t *file,
                            int *num_read_blob, int fill_fingerprints)
    {
            if (!o->file.ptr) {
                    enum object_type type;
                    unsigned long file_size;

                    (*num_read_blob)++;
                    if (opt->flags.allow_textconv &&
                    textconv_object(opt->repo, o->path, o->mode,
                                    &o->blob_oid, 1, &file->ptr, &file_size))
                            ;
                    else
                            file->ptr = repo_read_object_file(the_repository,
                                                            &o->blob_oid, &type,
                                                            &file_size);
                    file->size = file_size;

                    if (!file->ptr)
                            die("Cannot read blob %s for path %s",
                            oid_to_hex(&o->blob_oid),
                            o->path);
                    o->file = *file;
            }
            else
                    *file = o->file;
            if (fill_fingerprints)
                    fill_origin_fingerprints(o);
    }

    static void drop_origin_blob(struct blame_origin *o)
    {
            FREE_AND_NULL(o->file.ptr);
            drop_origin_fingerprints(o);
    }

    /*
    * Any merge of blames happens on lists of blames that arrived via
    * different parents in a single suspect.  In this case, we want to
    * sort according to the suspect line numbers as opposed to the final
    * image line numbers.  The function body is somewhat longish because
    * it avoids unnecessary writes.
    */

    static struct blame_entry *blame_merge(struct blame_entry *list1,
                                    struct blame_entry *list2)
    {
            struct blame_entry *p1 = list1, *p2 = list2,
                    **tail = &list1;

            if (!p1)
                    return p2;
            if (!p2)
                    return p1;

            if (p1->s_lno <= p2->s_lno) {
                    do {
                            tail = &p1->next;
                            if (!(p1 = *tail)) {
                                    *tail = p2;
                                    return list1;
                            }
                    } while (p1->s_lno <= p2->s_lno);
            }
            for (;;) {
                    *tail = p2;
                    do {
                            tail = &p2->next;
                            if (!(p2 = *tail))  {
                                    *tail = p1;
                                    return list1;
                            }
                    } while (p1->s_lno > p2->s_lno);
                    *tail = p1;
                    do {
                            tail = &p1->next;
                            if (!(p1 = *tail)) {
                                    *tail = p2;
                                    return list1;
                            }
                    } while (p1->s_lno <= p2->s_lno);
            }
    }

    DEFINE_LIST_SORT(static, sort_blame_entries, struct blame_entry, next);

    /*
    * Final image line numbers are all different, so we don't need a
    * three-way comparison here.
    */

    static int compare_blame_final(const struct blame_entry *e1,
                            const struct blame_entry *e2)
    {
            return e1->lno > e2->lno ? 1 : -1;
    }

    static int compare_blame_suspect(const struct blame_entry *s1,
                                    const struct blame_entry *s2)
    {
            /*
            * to allow for collating suspects, we sort according to the
            * respective pointer value as the primary sorting criterion.
            * The actual relation is pretty unimportant as long as it
            * establishes a total order.  Comparing as integers gives us
            * that.
            */
            if (s1->suspect != s2->suspect)
                    return (intptr_t)s1->suspect > (intptr_t)s2->suspect ? 1 : -1;
            if (s1->s_lno == s2->s_lno)
                    return 0;
            return s1->s_lno > s2->s_lno ? 1 : -1;
    }

    void blame_sort_final(struct blame_scoreboard *sb)
    {
            sort_blame_entries(&sb->ent, compare_blame_final);
    }

    static int compare_commits_by_reverse_commit_date(const void *a,
                                                    const void *b,
                                                    void *c)
    {
            return -compare_commits_by_commit_date(a, b, c);
    }

    /*
    * For debugging -- origin is refcounted, and this asserts that
    * we do not underflow.
    */
    static void sanity_check_refcnt(struct blame_scoreboard *sb)
    {
            int baa = 0;
            struct blame_entry *ent;

            for (ent = sb->ent; ent; ent = ent->next) {
                    /* Nobody should have zero or negative refcnt */
                    if (ent->suspect->refcnt <= 0) {
                            fprintf(stderr, "%s in %s has negative refcnt %d\n",
                                    ent->suspect->path,
                                    oid_to_hex(&ent->suspect->commit->object.oid),
                                    ent->suspect->refcnt);
                            baa = 1;
                    }
            }
            if (baa)
                    sb->on_sanity_fail(sb, baa);
    }

    /*
    * If two blame entries that are next to each other came from
    * contiguous lines in the same origin (i.e. <commit, path> pair),
    * merge them together.
    */
    void blame_coalesce(struct blame_scoreboard *sb)
    {
            struct blame_entry *ent, *next;

            for (ent = sb->ent; ent && (next = ent->next); ent = next) {
                    if (ent->suspect == next->suspect &&
                    ent->s_lno + ent->num_lines == next->s_lno &&
                    ent->lno + ent->num_lines == next->lno &&
                    ent->ignored == next->ignored &&
                    ent->unblamable == next->unblamable) {
                            ent->num_lines += next->num_lines;
                            ent->next = next->next;
                            blame_origin_decref(next->suspect);
                            free(next);
                            ent->score = 0;
                            next = ent; /* again */
                    }
            }

            if (sb->debug) /* sanity */
                    sanity_check_refcnt(sb);
    }

    /*
    * Merge the given sorted list of blames into a preexisting origin.
    * If there were no previous blames to that commit, it is entered into
    * the commit priority queue of the score board.
    */

    static void queue_blames(struct blame_scoreboard *sb, struct blame_origin *porigin,
                            struct blame_entry *sorted)
    {
            if (porigin->suspects)
                    porigin->suspects = blame_merge(porigin->suspects, sorted);
            else {
                    struct blame_origin *o;
                    for (o = get_blame_suspects(porigin->commit); o; o = o->next) {
                            if (o->suspects) {
                                    porigin->suspects = sorted;
                                    return;
                            }
                    }
                    porigin->suspects = sorted;
                    prio_queue_put(&sb->commits, porigin->commit);
            }
    }

    /*
    * Fill the blob_sha1 field of an origin if it hasn't, so that later
    * call to fill_origin_blob() can use it to locate the data.  blob_sha1
    * for an origin is also used to pass the blame for the entire file to
    * the parent to detect the case where a child's blob is identical to
    * that of its parent's.
    *
    * This also fills origin->mode for corresponding tree path.
    */
    static int fill_blob_sha1_and_mode(struct repository *r,
                                    struct blame_origin *origin)
    {
            if (!is_null_oid(&origin->blob_oid))
                    return 0;
            if (get_tree_entry(r, &origin->commit->object.oid, origin->path, &origin->blob_oid, &origin->mode))
                    goto error_out;
            if (oid_object_info(r, &origin->blob_oid, NULL) != OBJ_BLOB)
                    goto error_out;
            return 0;
    error_out:
            oidclr(&origin->blob_oid, the_repository->hash_algo);
            origin->mode = S_IFINVALID;
            return -1;
    }

    struct blame_bloom_data {
            /*
            * Changed-path Bloom filter keys. These can help prevent
            * computing diffs against first parents, but we need to
            * expand the list as code is moved or files are renamed.
            */
            struct bloom_filter_settings *settings;
            struct bloom_key **keys;
            int nr;
            int alloc;
    };

    static int bloom_count_queries = 0;
    static int bloom_count_no = 0;
    static int maybe_changed_path(struct repository *r,
                            struct blame_origin *origin,
                            struct blame_bloom_data *bd)
    {
            int i;
            struct bloom_filter *filter;

            if (!bd)
                    return 1;

            if (commit_graph_generation(origin->commit) == GENERATION_NUMBER_INFINITY)
                    return 1;

            filter = get_bloom_filter(r, origin->commit);

            if (!filter)
                    return 1;

            bloom_count_queries++;
            for (i = 0; i < bd->nr; i++) {
                    if (bloom_filter_contains(filter,
                                            bd->keys[i],
                                            bd->settings))
                            return 1;
            }

            bloom_count_no++;
            return 0;
    }

    static void add_bloom_key(struct blame_bloom_data *bd,
                            const char *path)
    {
            if (!bd)
                    return;

            if (bd->nr >= bd->alloc) {
                    bd->alloc *= 2;
                    REALLOC_ARRAY(bd->keys, bd->alloc);
            }

            bd->keys[bd->nr] = xmalloc(sizeof(struct bloom_key));
            fill_bloom_key(path, strlen(path), bd->keys[bd->nr], bd->settings);
            bd->nr++;
    }

    /*
    * We have an origin -- check if the same path exists in the
    * parent and return an origin structure to represent it.
    */
    static struct blame_origin *find_origin(struct repository *r,
                                            struct commit *parent,
                                            struct blame_origin *origin,
                                            struct blame_bloom_data *bd)
    {
            struct blame_origin *porigin;
            struct diff_options diff_opts;
            const char *paths[2];

            /* First check any existing origins */
            for (porigin = get_blame_suspects(parent); porigin; porigin = porigin->next)
                    if (!strcmp(porigin->path, origin->path)) {
                            /*
                            * The same path between origin and its parent
                            * without renaming -- the most common case.
                            */
                            return blame_origin_incref (porigin);
                    }

            /* See if the origin->path is different between parent
            * and origin first.  Most of the time they are the
            * same and diff-tree is fairly efficient about this.
            */
            repo_diff_setup(r, &diff_opts);
            diff_opts.flags.recursive = 1;
            diff_opts.detect_rename = 0;
            diff_opts.output_format = DIFF_FORMAT_NO_OUTPUT;
            paths[0] = origin->path;
            paths[1] = NULL;

            parse_pathspec(&diff_opts.pathspec,
                    PATHSPEC_ALL_MAGIC & ~PATHSPEC_LITERAL,
                    PATHSPEC_LITERAL_PATH, "", paths);
            diff_setup_done(&diff_opts);

            if (is_null_oid(&origin->commit->object.oid))
                    do_diff_cache(get_commit_tree_oid(parent), &diff_opts);
            else {
                    int compute_diff = 1;
                    if (origin->commit->parents &&
                    oideq(&parent->object.oid,
                            &origin->commit->parents->item->object.oid))
                            compute_diff = maybe_changed_path(r, origin, bd);

                    if (compute_diff)
                            diff_tree_oid(get_commit_tree_oid(parent),
                                    get_commit_tree_oid(origin->commit),
                                    "", &diff_opts);
            }
            diffcore_std(&diff_opts);

            if (!diff_queued_diff.nr) {
                    /* The path is the same as parent */
                    porigin = get_origin(parent, origin->path);
                    oidcpy(&porigin->blob_oid, &origin->blob_oid);
                    porigin->mode = origin->mode;
            } else {
                    /*
                    * Since origin->path is a pathspec, if the parent
                    * commit had it as a directory, we will see a whole
                    * bunch of deletion of files in the directory that we
                    * do not care about.
                    */
                    int i;
                    struct diff_filepair *p = NULL;
                    for (i = 0; i < diff_queued_diff.nr; i++) {
                            const char *name;
                            p = diff_queued_diff.queue[i];
                            name = p->one->path ? p->one->path : p->two->path;
                            if (!strcmp(name, origin->path))
                                    break;
                    }
                    if (!p)
                            die("internal error in blame::find_origin");
                    switch (p->status) {
                    default:
                            die("internal error in blame::find_origin (%c)",
                            p->status);
                    case 'M':
                            porigin = get_origin(parent, origin->path);
                            oidcpy(&porigin->blob_oid, &p->one->oid);
                            porigin->mode = p->one->mode;
                            break;
                    case 'A':
                    case 'T':
                            /* Did not exist in parent, or type changed */
                            break;
                    }
            }
            diff_flush(&diff_opts);
            return porigin;
    }

    /*
    * We have an origin -- find the path that corresponds to it in its
    * parent and return an origin structure to represent it.
    */
    static struct blame_origin *find_rename(struct repository *r,
                                            struct commit *parent,
                                            struct blame_origin *origin,
                                            struct blame_bloom_data *bd)
    {
            struct blame_origin *porigin = NULL;
            struct diff_options diff_opts;
            int i;

            repo_diff_setup(r, &diff_opts);
            diff_opts.flags.recursive = 1;
            diff_opts.detect_rename = DIFF_DETECT_RENAME;
            diff_opts.output_format = DIFF_FORMAT_NO_OUTPUT;
            diff_opts.single_follow = origin->path;
            diff_setup_done(&diff_opts);

            if (is_null_oid(&origin->commit->object.oid))
                    do_diff_cache(get_commit_tree_oid(parent), &diff_opts);
            else
                    diff_tree_oid(get_commit_tree_oid(parent),
                            get_commit_tree_oid(origin->commit),
                            "", &diff_opts);
            diffcore_std(&diff_opts);

            for (i = 0; i < diff_queued_diff.nr; i++) {
                    struct diff_filepair *p = diff_queued_diff.queue[i];
                    if ((p->status == 'R' || p->status == 'C') &&
                    !strcmp(p->two->path, origin->path)) {
                            add_bloom_key(bd, p->one->path);
                            porigin = get_origin(parent, p->one->path);
                            oidcpy(&porigin->blob_oid, &p->one->oid);
                            porigin->mode = p->one->mode;
                            break;
                    }
            }
            diff_flush(&diff_opts);
            return porigin;
    }

    /*
    * Append a new blame entry to a given output queue.
    */
    static void add_blame_entry(struct blame_entry ***queue,
                            const struct blame_entry *src)
    {
            struct blame_entry *e = xmalloc(sizeof(*e));
            memcpy(e, src, sizeof(*e));
            blame_origin_incref(e->suspect);

            e->next = **queue;
            **queue = e;
            *queue = &e->next;
    }

    /*
    * src typically is on-stack; we want to copy the information in it to
    * a malloced blame_entry that gets added to the given queue.  The
    * origin of dst loses a refcnt.
    */
    static void dup_entry(struct blame_entry ***queue,
                    struct blame_entry *dst, struct blame_entry *src)
    {
            blame_origin_incref(src->suspect);
            blame_origin_decref(dst->suspect);
            memcpy(dst, src, sizeof(*src));
            dst->next = **queue;
            **queue = dst;
            *queue = &dst->next;
    }

    const char *blame_nth_line(struct blame_scoreboard *sb, long lno)
    {
            return sb->final_buf + sb->lineno[lno];
    }

    /*
    * It is known that lines between tlno to same came from parent, and e
    * has an overlap with that range.  it also is known that parent's
    * line plno corresponds to e's line tlno.
    *
    *                <---- e ----->
    *                   <------>
    *                   <------------>
    *             <------------>
    *             <------------------>
    *
    * Split e into potentially three parts; before this chunk, the chunk
    * to be blamed for the parent, and after that portion.
    */
    static void split_overlap(struct blame_entry *split,
                            struct blame_entry *e,
                            int tlno, int plno, int same,
                            struct blame_origin *parent)
    {
            int chunk_end_lno;
            int i;
            memset(split, 0, sizeof(struct blame_entry [3]));

            for (i = 0; i < 3; i++) {
                    split[i].ignored = e->ignored;
                    split[i].unblamable = e->unblamable;
            }

            if (e->s_lno < tlno) {
                    /* there is a pre-chunk part not blamed on parent */
                    split[0].suspect = blame_origin_incref(e->suspect);
                    split[0].lno = e->lno;
                    split[0].s_lno = e->s_lno;
                    split[0].num_lines = tlno - e->s_lno;
                    split[1].lno = e->lno + tlno - e->s_lno;
                    split[1].s_lno = plno;
            }
            else {
                    split[1].lno = e->lno;
                    split[1].s_lno = plno + (e->s_lno - tlno);
            }

            if (same < e->s_lno + e->num_lines) {
                    /* there is a post-chunk part not blamed on parent */
                    split[2].suspect = blame_origin_incref(e->suspect);
                    split[2].lno = e->lno + (same - e->s_lno);
                    split[2].s_lno = e->s_lno + (same - e->s_lno);
                    split[2].num_lines = e->s_lno + e->num_lines - same;
                    chunk_end_lno = split[2].lno;
            }
            else
                    chunk_end_lno = e->lno + e->num_lines;
            split[1].num_lines = chunk_end_lno - split[1].lno;

            /*
            * if it turns out there is nothing to blame the parent for,
            * forget about the splitting.  !split[1].suspect signals this.
            */
            if (split[1].num_lines < 1)
                    return;
            split[1].suspect = blame_origin_incref(parent);
    }

    /*
    * split_overlap() divided an existing blame e into up to three parts
    * in split.  Any assigned blame is moved to queue to
    * reflect the split.
    */
    static void split_blame(struct blame_entry ***blamed,
                            struct blame_entry ***unblamed,
                            struct blame_entry *split,
                            struct blame_entry *e)
    {
            if (split[0].suspect && split[2].suspect) {
                    /* The first part (reuse storage for the existing entry e) */
                    dup_entry(unblamed, e, &split[0]);

                    /* The last part -- me */
                    add_blame_entry(unblamed, &split[2]);

                    /* ... and the middle part -- parent */
                    add_blame_entry(blamed, &split[1]);
            }
            else if (!split[0].suspect && !split[2].suspect)
                    /*
                    * The parent covers the entire area; reuse storage for
                    * e and replace it with the parent.
                    */
                    dup_entry(blamed, e, &split[1]);
            else if (split[0].suspect) {
                    /* me and then parent */
                    dup_entry(unblamed, e, &split[0]);
                    add_blame_entry(blamed, &split[1]);
            }
            else {
                    /* parent and then me */
                    dup_entry(blamed, e, &split[1]);
                    add_blame_entry(unblamed, &split[2]);
            }
    }

    /*
    * After splitting the blame, the origins used by the
    * on-stack blame_entry should lose one refcnt each.
    */
    static void decref_split(struct blame_entry *split)
    {
            int i;

            for (i = 0; i < 3; i++)
                    blame_origin_decref(split[i].suspect);
    }

    /*
    * reverse_blame reverses the list given in head, appending tail.
    * That allows us to build lists in reverse order, then reverse them
    * afterwards.  This can be faster than building the list in proper
    * order right away.  The reason is that building in proper order
    * requires writing a link in the _previous_ element, while building
    * in reverse order just requires placing the list head into the
    * _current_ element.
    */

    static struct blame_entry *reverse_blame(struct blame_entry *head,
                                            struct blame_entry *tail)
    {
            while (head) {
                    struct blame_entry *next = head->next;
                    head->next = tail;
                    tail = head;
                    head = next;
            }
            return tail;
    }

    /*
    * Splits a blame entry into two entries at 'len' lines.  The original 'e'
    * consists of len lines, i.e. [e->lno, e->lno + len), and the second part,
    * which is returned, consists of the remainder: [e->lno + len, e->lno +
    * e->num_lines).  The caller needs to sort out the reference counting for the
    * new entry's suspect.
    */
    static struct blame_entry *split_blame_at(struct blame_entry *e, int len,
                                            struct blame_origin *new_suspect)
    {
            struct blame_entry *n = xcalloc(1, sizeof(struct blame_entry));

            n->suspect = new_suspect;
            n->ignored = e->ignored;
            n->unblamable = e->unblamable;
            n->lno = e->lno + len;
            n->s_lno = e->s_lno + len;
            n->num_lines = e->num_lines - len;
            e->num_lines = len;
            e->score = 0;
            return n;
    }

    struct blame_line_tracker {
            int is_parent;
            int s_lno;
    };

    static int are_lines_adjacent(struct blame_line_tracker *first,
                            struct blame_line_tracker *second)
    {
            return first->is_parent == second->is_parent &&
            first->s_lno + 1 == second->s_lno;
    }

    static int scan_parent_range(struct fingerprint *p_fps,
                            struct fingerprint *t_fps, int t_idx,
                            int from, int nr_lines)
    {
            int sim, p_idx;
            #define FINGERPRINT_FILE_THRESHOLD      10
            int best_sim_val = FINGERPRINT_FILE_THRESHOLD;
            int best_sim_idx = -1;

            for (p_idx = from; p_idx < from + nr_lines; p_idx++) {
                    sim = fingerprint_similarity(&t_fps[t_idx], &p_fps[p_idx]);
                    if (sim < best_sim_val)
                            continue;
                    /* Break ties with the closest-to-target line number */
                    if (sim == best_sim_val && best_sim_idx != -1 &&
                    abs(best_sim_idx - t_idx) < abs(p_idx - t_idx))
                            continue;
                    best_sim_val = sim;
                    best_sim_idx = p_idx;
            }
            return best_sim_idx;
    }

    /*
    * The first pass checks the blame entry (from the target) against the parent's
    * diff chunk.  If that fails for a line, the second pass tries to match that
    * line to any part of parent file.  That catches cases where a change was
    * broken into two chunks by 'context.'
    */
    static void guess_line_blames(struct blame_origin *parent,
                            struct blame_origin *target,
                            int tlno, int offset, int same, int parent_len,
                            struct blame_line_tracker *line_blames)
    {
            int i, best_idx, target_idx;
            int parent_slno = tlno + offset;
            int *fuzzy_matches;

            fuzzy_matches = fuzzy_find_matching_lines(parent, target,
                                                    tlno, parent_slno, same,
                                                    parent_len);
            for (i = 0; i < same - tlno; i++) {
                    target_idx = tlno + i;
                    if (fuzzy_matches && fuzzy_matches[i] >= 0) {
                            best_idx = fuzzy_matches[i];
                    } else {
                            best_idx = scan_parent_range(parent->fingerprints,
                                                    target->fingerprints,
                                                    target_idx, 0,
                                                    parent->num_lines);
                    }
                    if (best_idx >= 0) {
                            line_blames[i].is_parent = 1;
                            line_blames[i].s_lno = best_idx;
                    } else {
                            line_blames[i].is_parent = 0;
                            line_blames[i].s_lno = target_idx;
                    }
            }
            free(fuzzy_matches);
    }

    /*
    * This decides which parts of a blame entry go to the parent (added to the
    * ignoredp list) and which stay with the target (added to the diffp list).  The
    * actual decision was made in a separate heuristic function, and those answers
    * for the lines in 'e' are in line_blames.  This consumes e, essentially
    * putting it on a list.
    *
    * Note that the blame entries on the ignoredp list are not necessarily sorted
    * with respect to the parent's line numbers yet.
    */
    static void ignore_blame_entry(struct blame_entry *e,
                            struct blame_origin *parent,
                            struct blame_entry **diffp,
                            struct blame_entry **ignoredp,
                            struct blame_line_tracker *line_blames)
    {
            int entry_len, nr_lines, i;

            /*
            * We carve new entries off the front of e.  Each entry comes from a
            * contiguous chunk of lines: adjacent lines from the same origin
            * (either the parent or the target).
            */
            entry_len = 1;
            nr_lines = e->num_lines;        /* e changes in the loop */
            for (i = 0; i < nr_lines; i++) {
                    struct blame_entry *next = NULL;

                    /*
                    * We are often adjacent to the next line - only split the blame
                    * entry when we have to.
                    */
                    if (i + 1 < nr_lines) {
                            if (are_lines_adjacent(&line_blames[i],
                                            &line_blames[i + 1])) {
                                    entry_len++;
                                    continue;
                            }
                            next = split_blame_at(e, entry_len,
                                            blame_origin_incref(e->suspect));
                    }
                    if (line_blames[i].is_parent) {
                            e->ignored = 1;
                            blame_origin_decref(e->suspect);
                            e->suspect = blame_origin_incref(parent);
                            e->s_lno = line_blames[i - entry_len + 1].s_lno;
                            e->next = *ignoredp;
                            *ignoredp = e;
                    } else {
                            e->unblamable = 1;
                            /* e->s_lno is already in the target's address space. */
                            e->next = *diffp;
                            *diffp = e;
                    }
                    assert(e->num_lines == entry_len);
                    e = next;
                    entry_len = 1;
            }
            assert(!e);
    }

    /*
    * Process one hunk from the patch between the current suspect for
    * blame_entry e and its parent.  This first blames any unfinished
    * entries before the chunk (which is where target and parent start
    * differing) on the parent, and then splits blame entries at the
    * start and at the end of the difference region.  Since use of -M and
    * -C options may lead to overlapping/duplicate source line number
    * ranges, all we can rely on from sorting/merging is the order of the
    * first suspect line number.
    *
    * tlno: line number in the target where this chunk begins
    * same: line number in the target where this chunk ends
    * offset: add to tlno to get the chunk starting point in the parent
    * parent_len: number of lines in the parent chunk
    */
    static void blame_chunk(struct blame_entry ***dstq, struct blame_entry ***srcq,
                            int tlno, int offset, int same, int parent_len,
                            struct blame_origin *parent,
                            struct blame_origin *target, int ignore_diffs)
    {
            struct blame_entry *e = **srcq;
            struct blame_entry *samep = NULL, *diffp = NULL, *ignoredp = NULL;
            struct blame_line_tracker *line_blames = NULL;

            while (e && e->s_lno < tlno) {
                    struct blame_entry *next = e->next;
                    /*
                    * current record starts before differing portion.  If
                    * it reaches into it, we need to split it up and
                    * examine the second part separately.
                    */
                    if (e->s_lno + e->num_lines > tlno) {
                            /* Move second half to a new record */
                            struct blame_entry *n;

                            n = split_blame_at(e, tlno - e->s_lno, e->suspect);
                            /* Push new record to diffp */
                            n->next = diffp;
                            diffp = n;
                    } else
                            blame_origin_decref(e->suspect);
                    /* Pass blame for everything before the differing
                    * chunk to the parent */
                    e->suspect = blame_origin_incref(parent);
                    e->s_lno += offset;
                    e->next = samep;
                    samep = e;
                    e = next;
            }
            /*
            * As we don't know how much of a common stretch after this
            * diff will occur, the currently blamed parts are all that we
            * can assign to the parent for now.
            */

            if (samep) {
                    **dstq = reverse_blame(samep, **dstq);
                    *dstq = &samep->next;
            }
            /*
            * Prepend the split off portions: everything after e starts
            * after the blameable portion.
            */
            e = reverse_blame(diffp, e);

            /*
            * Now retain records on the target while parts are different
            * from the parent.
            */
            samep = NULL;
            diffp = NULL;

            if (ignore_diffs && same - tlno > 0) {
                    CALLOC_ARRAY(line_blames, same - tlno);
                    guess_line_blames(parent, target, tlno, offset, same,
                                    parent_len, line_blames);
            }

            while (e && e->s_lno < same) {
                    struct blame_entry *next = e->next;

                    /*
                    * If current record extends into sameness, need to split.
                    */
                    if (e->s_lno + e->num_lines > same) {
                            /*
                            * Move second half to a new record to be
                            * processed by later chunks
                            */
                            struct blame_entry *n;

                            n = split_blame_at(e, same - e->s_lno,
                                            blame_origin_incref(e->suspect));
                            /* Push new record to samep */
                            n->next = samep;
                            samep = n;
                    }
                    if (ignore_diffs) {
                            ignore_blame_entry(e, parent, &diffp, &ignoredp,
                                            line_blames + e->s_lno - tlno);
                    } else {
                            e->next = diffp;
                            diffp = e;
                    }
                    e = next;
            }
            free(line_blames);
            if (ignoredp) {
                    /*
                    * Note ignoredp is not sorted yet, and thus neither is dstq.
                    * That list must be sorted before we queue_blames().  We defer
                    * sorting until after all diff hunks are processed, so that
                    * guess_line_blames() can pick *any* line in the parent.  The
                    * slight drawback is that we end up sorting all blame entries
                    * passed to the parent, including those that are unrelated to
                    * changes made by the ignored commit.
                    */
                    **dstq = reverse_blame(ignoredp, **dstq);
                    *dstq = &ignoredp->next;
            }
            **srcq = reverse_blame(diffp, reverse_blame(samep, e));
            /* Move across elements that are in the unblamable portion */
            if (diffp)
                    *srcq = &diffp->next;
    }

    struct blame_chunk_cb_data {
            struct blame_origin *parent;
            struct blame_origin *target;
            long offset;
            int ignore_diffs;
            struct blame_entry **dstq;
            struct blame_entry **srcq;
    };

    /* diff chunks are from parent to target */
    static int blame_chunk_cb(long start_a, long count_a,
                            long start_b, long count_b, void *data)
    {
            struct blame_chunk_cb_data *d = data;
            if (start_a - start_b != d->offset)
                    die("internal error in blame::blame_chunk_cb");
            blame_chunk(&d->dstq, &d->srcq, start_b, start_a - start_b,
                    start_b + count_b, count_a, d->parent, d->target,
                    d->ignore_diffs);
            d->offset = start_a + count_a - (start_b + count_b);
            return 0;
    }

    /*
    * We are looking at the origin 'target' and aiming to pass blame
    * for the lines it is suspected to its parent.  Run diff to find
    * which lines came from parent and pass blame for them.
    */
    static void pass_blame_to_parent(struct blame_scoreboard *sb,
                                    struct blame_origin *target,
                                    struct blame_origin *parent, int ignore_diffs)
    {
            mmfile_t file_p, file_o;
            struct blame_chunk_cb_data d;
            struct blame_entry *newdest = NULL;

            if (!target->suspects)
                    return; /* nothing remains for this target */

            d.parent = parent;
            d.target = target;
            d.offset = 0;
            d.ignore_diffs = ignore_diffs;
            d.dstq = &newdest; d.srcq = &target->suspects;

            fill_origin_blob(&sb->revs->diffopt, parent, &file_p,
                            &sb->num_read_blob, ignore_diffs);
            fill_origin_blob(&sb->revs->diffopt, target, &file_o,
                            &sb->num_read_blob, ignore_diffs);
            sb->num_get_patch++;

            if (diff_hunks(&file_p, &file_o, blame_chunk_cb, &d, sb->xdl_opts))
                    die("unable to generate diff (%s -> %s)",
                    oid_to_hex(&parent->commit->object.oid),
                    oid_to_hex(&target->commit->object.oid));
            /* The rest are the same as the parent */
            blame_chunk(&d.dstq, &d.srcq, INT_MAX, d.offset, INT_MAX, 0,
                    parent, target, 0);
            *d.dstq = NULL;
            if (ignore_diffs)
                    sort_blame_entries(&newdest, compare_blame_suspect);
            queue_blames(sb, parent, newdest);

            return;
    }

    /*
    * The lines in blame_entry after splitting blames many times can become
    * very small and trivial, and at some point it becomes pointless to
    * blame the parents.  E.g. "\t\t}\n\t}\n\n" appears everywhere in any
    * ordinary C program, and it is not worth to say it was copied from
    * totally unrelated file in the parent.
    *
    * Compute how trivial the lines in the blame_entry are.
    */
    unsigned blame_entry_score(struct blame_scoreboard *sb, struct blame_entry *e)
    {
            unsigned score;
            const char *cp, *ep;

            if (e->score)
                    return e->score;

            score = 1;
            cp = blame_nth_line(sb, e->lno);
            ep = blame_nth_line(sb, e->lno + e->num_lines);
            while (cp < ep) {
                    unsigned ch = *((unsigned char *)cp);
                    if (isalnum(ch))
                            score++;
                    cp++;
            }
            e->score = score;
            return score;
    }

    /*
    * best_so_far[] and potential[] are both a split of an existing blame_entry
    * that passes blame to the parent.  Maintain best_so_far the best split so
    * far, by comparing potential and best_so_far and copying potential into
    * bst_so_far as needed.
    */
    static void copy_split_if_better(struct blame_scoreboard *sb,
                                    struct blame_entry *best_so_far,
                                    struct blame_entry *potential)
    {
            int i;

            if (!potential[1].suspect)
                    return;
            if (best_so_far[1].suspect) {
                    if (blame_entry_score(sb, &potential[1]) <
                    blame_entry_score(sb, &best_so_far[1]))
                            return;
            }

            for (i = 0; i < 3; i++)
                    blame_origin_incref(potential[i].suspect);
            decref_split(best_so_far);
            memcpy(best_so_far, potential, sizeof(struct blame_entry[3]));
    }

    /*
    * We are looking at a part of the final image represented by
    * ent (tlno and same are offset by ent->s_lno).
    * tlno is where we are looking at in the final image.
    * up to (but not including) same match preimage.
    * plno is where we are looking at in the preimage.
    *
    * <-------------- final image ---------------------->
    *       <------ent------>
    *         ^tlno ^same
    *    <---------preimage----->
    *         ^plno
    *
    * All line numbers are 0-based.
    */
    static void handle_split(struct blame_scoreboard *sb,
                            struct blame_entry *ent,
                            int tlno, int plno, int same,
                            struct blame_origin *parent,
                            struct blame_entry *split)
    {
            if (ent->num_lines <= tlno)
                    return;
            if (tlno < same) {
                    struct blame_entry potential[3];
                    tlno += ent->s_lno;
                    same += ent->s_lno;
                    split_overlap(potential, ent, tlno, plno, same, parent);
                    copy_split_if_better(sb, split, potential);
                    decref_split(potential);
            }
    }

    struct handle_split_cb_data {
            struct blame_scoreboard *sb;
            struct blame_entry *ent;
            struct blame_origin *parent;
            struct blame_entry *split;
            long plno;
            long tlno;
    };

    static int handle_split_cb(long start_a, long count_a,
                            long start_b, long count_b, void *data)
    {
            struct handle_split_cb_data *d = data;
            handle_split(d->sb, d->ent, d->tlno, d->plno, start_b, d->parent,
                    d->split);
            d->plno = start_a + count_a;
            d->tlno = start_b + count_b;
            return 0;
    }

    /*
    * Find the lines from parent that are the same as ent so that
    * we can pass blames to it.  file_p has the blob contents for
    * the parent.
    */
    static void find_copy_in_blob(struct blame_scoreboard *sb,
                            struct blame_entry *ent,
                            struct blame_origin *parent,
                            struct blame_entry *split,
                            mmfile_t *file_p)
    {
            const char *cp;
            mmfile_t file_o;
            struct handle_split_cb_data d;

            memset(&d, 0, sizeof(d));
            d.sb = sb; d.ent = ent; d.parent = parent; d.split = split;
            /*
            * Prepare mmfile that contains only the lines in ent.
            */
            cp = blame_nth_line(sb, ent->lno);
            file_o.ptr = (char *) cp;
            file_o.size = blame_nth_line(sb, ent->lno + ent->num_lines) - cp;

            /*
            * file_o is a part of final image we are annotating.
            * file_p partially may match that image.
            */
            memset(split, 0, sizeof(struct blame_entry [3]));
            if (diff_hunks(file_p, &file_o, handle_split_cb, &d, sb->xdl_opts))
                    die("unable to generate diff (%s)",
                    oid_to_hex(&parent->commit->object.oid));
            /* remainder, if any, all match the preimage */
            handle_split(sb, ent, d.tlno, d.plno, ent->num_lines, parent, split);
    }

    /* Move all blame entries from list *source that have a score smaller
    * than score_min to the front of list *small.
    * Returns a pointer to the link pointing to the old head of the small list.
    */

    static struct blame_entry **filter_small(struct blame_scoreboard *sb,
                                            struct blame_entry **small,
                                            struct blame_entry **source,
                                            unsigned score_min)
    {
            struct blame_entry *p = *source;
            struct blame_entry *oldsmall = *small;
            while (p) {
                    if (blame_entry_score(sb, p) <= score_min) {
                            *small = p;
                            small = &p->next;
                            p = *small;
                    } else {
                            *source = p;
                            source = &p->next;
                            p = *source;
                    }
            }
            *small = oldsmall;
            *source = NULL;
            return small;
    }

    /*
    * See if lines currently target is suspected for can be attributed to
    * parent.
    */
    static void find_move_in_parent(struct blame_scoreboard *sb,
                                    struct blame_entry ***blamed,
                                    struct blame_entry **toosmall,
                                    struct blame_origin *target,
                                    struct blame_origin *parent)
    {
            struct blame_entry *e, split[3];
            struct blame_entry *unblamed = target->suspects;
            struct blame_entry *leftover = NULL;
            mmfile_t file_p;

            if (!unblamed)
                    return; /* nothing remains for this target */

            fill_origin_blob(&sb->revs->diffopt, parent, &file_p,
                            &sb->num_read_blob, 0);
            if (!file_p.ptr)
                    return;

            /* At each iteration, unblamed has a NULL-terminated list of
            * entries that have not yet been tested for blame.  leftover
            * contains the reversed list of entries that have been tested
            * without being assignable to the parent.
            */
            do {
                    struct blame_entry **unblamedtail = &unblamed;
                    struct blame_entry *next;
                    for (e = unblamed; e; e = next) {
                            next = e->next;
                            find_copy_in_blob(sb, e, parent, split, &file_p);
                            if (split[1].suspect &&
                            sb->move_score < blame_entry_score(sb, &split[1])) {
                                    split_blame(blamed, &unblamedtail, split, e);
                            } else {
                                    e->next = leftover;
                                    leftover = e;
                            }
                            decref_split(split);
                    }
                    *unblamedtail = NULL;
                    toosmall = filter_small(sb, toosmall, &unblamed, sb->move_score);
            } while (unblamed);
            target->suspects = reverse_blame(leftover, NULL);
    }

    struct blame_list {
            struct blame_entry *ent;
            struct blame_entry split[3];
    };

    /*
    * Count the number of entries the target is suspected for,
    * and prepare a list of entry and the best split.
    */
    static struct blame_list *setup_blame_list(struct blame_entry *unblamed,
                                            int *num_ents_p)
    {
            struct blame_entry *e;
            int num_ents, i;
            struct blame_list *blame_list = NULL;

            for (e = unblamed, num_ents = 0; e; e = e->next)
                    num_ents++;
            if (num_ents) {
                    CALLOC_ARRAY(blame_list, num_ents);
                    for (e = unblamed, i = 0; e; e = e->next)
                            blame_list[i++].ent = e;
            }
            *num_ents_p = num_ents;
            return blame_list;
    }

    /*
    * For lines target is suspected for, see if we can find code movement
    * across file boundary from the parent commit.  porigin is the path
    * in the parent we already tried.
    */
    static void find_copy_in_parent(struct blame_scoreboard *sb,
                                    struct blame_entry ***blamed,
                                    struct blame_entry **toosmall,
                                    struct blame_origin *target,
                                    struct commit *parent,
                                    struct blame_origin *porigin,
                                    int opt)
    {
            struct diff_options diff_opts;
            int i, j;
            struct blame_list *blame_list;
            int num_ents;
            struct blame_entry *unblamed = target->suspects;
            struct blame_entry *leftover = NULL;

            if (!unblamed)
                    return; /* nothing remains for this target */

            repo_diff_setup(sb->repo, &diff_opts);
            diff_opts.flags.recursive = 1;
            diff_opts.output_format = DIFF_FORMAT_NO_OUTPUT;

            diff_setup_done(&diff_opts);

            /* Try "find copies harder" on new path if requested;
            * we do not want to use diffcore_rename() actually to
            * match things up; find_copies_harder is set only to
            * force diff_tree_oid() to feed all filepairs to diff_queue,
            * and this code needs to be after diff_setup_done(), which
            * usually makes find-copies-harder imply copy detection.
            */
            if ((opt & PICKAXE_BLAME_COPY_HARDEST)
            || ((opt & PICKAXE_BLAME_COPY_HARDER)
                    && (!porigin || strcmp(target->path, porigin->path))))
                    diff_opts.flags.find_copies_harder = 1;

            if (is_null_oid(&target->commit->object.oid))
                    do_diff_cache(get_commit_tree_oid(parent), &diff_opts);
            else
                    diff_tree_oid(get_commit_tree_oid(parent),
                            get_commit_tree_oid(target->commit),
                            "", &diff_opts);

            if (!diff_opts.flags.find_copies_harder)
                    diffcore_std(&diff_opts);

            do {
                    struct blame_entry **unblamedtail = &unblamed;
                    blame_list = setup_blame_list(unblamed, &num_ents);

                    for (i = 0; i < diff_queued_diff.nr; i++) {
                            struct diff_filepair *p = diff_queued_diff.queue[i];
                            struct blame_origin *norigin;
                            mmfile_t file_p;
                            struct blame_entry potential[3];

                            if (!DIFF_FILE_VALID(p->one))
                                    continue; /* does not exist in parent */
                            if (S_ISGITLINK(p->one->mode))
                                    continue; /* ignore git links */
                            if (porigin && !strcmp(p->one->path, porigin->path))
                                    /* find_move already dealt with this path */
                                    continue;

                            norigin = get_origin(parent, p->one->path);
                            oidcpy(&norigin->blob_oid, &p->one->oid);
                            norigin->mode = p->one->mode;
                            fill_origin_blob(&sb->revs->diffopt, norigin, &file_p,
                                            &sb->num_read_blob, 0);
                            if (!file_p.ptr)
                                    continue;

                            for (j = 0; j < num_ents; j++) {
                                    find_copy_in_blob(sb, blame_list[j].ent,
                                                    norigin, potential, &file_p);
                                    copy_split_if_better(sb, blame_list[j].split,
                                                    potential);
                                    decref_split(potential);
                            }
                            blame_origin_decref(norigin);
                    }

                    for (j = 0; j < num_ents; j++) {
                            struct blame_entry *split = blame_list[j].split;
                            if (split[1].suspect &&
                            sb->copy_score < blame_entry_score(sb, &split[1])) {
                                    split_blame(blamed, &unblamedtail, split,
                                            blame_list[j].ent);
                            } else {
                                    blame_list[j].ent->next = leftover;
                                    leftover = blame_list[j].ent;
                            }
                            decref_split(split);
                    }
                    free(blame_list);
                    *unblamedtail = NULL;
                    toosmall = filter_small(sb, toosmall, &unblamed, sb->copy_score);
            } while (unblamed);
            target->suspects = reverse_blame(leftover, NULL);
            diff_flush(&diff_opts);
    }

    /*
    * The blobs of origin and porigin exactly match, so everything
    * origin is suspected for can be blamed on the parent.
    */
    static void pass_whole_blame(struct blame_scoreboard *sb,
                            struct blame_origin *origin, struct blame_origin *porigin)
    {
            struct blame_entry *e, *suspects;

            if (!porigin->file.ptr && origin->file.ptr) {
                    /* Steal its file */
                    porigin->file = origin->file;
                    origin->file.ptr = NULL;
            }
            suspects = origin->suspects;
            origin->suspects = NULL;
            for (e = suspects; e; e = e->next) {
                    blame_origin_incref(porigin);
                    blame_origin_decref(e->suspect);
                    e->suspect = porigin;
            }
            queue_blames(sb, porigin, suspects);
    }

    /*
    * We pass blame from the current commit to its parents.  We keep saying
    * "parent" (and "porigin"), but what we mean is to find scapegoat to
    * exonerate ourselves.
    */
    static struct commit_list *first_scapegoat(struct rev_info *revs, struct commit *commit,
                                            int reverse)
    {
            if (!reverse) {
                    if (revs->first_parent_only &&
                    commit->parents &&
                    commit->parents->next) {
                            free_commit_list(commit->parents->next);
                            commit->parents->next = NULL;
                    }
                    return commit->parents;
            }
            return lookup_decoration(&revs->children, &commit->object);
    }

    static int num_scapegoats(struct rev_info *revs, struct commit *commit, int reverse)
    {
            struct commit_list *l = first_scapegoat(revs, commit, reverse);
            return commit_list_count(l);
    }

    /* Distribute collected unsorted blames to the respected sorted lists
    * in the various origins.
    */
    static void distribute_blame(struct blame_scoreboard *sb, struct blame_entry *blamed)
    {
            sort_blame_entries(&blamed, compare_blame_suspect);
            while (blamed)
            {
                    struct blame_origin *porigin = blamed->suspect;
                    struct blame_entry *suspects = NULL;
                    do {
                            struct blame_entry *next = blamed->next;
                            blamed->next = suspects;
                            suspects = blamed;
                            blamed = next;
                    } while (blamed && blamed->suspect == porigin);
                    suspects = reverse_blame(suspects, NULL);
                    queue_blames(sb, porigin, suspects);
            }
    }

    #define MAXSG 16

    typedef struct blame_origin *(*blame_find_alg)(struct repository *,
                                            struct commit *,
                                            struct blame_origin *,
                                            struct blame_bloom_data *);

    static void pass_blame(struct blame_scoreboard *sb, struct blame_origin *origin, int opt)
    {
            struct rev_info *revs = sb->revs;
            int i, pass, num_sg;
            struct commit *commit = origin->commit;
            struct commit_list *sg;
            struct blame_origin *sg_buf[MAXSG];
            struct blame_origin *porigin, **sg_origin = sg_buf;
            struct blame_entry *toosmall = NULL;
            struct blame_entry *blames, **blametail = &blames;

            num_sg = num_scapegoats(revs, commit, sb->reverse);
            if (!num_sg)
                    goto finish;
            else if (num_sg < ARRAY_SIZE(sg_buf))
                    memset(sg_buf, 0, sizeof(sg_buf));
            else
                    CALLOC_ARRAY(sg_origin, num_sg);

            /*
            * The first pass looks for unrenamed path to optimize for
            * common cases, then we look for renames in the second pass.
            */
            for (pass = 0; pass < 2 - sb->no_whole_file_rename; pass++) {
                    blame_find_alg find = pass ? find_rename : find_origin;

                    for (i = 0, sg = first_scapegoat(revs, commit, sb->reverse);
                    i < num_sg && sg;
                    sg = sg->next, i++) {
                            struct commit *p = sg->item;
                            int j, same;

                            if (sg_origin[i])
                                    continue;
                            if (repo_parse_commit(the_repository, p))
                                    continue;
                            porigin = find(sb->repo, p, origin, sb->bloom_data);
                            if (!porigin)
                                    continue;
                            if (oideq(&porigin->blob_oid, &origin->blob_oid)) {
                                    pass_whole_blame(sb, origin, porigin);
                                    blame_origin_decref(porigin);
                                    goto finish;
                            }
                            for (j = same = 0; j < i; j++)
                                    if (sg_origin[j] &&
                                    oideq(&sg_origin[j]->blob_oid, &porigin->blob_oid)) {
                                            same = 1;
                                            break;
                                    }
                            if (!same)
                                    sg_origin[i] = porigin;
                            else
                                    blame_origin_decref(porigin);
                    }
            }

            sb->num_commits++;
            for (i = 0, sg = first_scapegoat(revs, commit, sb->reverse);
            i < num_sg && sg;
            sg = sg->next, i++) {
                    struct blame_origin *porigin = sg_origin[i];
                    if (!porigin)
                            continue;
                    if (!origin->previous) {
                            blame_origin_incref(porigin);
                            origin->previous = porigin;
                    }
                    pass_blame_to_parent(sb, origin, porigin, 0);
                    if (!origin->suspects)
                            goto finish;
            }

            /*
            * Pass remaining suspects for ignored commits to their parents.
            */
            if (oidset_contains(&sb->ignore_list, &commit->object.oid)) {
                    for (i = 0, sg = first_scapegoat(revs, commit, sb->reverse);
                    i < num_sg && sg;
                    sg = sg->next, i++) {
                            struct blame_origin *porigin = sg_origin[i];

                            if (!porigin)
                                    continue;
                            pass_blame_to_parent(sb, origin, porigin, 1);
                            /*
                            * Preemptively drop porigin so we can refresh the
                            * fingerprints if we use the parent again, which can
                            * occur if you ignore back-to-back commits.
                            */
                            drop_origin_blob(porigin);
                            if (!origin->suspects)
                                    goto finish;
                    }
            }

            /*
            * Optionally find moves in parents' files.
            */
            if (opt & PICKAXE_BLAME_MOVE) {
                    filter_small(sb, &toosmall, &origin->suspects, sb->move_score);
                    if (origin->suspects) {
                            for (i = 0, sg = first_scapegoat(revs, commit, sb->reverse);
                            i < num_sg && sg;
                            sg = sg->next, i++) {
                                    struct blame_origin *porigin = sg_origin[i];
                                    if (!porigin)
                                            continue;
                                    find_move_in_parent(sb, &blametail, &toosmall, origin, porigin);
                                    if (!origin->suspects)
                                            break;
                            }
                    }
            }

            /*
            * Optionally find copies from parents' files.
            */
            if (opt & PICKAXE_BLAME_COPY) {
                    if (sb->copy_score > sb->move_score)
                            filter_small(sb, &toosmall, &origin->suspects, sb->copy_score);
                    else if (sb->copy_score < sb->move_score) {
                            origin->suspects = blame_merge(origin->suspects, toosmall);
                            toosmall = NULL;
                            filter_small(sb, &toosmall, &origin->suspects, sb->copy_score);
                    }
                    if (!origin->suspects)
                            goto finish;

                    for (i = 0, sg = first_scapegoat(revs, commit, sb->reverse);
                    i < num_sg && sg;
                    sg = sg->next, i++) {
                            struct blame_origin *porigin = sg_origin[i];
                            find_copy_in_parent(sb, &blametail, &toosmall,
                                            origin, sg->item, porigin, opt);
                            if (!origin->suspects)
                                    goto finish;
                    }
            }

    finish:
            *blametail = NULL;
            distribute_blame(sb, blames);
            /*
            * prepend toosmall to origin->suspects
            *
            * There is no point in sorting: this ends up on a big
            * unsorted list in the caller anyway.
            */
            if (toosmall) {
                    struct blame_entry **tail = &toosmall;
                    while (*tail)
                            tail = &(*tail)->next;
                    *tail = origin->suspects;
                    origin->suspects = toosmall;
            }
            for (i = 0; i < num_sg; i++) {
                    if (sg_origin[i]) {
                            if (!sg_origin[i]->suspects)
                                    drop_origin_blob(sg_origin[i]);
                            blame_origin_decref(sg_origin[i]);
                    }
            }
            drop_origin_blob(origin);
            if (sg_buf != sg_origin)
                    free(sg_origin);
    }

    /*
    * The main loop -- while we have blobs with lines whose true origin
    * is still unknown, pick one blob, and allow its lines to pass blames
    * to its parents. */
    void assign_blame(struct blame_scoreboard *sb, int opt)
    {
            struct rev_info *revs = sb->revs;
            struct commit *commit = prio_queue_get(&sb->commits);

            while (commit) {
                    struct blame_entry *ent;
                    struct blame_origin *suspect = get_blame_suspects(commit);

                    /* find one suspect to break down */
                    while (suspect && !suspect->suspects)
                            suspect = suspect->next;

                    if (!suspect) {
                            commit = prio_queue_get(&sb->commits);
                            continue;
                    }

                    assert(commit == suspect->commit);

                    /*
                    * We will use this suspect later in the loop,
                    * so hold onto it in the meantime.
                    */
                    blame_origin_incref(suspect);
                    repo_parse_commit(the_repository, commit);
                    if (sb->reverse ||
                    (!(commit->object.flags & UNINTERESTING) &&
                    !(revs->max_age != -1 && commit->date < revs->max_age)))
                            pass_blame(sb, suspect, opt);
                    else {
                            commit->object.flags |= UNINTERESTING;
                            if (commit->object.parsed)
                                    mark_parents_uninteresting(sb->revs, commit);
                    }
                    /* treat root commit as boundary */
                    if (!commit->parents && !sb->show_root)
                            commit->object.flags |= UNINTERESTING;

                    /* Take responsibility for the remaining entries */
                    ent = suspect->suspects;
                    if (ent) {
                            suspect->guilty = 1;
                            for (;;) {
                                    struct blame_entry *next = ent->next;
                                    if (sb->found_guilty_entry)
                                            sb->found_guilty_entry(ent, sb->found_guilty_entry_data);
                                    if (next) {
                                            ent = next;
                                            continue;
                                    }
                                    ent->next = sb->ent;
                                    sb->ent = suspect->suspects;
                                    suspect->suspects = NULL;
                                    break;
                            }
                    }
                    blame_origin_decref(suspect);

                    if (sb->debug) /* sanity */
                            sanity_check_refcnt(sb);
            }
    }

    /*
    * To allow quick access to the contents of nth line in the
    * final image, prepare an index in the scoreboard.
    */
    static int prepare_lines(struct blame_scoreboard *sb)
    {
            sb->num_lines = find_line_starts(&sb->lineno, sb->final_buf,
                                            sb->final_buf_size);
            return sb->num_lines;
    }

    static struct commit *find_single_final(struct rev_info *revs,
                                            const char **name_p)
    {
            int i;
            struct commit *found = NULL;
            const char *name = NULL;

            for (i = 0; i < revs->pending.nr; i++) {
                    struct object *obj = revs->pending.objects[i].item;
                    if (obj->flags & UNINTERESTING)
                            continue;
                    obj = deref_tag(revs->repo, obj, NULL, 0);
                    if (!obj || obj->type != OBJ_COMMIT)
                            die("Non commit %s?", revs->pending.objects[i].name);
                    if (found)
                            die("More than one commit to dig from %s and %s?",
                            revs->pending.objects[i].name, name);
                    found = (struct commit *)obj;
                    name = revs->pending.objects[i].name;
            }
            if (name_p)
                    *name_p = xstrdup_or_null(name);
            return found;
    }

    static struct commit *dwim_reverse_initial(struct rev_info *revs,
                                            const char **name_p)
    {
            /*
            * DWIM "git blame --reverse ONE -- PATH" as
            * "git blame --reverse ONE..HEAD -- PATH" but only do so
            * when it makes sense.
            */
            struct object *obj;
            struct commit *head_commit;
            struct object_id head_oid;

            if (revs->pending.nr != 1)
                    return NULL;

            /* Is that sole rev a committish? */
            obj = revs->pending.objects[0].item;
            obj = deref_tag(revs->repo, obj, NULL, 0);
            if (!obj || obj->type != OBJ_COMMIT)
                    return NULL;

            /* Do we have HEAD? */
            if (!refs_resolve_ref_unsafe(get_main_ref_store(the_repository), "HEAD", RESOLVE_REF_READING, &head_oid, NULL))
                    return NULL;
            head_commit = lookup_commit_reference_gently(revs->repo,
                                                    &head_oid, 1);
            if (!head_commit)
                    return NULL;

            /* Turn "ONE" into "ONE..HEAD" then */
            obj->flags |= UNINTERESTING;
            add_pending_object(revs, &head_commit->object, "HEAD");

            if (name_p)
                    *name_p = revs->pending.objects[0].name;
            return (struct commit *)obj;
    }

    static struct commit *find_single_initial(struct rev_info *revs,
                                            const char **name_p)
    {
            int i;
            struct commit *found = NULL;
            const char *name = NULL;

            /*
            * There must be one and only one negative commit, and it must be
            * the boundary.
            */
            for (i = 0; i < revs->pending.nr; i++) {
                    struct object *obj = revs->pending.objects[i].item;
                    if (!(obj->flags & UNINTERESTING))
                            continue;
                    obj = deref_tag(revs->repo, obj, NULL, 0);
                    if (!obj || obj->type != OBJ_COMMIT)
                            die("Non commit %s?", revs->pending.objects[i].name);
                    if (found)
                            die("More than one commit to dig up from, %s and %s?",
                            revs->pending.objects[i].name, name);
                    found = (struct commit *) obj;
                    name = revs->pending.objects[i].name;
            }

            if (!name)
                    found = dwim_reverse_initial(revs, &name);
            if (!name)
                    die("No commit to dig up from?");

            if (name_p)
                    *name_p = xstrdup(name);
            return found;
    }

    void init_scoreboard(struct blame_scoreboard *sb)
    {
            memset(sb, 0, sizeof(struct blame_scoreboard));
            sb->move_score = BLAME_DEFAULT_MOVE_SCORE;
            sb->copy_score = BLAME_DEFAULT_COPY_SCORE;
    }

    void setup_scoreboard(struct blame_scoreboard *sb,
                    struct blame_origin **orig)
    {
            const char *final_commit_name = NULL;
            struct blame_origin *o;
            struct commit *final_commit = NULL;
            enum object_type type;

            init_blame_suspects(&blame_suspects);

            if (sb->reverse && sb->contents_from)
                    die(_("--contents and --reverse do not blend well."));

            if (!sb->repo)
                    BUG("repo is NULL");

            if (!sb->reverse) {
                    sb->final = find_single_final(sb->revs, &final_commit_name);
                    sb->commits.compare = compare_commits_by_commit_date;
            } else {
                    sb->final = find_single_initial(sb->revs, &final_commit_name);
                    sb->commits.compare = compare_commits_by_reverse_commit_date;
            }

            if (sb->reverse && sb->revs->first_parent_only)
                    sb->revs->children.name = NULL;

            if (sb->contents_from || !sb->final) {
                    struct object_id head_oid, *parent_oid;

                    /*
                    * Build a fake commit at the top of the history, when
                    * (1) "git blame [^A] --path", i.e. with no positive end
                    *     of the history range, in which case we build such
                    *     a fake commit on top of the HEAD to blame in-tree
                    *     modifications.
                    * (2) "git blame --contents=file [A] -- path", with or
                    *     without positive end of the history range but with
                    *     --contents, in which case we pretend that there is
                    *     a fake commit on top of the positive end (defaulting to
                    *     HEAD) that has the given contents in the path.
                    */
                    if (sb->final) {
                            parent_oid = &sb->final->object.oid;
                    } else {
                            if (!refs_resolve_ref_unsafe(get_main_ref_store(the_repository), "HEAD", RESOLVE_REF_READING, &head_oid, NULL))
                                    die("no such ref: HEAD");
                            parent_oid = &head_oid;
                    }

                    if (!sb->contents_from)
                            setup_work_tree();

                    sb->final = fake_working_tree_commit(sb->repo,
                                                    &sb->revs->diffopt,
                                                    sb->path, sb->contents_from,
                                                    parent_oid);
                    add_pending_object(sb->revs, &(sb->final->object), ":");
            }

            if (sb->reverse && sb->revs->first_parent_only) {
                    final_commit = find_single_final(sb->revs, NULL);
                    if (!final_commit)
                            die(_("--reverse and --first-parent together require specified latest commit"));
            }

            /*
            * If we have bottom, this will mark the ancestors of the
            * bottom commits we would reach while traversing as
            * uninteresting.
            */
            if (prepare_revision_walk(sb->revs))
                    die(_("revision walk setup failed"));

            if (sb->reverse && sb->revs->first_parent_only) {
                    struct commit *c = final_commit;

                    sb->revs->children.name = "children";
                    while (c->parents &&
                    !oideq(&c->object.oid, &sb->final->object.oid)) {
                            struct commit_list *l = xcalloc(1, sizeof(*l));

                            l->item = c;
                            if (add_decoration(&sb->revs->children,
                                            &c->parents->item->object, l))
                                    BUG("not unique item in first-parent chain");
                            c = c->parents->item;
                    }

                    if (!oideq(&c->object.oid, &sb->final->object.oid))
                            die(_("--reverse --first-parent together require range along first-parent chain"));
            }

            if (is_null_oid(&sb->final->object.oid)) {
                    o = get_blame_suspects(sb->final);
                    sb->final_buf = xmemdupz(o->file.ptr, o->file.size);
                    sb->final_buf_size = o->file.size;
            }
            else {
                    o = get_origin(sb->final, sb->path);
                    if (fill_blob_sha1_and_mode(sb->repo, o))
                            die(_("no such path %s in %s"), sb->path, final_commit_name);

                    if (sb->revs->diffopt.flags.allow_textconv &&
                    textconv_object(sb->repo, sb->path, o->mode, &o->blob_oid, 1, (char **) &sb->final_buf,
                                    &sb->final_buf_size))
                            ;
                    else
                            sb->final_buf = repo_read_object_file(the_repository,
                                                            &o->blob_oid,
                                                            &type,
                                                            &sb->final_buf_size);

                    if (!sb->final_buf)
                            die(_("cannot read blob %s for path %s"),
                            oid_to_hex(&o->blob_oid),
                            sb->path);
            }
            sb->num_read_blob++;
            prepare_lines(sb);

            if (orig)
                    *orig = o;

            free((char *)final_commit_name);
    }



    struct blame_entry *blame_entry_prepend(struct blame_entry *head,
                                            long start, long end,
                                            struct blame_origin *o)
    {
            struct blame_entry *new_head = xcalloc(1, sizeof(struct blame_entry));
            new_head->lno = start;
            new_head->num_lines = end - start;
            new_head->suspect = o;
            new_head->s_lno = start;
            new_head->next = head;
            blame_origin_incref(o);
            return new_head;
    }

    void setup_blame_bloom_data(struct blame_scoreboard *sb)
    {
            struct blame_bloom_data *bd;
            struct bloom_filter_settings *bs;

            if (!sb->repo->objects->commit_graph)
                    return;

            bs = get_bloom_filter_settings(sb->repo);
            if (!bs)
                    return;

            bd = xmalloc(sizeof(struct blame_bloom_data));

            bd->settings = bs;

            bd->alloc = 4;
            bd->nr = 0;
            ALLOC_ARRAY(bd->keys, bd->alloc);

            add_bloom_key(bd, sb->path);

            sb->bloom_data = bd;
    }

    void cleanup_scoreboard(struct blame_scoreboard *sb)
    {
            free(sb->lineno);
            free(sb->final_buf);
            clear_prio_queue(&sb->commits);
            oidset_clear(&sb->ignore_list);

            if (sb->bloom_data) {
                    int i;
                    for (i = 0; i < sb->bloom_data->nr; i++) {
                            free(sb->bloom_data->keys[i]->hashes);
                            free(sb->bloom_data->keys[i]);
                    }
                    free(sb->bloom_data->keys);
                    FREE_AND_NULL(sb->bloom_data);

                    trace2_data_intmax("blame", sb->repo,
                                    "bloom/queries", bloom_count_queries);
                    trace2_data_intmax("blame", sb->repo,
                                    "bloom/response-no", bloom_count_no);
            }


    }


    """,

    "error":"z/OS often uses the EBCDIC character set by default, while Git expects ASCII/UTF-8 on most platforms.
            Without proper conversion, Git operations like blame could fail or produce incorrect results due to misinterpreted file content.",
    "error_category":"Functionality patch",
    "Corrected_Code":
    """
            #define USE_THE_REPOSITORY_VARIABLE
            #define DISABLE_SIGN_COMPARE_WARNINGS

            #include "git-compat-util.h"
            #include "refs.h"
            #include "object-store-ll.h"
            #include "cache-tree.h"
            #include "mergesort.h"
            #include "commit.h"
            #include "convert.h"
            #include "diff.h"
            #include "diffcore.h"
            #include "gettext.h"
            #include "hex.h"
            #include "path.h"
            #include "read-cache.h"
            #include "revision.h"
            #include "setup.h"
            #include "tag.h"
            #include "trace2.h"
            #include "blame.h"
            #include "alloc.h"
            #include "commit-slab.h"
            #include "bloom.h"
            #include "commit-graph.h"

            define_commit_slab(blame_suspects, struct blame_origin *);
            static struct blame_suspects blame_suspects;

            struct blame_origin *get_blame_suspects(struct commit *commit)
            {
                    struct blame_origin **result;

                    result = blame_suspects_peek(&blame_suspects, commit);

                    return result ? *result : NULL;
            }

            static void set_blame_suspects(struct commit *commit, struct blame_origin *origin)
            {
                    *blame_suspects_at(&blame_suspects, commit) = origin;
            }

            void blame_origin_decref(struct blame_origin *o)
            {
                    if (o && --o->refcnt <= 0) {
                            struct blame_origin *p, *l = NULL;
                            if (o->previous)
                                    blame_origin_decref(o->previous);
                            free(o->file.ptr);
                            /* Should be present exactly once in commit chain */
                            for (p = get_blame_suspects(o->commit); p; l = p, p = p->next) {
                                    if (p == o) {
                                            if (l)
                                                    l->next = p->next;
                                            else
                                                    set_blame_suspects(o->commit, p->next);
                                            free(o);
                                            return;
                                    }
                            }
                            die("internal error in blame_origin_decref");
                    }
            }

            /*
            * Given a commit and a path in it, create a new origin structure.
            * The callers that add blame to the scoreboard should use
            * get_origin() to obtain shared, refcounted copy instead of calling
            * this function directly.
            */
            static struct blame_origin *make_origin(struct commit *commit, const char *path)
            {
                    struct blame_origin *o;
                    FLEX_ALLOC_STR(o, path, path);
                    o->commit = commit;
                    o->refcnt = 1;
                    o->next = get_blame_suspects(commit);
                    set_blame_suspects(commit, o);
                    return o;
            }

            /*
            * Locate an existing origin or create a new one.
            * This moves the origin to front position in the commit util list.
            */
            static struct blame_origin *get_origin(struct commit *commit, const char *path)
            {
                    struct blame_origin *o, *l;

                    for (o = get_blame_suspects(commit), l = NULL; o; l = o, o = o->next) {
                            if (!strcmp(o->path, path)) {
                                    /* bump to front */
                                    if (l) {
                                            l->next = o->next;
                                            o->next = get_blame_suspects(commit);
                                            set_blame_suspects(commit, o);
                                    }
                                    return blame_origin_incref(o);
                            }
                    }
                    return make_origin(commit, path);
            }



            static void verify_working_tree_path(struct repository *r,
                                            struct commit *work_tree, const char *path)
            {
                    struct commit_list *parents;
                    int pos;

                    for (parents = work_tree->parents; parents; parents = parents->next) {
                            const struct object_id *commit_oid = &parents->item->object.oid;
                            struct object_id blob_oid;
                            unsigned short mode;

                            if (!get_tree_entry(r, commit_oid, path, &blob_oid, &mode) &&
                            oid_object_info(r, &blob_oid, NULL) == OBJ_BLOB)
                                    return;
                    }

                    pos = index_name_pos(r->index, path, strlen(path));
                    if (pos >= 0)
                            ; /* path is in the index */
                    else if (-1 - pos < r->index->cache_nr &&
                            !strcmp(r->index->cache[-1 - pos]->name, path))
                            ; /* path is in the index, unmerged */
                    else
                            die("no such path '%s' in HEAD", path);
            }

            static struct commit_list **append_parent(struct repository *r,
                                                    struct commit_list **tail,
                                                    const struct object_id *oid)
            {
                    struct commit *parent;

                    parent = lookup_commit_reference(r, oid);
                    if (!parent)
                            die("no such commit %s", oid_to_hex(oid));
                    return &commit_list_insert(parent, tail)->next;
            }

            static void append_merge_parents(struct repository *r,
                                            struct commit_list **tail)
            {
                    int merge_head;
                    struct strbuf line = STRBUF_INIT;

                    merge_head = open(git_path_merge_head(r), O_RDONLY);
                    if (merge_head < 0) {
                            if (errno == ENOENT)
                                    return;
                            die("cannot open '%s' for reading",
                            git_path_merge_head(r));
                    }

                    while (!strbuf_getwholeline_fd(&line, merge_head, '\n')) {
                            struct object_id oid;
                            if (get_oid_hex(line.buf, &oid))
                                    die("unknown line in '%s': %s",
                                    git_path_merge_head(r), line.buf);
                            tail = append_parent(r, tail, &oid);
                    }
                    close(merge_head);
                    strbuf_release(&line);
            }

            /*
            * This isn't as simple as passing sb->buf and sb->len, because we
            * want to transfer ownership of the buffer to the commit (so we
            * must use detach).
            */
            static void set_commit_buffer_from_strbuf(struct repository *r,
                                                    struct commit *c,
                                                    struct strbuf *sb)
            {
                    size_t len;
                    void *buf = strbuf_detach(sb, &len);
                    set_commit_buffer(r, c, buf, len);
            }

            /*
            * Prepare a dummy commit that represents the work tree (or staged) item.
            * Note that annotating work tree item never works in the reverse.
            */
            static struct commit *fake_working_tree_commit(struct repository *r,
                                                    struct diff_options *opt,
                                                    const char *path,
                                                    const char *contents_from,
                                                    struct object_id *oid)
            {
                    struct commit *commit;
                    struct blame_origin *origin;
                    struct commit_list **parent_tail, *parent;
                    struct strbuf buf = STRBUF_INIT;
                    const char *ident;
                    time_t now;
                    int len;
                    struct cache_entry *ce;
                    unsigned mode;
                    struct strbuf msg = STRBUF_INIT;

                    repo_read_index(r);
                    time(&now);
                    commit = alloc_commit_node(r);
                    commit->object.parsed = 1;
                    commit->date = now;
                    parent_tail = &commit->parents;

                    parent_tail = append_parent(r, parent_tail, oid);
                    append_merge_parents(r, parent_tail);
                    verify_working_tree_path(r, commit, path);

                    origin = make_origin(commit, path);

                    if (contents_from)
                            ident = fmt_ident("External file (--contents)", "external.file",
                                            WANT_BLANK_IDENT, NULL, 0);
                    else
                            ident = fmt_ident("Not Committed Yet", "not.committed.yet",
                                            WANT_BLANK_IDENT, NULL, 0);
                    strbuf_addstr(&msg, "tree 0000000000000000000000000000000000000000\n");
                    for (parent = commit->parents; parent; parent = parent->next)
                            strbuf_addf(&msg, "parent %s\n",
                                    oid_to_hex(&parent->item->object.oid));
                    strbuf_addf(&msg,
                            "author %s\n"
                            "committer %s\n\n"
                            "Version of %s from %s\n",
                            ident, ident, path,
                            (!contents_from ? path :
                            (!strcmp(contents_from, "-") ? "standard input" : contents_from)));
                    set_commit_buffer_from_strbuf(r, commit, &msg);

                    if (!contents_from || strcmp("-", contents_from)) {
                            struct stat st;
                            const char *read_from;
                            char *buf_ptr;
                            unsigned long buf_len;

                            if (contents_from) {
                                    if (stat(contents_from, &st) < 0)
                                            die_errno("Cannot stat '%s'", contents_from);
                                    read_from = contents_from;
                            }
                            else {
                                    if (lstat(path, &st) < 0)
                                            die_errno("Cannot lstat '%s'", path);
                                    read_from = path;
                            }
                            mode = canon_mode(st.st_mode);

                            switch (st.st_mode & S_IFMT) {
                            case S_IFREG:
                                    if (opt->flags.allow_textconv &&
                                    textconv_object(r, read_from, mode, null_oid(), 0, &buf_ptr, &buf_len))
                                            strbuf_attach(&buf, buf_ptr, buf_len, buf_len + 1);
                                    else if (strbuf_read_file(&buf, read_from, st.st_size) != st.st_size)
                                            die_errno("cannot open or read '%s'", read_from);
                                    break;
                            case S_IFLNK:
                                    if (strbuf_readlink(&buf, read_from, st.st_size) < 0)
                                            die_errno("cannot readlink '%s'", read_from);
                                    break;
                            default:
                                    die("unsupported file type %s", read_from);
                            }
                    }
                    else {
                            /* Reading from stdin */
                            mode = 0;
                            if (strbuf_read(&buf, 0, 0) < 0)
                                    die_errno("failed to read from stdin");
                    }
            #ifdef __MVS__
                    int autocvtToASCII;
                    validate_codeset(r->index, path, &autocvtToASCII);
                    if (autocvtToASCII)
            #endif
                    convert_to_git(r->index, path, buf.buf, buf.len, &buf, 0);
                    origin->file.ptr = buf.buf;
                    origin->file.size = buf.len;
                    pretend_object_file(buf.buf, buf.len, OBJ_BLOB, &origin->blob_oid);

                    /*
                    * Read the current index, replace the path entry with
                    * origin->blob_sha1 without mucking with its mode or type
                    * bits; we are not going to write this index out -- we just
                    * want to run "diff-index --cached".
                    */
                    discard_index(r->index);
                    repo_read_index(r);

                    len = strlen(path);
                    if (!mode) {
                            int pos = index_name_pos(r->index, path, len);
                            if (0 <= pos)
                                    mode = r->index->cache[pos]->ce_mode;
                            else
                                    /* Let's not bother reading from HEAD tree */
                                    mode = S_IFREG | 0644;
                    }
                    ce = make_empty_cache_entry(r->index, len);
                    oidcpy(&ce->oid, &origin->blob_oid);
                    memcpy(ce->name, path, len);
                    ce->ce_flags = create_ce_flags(0);
                    ce->ce_namelen = len;
                    ce->ce_mode = create_ce_mode(mode);
                    add_index_entry(r->index, ce,
                                    ADD_CACHE_OK_TO_ADD | ADD_CACHE_OK_TO_REPLACE);

                    cache_tree_invalidate_path(r->index, path);

                    return commit;
            }



            static int diff_hunks(mmfile_t *file_a, mmfile_t *file_b,
                            xdl_emit_hunk_consume_func_t hunk_func, void *cb_data, int xdl_opts)
            {
                    xpparam_t xpp = {0};
                    xdemitconf_t xecfg = {0};
                    xdemitcb_t ecb = {NULL};

                    xpp.flags = xdl_opts;
                    xecfg.hunk_func = hunk_func;
                    ecb.priv = cb_data;
                    return xdi_diff(file_a, file_b, &xpp, &xecfg, &ecb);
            }

            static const char *get_next_line(const char *start, const char *end)
            {
                    const char *nl = memchr(start, '\n', end - start);

                    return nl ? nl + 1 : end;
            }

            static int find_line_starts(int **line_starts, const char *buf,
                                    unsigned long len)
            {
                    const char *end = buf + len;
                    const char *p;
                    int *lineno;
                    int num = 0;

                    for (p = buf; p < end; p = get_next_line(p, end))
                            num++;

                    ALLOC_ARRAY(*line_starts, num + 1);
                    lineno = *line_starts;

                    for (p = buf; p < end; p = get_next_line(p, end))
                            *lineno++ = p - buf;

                    *lineno = len;

                    return num;
            }

            struct fingerprint_entry;

            /* A fingerprint is intended to loosely represent a string, such that two
            * fingerprints can be quickly compared to give an indication of the similarity
            * of the strings that they represent.
            *
            * A fingerprint is represented as a multiset of the lower-cased byte pairs in
            * the string that it represents. Whitespace is added at each end of the
            * string. Whitespace pairs are ignored. Whitespace is converted to '\0'.
            * For example, the string "Darth   Radar" will be converted to the following
            * fingerprint:
            * {"\0d", "da", "da", "ar", "ar", "rt", "th", "h\0", "\0r", "ra", "ad", "r\0"}
            *
            * The similarity between two fingerprints is the size of the intersection of
            * their multisets, including repeated elements. See fingerprint_similarity for
            * examples.
            *
            * For ease of implementation, the fingerprint is implemented as a map
            * of byte pairs to the count of that byte pair in the string, instead of
            * allowing repeated elements in a set.
            */
            struct fingerprint {
                    struct hashmap map;
                    /* As we know the maximum number of entries in advance, it's
                    * convenient to store the entries in a single array instead of having
                    * the hashmap manage the memory.
                    */
                    struct fingerprint_entry *entries;
            };

            /* A byte pair in a fingerprint. Stores the number of times the byte pair
            * occurs in the string that the fingerprint represents.
            */
            struct fingerprint_entry {
                    /* The hashmap entry - the hash represents the byte pair in its
                    * entirety so we don't need to store the byte pair separately.
                    */
                    struct hashmap_entry entry;
                    /* The number of times the byte pair occurs in the string that the
                    * fingerprint represents.
                    */
                    int count;
            };

            /* See `struct fingerprint` for an explanation of what a fingerprint is.
            * \param result the fingerprint of the string is stored here. This must be
            *               freed later using free_fingerprint.
            * \param line_begin the start of the string
            * \param line_end the end of the string
            */
            static void get_fingerprint(struct fingerprint *result,
                                    const char *line_begin,
                                    const char *line_end)
            {
                    unsigned int hash, c0 = 0, c1;
                    const char *p;
                    int max_map_entry_count = 1 + line_end - line_begin;
                    struct fingerprint_entry *entry = xcalloc(max_map_entry_count,
                            sizeof(struct fingerprint_entry));
                    struct fingerprint_entry *found_entry;

                    hashmap_init(&result->map, NULL, NULL, max_map_entry_count);
                    result->entries = entry;
                    for (p = line_begin; p <= line_end; ++p, c0 = c1) {
                            /* Always terminate the string with whitespace.
                            * Normalise whitespace to 0, and normalise letters to
                            * lower case. This won't work for multibyte characters but at
                            * worst will match some unrelated characters.
                            */
                            if ((p == line_end) || isspace(*p))
                                    c1 = 0;
                            else
                                    c1 = tolower(*p);
                            hash = c0 | (c1 << 8);
                            /* Ignore whitespace pairs */
                            if (hash == 0)
                                    continue;
                            hashmap_entry_init(&entry->entry, hash);

                            found_entry = hashmap_get_entry(&result->map, entry,
                                                            /* member name */ entry, NULL);
                            if (found_entry) {
                                    found_entry->count += 1;
                            } else {
                                    entry->count = 1;
                                    hashmap_add(&result->map, &entry->entry);
                                    ++entry;
                            }
                    }
            }

            static void free_fingerprint(struct fingerprint *f)
            {
                    hashmap_clear(&f->map);
                    free(f->entries);
            }

            /* Calculates the similarity between two fingerprints as the size of the
            * intersection of their multisets, including repeated elements. See
            * `struct fingerprint` for an explanation of the fingerprint representation.
            * The similarity between "cat mat" and "father rather" is 2 because "at" is
            * present twice in both strings while the similarity between "tim" and "mit"
            * is 0.
            */
            static int fingerprint_similarity(struct fingerprint *a, struct fingerprint *b)
            {
                    int intersection = 0;
                    struct hashmap_iter iter;
                    const struct fingerprint_entry *entry_a, *entry_b;

                    hashmap_for_each_entry(&b->map, &iter, entry_b,
                                            entry /* member name */) {
                            entry_a = hashmap_get_entry(&a->map, entry_b, entry, NULL);
                            if (entry_a) {
                                    intersection += entry_a->count < entry_b->count ?
                                                    entry_a->count : entry_b->count;
                            }
                    }
                    return intersection;
            }

            /* Subtracts byte-pair elements in B from A, modifying A in place.
            */
            static void fingerprint_subtract(struct fingerprint *a, struct fingerprint *b)
            {
                    struct hashmap_iter iter;
                    struct fingerprint_entry *entry_a;
                    const struct fingerprint_entry *entry_b;

                    hashmap_iter_init(&b->map, &iter);

                    hashmap_for_each_entry(&b->map, &iter, entry_b,
                                            entry /* member name */) {
                            entry_a = hashmap_get_entry(&a->map, entry_b, entry, NULL);
                            if (entry_a) {
                                    if (entry_a->count <= entry_b->count)
                                            hashmap_remove(&a->map, &entry_b->entry, NULL);
                                    else
                                            entry_a->count -= entry_b->count;
                            }
                    }
            }

            /* Calculate fingerprints for a series of lines.
            * Puts the fingerprints in the fingerprints array, which must have been
            * preallocated to allow storing line_count elements.
            */
            static void get_line_fingerprints(struct fingerprint *fingerprints,
                                            const char *content, const int *line_starts,
                                            long first_line, long line_count)
            {
                    int i;
                    const char *linestart, *lineend;

                    line_starts += first_line;
                    for (i = 0; i < line_count; ++i) {
                            linestart = content + line_starts[i];
                            lineend = content + line_starts[i + 1];
                            get_fingerprint(fingerprints + i, linestart, lineend);
                    }
            }

            static void free_line_fingerprints(struct fingerprint *fingerprints,
                                            int nr_fingerprints)
            {
                    int i;

                    for (i = 0; i < nr_fingerprints; i++)
                            free_fingerprint(&fingerprints[i]);
            }

            /* This contains the data necessary to linearly map a line number in one half
            * of a diff chunk to the line in the other half of the diff chunk that is
            * closest in terms of its position as a fraction of the length of the chunk.
            */
            struct line_number_mapping {
                    int destination_start, destination_length,
                            source_start, source_length;
            };

            /* Given a line number in one range, offset and scale it to map it onto the
            * other range.
            * Essentially this mapping is a simple linear equation but the calculation is
            * more complicated to allow performing it with integer operations.
            * Another complication is that if a line could map onto many lines in the
            * destination range then we want to choose the line at the center of those
            * possibilities.
            * Example: if the chunk is 2 lines long in A and 10 lines long in B then the
            * first 5 lines in B will map onto the first line in the A chunk, while the
            * last 5 lines will all map onto the second line in the A chunk.
            * Example: if the chunk is 10 lines long in A and 2 lines long in B then line
            * 0 in B will map onto line 2 in A, and line 1 in B will map onto line 7 in A.
            */
            static int map_line_number(int line_number,
                    const struct line_number_mapping *mapping)
            {
                    return ((line_number - mapping->source_start) * 2 + 1) *
                    mapping->destination_length /
                    (mapping->source_length * 2) +
                    mapping->destination_start;
            }

            /* Get a pointer to the element storing the similarity between a line in A
            * and a line in B.
            *
            * The similarities are stored in a 2-dimensional array. Each "row" in the
            * array contains the similarities for a line in B. The similarities stored in
            * a row are the similarities between the line in B and the nearby lines in A.
            * To keep the length of each row the same, it is padded out with values of -1
            * where the search range extends beyond the lines in A.
            * For example, if max_search_distance_a is 2 and the two sides of a diff chunk
            * look like this:
            * a | m
            * b | n
            * c | o
            * d | p
            * e | q
            * Then the similarity array will contain:
            * [-1, -1, am, bm, cm,
            *  -1, an, bn, cn, dn,
            *  ao, bo, co, do, eo,
            *  bp, cp, dp, ep, -1,
            *  cq, dq, eq, -1, -1]
            * Where similarities are denoted either by -1 for invalid, or the
            * concatenation of the two lines in the diff being compared.
            *
            * \param similarities array of similarities between lines in A and B
            * \param line_a the index of the line in A, in the same frame of reference as
            *      closest_line_a.
            * \param local_line_b the index of the line in B, relative to the first line
            *                     in B that similarities represents.
            * \param closest_line_a the index of the line in A that is deemed to be
            *                       closest to local_line_b. This must be in the same
            *                       frame of reference as line_a. This value defines
            *                       where similarities is centered for the line in B.
            * \param max_search_distance_a maximum distance in lines from the closest line
            *                              in A for other lines in A for which
            *                              similarities may be calculated.
            */
            static int *get_similarity(int *similarities,
                                    int line_a, int local_line_b,
                                    int closest_line_a, int max_search_distance_a)
            {
                    assert(abs(line_a - closest_line_a) <=
                    max_search_distance_a);
                    return similarities + line_a - closest_line_a +
                    max_search_distance_a +
                    local_line_b * (max_search_distance_a * 2 + 1);
            }

            #define CERTAIN_NOTHING_MATCHES -2
            #define CERTAINTY_NOT_CALCULATED -1

            /* Given a line in B, first calculate its similarities with nearby lines in A
            * if not already calculated, then identify the most similar and second most
            * similar lines. The "certainty" is calculated based on those two
            * similarities.
            *
            * \param start_a the index of the first line of the chunk in A
            * \param length_a the length in lines of the chunk in A
            * \param local_line_b the index of the line in B, relative to the first line
            *                     in the chunk.
            * \param fingerprints_a array of fingerprints for the chunk in A
            * \param fingerprints_b array of fingerprints for the chunk in B
            * \param similarities 2-dimensional array of similarities between lines in A
            *                     and B. See get_similarity() for more details.
            * \param certainties array of values indicating how strongly a line in B is
            *                    matched with some line in A.
            * \param second_best_result array of absolute indices in A for the second
            *                           closest match of a line in B.
            * \param result array of absolute indices in A for the closest match of a line
            *               in B.
            * \param max_search_distance_a maximum distance in lines from the closest line
            *                              in A for other lines in A for which
            *                              similarities may be calculated.
            * \param map_line_number_in_b_to_a parameter to map_line_number().
            */
            static void find_best_line_matches(
                    int start_a,
                    int length_a,
                    int start_b,
                    int local_line_b,
                    struct fingerprint *fingerprints_a,
                    struct fingerprint *fingerprints_b,
                    int *similarities,
                    int *certainties,
                    int *second_best_result,
                    int *result,
                    const int max_search_distance_a,
                    const struct line_number_mapping *map_line_number_in_b_to_a)
            {

                    int i, search_start, search_end, closest_local_line_a, *similarity,
                            best_similarity = 0, second_best_similarity = 0,
                            best_similarity_index = 0, second_best_similarity_index = 0;

                    /* certainty has already been calculated so no need to redo the work */
                    if (certainties[local_line_b] != CERTAINTY_NOT_CALCULATED)
                            return;

                    closest_local_line_a = map_line_number(
                            local_line_b + start_b, map_line_number_in_b_to_a) - start_a;

                    search_start = closest_local_line_a - max_search_distance_a;
                    if (search_start < 0)
                            search_start = 0;

                    search_end = closest_local_line_a + max_search_distance_a + 1;
                    if (search_end > length_a)
                            search_end = length_a;

                    for (i = search_start; i < search_end; ++i) {
                            similarity = get_similarity(similarities,
                                                    i, local_line_b,
                                                    closest_local_line_a,
                                                    max_search_distance_a);
                            if (*similarity == -1) {
                                    /* This value will never exceed 10 but assert just in
                                    * case
                                    */
                                    assert(abs(i - closest_local_line_a) < 1000);
                                    /* scale the similarity by (1000 - distance from
                                    * closest line) to act as a tie break between lines
                                    * that otherwise are equally similar.
                                    */
                                    *similarity = fingerprint_similarity(
                                            fingerprints_b + local_line_b,
                                            fingerprints_a + i) *
                                            (1000 - abs(i - closest_local_line_a));
                            }
                            if (*similarity > best_similarity) {
                                    second_best_similarity = best_similarity;
                                    second_best_similarity_index = best_similarity_index;
                                    best_similarity = *similarity;
                                    best_similarity_index = i;
                            } else if (*similarity > second_best_similarity) {
                                    second_best_similarity = *similarity;
                                    second_best_similarity_index = i;
                            }
                    }

                    if (best_similarity == 0) {
                            /* this line definitely doesn't match with anything. Mark it
                            * with this special value so it doesn't get invalidated and
                            * won't be recalculated.
                            */
                            certainties[local_line_b] = CERTAIN_NOTHING_MATCHES;
                            result[local_line_b] = -1;
                    } else {
                            /* Calculate the certainty with which this line matches.
                            * If the line matches well with two lines then that reduces
                            * the certainty. However we still want to prioritise matching
                            * a line that matches very well with two lines over matching a
                            * line that matches poorly with one line, hence doubling
                            * best_similarity.
                            * This means that if we have
                            * line X that matches only one line with a score of 3,
                            * line Y that matches two lines equally with a score of 5,
                            * and line Z that matches only one line with a score or 2,
                            * then the lines in order of certainty are X, Y, Z.
                            */
                            certainties[local_line_b] = best_similarity * 2 -
                                    second_best_similarity;

                            /* We keep both the best and second best results to allow us to
                            * check at a later stage of the matching process whether the
                            * result needs to be invalidated.
                            */
                            result[local_line_b] = start_a + best_similarity_index;
                            second_best_result[local_line_b] =
                                    start_a + second_best_similarity_index;
                    }
            }

            /*
            * This finds the line that we can match with the most confidence, and
            * uses it as a partition. It then calls itself on the lines on either side of
            * that partition. In this way we avoid lines appearing out of order, and
            * retain a sensible line ordering.
            * \param start_a index of the first line in A with which lines in B may be
            *                compared.
            * \param start_b index of the first line in B for which matching should be
            *                done.
            * \param length_a number of lines in A with which lines in B may be compared.
            * \param length_b number of lines in B for which matching should be done.
            * \param fingerprints_a mutable array of fingerprints in A. The first element
            *                       corresponds to the line at start_a.
            * \param fingerprints_b array of fingerprints in B. The first element
            *                       corresponds to the line at start_b.
            * \param similarities 2-dimensional array of similarities between lines in A
            *                     and B. See get_similarity() for more details.
            * \param certainties array of values indicating how strongly a line in B is
            *                    matched with some line in A.
            * \param second_best_result array of absolute indices in A for the second
            *                           closest match of a line in B.
            * \param result array of absolute indices in A for the closest match of a line
            *               in B.
            * \param max_search_distance_a maximum distance in lines from the closest line
            *                            in A for other lines in A for which
            *                            similarities may be calculated.
            * \param max_search_distance_b an upper bound on the greatest possible
            *                            distance between lines in B such that they will
            *                              both be compared with the same line in A
            *                            according to max_search_distance_a.
            * \param map_line_number_in_b_to_a parameter to map_line_number().
            */
            static void fuzzy_find_matching_lines_recurse(
                    int start_a, int start_b,
                    int length_a, int length_b,
                    struct fingerprint *fingerprints_a,
                    struct fingerprint *fingerprints_b,
                    int *similarities,
                    int *certainties,
                    int *second_best_result,
                    int *result,
                    int max_search_distance_a,
                    int max_search_distance_b,
                    const struct line_number_mapping *map_line_number_in_b_to_a)
            {
                    int i, invalidate_min, invalidate_max, offset_b,
                            second_half_start_a, second_half_start_b,
                            second_half_length_a, second_half_length_b,
                            most_certain_line_a, most_certain_local_line_b = -1,
                            most_certain_line_certainty = -1,
                            closest_local_line_a;

                    for (i = 0; i < length_b; ++i) {
                            find_best_line_matches(start_a,
                                            length_a,
                                            start_b,
                                            i,
                                            fingerprints_a,
                                            fingerprints_b,
                                            similarities,
                                            certainties,
                                            second_best_result,
                                            result,
                                            max_search_distance_a,
                                            map_line_number_in_b_to_a);

                            if (certainties[i] > most_certain_line_certainty) {
                                    most_certain_line_certainty = certainties[i];
                                    most_certain_local_line_b = i;
                            }
                    }

                    /* No matches. */
                    if (most_certain_local_line_b == -1)
                            return;

                    most_certain_line_a = result[most_certain_local_line_b];

                    /*
                    * Subtract the most certain line's fingerprint in B from the matched
                    * fingerprint in A. This means that other lines in B can't also match
                    * the same parts of the line in A.
                    */
                    fingerprint_subtract(fingerprints_a + most_certain_line_a - start_a,
                                    fingerprints_b + most_certain_local_line_b);

                    /* Invalidate results that may be affected by the choice of most
                    * certain line.
                    */
                    invalidate_min = most_certain_local_line_b - max_search_distance_b;
                    invalidate_max = most_certain_local_line_b + max_search_distance_b + 1;
                    if (invalidate_min < 0)
                            invalidate_min = 0;
                    if (invalidate_max > length_b)
                            invalidate_max = length_b;

                    /* As the fingerprint in A has changed, discard previously calculated
                    * similarity values with that fingerprint.
                    */
                    for (i = invalidate_min; i < invalidate_max; ++i) {
                            closest_local_line_a = map_line_number(
                                    i + start_b, map_line_number_in_b_to_a) - start_a;

                            /* Check that the lines in A and B are close enough that there
                            * is a similarity value for them.
                            */
                            if (abs(most_certain_line_a - start_a - closest_local_line_a) >
                                    max_search_distance_a) {
                                    continue;
                            }

                            *get_similarity(similarities, most_certain_line_a - start_a,
                                            i, closest_local_line_a,
                                            max_search_distance_a) = -1;
                    }

                    /* More invalidating of results that may be affected by the choice of
                    * most certain line.
                    * Discard the matches for lines in B that are currently matched with a
                    * line in A such that their ordering contradicts the ordering imposed
                    * by the choice of most certain line.
                    */
                    for (i = most_certain_local_line_b - 1; i >= invalidate_min; --i) {
                            /* In this loop we discard results for lines in B that are
                            * before most-certain-line-B but are matched with a line in A
                            * that is after most-certain-line-A.
                            */
                            if (certainties[i] >= 0 &&
                            (result[i] >= most_certain_line_a ||
                            second_best_result[i] >= most_certain_line_a)) {
                                    certainties[i] = CERTAINTY_NOT_CALCULATED;
                            }
                    }
                    for (i = most_certain_local_line_b + 1; i < invalidate_max; ++i) {
                            /* In this loop we discard results for lines in B that are
                            * after most-certain-line-B but are matched with a line in A
                            * that is before most-certain-line-A.
                            */
                            if (certainties[i] >= 0 &&
                            (result[i] <= most_certain_line_a ||
                            second_best_result[i] <= most_certain_line_a)) {
                                    certainties[i] = CERTAINTY_NOT_CALCULATED;
                            }
                    }

                    /* Repeat the matching process for lines before the most certain line.
                    */
                    if (most_certain_local_line_b > 0) {
                            fuzzy_find_matching_lines_recurse(
                                    start_a, start_b,
                                    most_certain_line_a + 1 - start_a,
                                    most_certain_local_line_b,
                                    fingerprints_a, fingerprints_b, similarities,
                                    certainties, second_best_result, result,
                                    max_search_distance_a,
                                    max_search_distance_b,
                                    map_line_number_in_b_to_a);
                    }
                    /* Repeat the matching process for lines after the most certain line.
                    */
                    if (most_certain_local_line_b + 1 < length_b) {
                            second_half_start_a = most_certain_line_a;
                            offset_b = most_certain_local_line_b + 1;
                            second_half_start_b = start_b + offset_b;
                            second_half_length_a =
                                    length_a + start_a - second_half_start_a;
                            second_half_length_b =
                                    length_b + start_b - second_half_start_b;
                            fuzzy_find_matching_lines_recurse(
                                    second_half_start_a, second_half_start_b,
                                    second_half_length_a, second_half_length_b,
                                    fingerprints_a + second_half_start_a - start_a,
                                    fingerprints_b + offset_b,
                                    similarities +
                                            offset_b * (max_search_distance_a * 2 + 1),
                                    certainties + offset_b,
                                    second_best_result + offset_b, result + offset_b,
                                    max_search_distance_a,
                                    max_search_distance_b,
                                    map_line_number_in_b_to_a);
                    }
            }

            /* Find the lines in the parent line range that most closely match the lines in
            * the target line range. This is accomplished by matching fingerprints in each
            * blame_origin, and choosing the best matches that preserve the line ordering.
            * See struct fingerprint for details of fingerprint matching, and
            * fuzzy_find_matching_lines_recurse for details of preserving line ordering.
            *
            * The performance is believed to be O(n log n) in the typical case and O(n^2)
            * in a pathological case, where n is the number of lines in the target range.
            */
            static int *fuzzy_find_matching_lines(struct blame_origin *parent,
                                            struct blame_origin *target,
                                            int tlno, int parent_slno, int same,
                                            int parent_len)
            {
                    /* We use the terminology "A" for the left hand side of the diff AKA
                    * parent, and "B" for the right hand side of the diff AKA target. */
                    int start_a = parent_slno;
                    int length_a = parent_len;
                    int start_b = tlno;
                    int length_b = same - tlno;

                    struct line_number_mapping map_line_number_in_b_to_a = {
                            start_a, length_a, start_b, length_b
                    };

                    struct fingerprint *fingerprints_a = parent->fingerprints;
                    struct fingerprint *fingerprints_b = target->fingerprints;

                    int i, *result, *second_best_result,
                            *certainties, *similarities, similarity_count;

                    /*
                    * max_search_distance_a means that given a line in B, compare it to
                    * the line in A that is closest to its position, and the lines in A
                    * that are no greater than max_search_distance_a lines away from the
                    * closest line in A.
                    *
                    * max_search_distance_b is an upper bound on the greatest possible
                    * distance between lines in B such that they will both be compared
                    * with the same line in A according to max_search_distance_a.
                    */
                    int max_search_distance_a = 10, max_search_distance_b;

                    if (length_a <= 0)
                            return NULL;

                    if (max_search_distance_a >= length_a)
                            max_search_distance_a = length_a ? length_a - 1 : 0;

                    max_search_distance_b = ((2 * max_search_distance_a + 1) * length_b
                                            - 1) / length_a;

                    CALLOC_ARRAY(result, length_b);
                    CALLOC_ARRAY(second_best_result, length_b);
                    CALLOC_ARRAY(certainties, length_b);

                    /* See get_similarity() for details of similarities. */
                    similarity_count = length_b * (max_search_distance_a * 2 + 1);
                    CALLOC_ARRAY(similarities, similarity_count);

                    for (i = 0; i < length_b; ++i) {
                            result[i] = -1;
                            second_best_result[i] = -1;
                            certainties[i] = CERTAINTY_NOT_CALCULATED;
                    }

                    for (i = 0; i < similarity_count; ++i)
                            similarities[i] = -1;

                    fuzzy_find_matching_lines_recurse(start_a, start_b,
                                                    length_a, length_b,
                                                    fingerprints_a + start_a,
                                                    fingerprints_b + start_b,
                                                    similarities,
                                                    certainties,
                                                    second_best_result,
                                                    result,
                                                    max_search_distance_a,
                                                    max_search_distance_b,
                                                    &map_line_number_in_b_to_a);

                    free(similarities);
                    free(certainties);
                    free(second_best_result);

                    return result;
            }

            static void fill_origin_fingerprints(struct blame_origin *o)
            {
                    int *line_starts;

                    if (o->fingerprints)
                            return;
                    o->num_lines = find_line_starts(&line_starts, o->file.ptr,
                                                    o->file.size);
                    CALLOC_ARRAY(o->fingerprints, o->num_lines);
                    get_line_fingerprints(o->fingerprints, o->file.ptr, line_starts,
                                    0, o->num_lines);
                    free(line_starts);
            }

            static void drop_origin_fingerprints(struct blame_origin *o)
            {
                    if (o->fingerprints) {
                            free_line_fingerprints(o->fingerprints, o->num_lines);
                            o->num_lines = 0;
                            FREE_AND_NULL(o->fingerprints);
                    }
            }

            /*
            * Given an origin, prepare mmfile_t structure to be used by the
            * diff machinery
            */
            static void fill_origin_blob(struct diff_options *opt,
                                    struct blame_origin *o, mmfile_t *file,
                                    int *num_read_blob, int fill_fingerprints)
            {
                    if (!o->file.ptr) {
                            enum object_type type;
                            unsigned long file_size;

                            (*num_read_blob)++;
                            if (opt->flags.allow_textconv &&
                            textconv_object(opt->repo, o->path, o->mode,
                                            &o->blob_oid, 1, &file->ptr, &file_size))
                                    ;
                            else
                                    file->ptr = repo_read_object_file(the_repository,
                                                                    &o->blob_oid, &type,
                                                                    &file_size);
                            file->size = file_size;

                            if (!file->ptr)
                                    die("Cannot read blob %s for path %s",
                                    oid_to_hex(&o->blob_oid),
                                    o->path);
                            o->file = *file;
                    }
                    else
                            *file = o->file;
                    if (fill_fingerprints)
                            fill_origin_fingerprints(o);
            }

            static void drop_origin_blob(struct blame_origin *o)
            {
                    FREE_AND_NULL(o->file.ptr);
                    drop_origin_fingerprints(o);
            }

            /*
            * Any merge of blames happens on lists of blames that arrived via
            * different parents in a single suspect.  In this case, we want to
            * sort according to the suspect line numbers as opposed to the final
            * image line numbers.  The function body is somewhat longish because
            * it avoids unnecessary writes.
            */

            static struct blame_entry *blame_merge(struct blame_entry *list1,
                                            struct blame_entry *list2)
            {
                    struct blame_entry *p1 = list1, *p2 = list2,
                            **tail = &list1;

                    if (!p1)
                            return p2;
                    if (!p2)
                            return p1;

                    if (p1->s_lno <= p2->s_lno) {
                            do {
                                    tail = &p1->next;
                                    if (!(p1 = *tail)) {
                                            *tail = p2;
                                            return list1;
                                    }
                            } while (p1->s_lno <= p2->s_lno);
                    }
                    for (;;) {
                            *tail = p2;
                            do {
                                    tail = &p2->next;
                                    if (!(p2 = *tail))  {
                                            *tail = p1;
                                            return list1;
                                    }
                            } while (p1->s_lno > p2->s_lno);
                            *tail = p1;
                            do {
                                    tail = &p1->next;
                                    if (!(p1 = *tail)) {
                                            *tail = p2;
                                            return list1;
                                    }
                            } while (p1->s_lno <= p2->s_lno);
                    }
            }

            DEFINE_LIST_SORT(static, sort_blame_entries, struct blame_entry, next);

            /*
            * Final image line numbers are all different, so we don't need a
            * three-way comparison here.
            */

            static int compare_blame_final(const struct blame_entry *e1,
                                    const struct blame_entry *e2)
            {
                    return e1->lno > e2->lno ? 1 : -1;
            }

            static int compare_blame_suspect(const struct blame_entry *s1,
                                            const struct blame_entry *s2)
            {
                    /*
                    * to allow for collating suspects, we sort according to the
                    * respective pointer value as the primary sorting criterion.
                    * The actual relation is pretty unimportant as long as it
                    * establishes a total order.  Comparing as integers gives us
                    * that.
                    */
                    if (s1->suspect != s2->suspect)
                            return (intptr_t)s1->suspect > (intptr_t)s2->suspect ? 1 : -1;
                    if (s1->s_lno == s2->s_lno)
                            return 0;
                    return s1->s_lno > s2->s_lno ? 1 : -1;
            }

            void blame_sort_final(struct blame_scoreboard *sb)
            {
                    sort_blame_entries(&sb->ent, compare_blame_final);
            }

            static int compare_commits_by_reverse_commit_date(const void *a,
                                                            const void *b,
                                                            void *c)
            {
                    return -compare_commits_by_commit_date(a, b, c);
            }

            /*
            * For debugging -- origin is refcounted, and this asserts that
            * we do not underflow.
            */
            static void sanity_check_refcnt(struct blame_scoreboard *sb)
            {
                    int baa = 0;
                    struct blame_entry *ent;

                    for (ent = sb->ent; ent; ent = ent->next) {
                            /* Nobody should have zero or negative refcnt */
                            if (ent->suspect->refcnt <= 0) {
                                    fprintf(stderr, "%s in %s has negative refcnt %d\n",
                                            ent->suspect->path,
                                            oid_to_hex(&ent->suspect->commit->object.oid),
                                            ent->suspect->refcnt);
                                    baa = 1;
                            }
                    }
                    if (baa)
                            sb->on_sanity_fail(sb, baa);
            }

            /*
            * If two blame entries that are next to each other came from
            * contiguous lines in the same origin (i.e. <commit, path> pair),
            * merge them together.
            */
            void blame_coalesce(struct blame_scoreboard *sb)
            {
                    struct blame_entry *ent, *next;

                    for (ent = sb->ent; ent && (next = ent->next); ent = next) {
                            if (ent->suspect == next->suspect &&
                            ent->s_lno + ent->num_lines == next->s_lno &&
                            ent->lno + ent->num_lines == next->lno &&
                            ent->ignored == next->ignored &&
                            ent->unblamable == next->unblamable) {
                                    ent->num_lines += next->num_lines;
                                    ent->next = next->next;
                                    blame_origin_decref(next->suspect);
                                    free(next);
                                    ent->score = 0;
                                    next = ent; /* again */
                            }
                    }

                    if (sb->debug) /* sanity */
                            sanity_check_refcnt(sb);
            }

            /*
            * Merge the given sorted list of blames into a preexisting origin.
            * If there were no previous blames to that commit, it is entered into
            * the commit priority queue of the score board.
            */

            static void queue_blames(struct blame_scoreboard *sb, struct blame_origin *porigin,
                                    struct blame_entry *sorted)
            {
                    if (porigin->suspects)
                            porigin->suspects = blame_merge(porigin->suspects, sorted);
                    else {
                            struct blame_origin *o;
                            for (o = get_blame_suspects(porigin->commit); o; o = o->next) {
                                    if (o->suspects) {
                                            porigin->suspects = sorted;
                                            return;
                                    }
                            }
                            porigin->suspects = sorted;
                            prio_queue_put(&sb->commits, porigin->commit);
                    }
            }

            /*
            * Fill the blob_sha1 field of an origin if it hasn't, so that later
            * call to fill_origin_blob() can use it to locate the data.  blob_sha1
            * for an origin is also used to pass the blame for the entire file to
            * the parent to detect the case where a child's blob is identical to
            * that of its parent's.
            *
            * This also fills origin->mode for corresponding tree path.
            */
            static int fill_blob_sha1_and_mode(struct repository *r,
                                            struct blame_origin *origin)
            {
                    if (!is_null_oid(&origin->blob_oid))
                            return 0;
                    if (get_tree_entry(r, &origin->commit->object.oid, origin->path, &origin->blob_oid, &origin->mode))
                            goto error_out;
                    if (oid_object_info(r, &origin->blob_oid, NULL) != OBJ_BLOB)
                            goto error_out;
                    return 0;
            error_out:
                    oidclr(&origin->blob_oid, the_repository->hash_algo);
                    origin->mode = S_IFINVALID;
                    return -1;
            }

            struct blame_bloom_data {
                    /*
                    * Changed-path Bloom filter keys. These can help prevent
                    * computing diffs against first parents, but we need to
                    * expand the list as code is moved or files are renamed.
                    */
                    struct bloom_filter_settings *settings;
                    struct bloom_key **keys;
                    int nr;
                    int alloc;
            };

            static int bloom_count_queries = 0;
            static int bloom_count_no = 0;
            static int maybe_changed_path(struct repository *r,
                                    struct blame_origin *origin,
                                    struct blame_bloom_data *bd)
            {
                    int i;
                    struct bloom_filter *filter;

                    if (!bd)
                            return 1;

                    if (commit_graph_generation(origin->commit) == GENERATION_NUMBER_INFINITY)
                            return 1;

                    filter = get_bloom_filter(r, origin->commit);

                    if (!filter)
                            return 1;

                    bloom_count_queries++;
                    for (i = 0; i < bd->nr; i++) {
                            if (bloom_filter_contains(filter,
                                                    bd->keys[i],
                                                    bd->settings))
                                    return 1;
                    }

                    bloom_count_no++;
                    return 0;
            }

            static void add_bloom_key(struct blame_bloom_data *bd,
                                    const char *path)
            {
                    if (!bd)
                            return;

                    if (bd->nr >= bd->alloc) {
                            bd->alloc *= 2;
                            REALLOC_ARRAY(bd->keys, bd->alloc);
                    }

                    bd->keys[bd->nr] = xmalloc(sizeof(struct bloom_key));
                    fill_bloom_key(path, strlen(path), bd->keys[bd->nr], bd->settings);
                    bd->nr++;
            }

            /*
            * We have an origin -- check if the same path exists in the
            * parent and return an origin structure to represent it.
            */
            static struct blame_origin *find_origin(struct repository *r,
                                                    struct commit *parent,
                                                    struct blame_origin *origin,
                                                    struct blame_bloom_data *bd)
            {
                    struct blame_origin *porigin;
                    struct diff_options diff_opts;
                    const char *paths[2];

                    /* First check any existing origins */
                    for (porigin = get_blame_suspects(parent); porigin; porigin = porigin->next)
                            if (!strcmp(porigin->path, origin->path)) {
                                    /*
                                    * The same path between origin and its parent
                                    * without renaming -- the most common case.
                                    */
                                    return blame_origin_incref (porigin);
                            }

                    /* See if the origin->path is different between parent
                    * and origin first.  Most of the time they are the
                    * same and diff-tree is fairly efficient about this.
                    */
                    repo_diff_setup(r, &diff_opts);
                    diff_opts.flags.recursive = 1;
                    diff_opts.detect_rename = 0;
                    diff_opts.output_format = DIFF_FORMAT_NO_OUTPUT;
                    paths[0] = origin->path;
                    paths[1] = NULL;

                    parse_pathspec(&diff_opts.pathspec,
                            PATHSPEC_ALL_MAGIC & ~PATHSPEC_LITERAL,
                            PATHSPEC_LITERAL_PATH, "", paths);
                    diff_setup_done(&diff_opts);

                    if (is_null_oid(&origin->commit->object.oid))
                            do_diff_cache(get_commit_tree_oid(parent), &diff_opts);
                    else {
                            int compute_diff = 1;
                            if (origin->commit->parents &&
                            oideq(&parent->object.oid,
                                    &origin->commit->parents->item->object.oid))
                                    compute_diff = maybe_changed_path(r, origin, bd);

                            if (compute_diff)
                                    diff_tree_oid(get_commit_tree_oid(parent),
                                            get_commit_tree_oid(origin->commit),
                                            "", &diff_opts);
                    }
                    diffcore_std(&diff_opts);

                    if (!diff_queued_diff.nr) {
                            /* The path is the same as parent */
                            porigin = get_origin(parent, origin->path);
                            oidcpy(&porigin->blob_oid, &origin->blob_oid);
                            porigin->mode = origin->mode;
                    } else {
                            /*
                            * Since origin->path is a pathspec, if the parent
                            * commit had it as a directory, we will see a whole
                            * bunch of deletion of files in the directory that we
                            * do not care about.
                            */
                            int i;
                            struct diff_filepair *p = NULL;
                            for (i = 0; i < diff_queued_diff.nr; i++) {
                                    const char *name;
                                    p = diff_queued_diff.queue[i];
                                    name = p->one->path ? p->one->path : p->two->path;
                                    if (!strcmp(name, origin->path))
                                            break;
                            }
                            if (!p)
                                    die("internal error in blame::find_origin");
                            switch (p->status) {
                            default:
                                    die("internal error in blame::find_origin (%c)",
                                    p->status);
                            case 'M':
                                    porigin = get_origin(parent, origin->path);
                                    oidcpy(&porigin->blob_oid, &p->one->oid);
                                    porigin->mode = p->one->mode;
                                    break;
                            case 'A':
                            case 'T':
                                    /* Did not exist in parent, or type changed */
                                    break;
                            }
                    }
                    diff_flush(&diff_opts);
                    return porigin;
            }

            /*
            * We have an origin -- find the path that corresponds to it in its
            * parent and return an origin structure to represent it.
            */
            static struct blame_origin *find_rename(struct repository *r,
                                                    struct commit *parent,
                                                    struct blame_origin *origin,
                                                    struct blame_bloom_data *bd)
            {
                    struct blame_origin *porigin = NULL;
                    struct diff_options diff_opts;
                    int i;

                    repo_diff_setup(r, &diff_opts);
                    diff_opts.flags.recursive = 1;
                    diff_opts.detect_rename = DIFF_DETECT_RENAME;
                    diff_opts.output_format = DIFF_FORMAT_NO_OUTPUT;
                    diff_opts.single_follow = origin->path;
                    diff_setup_done(&diff_opts);

                    if (is_null_oid(&origin->commit->object.oid))
                            do_diff_cache(get_commit_tree_oid(parent), &diff_opts);
                    else
                            diff_tree_oid(get_commit_tree_oid(parent),
                                    get_commit_tree_oid(origin->commit),
                                    "", &diff_opts);
                    diffcore_std(&diff_opts);

                    for (i = 0; i < diff_queued_diff.nr; i++) {
                            struct diff_filepair *p = diff_queued_diff.queue[i];
                            if ((p->status == 'R' || p->status == 'C') &&
                            !strcmp(p->two->path, origin->path)) {
                                    add_bloom_key(bd, p->one->path);
                                    porigin = get_origin(parent, p->one->path);
                                    oidcpy(&porigin->blob_oid, &p->one->oid);
                                    porigin->mode = p->one->mode;
                                    break;
                            }
                    }
                    diff_flush(&diff_opts);
                    return porigin;
            }

            /*
            * Append a new blame entry to a given output queue.
            */
            static void add_blame_entry(struct blame_entry ***queue,
                                    const struct blame_entry *src)
            {
                    struct blame_entry *e = xmalloc(sizeof(*e));
                    memcpy(e, src, sizeof(*e));
                    blame_origin_incref(e->suspect);

                    e->next = **queue;
                    **queue = e;
                    *queue = &e->next;
            }

            /*
            * src typically is on-stack; we want to copy the information in it to
            * a malloced blame_entry that gets added to the given queue.  The
            * origin of dst loses a refcnt.
            */
            static void dup_entry(struct blame_entry ***queue,
                            struct blame_entry *dst, struct blame_entry *src)
            {
                    blame_origin_incref(src->suspect);
                    blame_origin_decref(dst->suspect);
                    memcpy(dst, src, sizeof(*src));
                    dst->next = **queue;
                    **queue = dst;
                    *queue = &dst->next;
            }

            const char *blame_nth_line(struct blame_scoreboard *sb, long lno)
            {
                    return sb->final_buf + sb->lineno[lno];
            }

            /*
            * It is known that lines between tlno to same came from parent, and e
            * has an overlap with that range.  it also is known that parent's
            * line plno corresponds to e's line tlno.
            *
            *                <---- e ----->
            *                   <------>
            *                   <------------>
            *             <------------>
            *             <------------------>
            *
            * Split e into potentially three parts; before this chunk, the chunk
            * to be blamed for the parent, and after that portion.
            */
            static void split_overlap(struct blame_entry *split,
                                    struct blame_entry *e,
                                    int tlno, int plno, int same,
                                    struct blame_origin *parent)
            {
                    int chunk_end_lno;
                    int i;
                    memset(split, 0, sizeof(struct blame_entry [3]));

                    for (i = 0; i < 3; i++) {
                            split[i].ignored = e->ignored;
                            split[i].unblamable = e->unblamable;
                    }

                    if (e->s_lno < tlno) {
                            /* there is a pre-chunk part not blamed on parent */
                            split[0].suspect = blame_origin_incref(e->suspect);
                            split[0].lno = e->lno;
                            split[0].s_lno = e->s_lno;
                            split[0].num_lines = tlno - e->s_lno;
                            split[1].lno = e->lno + tlno - e->s_lno;
                            split[1].s_lno = plno;
                    }
                    else {
                            split[1].lno = e->lno;
                            split[1].s_lno = plno + (e->s_lno - tlno);
                    }

                    if (same < e->s_lno + e->num_lines) {
                            /* there is a post-chunk part not blamed on parent */
                            split[2].suspect = blame_origin_incref(e->suspect);
                            split[2].lno = e->lno + (same - e->s_lno);
                            split[2].s_lno = e->s_lno + (same - e->s_lno);
                            split[2].num_lines = e->s_lno + e->num_lines - same;
                            chunk_end_lno = split[2].lno;
                    }
                    else
                            chunk_end_lno = e->lno + e->num_lines;
                    split[1].num_lines = chunk_end_lno - split[1].lno;

                    /*
                    * if it turns out there is nothing to blame the parent for,
                    * forget about the splitting.  !split[1].suspect signals this.
                    */
                    if (split[1].num_lines < 1)
                            return;
                    split[1].suspect = blame_origin_incref(parent);
            }

            /*
            * split_overlap() divided an existing blame e into up to three parts
            * in split.  Any assigned blame is moved to queue to
            * reflect the split.
            */
            static void split_blame(struct blame_entry ***blamed,
                                    struct blame_entry ***unblamed,
                                    struct blame_entry *split,
                                    struct blame_entry *e)
            {
                    if (split[0].suspect && split[2].suspect) {
                            /* The first part (reuse storage for the existing entry e) */
                            dup_entry(unblamed, e, &split[0]);

                            /* The last part -- me */
                            add_blame_entry(unblamed, &split[2]);

                            /* ... and the middle part -- parent */
                            add_blame_entry(blamed, &split[1]);
                    }
                    else if (!split[0].suspect && !split[2].suspect)
                            /*
                            * The parent covers the entire area; reuse storage for
                            * e and replace it with the parent.
                            */
                            dup_entry(blamed, e, &split[1]);
                    else if (split[0].suspect) {
                            /* me and then parent */
                            dup_entry(unblamed, e, &split[0]);
                            add_blame_entry(blamed, &split[1]);
                    }
                    else {
                            /* parent and then me */
                            dup_entry(blamed, e, &split[1]);
                            add_blame_entry(unblamed, &split[2]);
                    }
            }

            /*
            * After splitting the blame, the origins used by the
            * on-stack blame_entry should lose one refcnt each.
            */
            static void decref_split(struct blame_entry *split)
            {
                    int i;

                    for (i = 0; i < 3; i++)
                            blame_origin_decref(split[i].suspect);
            }

            /*
            * reverse_blame reverses the list given in head, appending tail.
            * That allows us to build lists in reverse order, then reverse them
            * afterwards.  This can be faster than building the list in proper
            * order right away.  The reason is that building in proper order
            * requires writing a link in the _previous_ element, while building
            * in reverse order just requires placing the list head into the
            * _current_ element.
            */

            static struct blame_entry *reverse_blame(struct blame_entry *head,
                                                    struct blame_entry *tail)
            {
                    while (head) {
                            struct blame_entry *next = head->next;
                            head->next = tail;
                            tail = head;
                            head = next;
                    }
                    return tail;
            }

            /*
            * Splits a blame entry into two entries at 'len' lines.  The original 'e'
            * consists of len lines, i.e. [e->lno, e->lno + len), and the second part,
            * which is returned, consists of the remainder: [e->lno + len, e->lno +
            * e->num_lines).  The caller needs to sort out the reference counting for the
            * new entry's suspect.
            */
            static struct blame_entry *split_blame_at(struct blame_entry *e, int len,
                                                    struct blame_origin *new_suspect)
            {
                    struct blame_entry *n = xcalloc(1, sizeof(struct blame_entry));

                    n->suspect = new_suspect;
                    n->ignored = e->ignored;
                    n->unblamable = e->unblamable;
                    n->lno = e->lno + len;
                    n->s_lno = e->s_lno + len;
                    n->num_lines = e->num_lines - len;
                    e->num_lines = len;
                    e->score = 0;
                    return n;
            }

            struct blame_line_tracker {
                    int is_parent;
                    int s_lno;
            };

            static int are_lines_adjacent(struct blame_line_tracker *first,
                                    struct blame_line_tracker *second)
            {
                    return first->is_parent == second->is_parent &&
                    first->s_lno + 1 == second->s_lno;
            }

            static int scan_parent_range(struct fingerprint *p_fps,
                                    struct fingerprint *t_fps, int t_idx,
                                    int from, int nr_lines)
            {
                    int sim, p_idx;
                    #define FINGERPRINT_FILE_THRESHOLD      10
                    int best_sim_val = FINGERPRINT_FILE_THRESHOLD;
                    int best_sim_idx = -1;

                    for (p_idx = from; p_idx < from + nr_lines; p_idx++) {
                            sim = fingerprint_similarity(&t_fps[t_idx], &p_fps[p_idx]);
                            if (sim < best_sim_val)
                                    continue;
                            /* Break ties with the closest-to-target line number */
                            if (sim == best_sim_val && best_sim_idx != -1 &&
                            abs(best_sim_idx - t_idx) < abs(p_idx - t_idx))
                                    continue;
                            best_sim_val = sim;
                            best_sim_idx = p_idx;
                    }
                    return best_sim_idx;
            }

            /*
            * The first pass checks the blame entry (from the target) against the parent's
            * diff chunk.  If that fails for a line, the second pass tries to match that
            * line to any part of parent file.  That catches cases where a change was
            * broken into two chunks by 'context.'
            */
            static void guess_line_blames(struct blame_origin *parent,
                                    struct blame_origin *target,
                                    int tlno, int offset, int same, int parent_len,
                                    struct blame_line_tracker *line_blames)
            {
                    int i, best_idx, target_idx;
                    int parent_slno = tlno + offset;
                    int *fuzzy_matches;

                    fuzzy_matches = fuzzy_find_matching_lines(parent, target,
                                                            tlno, parent_slno, same,
                                                            parent_len);
                    for (i = 0; i < same - tlno; i++) {
                            target_idx = tlno + i;
                            if (fuzzy_matches && fuzzy_matches[i] >= 0) {
                                    best_idx = fuzzy_matches[i];
                            } else {
                                    best_idx = scan_parent_range(parent->fingerprints,
                                                            target->fingerprints,
                                                            target_idx, 0,
                                                            parent->num_lines);
                            }
                            if (best_idx >= 0) {
                                    line_blames[i].is_parent = 1;
                                    line_blames[i].s_lno = best_idx;
                            } else {
                                    line_blames[i].is_parent = 0;
                                    line_blames[i].s_lno = target_idx;
                            }
                    }
                    free(fuzzy_matches);
            }

            /*
            * This decides which parts of a blame entry go to the parent (added to the
            * ignoredp list) and which stay with the target (added to the diffp list).  The
            * actual decision was made in a separate heuristic function, and those answers
            * for the lines in 'e' are in line_blames.  This consumes e, essentially
            * putting it on a list.
            *
            * Note that the blame entries on the ignoredp list are not necessarily sorted
            * with respect to the parent's line numbers yet.
            */
            static void ignore_blame_entry(struct blame_entry *e,
                                    struct blame_origin *parent,
                                    struct blame_entry **diffp,
                                    struct blame_entry **ignoredp,
                                    struct blame_line_tracker *line_blames)
            {
                    int entry_len, nr_lines, i;

                    /*
                    * We carve new entries off the front of e.  Each entry comes from a
                    * contiguous chunk of lines: adjacent lines from the same origin
                    * (either the parent or the target).
                    */
                    entry_len = 1;
                    nr_lines = e->num_lines;        /* e changes in the loop */
                    for (i = 0; i < nr_lines; i++) {
                            struct blame_entry *next = NULL;

                            /*
                            * We are often adjacent to the next line - only split the blame
                            * entry when we have to.
                            */
                            if (i + 1 < nr_lines) {
                                    if (are_lines_adjacent(&line_blames[i],
                                                    &line_blames[i + 1])) {
                                            entry_len++;
                                            continue;
                                    }
                                    next = split_blame_at(e, entry_len,
                                                    blame_origin_incref(e->suspect));
                            }
                            if (line_blames[i].is_parent) {
                                    e->ignored = 1;
                                    blame_origin_decref(e->suspect);
                                    e->suspect = blame_origin_incref(parent);
                                    e->s_lno = line_blames[i - entry_len + 1].s_lno;
                                    e->next = *ignoredp;
                                    *ignoredp = e;
                            } else {
                                    e->unblamable = 1;
                                    /* e->s_lno is already in the target's address space. */
                                    e->next = *diffp;
                                    *diffp = e;
                            }
                            assert(e->num_lines == entry_len);
                            e = next;
                            entry_len = 1;
                    }
                    assert(!e);
            }

            /*
            * Process one hunk from the patch between the current suspect for
            * blame_entry e and its parent.  This first blames any unfinished
            * entries before the chunk (which is where target and parent start
            * differing) on the parent, and then splits blame entries at the
            * start and at the end of the difference region.  Since use of -M and
            * -C options may lead to overlapping/duplicate source line number
            * ranges, all we can rely on from sorting/merging is the order of the
            * first suspect line number.
            *
            * tlno: line number in the target where this chunk begins
            * same: line number in the target where this chunk ends
            * offset: add to tlno to get the chunk starting point in the parent
            * parent_len: number of lines in the parent chunk
            */
            static void blame_chunk(struct blame_entry ***dstq, struct blame_entry ***srcq,
                                    int tlno, int offset, int same, int parent_len,
                                    struct blame_origin *parent,
                                    struct blame_origin *target, int ignore_diffs)
            {
                    struct blame_entry *e = **srcq;
                    struct blame_entry *samep = NULL, *diffp = NULL, *ignoredp = NULL;
                    struct blame_line_tracker *line_blames = NULL;

                    while (e && e->s_lno < tlno) {
                            struct blame_entry *next = e->next;
                            /*
                            * current record starts before differing portion.  If
                            * it reaches into it, we need to split it up and
                            * examine the second part separately.
                            */
                            if (e->s_lno + e->num_lines > tlno) {
                                    /* Move second half to a new record */
                                    struct blame_entry *n;

                                    n = split_blame_at(e, tlno - e->s_lno, e->suspect);
                                    /* Push new record to diffp */
                                    n->next = diffp;
                                    diffp = n;
                            } else
                                    blame_origin_decref(e->suspect);
                            /* Pass blame for everything before the differing
                            * chunk to the parent */
                            e->suspect = blame_origin_incref(parent);
                            e->s_lno += offset;
                            e->next = samep;
                            samep = e;
                            e = next;
                    }
                    /*
                    * As we don't know how much of a common stretch after this
                    * diff will occur, the currently blamed parts are all that we
                    * can assign to the parent for now.
                    */

                    if (samep) {
                            **dstq = reverse_blame(samep, **dstq);
                            *dstq = &samep->next;
                    }
                    /*
                    * Prepend the split off portions: everything after e starts
                    * after the blameable portion.
                    */
                    e = reverse_blame(diffp, e);

                    /*
                    * Now retain records on the target while parts are different
                    * from the parent.
                    */
                    samep = NULL;
                    diffp = NULL;

                    if (ignore_diffs && same - tlno > 0) {
                            CALLOC_ARRAY(line_blames, same - tlno);
                            guess_line_blames(parent, target, tlno, offset, same,
                                            parent_len, line_blames);
                    }

                    while (e && e->s_lno < same) {
                            struct blame_entry *next = e->next;

                            /*
                            * If current record extends into sameness, need to split.
                            */
                            if (e->s_lno + e->num_lines > same) {
                                    /*
                                    * Move second half to a new record to be
                                    * processed by later chunks
                                    */
                                    struct blame_entry *n;

                                    n = split_blame_at(e, same - e->s_lno,
                                                    blame_origin_incref(e->suspect));
                                    /* Push new record to samep */
                                    n->next = samep;
                                    samep = n;
                            }
                            if (ignore_diffs) {
                                    ignore_blame_entry(e, parent, &diffp, &ignoredp,
                                                    line_blames + e->s_lno - tlno);
                            } else {
                                    e->next = diffp;
                                    diffp = e;
                            }
                            e = next;
                    }
                    free(line_blames);
                    if (ignoredp) {
                            /*
                            * Note ignoredp is not sorted yet, and thus neither is dstq.
                            * That list must be sorted before we queue_blames().  We defer
                            * sorting until after all diff hunks are processed, so that
                            * guess_line_blames() can pick *any* line in the parent.  The
                            * slight drawback is that we end up sorting all blame entries
                            * passed to the parent, including those that are unrelated to
                            * changes made by the ignored commit.
                            */
                            **dstq = reverse_blame(ignoredp, **dstq);
                            *dstq = &ignoredp->next;
                    }
                    **srcq = reverse_blame(diffp, reverse_blame(samep, e));
                    /* Move across elements that are in the unblamable portion */
                    if (diffp)
                            *srcq = &diffp->next;
            }

            struct blame_chunk_cb_data {
                    struct blame_origin *parent;
                    struct blame_origin *target;
                    long offset;
                    int ignore_diffs;
                    struct blame_entry **dstq;
                    struct blame_entry **srcq;
            };

            /* diff chunks are from parent to target */
            static int blame_chunk_cb(long start_a, long count_a,
                                    long start_b, long count_b, void *data)
            {
                    struct blame_chunk_cb_data *d = data;
                    if (start_a - start_b != d->offset)
                            die("internal error in blame::blame_chunk_cb");
                    blame_chunk(&d->dstq, &d->srcq, start_b, start_a - start_b,
                            start_b + count_b, count_a, d->parent, d->target,
                            d->ignore_diffs);
                    d->offset = start_a + count_a - (start_b + count_b);
                    return 0;
            }

            /*
            * We are looking at the origin 'target' and aiming to pass blame
            * for the lines it is suspected to its parent.  Run diff to find
            * which lines came from parent and pass blame for them.
            */
            static void pass_blame_to_parent(struct blame_scoreboard *sb,
                                            struct blame_origin *target,
                                            struct blame_origin *parent, int ignore_diffs)
            {
                    mmfile_t file_p, file_o;
                    struct blame_chunk_cb_data d;
                    struct blame_entry *newdest = NULL;

                    if (!target->suspects)
                            return; /* nothing remains for this target */

                    d.parent = parent;
                    d.target = target;
                    d.offset = 0;
                    d.ignore_diffs = ignore_diffs;
                    d.dstq = &newdest; d.srcq = &target->suspects;

                    fill_origin_blob(&sb->revs->diffopt, parent, &file_p,
                                    &sb->num_read_blob, ignore_diffs);
                    fill_origin_blob(&sb->revs->diffopt, target, &file_o,
                                    &sb->num_read_blob, ignore_diffs);
                    sb->num_get_patch++;

                    if (diff_hunks(&file_p, &file_o, blame_chunk_cb, &d, sb->xdl_opts))
                            die("unable to generate diff (%s -> %s)",
                            oid_to_hex(&parent->commit->object.oid),
                            oid_to_hex(&target->commit->object.oid));
                    /* The rest are the same as the parent */
                    blame_chunk(&d.dstq, &d.srcq, INT_MAX, d.offset, INT_MAX, 0,
                            parent, target, 0);
                    *d.dstq = NULL;
                    if (ignore_diffs)
                            sort_blame_entries(&newdest, compare_blame_suspect);
                    queue_blames(sb, parent, newdest);

                    return;
            }

            /*
            * The lines in blame_entry after splitting blames many times can become
            * very small and trivial, and at some point it becomes pointless to
            * blame the parents.  E.g. "\t\t}\n\t}\n\n" appears everywhere in any
            * ordinary C program, and it is not worth to say it was copied from
            * totally unrelated file in the parent.
            *
            * Compute how trivial the lines in the blame_entry are.
            */
            unsigned blame_entry_score(struct blame_scoreboard *sb, struct blame_entry *e)
            {
                    unsigned score;
                    const char *cp, *ep;

                    if (e->score)
                            return e->score;

                    score = 1;
                    cp = blame_nth_line(sb, e->lno);
                    ep = blame_nth_line(sb, e->lno + e->num_lines);
                    while (cp < ep) {
                            unsigned ch = *((unsigned char *)cp);
                            if (isalnum(ch))
                                    score++;
                            cp++;
                    }
                    e->score = score;
                    return score;
            }

            /*
            * best_so_far[] and potential[] are both a split of an existing blame_entry
            * that passes blame to the parent.  Maintain best_so_far the best split so
            * far, by comparing potential and best_so_far and copying potential into
            * bst_so_far as needed.
            */
            static void copy_split_if_better(struct blame_scoreboard *sb,
                                            struct blame_entry *best_so_far,
                                            struct blame_entry *potential)
            {
                    int i;

                    if (!potential[1].suspect)
                            return;
                    if (best_so_far[1].suspect) {
                            if (blame_entry_score(sb, &potential[1]) <
                            blame_entry_score(sb, &best_so_far[1]))
                                    return;
                    }

                    for (i = 0; i < 3; i++)
                            blame_origin_incref(potential[i].suspect);
                    decref_split(best_so_far);
                    memcpy(best_so_far, potential, sizeof(struct blame_entry[3]));
            }

            /*
            * We are looking at a part of the final image represented by
            * ent (tlno and same are offset by ent->s_lno).
            * tlno is where we are looking at in the final image.
            * up to (but not including) same match preimage.
            * plno is where we are looking at in the preimage.
            *
            * <-------------- final image ---------------------->
            *       <------ent------>
            *         ^tlno ^same
            *    <---------preimage----->
            *         ^plno
            *
            * All line numbers are 0-based.
            */
            static void handle_split(struct blame_scoreboard *sb,
                                    struct blame_entry *ent,
                                    int tlno, int plno, int same,
                                    struct blame_origin *parent,
                                    struct blame_entry *split)
            {
                    if (ent->num_lines <= tlno)
                            return;
                    if (tlno < same) {
                            struct blame_entry potential[3];
                            tlno += ent->s_lno;
                            same += ent->s_lno;
                            split_overlap(potential, ent, tlno, plno, same, parent);
                            copy_split_if_better(sb, split, potential);
                            decref_split(potential);
                    }
            }

            struct handle_split_cb_data {
                    struct blame_scoreboard *sb;
                    struct blame_entry *ent;
                    struct blame_origin *parent;
                    struct blame_entry *split;
                    long plno;
                    long tlno;
            };

            static int handle_split_cb(long start_a, long count_a,
                                    long start_b, long count_b, void *data)
            {
                    struct handle_split_cb_data *d = data;
                    handle_split(d->sb, d->ent, d->tlno, d->plno, start_b, d->parent,
                            d->split);
                    d->plno = start_a + count_a;
                    d->tlno = start_b + count_b;
                    return 0;
            }

            /*
            * Find the lines from parent that are the same as ent so that
            * we can pass blames to it.  file_p has the blob contents for
            * the parent.
            */
            static void find_copy_in_blob(struct blame_scoreboard *sb,
                                    struct blame_entry *ent,
                                    struct blame_origin *parent,
                                    struct blame_entry *split,
                                    mmfile_t *file_p)
            {
                    const char *cp;
                    mmfile_t file_o;
                    struct handle_split_cb_data d;

                    memset(&d, 0, sizeof(d));
                    d.sb = sb; d.ent = ent; d.parent = parent; d.split = split;
                    /*
                    * Prepare mmfile that contains only the lines in ent.
                    */
                    cp = blame_nth_line(sb, ent->lno);
                    file_o.ptr = (char *) cp;
                    file_o.size = blame_nth_line(sb, ent->lno + ent->num_lines) - cp;

                    /*
                    * file_o is a part of final image we are annotating.
                    * file_p partially may match that image.
                    */
                    memset(split, 0, sizeof(struct blame_entry [3]));
                    if (diff_hunks(file_p, &file_o, handle_split_cb, &d, sb->xdl_opts))
                            die("unable to generate diff (%s)",
                            oid_to_hex(&parent->commit->object.oid));
                    /* remainder, if any, all match the preimage */
                    handle_split(sb, ent, d.tlno, d.plno, ent->num_lines, parent, split);
            }

            /* Move all blame entries from list *source that have a score smaller
            * than score_min to the front of list *small.
            * Returns a pointer to the link pointing to the old head of the small list.
            */

            static struct blame_entry **filter_small(struct blame_scoreboard *sb,
                                                    struct blame_entry **small,
                                                    struct blame_entry **source,
                                                    unsigned score_min)
            {
                    struct blame_entry *p = *source;
                    struct blame_entry *oldsmall = *small;
                    while (p) {
                            if (blame_entry_score(sb, p) <= score_min) {
                                    *small = p;
                                    small = &p->next;
                                    p = *small;
                            } else {
                                    *source = p;
                                    source = &p->next;
                                    p = *source;
                            }
                    }
                    *small = oldsmall;
                    *source = NULL;
                    return small;
            }

            /*
            * See if lines currently target is suspected for can be attributed to
            * parent.
            */
            static void find_move_in_parent(struct blame_scoreboard *sb,
                                            struct blame_entry ***blamed,
                                            struct blame_entry **toosmall,
                                            struct blame_origin *target,
                                            struct blame_origin *parent)
            {
                    struct blame_entry *e, split[3];
                    struct blame_entry *unblamed = target->suspects;
                    struct blame_entry *leftover = NULL;
                    mmfile_t file_p;

                    if (!unblamed)
                            return; /* nothing remains for this target */

                    fill_origin_blob(&sb->revs->diffopt, parent, &file_p,
                                    &sb->num_read_blob, 0);
                    if (!file_p.ptr)
                            return;

                    /* At each iteration, unblamed has a NULL-terminated list of
                    * entries that have not yet been tested for blame.  leftover
                    * contains the reversed list of entries that have been tested
                    * without being assignable to the parent.
                    */
                    do {
                            struct blame_entry **unblamedtail = &unblamed;
                            struct blame_entry *next;
                            for (e = unblamed; e; e = next) {
                                    next = e->next;
                                    find_copy_in_blob(sb, e, parent, split, &file_p);
                                    if (split[1].suspect &&
                                    sb->move_score < blame_entry_score(sb, &split[1])) {
                                            split_blame(blamed, &unblamedtail, split, e);
                                    } else {
                                            e->next = leftover;
                                            leftover = e;
                                    }
                                    decref_split(split);
                            }
                            *unblamedtail = NULL;
                            toosmall = filter_small(sb, toosmall, &unblamed, sb->move_score);
                    } while (unblamed);
                    target->suspects = reverse_blame(leftover, NULL);
            }

            struct blame_list {
                    struct blame_entry *ent;
                    struct blame_entry split[3];
            };

            /*
            * Count the number of entries the target is suspected for,
            * and prepare a list of entry and the best split.
            */
            static struct blame_list *setup_blame_list(struct blame_entry *unblamed,
                                                    int *num_ents_p)
            {
                    struct blame_entry *e;
                    int num_ents, i;
                    struct blame_list *blame_list = NULL;

                    for (e = unblamed, num_ents = 0; e; e = e->next)
                            num_ents++;
                    if (num_ents) {
                            CALLOC_ARRAY(blame_list, num_ents);
                            for (e = unblamed, i = 0; e; e = e->next)
                                    blame_list[i++].ent = e;
                    }
                    *num_ents_p = num_ents;
                    return blame_list;
            }

            /*
            * For lines target is suspected for, see if we can find code movement
            * across file boundary from the parent commit.  porigin is the path
            * in the parent we already tried.
            */
            static void find_copy_in_parent(struct blame_scoreboard *sb,
                                            struct blame_entry ***blamed,
                                            struct blame_entry **toosmall,
                                            struct blame_origin *target,
                                            struct commit *parent,
                                            struct blame_origin *porigin,
                                            int opt)
            {
                    struct diff_options diff_opts;
                    int i, j;
                    struct blame_list *blame_list;
                    int num_ents;
                    struct blame_entry *unblamed = target->suspects;
                    struct blame_entry *leftover = NULL;

                    if (!unblamed)
                            return; /* nothing remains for this target */

                    repo_diff_setup(sb->repo, &diff_opts);
                    diff_opts.flags.recursive = 1;
                    diff_opts.output_format = DIFF_FORMAT_NO_OUTPUT;

                    diff_setup_done(&diff_opts);

                    /* Try "find copies harder" on new path if requested;
                    * we do not want to use diffcore_rename() actually to
                    * match things up; find_copies_harder is set only to
                    * force diff_tree_oid() to feed all filepairs to diff_queue,
                    * and this code needs to be after diff_setup_done(), which
                    * usually makes find-copies-harder imply copy detection.
                    */
                    if ((opt & PICKAXE_BLAME_COPY_HARDEST)
                    || ((opt & PICKAXE_BLAME_COPY_HARDER)
                            && (!porigin || strcmp(target->path, porigin->path))))
                            diff_opts.flags.find_copies_harder = 1;

                    if (is_null_oid(&target->commit->object.oid))
                            do_diff_cache(get_commit_tree_oid(parent), &diff_opts);
                    else
                            diff_tree_oid(get_commit_tree_oid(parent),
                                    get_commit_tree_oid(target->commit),
                                    "", &diff_opts);

                    if (!diff_opts.flags.find_copies_harder)
                            diffcore_std(&diff_opts);

                    do {
                            struct blame_entry **unblamedtail = &unblamed;
                            blame_list = setup_blame_list(unblamed, &num_ents);

                            for (i = 0; i < diff_queued_diff.nr; i++) {
                                    struct diff_filepair *p = diff_queued_diff.queue[i];
                                    struct blame_origin *norigin;
                                    mmfile_t file_p;
                                    struct blame_entry potential[3];

                                    if (!DIFF_FILE_VALID(p->one))
                                            continue; /* does not exist in parent */
                                    if (S_ISGITLINK(p->one->mode))
                                            continue; /* ignore git links */
                                    if (porigin && !strcmp(p->one->path, porigin->path))
                                            /* find_move already dealt with this path */
                                            continue;

                                    norigin = get_origin(parent, p->one->path);
                                    oidcpy(&norigin->blob_oid, &p->one->oid);
                                    norigin->mode = p->one->mode;
                                    fill_origin_blob(&sb->revs->diffopt, norigin, &file_p,
                                                    &sb->num_read_blob, 0);
                                    if (!file_p.ptr)
                                            continue;

                                    for (j = 0; j < num_ents; j++) {
                                            find_copy_in_blob(sb, blame_list[j].ent,
                                                            norigin, potential, &file_p);
                                            copy_split_if_better(sb, blame_list[j].split,
                                                            potential);
                                            decref_split(potential);
                                    }
                                    blame_origin_decref(norigin);
                            }

                            for (j = 0; j < num_ents; j++) {
                                    struct blame_entry *split = blame_list[j].split;
                                    if (split[1].suspect &&
                                    sb->copy_score < blame_entry_score(sb, &split[1])) {
                                            split_blame(blamed, &unblamedtail, split,
                                                    blame_list[j].ent);
                                    } else {
                                            blame_list[j].ent->next = leftover;
                                            leftover = blame_list[j].ent;
                                    }
                                    decref_split(split);
                            }
                            free(blame_list);
                            *unblamedtail = NULL;
                            toosmall = filter_small(sb, toosmall, &unblamed, sb->copy_score);
                    } while (unblamed);
                    target->suspects = reverse_blame(leftover, NULL);
                    diff_flush(&diff_opts);
            }

            /*
            * The blobs of origin and porigin exactly match, so everything
            * origin is suspected for can be blamed on the parent.
            */
            static void pass_whole_blame(struct blame_scoreboard *sb,
                                    struct blame_origin *origin, struct blame_origin *porigin)
            {
                    struct blame_entry *e, *suspects;

                    if (!porigin->file.ptr && origin->file.ptr) {
                            /* Steal its file */
                            porigin->file = origin->file;
                            origin->file.ptr = NULL;
                    }
                    suspects = origin->suspects;
                    origin->suspects = NULL;
                    for (e = suspects; e; e = e->next) {
                            blame_origin_incref(porigin);
                            blame_origin_decref(e->suspect);
                            e->suspect = porigin;
                    }
                    queue_blames(sb, porigin, suspects);
            }

            /*
            * We pass blame from the current commit to its parents.  We keep saying
            * "parent" (and "porigin"), but what we mean is to find scapegoat to
            * exonerate ourselves.
            */
            static struct commit_list *first_scapegoat(struct rev_info *revs, struct commit *commit,
                                                    int reverse)
            {
                    if (!reverse) {
                            if (revs->first_parent_only &&
                            commit->parents &&
                            commit->parents->next) {
                                    free_commit_list(commit->parents->next);
                                    commit->parents->next = NULL;
                            }
                            return commit->parents;
                    }
                    return lookup_decoration(&revs->children, &commit->object);
            }

            static int num_scapegoats(struct rev_info *revs, struct commit *commit, int reverse)
            {
                    struct commit_list *l = first_scapegoat(revs, commit, reverse);
                    return commit_list_count(l);
            }

            /* Distribute collected unsorted blames to the respected sorted lists
            * in the various origins.
            */
            static void distribute_blame(struct blame_scoreboard *sb, struct blame_entry *blamed)
            {
                    sort_blame_entries(&blamed, compare_blame_suspect);
                    while (blamed)
                    {
                            struct blame_origin *porigin = blamed->suspect;
                            struct blame_entry *suspects = NULL;
                            do {
                                    struct blame_entry *next = blamed->next;
                                    blamed->next = suspects;
                                    suspects = blamed;
                                    blamed = next;
                            } while (blamed && blamed->suspect == porigin);
                            suspects = reverse_blame(suspects, NULL);
                            queue_blames(sb, porigin, suspects);
                    }
            }

            #define MAXSG 16

            typedef struct blame_origin *(*blame_find_alg)(struct repository *,
                                                    struct commit *,
                                                    struct blame_origin *,
                                                    struct blame_bloom_data *);

            static void pass_blame(struct blame_scoreboard *sb, struct blame_origin *origin, int opt)
            {
                    struct rev_info *revs = sb->revs;
                    int i, pass, num_sg;
                    struct commit *commit = origin->commit;
                    struct commit_list *sg;
                    struct blame_origin *sg_buf[MAXSG];
                    struct blame_origin *porigin, **sg_origin = sg_buf;
                    struct blame_entry *toosmall = NULL;
                    struct blame_entry *blames, **blametail = &blames;

                    num_sg = num_scapegoats(revs, commit, sb->reverse);
                    if (!num_sg)
                            goto finish;
                    else if (num_sg < ARRAY_SIZE(sg_buf))
                            memset(sg_buf, 0, sizeof(sg_buf));
                    else
                            CALLOC_ARRAY(sg_origin, num_sg);

                    /*
                    * The first pass looks for unrenamed path to optimize for
                    * common cases, then we look for renames in the second pass.
                    */
                    for (pass = 0; pass < 2 - sb->no_whole_file_rename; pass++) {
                            blame_find_alg find = pass ? find_rename : find_origin;

                            for (i = 0, sg = first_scapegoat(revs, commit, sb->reverse);
                            i < num_sg && sg;
                            sg = sg->next, i++) {
                                    struct commit *p = sg->item;
                                    int j, same;

                                    if (sg_origin[i])
                                            continue;
                                    if (repo_parse_commit(the_repository, p))
                                            continue;
                                    porigin = find(sb->repo, p, origin, sb->bloom_data);
                                    if (!porigin)
                                            continue;
                                    if (oideq(&porigin->blob_oid, &origin->blob_oid)) {
                                            pass_whole_blame(sb, origin, porigin);
                                            blame_origin_decref(porigin);
                                            goto finish;
                                    }
                                    for (j = same = 0; j < i; j++)
                                            if (sg_origin[j] &&
                                            oideq(&sg_origin[j]->blob_oid, &porigin->blob_oid)) {
                                                    same = 1;
                                                    break;
                                            }
                                    if (!same)
                                            sg_origin[i] = porigin;
                                    else
                                            blame_origin_decref(porigin);
                            }
                    }

                    sb->num_commits++;
                    for (i = 0, sg = first_scapegoat(revs, commit, sb->reverse);
                    i < num_sg && sg;
                    sg = sg->next, i++) {
                            struct blame_origin *porigin = sg_origin[i];
                            if (!porigin)
                                    continue;
                            if (!origin->previous) {
                                    blame_origin_incref(porigin);
                                    origin->previous = porigin;
                            }
                            pass_blame_to_parent(sb, origin, porigin, 0);
                            if (!origin->suspects)
                                    goto finish;
                    }

                    /*
                    * Pass remaining suspects for ignored commits to their parents.
                    */
                    if (oidset_contains(&sb->ignore_list, &commit->object.oid)) {
                            for (i = 0, sg = first_scapegoat(revs, commit, sb->reverse);
                            i < num_sg && sg;
                            sg = sg->next, i++) {
                                    struct blame_origin *porigin = sg_origin[i];

                                    if (!porigin)
                                            continue;
                                    pass_blame_to_parent(sb, origin, porigin, 1);
                                    /*
                                    * Preemptively drop porigin so we can refresh the
                                    * fingerprints if we use the parent again, which can
                                    * occur if you ignore back-to-back commits.
                                    */
                                    drop_origin_blob(porigin);
                                    if (!origin->suspects)
                                            goto finish;
                            }
                    }

                    /*
                    * Optionally find moves in parents' files.
                    */
                    if (opt & PICKAXE_BLAME_MOVE) {
                            filter_small(sb, &toosmall, &origin->suspects, sb->move_score);
                            if (origin->suspects) {
                                    for (i = 0, sg = first_scapegoat(revs, commit, sb->reverse);
                                    i < num_sg && sg;
                                    sg = sg->next, i++) {
                                            struct blame_origin *porigin = sg_origin[i];
                                            if (!porigin)
                                                    continue;
                                            find_move_in_parent(sb, &blametail, &toosmall, origin, porigin);
                                            if (!origin->suspects)
                                                    break;
                                    }
                            }
                    }

                    /*
                    * Optionally find copies from parents' files.
                    */
                    if (opt & PICKAXE_BLAME_COPY) {
                            if (sb->copy_score > sb->move_score)
                                    filter_small(sb, &toosmall, &origin->suspects, sb->copy_score);
                            else if (sb->copy_score < sb->move_score) {
                                    origin->suspects = blame_merge(origin->suspects, toosmall);
                                    toosmall = NULL;
                                    filter_small(sb, &toosmall, &origin->suspects, sb->copy_score);
                            }
                            if (!origin->suspects)
                                    goto finish;

                            for (i = 0, sg = first_scapegoat(revs, commit, sb->reverse);
                            i < num_sg && sg;
                            sg = sg->next, i++) {
                                    struct blame_origin *porigin = sg_origin[i];
                                    find_copy_in_parent(sb, &blametail, &toosmall,
                                                    origin, sg->item, porigin, opt);
                                    if (!origin->suspects)
                                            goto finish;
                            }
                    }

            finish:
                    *blametail = NULL;
                    distribute_blame(sb, blames);
                    /*
                    * prepend toosmall to origin->suspects
                    *
                    * There is no point in sorting: this ends up on a big
                    * unsorted list in the caller anyway.
                    */
                    if (toosmall) {
                            struct blame_entry **tail = &toosmall;
                            while (*tail)
                                    tail = &(*tail)->next;
                            *tail = origin->suspects;
                            origin->suspects = toosmall;
                    }
                    for (i = 0; i < num_sg; i++) {
                            if (sg_origin[i]) {
                                    if (!sg_origin[i]->suspects)
                                            drop_origin_blob(sg_origin[i]);
                                    blame_origin_decref(sg_origin[i]);
                            }
                    }
                    drop_origin_blob(origin);
                    if (sg_buf != sg_origin)
                            free(sg_origin);
            }

            /*
            * The main loop -- while we have blobs with lines whose true origin
            * is still unknown, pick one blob, and allow its lines to pass blames
            * to its parents. */
            void assign_blame(struct blame_scoreboard *sb, int opt)
            {
                    struct rev_info *revs = sb->revs;
                    struct commit *commit = prio_queue_get(&sb->commits);

                    while (commit) {
                            struct blame_entry *ent;
                            struct blame_origin *suspect = get_blame_suspects(commit);

                            /* find one suspect to break down */
                            while (suspect && !suspect->suspects)
                                    suspect = suspect->next;

                            if (!suspect) {
                                    commit = prio_queue_get(&sb->commits);
                                    continue;
                            }

                            assert(commit == suspect->commit);

                            /*
                            * We will use this suspect later in the loop,
                            * so hold onto it in the meantime.
                            */
                            blame_origin_incref(suspect);
                            repo_parse_commit(the_repository, commit);
                            if (sb->reverse ||
                            (!(commit->object.flags & UNINTERESTING) &&
                            !(revs->max_age != -1 && commit->date < revs->max_age)))
                                    pass_blame(sb, suspect, opt);
                            else {
                                    commit->object.flags |= UNINTERESTING;
                                    if (commit->object.parsed)
                                            mark_parents_uninteresting(sb->revs, commit);
                            }
                            /* treat root commit as boundary */
                            if (!commit->parents && !sb->show_root)
                                    commit->object.flags |= UNINTERESTING;

                            /* Take responsibility for the remaining entries */
                            ent = suspect->suspects;
                            if (ent) {
                                    suspect->guilty = 1;
                                    for (;;) {
                                            struct blame_entry *next = ent->next;
                                            if (sb->found_guilty_entry)
                                                    sb->found_guilty_entry(ent, sb->found_guilty_entry_data);
                                            if (next) {
                                                    ent = next;
                                                    continue;
                                            }
                                            ent->next = sb->ent;
                                            sb->ent = suspect->suspects;
                                            suspect->suspects = NULL;
                                            break;
                                    }
                            }
                            blame_origin_decref(suspect);

                            if (sb->debug) /* sanity */
                                    sanity_check_refcnt(sb);
                    }
            }

            /*
            * To allow quick access to the contents of nth line in the
            * final image, prepare an index in the scoreboard.
            */
            static int prepare_lines(struct blame_scoreboard *sb)
            {
                    sb->num_lines = find_line_starts(&sb->lineno, sb->final_buf,
                                                    sb->final_buf_size);
                    return sb->num_lines;
            }

            static struct commit *find_single_final(struct rev_info *revs,
                                                    const char **name_p)
            {
                    int i;
                    struct commit *found = NULL;
                    const char *name = NULL;

                    for (i = 0; i < revs->pending.nr; i++) {
                            struct object *obj = revs->pending.objects[i].item;
                            if (obj->flags & UNINTERESTING)
                                    continue;
                            obj = deref_tag(revs->repo, obj, NULL, 0);
                            if (!obj || obj->type != OBJ_COMMIT)
                                    die("Non commit %s?", revs->pending.objects[i].name);
                            if (found)
                                    die("More than one commit to dig from %s and %s?",
                                    revs->pending.objects[i].name, name);
                            found = (struct commit *)obj;
                            name = revs->pending.objects[i].name;
                    }
                    if (name_p)
                            *name_p = xstrdup_or_null(name);
                    return found;
            }

            static struct commit *dwim_reverse_initial(struct rev_info *revs,
                                                    const char **name_p)
            {
                    /*
                    * DWIM "git blame --reverse ONE -- PATH" as
                    * "git blame --reverse ONE..HEAD -- PATH" but only do so
                    * when it makes sense.
                    */
                    struct object *obj;
                    struct commit *head_commit;
                    struct object_id head_oid;

                    if (revs->pending.nr != 1)
                            return NULL;

                    /* Is that sole rev a committish? */
                    obj = revs->pending.objects[0].item;
                    obj = deref_tag(revs->repo, obj, NULL, 0);
                    if (!obj || obj->type != OBJ_COMMIT)
                            return NULL;

                    /* Do we have HEAD? */
                    if (!refs_resolve_ref_unsafe(get_main_ref_store(the_repository), "HEAD", RESOLVE_REF_READING, &head_oid, NULL))
                            return NULL;
                    head_commit = lookup_commit_reference_gently(revs->repo,
                                                            &head_oid, 1);
                    if (!head_commit)
                            return NULL;

                    /* Turn "ONE" into "ONE..HEAD" then */
                    obj->flags |= UNINTERESTING;
                    add_pending_object(revs, &head_commit->object, "HEAD");

                    if (name_p)
                            *name_p = revs->pending.objects[0].name;
                    return (struct commit *)obj;
            }

            static struct commit *find_single_initial(struct rev_info *revs,
                                                    const char **name_p)
            {
                    int i;
                    struct commit *found = NULL;
                    const char *name = NULL;

                    /*
                    * There must be one and only one negative commit, and it must be
                    * the boundary.
                    */
                    for (i = 0; i < revs->pending.nr; i++) {
                            struct object *obj = revs->pending.objects[i].item;
                            if (!(obj->flags & UNINTERESTING))
                                    continue;
                            obj = deref_tag(revs->repo, obj, NULL, 0);
                            if (!obj || obj->type != OBJ_COMMIT)
                                    die("Non commit %s?", revs->pending.objects[i].name);
                            if (found)
                                    die("More than one commit to dig up from, %s and %s?",
                                    revs->pending.objects[i].name, name);
                            found = (struct commit *) obj;
                            name = revs->pending.objects[i].name;
                    }

                    if (!name)
                            found = dwim_reverse_initial(revs, &name);
                    if (!name)
                            die("No commit to dig up from?");

                    if (name_p)
                            *name_p = xstrdup(name);
                    return found;
            }

            void init_scoreboard(struct blame_scoreboard *sb)
            {
                    memset(sb, 0, sizeof(struct blame_scoreboard));
                    sb->move_score = BLAME_DEFAULT_MOVE_SCORE;
                    sb->copy_score = BLAME_DEFAULT_COPY_SCORE;
            }

            void setup_scoreboard(struct blame_scoreboard *sb,
                            struct blame_origin **orig)
            {
                    const char *final_commit_name = NULL;
                    struct blame_origin *o;
                    struct commit *final_commit = NULL;
                    enum object_type type;

                    init_blame_suspects(&blame_suspects);

                    if (sb->reverse && sb->contents_from)
                            die(_("--contents and --reverse do not blend well."));

                    if (!sb->repo)
                            BUG("repo is NULL");

                    if (!sb->reverse) {
                            sb->final = find_single_final(sb->revs, &final_commit_name);
                            sb->commits.compare = compare_commits_by_commit_date;
                    } else {
                            sb->final = find_single_initial(sb->revs, &final_commit_name);
                            sb->commits.compare = compare_commits_by_reverse_commit_date;
                    }

                    if (sb->reverse && sb->revs->first_parent_only)
                            sb->revs->children.name = NULL;

                    if (sb->contents_from || !sb->final) {
                            struct object_id head_oid, *parent_oid;

                            /*
                            * Build a fake commit at the top of the history, when
                            * (1) "git blame [^A] --path", i.e. with no positive end
                            *     of the history range, in which case we build such
                            *     a fake commit on top of the HEAD to blame in-tree
                            *     modifications.
                            * (2) "git blame --contents=file [A] -- path", with or
                            *     without positive end of the history range but with
                            *     --contents, in which case we pretend that there is
                            *     a fake commit on top of the positive end (defaulting to
                            *     HEAD) that has the given contents in the path.
                            */
                            if (sb->final) {
                                    parent_oid = &sb->final->object.oid;
                            } else {
                                    if (!refs_resolve_ref_unsafe(get_main_ref_store(the_repository), "HEAD", RESOLVE_REF_READING, &head_oid, NULL))
                                            die("no such ref: HEAD");
                                    parent_oid = &head_oid;
                            }

                            if (!sb->contents_from)
                                    setup_work_tree();

                            sb->final = fake_working_tree_commit(sb->repo,
                                                            &sb->revs->diffopt,
                                                            sb->path, sb->contents_from,
                                                            parent_oid);
                            add_pending_object(sb->revs, &(sb->final->object), ":");
                    }

                    if (sb->reverse && sb->revs->first_parent_only) {
                            final_commit = find_single_final(sb->revs, NULL);
                            if (!final_commit)
                                    die(_("--reverse and --first-parent together require specified latest commit"));
                    }

                    /*
                    * If we have bottom, this will mark the ancestors of the
                    * bottom commits we would reach while traversing as
                    * uninteresting.
                    */
                    if (prepare_revision_walk(sb->revs))
                            die(_("revision walk setup failed"));

                    if (sb->reverse && sb->revs->first_parent_only) {
                            struct commit *c = final_commit;

                            sb->revs->children.name = "children";
                            while (c->parents &&
                            !oideq(&c->object.oid, &sb->final->object.oid)) {
                                    struct commit_list *l = xcalloc(1, sizeof(*l));

                                    l->item = c;
                                    if (add_decoration(&sb->revs->children,
                                                    &c->parents->item->object, l))
                                            BUG("not unique item in first-parent chain");
                                    c = c->parents->item;
                            }

                            if (!oideq(&c->object.oid, &sb->final->object.oid))
                                    die(_("--reverse --first-parent together require range along first-parent chain"));
                    }

                    if (is_null_oid(&sb->final->object.oid)) {
                            o = get_blame_suspects(sb->final);
                            sb->final_buf = xmemdupz(o->file.ptr, o->file.size);
                            sb->final_buf_size = o->file.size;
                    }
                    else {
                            o = get_origin(sb->final, sb->path);
                            if (fill_blob_sha1_and_mode(sb->repo, o))
                                    die(_("no such path %s in %s"), sb->path, final_commit_name);

                            if (sb->revs->diffopt.flags.allow_textconv &&
                            textconv_object(sb->repo, sb->path, o->mode, &o->blob_oid, 1, (char **) &sb->final_buf,
                                            &sb->final_buf_size))
                                    ;
                            else
                                    sb->final_buf = repo_read_object_file(the_repository,
                                                                    &o->blob_oid,
                                                                    &type,
                                                                    &sb->final_buf_size);

                            if (!sb->final_buf)
                                    die(_("cannot read blob %s for path %s"),
                                    oid_to_hex(&o->blob_oid),
                                    sb->path);
                    }
                    sb->num_read_blob++;
                    prepare_lines(sb);

                    if (orig)
                            *orig = o;

                    free((char *)final_commit_name);
            }



            struct blame_entry *blame_entry_prepend(struct blame_entry *head,
                                                    long start, long end,
                                                    struct blame_origin *o)
            {
                    struct blame_entry *new_head = xcalloc(1, sizeof(struct blame_entry));
                    new_head->lno = start;
                    new_head->num_lines = end - start;
                    new_head->suspect = o;
                    new_head->s_lno = start;
                    new_head->next = head;
                    blame_origin_incref(o);
                    return new_head;
            }

            void setup_blame_bloom_data(struct blame_scoreboard *sb)
            {
                    struct blame_bloom_data *bd;
                    struct bloom_filter_settings *bs;

                    if (!sb->repo->objects->commit_graph)
                            return;

                    bs = get_bloom_filter_settings(sb->repo);
                    if (!bs)
                            return;

                    bd = xmalloc(sizeof(struct blame_bloom_data));

                    bd->settings = bs;

                    bd->alloc = 4;
                    bd->nr = 0;
                    ALLOC_ARRAY(bd->keys, bd->alloc);

                    add_bloom_key(bd, sb->path);

                    sb->bloom_data = bd;
            }

            void cleanup_scoreboard(struct blame_scoreboard *sb)
            {
                    free(sb->lineno);
                    free(sb->final_buf);
                    clear_prio_queue(&sb->commits);
                    oidset_clear(&sb->ignore_list);

                    if (sb->bloom_data) {
                            int i;
                            for (i = 0; i < sb->bloom_data->nr; i++) {
                                    free(sb->bloom_data->keys[i]->hashes);
                                    free(sb->bloom_data->keys[i]);
                            }
                            free(sb->bloom_data->keys);
                            FREE_AND_NULL(sb->bloom_data);

                            trace2_data_intmax("blame", sb->repo,
                                            "bloom/queries", bloom_count_queries);
                            trace2_data_intmax("blame", sb->repo,
                                            "bloom/response-no", bloom_count_no);
                    }
            }
          """,

    "patch":
    """
                    diff --git a/blame.c b/blame.c
            index b830654..f2458c3 100644
            --- a/blame.c
            +++ b/blame.c
            @@ -267,6 +267,11 @@ static struct commit *fake_working_tree_commit(struct repository *r,
                            if (strbuf_read(&buf, 0, 0) < 0)
                                    die_errno("failed to read from stdin");
                    }
            +#ifdef __MVS__
            +   int autocvtToASCII;
            +   validate_codeset(r->index, path, &autocvtToASCII);
            +   if (autocvtToASCII)
            +#endif
                    convert_to_git(r->index, path, buf.buf, buf.len, &buf, 0);
                    origin->file.ptr = buf.buf;
                    origin->file.size = buf.len;

    """,

    },

    {
         "wrongcode":
         """
                    #ifndef BUILTIN_H
            #define BUILTIN_H

            #include "git-compat-util.h"
            #include "repository.h"

            /*
            * builtin API
            * ===========
            *
            * Adding a new built-in
            * ---------------------
            *
            * There are 4 things to do to add a built-in command implementation to
            * Git:
            *
            * . Define the implementation of the built-in command `foo` with
            *   signature:
            *
            *      int cmd_foo(int argc, const char **argv, const char *prefix);
            *
            * . Add the external declaration for the function to `builtin.h`.
            *
            * . Add the command to the `commands[]` table defined in `git.c`.
            *   The entry should look like:
            *
            *      { "foo", cmd_foo, <options> },
            *
            * where options is the bitwise-or of:
            *
            * `RUN_SETUP`:
            *      If there is not a Git directory to work on, abort.  If there
            *      is a work tree, chdir to the top of it if the command was
            *      invoked in a subdirectory.  If there is no work tree, no
            *      chdir() is done.
            *
            * `RUN_SETUP_GENTLY`:
            *      If there is a Git directory, chdir as per RUN_SETUP, otherwise,
            *      don't chdir anywhere.
            *
            * `USE_PAGER`:
            *
            *      If the standard output is connected to a tty, spawn a pager and
            *      feed our output to it.
            *
            * `NEED_WORK_TREE`:
            *
            *      Make sure there is a work tree, i.e. the command cannot act
            *      on bare repositories.
            *      This only makes sense when `RUN_SETUP` is also set.
            *
            * `DELAY_PAGER_CONFIG`:
            *
            *      If RUN_SETUP or RUN_SETUP_GENTLY is set, git.c normally handles
            *      the `pager.<cmd>`-configuration. If this flag is used, git.c
            *      will skip that step, instead allowing the built-in to make a
            *      more informed decision, e.g., by ignoring `pager.<cmd>` for
            *      certain subcommands.
            *
            * . Add `builtin/foo.o` to `BUILTIN_OBJS` in `Makefile`.
            *
            * Additionally, if `foo` is a new command, there are 4 more things to do:
            *
            * . Add tests to `t/` directory.
            *
            * . Write documentation in `Documentation/git-foo.txt`.
            *
            * . Add an entry for `git-foo` to `command-list.txt`.
            *
            * . Add an entry for `/git-foo` to `.gitignore`.
            *
            *
            * How a built-in is called
            * ------------------------
            *
            * The implementation `cmd_foo()` takes three parameters, `argc`, `argv,
            * and `prefix`.  The first two are similar to what `main()` of a
            * standalone command would be called with.
            *
            * When `RUN_SETUP` is specified in the `commands[]` table, and when you
            * were started from a subdirectory of the work tree, `cmd_foo()` is called
            * after chdir(2) to the top of the work tree, and `prefix` gets the path
            * to the subdirectory the command started from.  This allows you to
            * convert a user-supplied pathname (typically relative to that directory)
            * to a pathname relative to the top of the work tree.
            *
            * The return value from `cmd_foo()` becomes the exit status of the
            * command.
            */

            extern const char git_usage_string[];
            extern const char git_more_info_string[];

            /**
            * If a built-in has DELAY_PAGER_CONFIG set, the built-in should call this early
            * when it wishes to respect the `pager.foo`-config. The `cmd` is the name of
            * the built-in, e.g., "foo". If a paging-choice has already been setup, this
            * does nothing. The default in `def` should be 0 for "pager off", 1 for "pager
            * on" or -1 for "punt".
            *
            * You should most likely use a default of 0 or 1. "Punt" (-1) could be useful
            * to be able to fall back to some historical compatibility name.
            */
            void setup_auto_pager(const char *cmd, int def);

            int is_builtin(const char *s);

            /*
            * Builtins which do not use RUN_SETUP should never see
            * a prefix that is not empty; use this to protect downstream
            * code which is not prepared to call prefix_filename(), etc.
            */
            #define BUG_ON_NON_EMPTY_PREFIX(prefix) do { \
                    if ((prefix)) \
                            BUG("unexpected prefix in builtin: %s", (prefix)); \
            } while (0)

            int cmd_add(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_am(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_annotate(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_apply(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_archive(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_bisect(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_blame(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_branch(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_bugreport(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_bundle(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_cat_file(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_checkout(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_checkout__worker(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_checkout_index(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_check_attr(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_check_ignore(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_check_mailmap(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_check_ref_format(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_cherry(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_cherry_pick(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_clone(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_clean(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_column(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_commit(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_commit_graph(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_commit_tree(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_config(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_count_objects(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_credential(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_credential_cache(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_credential_cache_daemon(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_credential_store(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_describe(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_diagnose(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_diff_files(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_diff_index(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_diff(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_diff_tree(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_difftool(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_env__helper(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_fast_export(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_fast_import(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_fetch(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_fetch_pack(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_fmt_merge_msg(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_for_each_ref(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_for_each_repo(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_format_patch(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_fsck(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_fsmonitor__daemon(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_gc(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_get_tar_commit_id(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_grep(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_hash_object(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_help(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_hook(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_index_pack(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_init_db(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_interpret_trailers(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_log_reflog(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_log(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_ls_files(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_ls_tree(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_ls_remote(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_mailinfo(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_mailsplit(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_maintenance(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_merge(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_merge_base(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_merge_index(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_merge_ours(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_merge_file(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_merge_recursive(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_merge_tree(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_mktag(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_mktree(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_multi_pack_index(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_mv(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_name_rev(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_notes(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_pack_objects(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_pack_redundant(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_patch_id(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_prune(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_prune_packed(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_pull(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_push(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_range_diff(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_read_tree(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_rebase(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_rebase__interactive(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_receive_pack(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_reflog(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_refs(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_remote(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_remote_ext(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_remote_fd(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_repack(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_replay(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_rerere(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_reset(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_restore(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_rev_list(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_rev_parse(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_revert(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_rm(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_send_pack(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_shortlog(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_show(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_show_branch(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_show_index(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_sparse_checkout(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_status(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_stash(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_stripspace(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_submodule__helper(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_switch(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_symbolic_ref(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_tag(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_unpack_file(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_unpack_objects(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_update_index(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_update_ref(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_update_server_info(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_upload_archive(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_upload_archive_writer(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_upload_pack(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_var(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_verify_commit(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_verify_tag(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_version(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_whatchanged(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_worktree(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_write_tree(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_verify_pack(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_show_ref(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_pack_refs(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_replace(int argc, const char **argv, const char *prefix, struct repository *repo);

            #endif
         """,
    "error":"On z/OS, certain operations require explicitly tagging file descriptors for binary mode to prevent character encoding conversions (e.g., from EBCDIC to ASCII) that could corrupt data.
             Declaring this function allows other parts of the Git codebase to utilize it for handling file descriptors on z/OS.",
    "error category":"Fuctionality Patche",

    "Corrected_Code":
    """
            #ifndef BUILTIN_H
            #define BUILTIN_H

            #include "git-compat-util.h"
            #include "repository.h"

            /*
            * builtin API
            * ===========
            *
            * Adding a new built-in
            * ---------------------
            *
            * There are 4 things to do to add a built-in command implementation to
            * Git:
            *
            * . Define the implementation of the built-in command `foo` with
            *   signature:
            *
            *      int cmd_foo(int argc, const char **argv, const char *prefix);
            *
            * . Add the external declaration for the function to `builtin.h`.
            *
            * . Add the command to the `commands[]` table defined in `git.c`.
            *   The entry should look like:
            *
            *      { "foo", cmd_foo, <options> },
            *
            * where options is the bitwise-or of:
            *
            * `RUN_SETUP`:
            *      If there is not a Git directory to work on, abort.  If there
            *      is a work tree, chdir to the top of it if the command was
            *      invoked in a subdirectory.  If there is no work tree, no
            *      chdir() is done.
            *
            * `RUN_SETUP_GENTLY`:
            *      If there is a Git directory, chdir as per RUN_SETUP, otherwise,
            *      don't chdir anywhere.
            *
            * `USE_PAGER`:
            *
            *      If the standard output is connected to a tty, spawn a pager and
            *      feed our output to it.
            *
            * `NEED_WORK_TREE`:
            *
            *      Make sure there is a work tree, i.e. the command cannot act
            *      on bare repositories.
            *      This only makes sense when `RUN_SETUP` is also set.
            *
            * `DELAY_PAGER_CONFIG`:
            *
            *      If RUN_SETUP or RUN_SETUP_GENTLY is set, git.c normally handles
            *      the `pager.<cmd>`-configuration. If this flag is used, git.c
            *      will skip that step, instead allowing the built-in to make a
            *      more informed decision, e.g., by ignoring `pager.<cmd>` for
            *      certain subcommands.
            *
            * . Add `builtin/foo.o` to `BUILTIN_OBJS` in `Makefile`.
            *
            * Additionally, if `foo` is a new command, there are 4 more things to do:
            *
            * . Add tests to `t/` directory.
            *
            * . Write documentation in `Documentation/git-foo.txt`.
            *
            * . Add an entry for `git-foo` to `command-list.txt`.
            *
            * . Add an entry for `/git-foo` to `.gitignore`.
            *
            *
            * How a built-in is called
            * ------------------------
            *
            * The implementation `cmd_foo()` takes three parameters, `argc`, `argv,
            * and `prefix`.  The first two are similar to what `main()` of a
            * standalone command would be called with.
            *
            * When `RUN_SETUP` is specified in the `commands[]` table, and when you
            * were started from a subdirectory of the work tree, `cmd_foo()` is called
            * after chdir(2) to the top of the work tree, and `prefix` gets the path
            * to the subdirectory the command started from.  This allows you to
            * convert a user-supplied pathname (typically relative to that directory)
            * to a pathname relative to the top of the work tree.
            *
            * The return value from `cmd_foo()` becomes the exit status of the
            * command.
            */

            extern const char git_usage_string[];
            extern const char git_more_info_string[];

            /**
            * If a built-in has DELAY_PAGER_CONFIG set, the built-in should call this early
            * when it wishes to respect the `pager.foo`-config. The `cmd` is the name of
            * the built-in, e.g., "foo". If a paging-choice has already been setup, this
            * does nothing. The default in `def` should be 0 for "pager off", 1 for "pager
            * on" or -1 for "punt".
            *
            * You should most likely use a default of 0 or 1. "Punt" (-1) could be useful
            * to be able to fall back to some historical compatibility name.
            */
            void setup_auto_pager(const char *cmd, int def);

            int is_builtin(const char *s);

            /*
            * Builtins which do not use RUN_SETUP should never see
            * a prefix that is not empty; use this to protect downstream
            * code which is not prepared to call prefix_filename(), etc.
            */
            #define BUG_ON_NON_EMPTY_PREFIX(prefix) do { \
                    if ((prefix)) \
                            BUG("unexpected prefix in builtin: %s", (prefix)); \
            } while (0)

            int cmd_add(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_am(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_annotate(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_apply(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_archive(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_bisect(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_blame(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_branch(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_bugreport(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_bundle(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_cat_file(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_checkout(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_checkout__worker(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_checkout_index(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_check_attr(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_check_ignore(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_check_mailmap(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_check_ref_format(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_cherry(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_cherry_pick(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_clone(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_clean(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_column(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_commit(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_commit_graph(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_commit_tree(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_config(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_count_objects(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_credential(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_credential_cache(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_credential_cache_daemon(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_credential_store(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_describe(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_diagnose(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_diff_files(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_diff_index(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_diff(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_diff_tree(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_difftool(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_env__helper(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_fast_export(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_fast_import(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_fetch(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_fetch_pack(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_fmt_merge_msg(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_for_each_ref(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_for_each_repo(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_format_patch(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_fsck(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_fsmonitor__daemon(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_gc(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_get_tar_commit_id(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_grep(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_hash_object(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_help(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_hook(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_index_pack(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_init_db(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_interpret_trailers(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_log_reflog(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_log(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_ls_files(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_ls_tree(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_ls_remote(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_mailinfo(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_mailsplit(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_maintenance(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_merge(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_merge_base(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_merge_index(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_merge_ours(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_merge_file(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_merge_recursive(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_merge_tree(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_mktag(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_mktree(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_multi_pack_index(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_mv(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_name_rev(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_notes(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_pack_objects(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_pack_redundant(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_patch_id(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_prune(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_prune_packed(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_pull(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_push(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_range_diff(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_read_tree(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_rebase(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_rebase__interactive(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_receive_pack(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_reflog(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_refs(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_remote(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_remote_ext(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_remote_fd(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_repack(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_replay(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_rerere(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_reset(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_restore(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_rev_list(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_rev_parse(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_revert(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_rm(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_send_pack(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_shortlog(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_show(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_show_branch(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_show_index(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_sparse_checkout(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_status(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_stash(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_stripspace(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_submodule__helper(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_switch(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_symbolic_ref(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_tag(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_unpack_file(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_unpack_objects(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_update_index(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_update_ref(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_update_server_info(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_upload_archive(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_upload_archive_writer(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_upload_pack(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_var(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_verify_commit(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_verify_tag(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_version(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_whatchanged(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_worktree(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_write_tree(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_verify_pack(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_show_ref(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_pack_refs(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_replace(int argc, const char **argv, const char *prefix, struct repository *repo);
            #ifdef __MVS__
            extern int setbinaryfd(int);
            #endif
            #endif
    """,

    "patche":
    """
                    diff --git a/builtin.h b/builtin.h
            index f7b166b334..c7896cda4b 100644
            --- a/builtin.h
            +++ b/builtin.h
            @@ -253,5 +253,7 @@ int cmd_verify_pack(int argc, const char **argv, const char *prefix, struct repo
            int cmd_show_ref(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_pack_refs(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_replace(int argc, const char **argv, const char *prefix, struct repository *repo);
            -
            +#ifdef __MVS__
            +  extern int setbinaryfd(int);
            +#endif
            #endif
    """,

    },

    {
       "wrongcode":
       """
            #ifndef BUILTIN_H
            #define BUILTIN_H

            #include "git-compat-util.h"
            #include "repository.h"

            /*
            * builtin API
            * ===========
            *
            * Adding a new built-in
            * ---------------------
            *
            * There are 4 things to do to add a built-in command implementation to
            * Git:
            *
            * . Define the implementation of the built-in command `foo` with
            *   signature:
            *
            *      int cmd_foo(int argc, const char **argv, const char *prefix);
            *
            * . Add the external declaration for the function to `builtin.h`.
            *
            * . Add the command to the `commands[]` table defined in `git.c`.
            *   The entry should look like:
            *
            *      { "foo", cmd_foo, <options> },
            *
            * where options is the bitwise-or of:
            *
            * `RUN_SETUP`:
            *      If there is not a Git directory to work on, abort.  If there
            *      is a work tree, chdir to the top of it if the command was
            *      invoked in a subdirectory.  If there is no work tree, no
            *      chdir() is done.
            *
            * `RUN_SETUP_GENTLY`:
            *      If there is a Git directory, chdir as per RUN_SETUP, otherwise,
            *      don't chdir anywhere.
            *
            * `USE_PAGER`:
            *
            *      If the standard output is connected to a tty, spawn a pager and
            *      feed our output to it.
            *
            * `NEED_WORK_TREE`:
            *
            *      Make sure there is a work tree, i.e. the command cannot act
            *      on bare repositories.
            *      This only makes sense when `RUN_SETUP` is also set.
            *
            * `DELAY_PAGER_CONFIG`:
            *
            *      If RUN_SETUP or RUN_SETUP_GENTLY is set, git.c normally handles
            *      the `pager.<cmd>`-configuration. If this flag is used, git.c
            *      will skip that step, instead allowing the built-in to make a
            *      more informed decision, e.g., by ignoring `pager.<cmd>` for
            *      certain subcommands.
            *
            * . Add `builtin/foo.o` to `BUILTIN_OBJS` in `Makefile`.
            *
            * Additionally, if `foo` is a new command, there are 4 more things to do:
            *
            * . Add tests to `t/` directory.
            *
            * . Write documentation in `Documentation/git-foo.txt`.
            *
            * . Add an entry for `git-foo` to `command-list.txt`.
            *
            * . Add an entry for `/git-foo` to `.gitignore`.
            *
            *
            * How a built-in is called
            * ------------------------
            *
            * The implementation `cmd_foo()` takes three parameters, `argc`, `argv,
            * and `prefix`.  The first two are similar to what `main()` of a
            * standalone command would be called with.
            *
            * When `RUN_SETUP` is specified in the `commands[]` table, and when you
            * were started from a subdirectory of the work tree, `cmd_foo()` is called
            * after chdir(2) to the top of the work tree, and `prefix` gets the path
            * to the subdirectory the command started from.  This allows you to
            * convert a user-supplied pathname (typically relative to that directory)
            * to a pathname relative to the top of the work tree.
            *
            * The return value from `cmd_foo()` becomes the exit status of the
            * command.
            */

            extern const char git_usage_string[];
            extern const char git_more_info_string[];

            /**
            * If a built-in has DELAY_PAGER_CONFIG set, the built-in should call this early
            * when it wishes to respect the `pager.foo`-config. The `cmd` is the name of
            * the built-in, e.g., "foo". If a paging-choice has already been setup, this
            * does nothing. The default in `def` should be 0 for "pager off", 1 for "pager
            * on" or -1 for "punt".
            *
            * You should most likely use a default of 0 or 1. "Punt" (-1) could be useful
            * to be able to fall back to some historical compatibility name.
            */
            void setup_auto_pager(const char *cmd, int def);

            int is_builtin(const char *s);

            /*
            * Builtins which do not use RUN_SETUP should never see
            * a prefix that is not empty; use this to protect downstream
            * code which is not prepared to call prefix_filename(), etc.
            */
            #define BUG_ON_NON_EMPTY_PREFIX(prefix) do { \
                    if ((prefix)) \
                            BUG("unexpected prefix in builtin: %s", (prefix)); \
            } while (0)

            int cmd_add(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_am(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_annotate(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_apply(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_archive(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_bisect(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_blame(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_branch(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_bugreport(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_bundle(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_cat_file(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_checkout(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_checkout__worker(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_checkout_index(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_check_attr(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_check_ignore(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_check_mailmap(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_check_ref_format(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_cherry(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_cherry_pick(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_clone(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_clean(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_column(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_commit(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_commit_graph(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_commit_tree(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_config(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_count_objects(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_credential(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_credential_cache(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_credential_cache_daemon(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_credential_store(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_describe(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_diagnose(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_diff_files(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_diff_index(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_diff(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_diff_tree(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_difftool(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_env__helper(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_fast_export(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_fast_import(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_fetch(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_fetch_pack(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_fmt_merge_msg(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_for_each_ref(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_for_each_repo(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_format_patch(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_fsck(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_fsmonitor__daemon(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_gc(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_get_tar_commit_id(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_grep(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_hash_object(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_help(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_hook(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_index_pack(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_init_db(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_interpret_trailers(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_log_reflog(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_log(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_ls_files(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_ls_tree(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_ls_remote(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_mailinfo(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_mailsplit(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_maintenance(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_merge(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_merge_base(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_merge_index(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_merge_ours(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_merge_file(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_merge_recursive(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_merge_tree(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_mktag(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_mktree(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_multi_pack_index(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_mv(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_name_rev(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_notes(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_pack_objects(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_pack_redundant(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_patch_id(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_prune(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_prune_packed(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_pull(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_push(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_range_diff(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_read_tree(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_rebase(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_rebase__interactive(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_receive_pack(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_reflog(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_refs(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_remote(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_remote_ext(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_remote_fd(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_repack(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_replay(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_rerere(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_reset(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_restore(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_rev_list(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_rev_parse(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_revert(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_rm(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_send_pack(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_shortlog(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_show(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_show_branch(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_show_index(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_sparse_checkout(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_status(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_stash(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_stripspace(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_submodule__helper(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_switch(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_symbolic_ref(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_tag(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_unpack_file(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_unpack_objects(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_update_index(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_update_ref(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_update_server_info(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_upload_archive(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_upload_archive_writer(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_upload_pack(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_var(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_verify_commit(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_verify_tag(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_version(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_whatchanged(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_worktree(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_write_tree(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_verify_pack(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_show_ref(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_pack_refs(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_replace(int argc, const char **argv, const char *prefix, struct repository *repo);
            #ifdef __MVS__
            extern int setbinaryfd(int);
            #endif
            #endif
    """,
    "error":"By tagging file descriptors explicitly as binary, the function prevents automatic
             character encoding conversions (e.g., EBCDIC to ASCII or vice versa), which could corrupt binary files. Ensures Git can run seamlessly on z/OS without encountering issues
             related to file handling, encoding, or runtime errors due to missing declarations.",
    "error Category":"Functionality Patch",

    "Corrected_Code":
    """
            #ifndef BUILTIN_H
            #define BUILTIN_H

            #include "git-compat-util.h"
            #include "repository.h"

            /*
            * builtin API
            * ===========
            *
            * Adding a new built-in
            * ---------------------
            *
            * There are 4 things to do to add a built-in command implementation to
            * Git:
            *
            * . Define the implementation of the built-in command `foo` with
            *   signature:
            *
            *      int cmd_foo(int argc, const char **argv, const char *prefix);
            *
            * . Add the external declaration for the function to `builtin.h`.
            *
            * . Add the command to the `commands[]` table defined in `git.c`.
            *   The entry should look like:
            *
            *      { "foo", cmd_foo, <options> },
            *
            * where options is the bitwise-or of:
            *
            * `RUN_SETUP`:
            *      If there is not a Git directory to work on, abort.  If there
            *      is a work tree, chdir to the top of it if the command was
            *      invoked in a subdirectory.  If there is no work tree, no
            *      chdir() is done.
            *
            * `RUN_SETUP_GENTLY`:
            *      If there is a Git directory, chdir as per RUN_SETUP, otherwise,
            *      don't chdir anywhere.
            *
            * `USE_PAGER`:
            *
            *      If the standard output is connected to a tty, spawn a pager and
            *      feed our output to it.
            *
            * `NEED_WORK_TREE`:
            *
            *      Make sure there is a work tree, i.e. the command cannot act
            *      on bare repositories.
            *      This only makes sense when `RUN_SETUP` is also set.
            *
            * `DELAY_PAGER_CONFIG`:
            *
            *      If RUN_SETUP or RUN_SETUP_GENTLY is set, git.c normally handles
            *      the `pager.<cmd>`-configuration. If this flag is used, git.c
            *      will skip that step, instead allowing the built-in to make a
            *      more informed decision, e.g., by ignoring `pager.<cmd>` for
            *      certain subcommands.
            *
            * . Add `builtin/foo.o` to `BUILTIN_OBJS` in `Makefile`.
            *
            * Additionally, if `foo` is a new command, there are 4 more things to do:
            *
            * . Add tests to `t/` directory.
            *
            * . Write documentation in `Documentation/git-foo.txt`.
            *
            * . Add an entry for `git-foo` to `command-list.txt`.
            *
            * . Add an entry for `/git-foo` to `.gitignore`.
            *
            *
            * How a built-in is called
            * ------------------------
            *
            * The implementation `cmd_foo()` takes three parameters, `argc`, `argv,
            * and `prefix`.  The first two are similar to what `main()` of a
            * standalone command would be called with.
            *
            * When `RUN_SETUP` is specified in the `commands[]` table, and when you
            * were started from a subdirectory of the work tree, `cmd_foo()` is called
            * after chdir(2) to the top of the work tree, and `prefix` gets the path
            * to the subdirectory the command started from.  This allows you to
            * convert a user-supplied pathname (typically relative to that directory)
            * to a pathname relative to the top of the work tree.
            *
            * The return value from `cmd_foo()` becomes the exit status of the
            * command.
            */

            extern const char git_usage_string[];
            extern const char git_more_info_string[];

            /**
            * If a built-in has DELAY_PAGER_CONFIG set, the built-in should call this early
            * when it wishes to respect the `pager.foo`-config. The `cmd` is the name of
            * the built-in, e.g., "foo". If a paging-choice has already been setup, this
            * does nothing. The default in `def` should be 0 for "pager off", 1 for "pager
            * on" or -1 for "punt".
            *
            * You should most likely use a default of 0 or 1. "Punt" (-1) could be useful
            * to be able to fall back to some historical compatibility name.
            */
            void setup_auto_pager(const char *cmd, int def);

            int is_builtin(const char *s);

            /*
            * Builtins which do not use RUN_SETUP should never see
            * a prefix that is not empty; use this to protect downstream
            * code which is not prepared to call prefix_filename(), etc.
            */
            #define BUG_ON_NON_EMPTY_PREFIX(prefix) do { \
                    if ((prefix)) \
                            BUG("unexpected prefix in builtin: %s", (prefix)); \
            } while (0)

            int cmd_add(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_am(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_annotate(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_apply(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_archive(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_bisect(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_blame(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_branch(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_bugreport(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_bundle(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_cat_file(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_checkout(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_checkout__worker(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_checkout_index(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_check_attr(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_check_ignore(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_check_mailmap(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_check_ref_format(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_cherry(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_cherry_pick(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_clone(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_clean(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_column(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_commit(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_commit_graph(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_commit_tree(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_config(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_count_objects(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_credential(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_credential_cache(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_credential_cache_daemon(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_credential_store(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_describe(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_diagnose(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_diff_files(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_diff_index(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_diff(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_diff_tree(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_difftool(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_env__helper(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_fast_export(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_fast_import(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_fetch(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_fetch_pack(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_fmt_merge_msg(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_for_each_ref(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_for_each_repo(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_format_patch(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_fsck(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_fsmonitor__daemon(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_gc(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_get_tar_commit_id(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_grep(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_hash_object(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_help(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_hook(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_index_pack(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_init_db(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_interpret_trailers(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_log_reflog(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_log(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_ls_files(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_ls_tree(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_ls_remote(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_mailinfo(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_mailsplit(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_maintenance(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_merge(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_merge_base(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_merge_index(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_merge_ours(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_merge_file(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_merge_recursive(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_merge_tree(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_mktag(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_mktree(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_multi_pack_index(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_mv(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_name_rev(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_notes(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_pack_objects(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_pack_redundant(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_patch_id(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_prune(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_prune_packed(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_pull(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_push(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_range_diff(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_read_tree(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_rebase(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_rebase__interactive(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_receive_pack(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_reflog(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_refs(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_remote(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_remote_ext(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_remote_fd(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_repack(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_replay(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_rerere(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_reset(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_restore(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_rev_list(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_rev_parse(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_revert(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_rm(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_send_pack(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_shortlog(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_show(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_show_branch(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_show_index(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_sparse_checkout(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_status(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_stash(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_stripspace(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_submodule__helper(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_switch(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_symbolic_ref(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_tag(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_unpack_file(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_unpack_objects(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_update_index(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_update_ref(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_update_server_info(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_upload_archive(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_upload_archive_writer(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_upload_pack(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_var(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_verify_commit(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_verify_tag(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_version(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_whatchanged(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_worktree(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_write_tree(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_verify_pack(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_show_ref(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_pack_refs(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_replace(int argc, const char **argv, const char *prefix, struct repository *repo);
            #ifdef __MVS__
            extern int setbinaryfd(int);
            #endif
            #endif
    """,
    "Patche":
    """
                    diff --git a/builtin.h b/builtin.h
            index f7b166b334..c7896cda4b 100644
            --- a/builtin.h
            +++ b/builtin.h
            @@ -253,5 +253,7 @@ int cmd_verify_pack(int argc, const char **argv, const char *prefix, struct repo
            int cmd_show_ref(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_pack_refs(int argc, const char **argv, const char *prefix, struct repository *repo);
            int cmd_replace(int argc, const char **argv, const char *prefix, struct repository *repo);
            -
            +#ifdef __MVS__
            +  extern int setbinaryfd(int);
            +#endif
            #endif
    """,

    },

    {
        "wrongcode":
        """
                    #define USE_THE_REPOSITORY_VARIABLE
            #define DISABLE_SIGN_COMPARE_WARNINGS

            #include "git-compat-util.h"
            #include "object-store-ll.h"
            #include "commit.h"
            #include "convert.h"
            #include "diff.h"
            #include "diffcore.h"
            #include "environment.h"
            #include "hex.h"
            #include "object-name.h"
            #include "quote.h"
            #include "xdiff-interface.h"
            #include "xdiff/xmacros.h"
            #include "log-tree.h"
            #include "refs.h"
            #include "tree.h"
            #include "userdiff.h"
            #include "oid-array.h"
            #include "revision.h"

            static int compare_paths(const struct combine_diff_path *one,
                                    const struct diff_filespec *two)
            {
                    if (!S_ISDIR(one->mode) && !S_ISDIR(two->mode))
                            return strcmp(one->path, two->path);

                    return base_name_compare(one->path, strlen(one->path), one->mode,
                                            two->path, strlen(two->path), two->mode);
            }

            static int filename_changed(char status)
            {
                    return status == 'R' || status == 'C';
            }

            static struct combine_diff_path *intersect_paths(
                    struct combine_diff_path *curr,
                    int n,
                    int num_parent,
                    int combined_all_paths)
            {
                    struct diff_queue_struct *q = &diff_queued_diff;
                    struct combine_diff_path *p, **tail = &curr;
                    int i, j, cmp;

                    if (!n) {
                            for (i = 0; i < q->nr; i++) {
                                    int len;
                                    const char *path;
                                    if (diff_unmodified_pair(q->queue[i]))
                                            continue;
                                    path = q->queue[i]->two->path;
                                    len = strlen(path);
                                    p = xmalloc(combine_diff_path_size(num_parent, len));
                                    p->path = (char *) &(p->parent[num_parent]);
                                    memcpy(p->path, path, len);
                                    p->path[len] = 0;
                                    p->next = NULL;
                                    memset(p->parent, 0,
                                    sizeof(p->parent[0]) * num_parent);

                                    oidcpy(&p->oid, &q->queue[i]->two->oid);
                                    p->mode = q->queue[i]->two->mode;
                                    oidcpy(&p->parent[n].oid, &q->queue[i]->one->oid);
                                    p->parent[n].mode = q->queue[i]->one->mode;
                                    p->parent[n].status = q->queue[i]->status;

                                    if (combined_all_paths &&
                                    filename_changed(p->parent[n].status)) {
                                            strbuf_init(&p->parent[n].path, 0);
                                            strbuf_addstr(&p->parent[n].path,
                                                    q->queue[i]->one->path);
                                    }
                                    *tail = p;
                                    tail = &p->next;
                            }
                            return curr;
                    }

                    /*
                    * paths in curr (linked list) and q->queue[] (array) are
                    * both sorted in the tree order.
                    */
                    i = 0;
                    while ((p = *tail) != NULL) {
                            cmp = ((i >= q->nr)
                            ? -1 : compare_paths(p, q->queue[i]->two));

                            if (cmp < 0) {
                                    /* p->path not in q->queue[]; drop it */
                                    *tail = p->next;
                                    for (j = 0; j < num_parent; j++)
                                            if (combined_all_paths &&
                                            filename_changed(p->parent[j].status))
                                                    strbuf_release(&p->parent[j].path);
                                    free(p);
                                    continue;
                            }

                            if (cmp > 0) {
                                    /* q->queue[i] not in p->path; skip it */
                                    i++;
                                    continue;
                            }

                            oidcpy(&p->parent[n].oid, &q->queue[i]->one->oid);
                            p->parent[n].mode = q->queue[i]->one->mode;
                            p->parent[n].status = q->queue[i]->status;
                            if (combined_all_paths &&
                            filename_changed(p->parent[n].status))
                                    strbuf_addstr(&p->parent[n].path,
                                            q->queue[i]->one->path);

                            tail = &p->next;
                            i++;
                    }
                    return curr;
            }

            /* Lines lost from parent */
            struct lline {
                    struct lline *next, *prev;
                    int len;
                    unsigned long parent_map;
                    char line[FLEX_ARRAY];
            };

            /* Lines lost from current parent (before coalescing) */
            struct plost {
                    struct lline *lost_head, *lost_tail;
                    int len;
            };

            /* Lines surviving in the merge result */
            struct sline {
                    /* Accumulated and coalesced lost lines */
                    struct lline *lost;
                    int lenlost;
                    struct plost plost;
                    char *bol;
                    int len;
                    /* bit 0 up to (N-1) are on if the parent has this line (i.e.
                    * we did not change it).
                    * bit N is used for "interesting" lines, including context.
                    * bit (N+1) is used for "do not show deletion before this".
                    */
                    unsigned long flag;
                    unsigned long *p_lno;
            };

            static int match_string_spaces(const char *line1, int len1,
                                    const char *line2, int len2,
                                    long flags)
            {
                    if (flags & XDF_WHITESPACE_FLAGS) {
                            for (; len1 > 0 && XDL_ISSPACE(line1[len1 - 1]); len1--);
                            for (; len2 > 0 && XDL_ISSPACE(line2[len2 - 1]); len2--);
                    }

                    if (!(flags & (XDF_IGNORE_WHITESPACE | XDF_IGNORE_WHITESPACE_CHANGE)))
                            return (len1 == len2 && !memcmp(line1, line2, len1));

                    while (len1 > 0 && len2 > 0) {
                            len1--;
                            len2--;
                            if (XDL_ISSPACE(line1[len1]) || XDL_ISSPACE(line2[len2])) {
                                    if ((flags & XDF_IGNORE_WHITESPACE_CHANGE) &&
                                    (!XDL_ISSPACE(line1[len1]) || !XDL_ISSPACE(line2[len2])))
                                            return 0;

                                    for (; len1 > 0 && XDL_ISSPACE(line1[len1]); len1--);
                                    for (; len2 > 0 && XDL_ISSPACE(line2[len2]); len2--);
                            }
                            if (line1[len1] != line2[len2])
                                    return 0;
                    }

                    if (flags & XDF_IGNORE_WHITESPACE) {
                            /* Consume remaining spaces */
                            for (; len1 > 0 && XDL_ISSPACE(line1[len1 - 1]); len1--);
                            for (; len2 > 0 && XDL_ISSPACE(line2[len2 - 1]); len2--);
                    }

                    /* We matched full line1 and line2 */
                    if (!len1 && !len2)
                            return 1;

                    return 0;
            }

            enum coalesce_direction { MATCH, BASE, NEW };

            /* Coalesce new lines into base by finding LCS */
            static struct lline *coalesce_lines(struct lline *base, int *lenbase,
                                            struct lline *newline, int lennew,
                                            unsigned long parent, long flags)
            {
                    int **lcs;
                    enum coalesce_direction **directions;
                    struct lline *baseend, *newend = NULL;
                    int i, j, origbaselen = *lenbase;

                    if (!newline)
                            return base;

                    if (!base) {
                            *lenbase = lennew;
                            return newline;
                    }

                    /*
                    * Coalesce new lines into base by finding the LCS
                    * - Create the table to run dynamic programming
                    * - Compute the LCS
                    * - Then reverse read the direction structure:
                    *   - If we have MATCH, assign parent to base flag, and consume
                    *   both baseend and newend
                    *   - Else if we have BASE, consume baseend
                    *   - Else if we have NEW, insert newend lline into base and
                    *   consume newend
                    */
                    CALLOC_ARRAY(lcs, st_add(origbaselen, 1));
                    CALLOC_ARRAY(directions, st_add(origbaselen, 1));
                    for (i = 0; i < origbaselen + 1; i++) {
                            CALLOC_ARRAY(lcs[i], st_add(lennew, 1));
                            CALLOC_ARRAY(directions[i], st_add(lennew, 1));
                            directions[i][0] = BASE;
                    }
                    for (j = 1; j < lennew + 1; j++)
                            directions[0][j] = NEW;

                    for (i = 1, baseend = base; i < origbaselen + 1; i++) {
                            for (j = 1, newend = newline; j < lennew + 1; j++) {
                                    if (match_string_spaces(baseend->line, baseend->len,
                                                            newend->line, newend->len, flags)) {
                                            lcs[i][j] = lcs[i - 1][j - 1] + 1;
                                            directions[i][j] = MATCH;
                                    } else if (lcs[i][j - 1] >= lcs[i - 1][j]) {
                                            lcs[i][j] = lcs[i][j - 1];
                                            directions[i][j] = NEW;
                                    } else {
                                            lcs[i][j] = lcs[i - 1][j];
                                            directions[i][j] = BASE;
                                    }
                                    if (newend->next)
                                            newend = newend->next;
                            }
                            if (baseend->next)
                                    baseend = baseend->next;
                    }

                    for (i = 0; i < origbaselen + 1; i++)
                            free(lcs[i]);
                    free(lcs);

                    /* At this point, baseend and newend point to the end of each lists */
                    i--;
                    j--;
                    while (i != 0 || j != 0) {
                            if (directions[i][j] == MATCH) {
                                    baseend->parent_map |= 1<<parent;
                                    baseend = baseend->prev;
                                    newend = newend->prev;
                                    i--;
                                    j--;
                            } else if (directions[i][j] == NEW) {
                                    struct lline *lline;

                                    lline = newend;
                                    /* Remove lline from new list and update newend */
                                    if (lline->prev)
                                            lline->prev->next = lline->next;
                                    else
                                            newline = lline->next;
                                    if (lline->next)
                                            lline->next->prev = lline->prev;

                                    newend = lline->prev;
                                    j--;

                                    /* Add lline to base list */
                                    if (baseend) {
                                            lline->next = baseend->next;
                                            lline->prev = baseend;
                                            if (lline->prev)
                                                    lline->prev->next = lline;
                                    }
                                    else {
                                            lline->next = base;
                                            base = lline;
                                    }
                                    (*lenbase)++;

                                    if (lline->next)
                                            lline->next->prev = lline;

                            } else {
                                    baseend = baseend->prev;
                                    i--;
                            }
                    }

                    newend = newline;
                    while (newend) {
                            struct lline *lline = newend;
                            newend = newend->next;
                            free(lline);
                    }

                    for (i = 0; i < origbaselen + 1; i++)
                            free(directions[i]);
                    free(directions);

                    return base;
            }

            static char *grab_blob(struct repository *r,
                            const struct object_id *oid, unsigned int mode,
                            unsigned long *size, struct userdiff_driver *textconv,
                            const char *path)
            {
                    char *blob;
                    enum object_type type;

                    if (S_ISGITLINK(mode)) {
                            struct strbuf buf = STRBUF_INIT;
                            strbuf_addf(&buf, "Subproject commit %s\n", oid_to_hex(oid));
                            *size = buf.len;
                            blob = strbuf_detach(&buf, NULL);
                    } else if (is_null_oid(oid)) {
                            /* deleted blob */
                            *size = 0;
                            return xcalloc(1, 1);
                    } else if (textconv) {
                            struct diff_filespec *df = alloc_filespec(path);
                            fill_filespec(df, oid, 1, mode);
                            *size = fill_textconv(r, textconv, df, &blob);
                            free_filespec(df);
                    } else {
                            blob = repo_read_object_file(r, oid, &type, size);
                            if (!blob)
                                    die(_("unable to read %s"), oid_to_hex(oid));
                            if (type != OBJ_BLOB)
                                    die("object '%s' is not a blob!", oid_to_hex(oid));
                    }
                    return blob;
            }

            static void append_lost(struct sline *sline, int n, const char *line, int len)
            {
                    struct lline *lline;
                    unsigned long this_mask = (1UL<<n);
                    if (line[len-1] == '\n')
                            len--;

                    FLEX_ALLOC_MEM(lline, line, line, len);
                    lline->len = len;
                    lline->next = NULL;
                    lline->prev = sline->plost.lost_tail;
                    if (lline->prev)
                            lline->prev->next = lline;
                    else
                            sline->plost.lost_head = lline;
                    sline->plost.lost_tail = lline;
                    sline->plost.len++;
                    lline->parent_map = this_mask;
            }

            struct combine_diff_state {
                    unsigned int lno;
                    int ob, on, nb, nn;
                    unsigned long nmask;
                    int num_parent;
                    int n;
                    struct sline *sline;
                    struct sline *lost_bucket;
            };

            static void consume_hunk(void *state_,
                                    long ob, long on,
                                    long nb, long nn,
                                    const char *func UNUSED, long funclen UNUSED)
            {
                    struct combine_diff_state *state = state_;

                    state->ob = ob;
                    state->on = on;
                    state->nb = nb;
                    state->nn = nn;
                    state->lno = state->nb;
                    if (state->nn == 0) {
                            /* @@ -X,Y +N,0 @@ removed Y lines
                            * that would have come *after* line N
                            * in the result.  Our lost buckets hang
                            * to the line after the removed lines,
                            *
                            * Note that this is correct even when N == 0,
                            * in which case the hunk removes the first
                            * line in the file.
                            */
                            state->lost_bucket = &state->sline[state->nb];
                            if (!state->nb)
                                    state->nb = 1;
                    } else {
                            state->lost_bucket = &state->sline[state->nb-1];
                    }
                    if (!state->sline[state->nb-1].p_lno)
                            CALLOC_ARRAY(state->sline[state->nb - 1].p_lno,
                                    state->num_parent);
                    state->sline[state->nb-1].p_lno[state->n] = state->ob;
            }

            static int consume_line(void *state_, char *line, unsigned long len)
            {
                    struct combine_diff_state *state = state_;
                    if (!state->lost_bucket)
                            return 0; /* not in any hunk yet */
                    switch (line[0]) {
                    case '-':
                            append_lost(state->lost_bucket, state->n, line+1, len-1);
                            break;
                    case '+':
                            state->sline[state->lno-1].flag |= state->nmask;
                            state->lno++;
                            break;
                    }
                    return 0;
            }

            static void combine_diff(struct repository *r,
                                    const struct object_id *parent, unsigned int mode,
                                    mmfile_t *result_file,
                                    struct sline *sline, unsigned int cnt, int n,
                                    int num_parent, int result_deleted,
                                    struct userdiff_driver *textconv,
                                    const char *path, long flags)
            {
                    unsigned int p_lno, lno;
                    unsigned long nmask = (1UL << n);
                    xpparam_t xpp;
                    xdemitconf_t xecfg;
                    mmfile_t parent_file;
                    struct combine_diff_state state;
                    unsigned long sz;

                    if (result_deleted)
                            return; /* result deleted */

                    parent_file.ptr = grab_blob(r, parent, mode, &sz, textconv, path);
                    parent_file.size = sz;
                    memset(&xpp, 0, sizeof(xpp));
                    xpp.flags = flags;
                    memset(&xecfg, 0, sizeof(xecfg));
                    memset(&state, 0, sizeof(state));
                    state.nmask = nmask;
                    state.sline = sline;
                    state.lno = 1;
                    state.num_parent = num_parent;
                    state.n = n;

                    if (xdi_diff_outf(&parent_file, result_file, consume_hunk,
                                    consume_line, &state, &xpp, &xecfg))
                            die("unable to generate combined diff for %s",
                            oid_to_hex(parent));
                    free(parent_file.ptr);

                    /* Assign line numbers for this parent.
                    *
                    * sline[lno].p_lno[n] records the first line number
                    * (counting from 1) for parent N if the final hunk display
                    * started by showing sline[lno] (possibly showing the lost
                    * lines attached to it first).
                    */
                    for (lno = 0,  p_lno = 1; lno <= cnt; lno++) {
                            struct lline *ll;
                            sline[lno].p_lno[n] = p_lno;

                            /* Coalesce new lines */
                            if (sline[lno].plost.lost_head) {
                                    struct sline *sl = &sline[lno];
                                    sl->lost = coalesce_lines(sl->lost, &sl->lenlost,
                                                            sl->plost.lost_head,
                                                            sl->plost.len, n, flags);
                                    sl->plost.lost_head = sl->plost.lost_tail = NULL;
                                    sl->plost.len = 0;
                            }

                            /* How many lines would this sline advance the p_lno? */
                            ll = sline[lno].lost;
                            while (ll) {
                                    if (ll->parent_map & nmask)
                                            p_lno++; /* '-' means parent had it */
                                    ll = ll->next;
                            }
                            if (lno < cnt && !(sline[lno].flag & nmask))
                                    p_lno++; /* no '+' means parent had it */
                    }
                    sline[lno].p_lno[n] = p_lno; /* trailer */
            }

            static unsigned long context = 3;
            static char combine_marker = '@';

            static int interesting(struct sline *sline, unsigned long all_mask)
            {
                    /* If some parents lost lines here, or if we have added to
                    * some parent, it is interesting.
                    */
                    return ((sline->flag & all_mask) || sline->lost);
            }

            static unsigned long adjust_hunk_tail(struct sline *sline,
                                            unsigned long all_mask,
                                            unsigned long hunk_begin,
                                            unsigned long i)
            {
                    /* i points at the first uninteresting line.  If the last line
                    * of the hunk was interesting only because it has some
                    * deletion, then it is not all that interesting for the
                    * purpose of giving trailing context lines.  This is because
                    * we output '-' line and then unmodified sline[i-1] itself in
                    * that case which gives us one extra context line.
                    */
                    if ((hunk_begin + 1 <= i) && !(sline[i-1].flag & all_mask))
                            i--;
                    return i;
            }

            static unsigned long find_next(struct sline *sline,
                                    unsigned long mark,
                                    unsigned long i,
                                    unsigned long cnt,
                                    int look_for_uninteresting)
            {
                    /* We have examined up to i-1 and are about to look at i.
                    * Find next interesting or uninteresting line.  Here,
                    * "interesting" does not mean interesting(), but marked by
                    * the give_context() function below (i.e. it includes context
                    * lines that are not interesting to interesting() function
                    * that are surrounded by interesting() ones.
                    */
                    while (i <= cnt)
                            if (look_for_uninteresting
                            ? !(sline[i].flag & mark)
                            : (sline[i].flag & mark))
                                    return i;
                            else
                                    i++;
                    return i;
            }

            static int give_context(struct sline *sline, unsigned long cnt, int num_parent)
            {
                    unsigned long all_mask = (1UL<<num_parent) - 1;
                    unsigned long mark = (1UL<<num_parent);
                    unsigned long no_pre_delete = (2UL<<num_parent);
                    unsigned long i;

                    /* Two groups of interesting lines may have a short gap of
                    * uninteresting lines.  Connect such groups to give them a
                    * bit of context.
                    *
                    * We first start from what the interesting() function says,
                    * and mark them with "mark", and paint context lines with the
                    * mark.  So interesting() would still say false for such context
                    * lines but they are treated as "interesting" in the end.
                    */
                    i = find_next(sline, mark, 0, cnt, 0);
                    if (cnt < i)
                            return 0;

                    while (i <= cnt) {
                            unsigned long j = (context < i) ? (i - context) : 0;
                            unsigned long k;

                            /* Paint a few lines before the first interesting line. */
                            while (j < i) {
                                    if (!(sline[j].flag & mark))
                                            sline[j].flag |= no_pre_delete;
                                    sline[j++].flag |= mark;
                            }

                    again:
                            /* we know up to i is to be included.  where does the
                            * next uninteresting one start?
                            */
                            j = find_next(sline, mark, i, cnt, 1);
                            if (cnt < j)
                                    break; /* the rest are all interesting */

                            /* lookahead context lines */
                            k = find_next(sline, mark, j, cnt, 0);
                            j = adjust_hunk_tail(sline, all_mask, i, j);

                            if (k < j + context) {
                                    /* k is interesting and [j,k) are not, but
                                    * paint them interesting because the gap is small.
                                    */
                                    while (j < k)
                                            sline[j++].flag |= mark;
                                    i = k;
                                    goto again;
                            }

                            /* j is the first uninteresting line and there is
                            * no overlap beyond it within context lines.  Paint
                            * the trailing edge a bit.
                            */
                            i = k;
                            k = (j + context < cnt+1) ? j + context : cnt+1;
                            while (j < k)
                                    sline[j++].flag |= mark;
                    }
                    return 1;
            }

            static int make_hunks(struct sline *sline, unsigned long cnt,
                            int num_parent, int dense)
            {
                    unsigned long all_mask = (1UL<<num_parent) - 1;
                    unsigned long mark = (1UL<<num_parent);
                    unsigned long i;
                    int has_interesting = 0;

                    for (i = 0; i <= cnt; i++) {
                            if (interesting(&sline[i], all_mask))
                                    sline[i].flag |= mark;
                            else
                                    sline[i].flag &= ~mark;
                    }
                    if (!dense)
                            return give_context(sline, cnt, num_parent);

                    /* Look at each hunk, and if we have changes from only one
                    * parent, or the changes are the same from all but one
                    * parent, mark that uninteresting.
                    */
                    i = 0;
                    while (i <= cnt) {
                            unsigned long j, hunk_begin, hunk_end;
                            unsigned long same_diff;
                            while (i <= cnt && !(sline[i].flag & mark))
                                    i++;
                            if (cnt < i)
                                    break; /* No more interesting hunks */
                            hunk_begin = i;
                            for (j = i + 1; j <= cnt; j++) {
                                    if (!(sline[j].flag & mark)) {
                                            /* Look beyond the end to see if there
                                            * is an interesting line after this
                                            * hunk within context span.
                                            */
                                            unsigned long la; /* lookahead */
                                            int contin = 0;
                                            la = adjust_hunk_tail(sline, all_mask,
                                                            hunk_begin, j);
                                            la = (la + context < cnt + 1) ?
                                                    (la + context) : cnt + 1;
                                            while (la && j <= --la) {
                                                    if (sline[la].flag & mark) {
                                                            contin = 1;
                                                            break;
                                                    }
                                            }
                                            if (!contin)
                                                    break;
                                            j = la;
                                    }
                            }
                            hunk_end = j;

                            /* [i..hunk_end) are interesting.  Now is it really
                            * interesting?  We check if there are only two versions
                            * and the result matches one of them.  That is, we look
                            * at:
                            *   (+) line, which records lines added to which parents;
                            *       this line appears in the result.
                            *   (-) line, which records from what parents the line
                            *       was removed; this line does not appear in the result.
                            * then check the set of parents the result has difference
                            * from, from all lines.  If there are lines that has
                            * different set of parents that the result has differences
                            * from, that means we have more than two versions.
                            *
                            * Even when we have only two versions, if the result does
                            * not match any of the parents, the it should be considered
                            * interesting.  In such a case, we would have all '+' line.
                            * After passing the above "two versions" test, that would
                            * appear as "the same set of parents" to be "all parents".
                            */
                            same_diff = 0;
                            has_interesting = 0;
                            for (j = i; j < hunk_end && !has_interesting; j++) {
                                    unsigned long this_diff = sline[j].flag & all_mask;
                                    struct lline *ll = sline[j].lost;
                                    if (this_diff) {
                                            /* This has some changes.  Is it the
                                            * same as others?
                                            */
                                            if (!same_diff)
                                                    same_diff = this_diff;
                                            else if (same_diff != this_diff) {
                                                    has_interesting = 1;
                                                    break;
                                            }
                                    }
                                    while (ll && !has_interesting) {
                                            /* Lost this line from these parents;
                                            * who are they?  Are they the same?
                                            */
                                            this_diff = ll->parent_map;
                                            if (!same_diff)
                                                    same_diff = this_diff;
                                            else if (same_diff != this_diff) {
                                                    has_interesting = 1;
                                            }
                                            ll = ll->next;
                                    }
                            }

                            if (!has_interesting && same_diff != all_mask) {
                                    /* This hunk is not that interesting after all */
                                    for (j = hunk_begin; j < hunk_end; j++)
                                            sline[j].flag &= ~mark;
                            }
                            i = hunk_end;
                    }

                    has_interesting = give_context(sline, cnt, num_parent);
                    return has_interesting;
            }

            static void show_parent_lno(struct sline *sline, unsigned long l0, unsigned long l1, int n, unsigned long null_context)
            {
                    l0 = sline[l0].p_lno[n];
                    l1 = sline[l1].p_lno[n];
                    printf(" -%lu,%lu", l0, l1-l0-null_context);
            }

            static int hunk_comment_line(const char *bol)
            {
                    int ch;

                    if (!bol)
                            return 0;
                    ch = *bol & 0xff;
                    return (isalpha(ch) || ch == '_' || ch == '$');
            }

            static void show_line_to_eol(const char *line, int len, const char *reset)
            {
                    int saw_cr_at_eol = 0;
                    if (len < 0)
                            len = strlen(line);
                    saw_cr_at_eol = (len && line[len-1] == '\r');

                    printf("%.*s%s%s\n", len - saw_cr_at_eol, line,
                    reset,
                    saw_cr_at_eol ? "\r" : "");
            }

            static void dump_sline(struct sline *sline, const char *line_prefix,
                            unsigned long cnt, int num_parent,
                            int use_color, int result_deleted)
            {
                    unsigned long mark = (1UL<<num_parent);
                    unsigned long no_pre_delete = (2UL<<num_parent);
                    int i;
                    unsigned long lno = 0;
                    const char *c_frag = diff_get_color(use_color, DIFF_FRAGINFO);
                    const char *c_func = diff_get_color(use_color, DIFF_FUNCINFO);
                    const char *c_new = diff_get_color(use_color, DIFF_FILE_NEW);
                    const char *c_old = diff_get_color(use_color, DIFF_FILE_OLD);
                    const char *c_context = diff_get_color(use_color, DIFF_CONTEXT);
                    const char *c_reset = diff_get_color(use_color, DIFF_RESET);

                    if (result_deleted)
                            return; /* result deleted */

                    while (1) {
                            unsigned long hunk_end;
                            unsigned long rlines;
                            const char *hunk_comment = NULL;
                            unsigned long null_context = 0;

                            while (lno <= cnt && !(sline[lno].flag & mark)) {
                                    if (hunk_comment_line(sline[lno].bol))
                                            hunk_comment = sline[lno].bol;
                                    lno++;
                            }
                            if (cnt < lno)
                                    break;
                            else {
                                    for (hunk_end = lno + 1; hunk_end <= cnt; hunk_end++)
                                            if (!(sline[hunk_end].flag & mark))
                                                    break;
                            }
                            rlines = hunk_end - lno;
                            if (cnt < hunk_end)
                                    rlines--; /* pointing at the last delete hunk */

                            if (!context) {
                                    /*
                                    * Even when running with --unified=0, all
                                    * lines in the hunk needs to be processed in
                                    * the loop below in order to show the
                                    * deletion recorded in lost_head.  However,
                                    * we do not want to show the resulting line
                                    * with all blank context markers in such a
                                    * case.  Compensate.
                                    */
                                    unsigned long j;
                                    for (j = lno; j < hunk_end; j++)
                                            if (!(sline[j].flag & (mark-1)))
                                                    null_context++;
                                    rlines -= null_context;
                            }

                            printf("%s%s", line_prefix, c_frag);
                            for (i = 0; i <= num_parent; i++) putchar(combine_marker);
                            for (i = 0; i < num_parent; i++)
                                    show_parent_lno(sline, lno, hunk_end, i, null_context);
                            printf(" +%lu,%lu ", lno+1, rlines);
                            for (i = 0; i <= num_parent; i++) putchar(combine_marker);

                            if (hunk_comment) {
                                    int comment_end = 0;
                                    for (i = 0; i < 40; i++) {
                                            int ch = hunk_comment[i] & 0xff;
                                            if (!ch || ch == '\n')
                                                    break;
                                            if (!isspace(ch))
                                            comment_end = i;
                                    }
                                    if (comment_end)
                                            printf("%s%s %s%s", c_reset,
                                                            c_context, c_reset,
                                                            c_func);
                                    for (i = 0; i < comment_end; i++)
                                            putchar(hunk_comment[i]);
                            }

                            printf("%s\n", c_reset);
                            while (lno < hunk_end) {
                                    struct lline *ll;
                                    int j;
                                    unsigned long p_mask;
                                    struct sline *sl = &sline[lno++];
                                    ll = (sl->flag & no_pre_delete) ? NULL : sl->lost;
                                    while (ll) {
                                            printf("%s%s", line_prefix, c_old);
                                            for (j = 0; j < num_parent; j++) {
                                                    if (ll->parent_map & (1UL<<j))
                                                            putchar('-');
                                                    else
                                                            putchar(' ');
                                            }
                                            show_line_to_eol(ll->line, -1, c_reset);
                                            ll = ll->next;
                                    }
                                    if (cnt < lno)
                                            break;
                                    p_mask = 1;
                                    fputs(line_prefix, stdout);
                                    if (!(sl->flag & (mark-1))) {
                                            /*
                                            * This sline was here to hang the
                                            * lost lines in front of it.
                                            */
                                            if (!context)
                                                    continue;
                                            fputs(c_context, stdout);
                                    }
                                    else
                                            fputs(c_new, stdout);
                                    for (j = 0; j < num_parent; j++) {
                                            if (p_mask & sl->flag)
                                                    putchar('+');
                                            else
                                                    putchar(' ');
                                            p_mask <<= 1;
                                    }
                                    show_line_to_eol(sl->bol, sl->len, c_reset);
                            }
                    }
            }

            static void reuse_combine_diff(struct sline *sline, unsigned long cnt,
                                    int i, int j)
            {
                    /* We have already examined parent j and we know parent i
                    * and parent j are the same, so reuse the combined result
                    * of parent j for parent i.
                    */
                    unsigned long lno, imask, jmask;
                    imask = (1UL<<i);
                    jmask = (1UL<<j);

                    for (lno = 0; lno <= cnt; lno++) {
                            struct lline *ll = sline->lost;
                            sline->p_lno[i] = sline->p_lno[j];
                            while (ll) {
                                    if (ll->parent_map & jmask)
                                            ll->parent_map |= imask;
                                    ll = ll->next;
                            }
                            if (sline->flag & jmask)
                                    sline->flag |= imask;
                            sline++;
                    }
                    /* the overall size of the file (sline[cnt]) */
                    sline->p_lno[i] = sline->p_lno[j];
            }

            static void dump_quoted_path(const char *head,
                                    const char *prefix,
                                    const char *path,
                                    const char *line_prefix,
                                    const char *c_meta, const char *c_reset)
            {
                    static struct strbuf buf = STRBUF_INIT;

                    strbuf_reset(&buf);
                    strbuf_addstr(&buf, line_prefix);
                    strbuf_addstr(&buf, c_meta);
                    strbuf_addstr(&buf, head);
                    quote_two_c_style(&buf, prefix, path, 0);
                    strbuf_addstr(&buf, c_reset);
                    puts(buf.buf);
            }

            static void show_combined_header(struct combine_diff_path *elem,
                                            int num_parent,
                                            struct rev_info *rev,
                                            const char *line_prefix,
                                            int mode_differs,
                                            int show_file_header)
            {
                    struct diff_options *opt = &rev->diffopt;
                    int abbrev = opt->flags.full_index ? the_hash_algo->hexsz : DEFAULT_ABBREV;
                    const char *a_prefix = opt->a_prefix ? opt->a_prefix : "a/";
                    const char *b_prefix = opt->b_prefix ? opt->b_prefix : "b/";
                    const char *c_meta = diff_get_color_opt(opt, DIFF_METAINFO);
                    const char *c_reset = diff_get_color_opt(opt, DIFF_RESET);
                    const char *abb;
                    int added = 0;
                    int deleted = 0;
                    int i;
                    int dense = rev->dense_combined_merges;

                    if (rev->loginfo && !rev->no_commit_id)
                            show_log(rev);

                    dump_quoted_path(dense ? "diff --cc " : "diff --combined ",
                                    "", elem->path, line_prefix, c_meta, c_reset);
                    printf("%s%sindex ", line_prefix, c_meta);
                    for (i = 0; i < num_parent; i++) {
                            abb = repo_find_unique_abbrev(the_repository,
                                                    &elem->parent[i].oid, abbrev);
                            printf("%s%s", i ? "," : "", abb);
                    }
                    abb = repo_find_unique_abbrev(the_repository, &elem->oid, abbrev);
                    printf("..%s%s\n", abb, c_reset);

                    if (mode_differs) {
                            deleted = !elem->mode;

                            /* We say it was added if nobody had it */
                            added = !deleted;
                            for (i = 0; added && i < num_parent; i++)
                                    if (elem->parent[i].status !=
                                    DIFF_STATUS_ADDED)
                                            added = 0;
                            if (added)
                                    printf("%s%snew file mode %06o",
                                    line_prefix, c_meta, elem->mode);
                            else {
                                    if (deleted)
                                            printf("%s%sdeleted file ",
                                            line_prefix, c_meta);
                                    printf("mode ");
                                    for (i = 0; i < num_parent; i++) {
                                            printf("%s%06o", i ? "," : "",
                                            elem->parent[i].mode);
                                    }
                                    if (elem->mode)
                                            printf("..%06o", elem->mode);
                            }
                            printf("%s\n", c_reset);
                    }

                    if (!show_file_header)
                            return;

                    if (rev->combined_all_paths) {
                            for (i = 0; i < num_parent; i++) {
                                    char *path = filename_changed(elem->parent[i].status)
                                            ? elem->parent[i].path.buf : elem->path;
                                    if (elem->parent[i].status == DIFF_STATUS_ADDED)
                                            dump_quoted_path("--- ", "", "/dev/null",
                                                            line_prefix, c_meta, c_reset);
                                    else
                                            dump_quoted_path("--- ", a_prefix, path,
                                                            line_prefix, c_meta, c_reset);
                            }
                    } else {
                            if (added)
                                    dump_quoted_path("--- ", "", "/dev/null",
                                                    line_prefix, c_meta, c_reset);
                            else
                                    dump_quoted_path("--- ", a_prefix, elem->path,
                                                    line_prefix, c_meta, c_reset);
                    }
                    if (deleted)
                            dump_quoted_path("+++ ", "", "/dev/null",
                                            line_prefix, c_meta, c_reset);
                    else
                            dump_quoted_path("+++ ", b_prefix, elem->path,
                                            line_prefix, c_meta, c_reset);
            }

            static void show_patch_diff(struct combine_diff_path *elem, int num_parent,
                                    int working_tree_file,
                                    struct rev_info *rev)
            {
                    struct diff_options *opt = &rev->diffopt;
                    unsigned long result_size, cnt, lno;
                    int result_deleted = 0;
                    char *result, *cp;
                    struct sline *sline; /* survived lines */
                    int mode_differs = 0;
                    int i, show_hunks;
                    mmfile_t result_file;
                    struct userdiff_driver *userdiff;
                    struct userdiff_driver *textconv = NULL;
                    int is_binary;
                    const char *line_prefix = diff_line_prefix(opt);

                    context = opt->context;
                    userdiff = userdiff_find_by_path(opt->repo->index, elem->path);
                    if (!userdiff)
                            userdiff = userdiff_find_by_name("default");
                    if (opt->flags.allow_textconv)
                            textconv = userdiff_get_textconv(opt->repo, userdiff);

                    /* Read the result of merge first */
                    if (!working_tree_file)
                            result = grab_blob(opt->repo, &elem->oid, elem->mode, &result_size,
                                            textconv, elem->path);
                    else {
                            /* Used by diff-tree to read from the working tree */
                            struct stat st;
                            int fd = -1;

                            if (lstat(elem->path, &st) < 0)
                                    goto deleted_file;

                            if (S_ISLNK(st.st_mode)) {
                                    struct strbuf buf = STRBUF_INIT;

                                    if (strbuf_readlink(&buf, elem->path, st.st_size) < 0) {
                                            error_errno("readlink(%s)", elem->path);
                                            return;
                                    }
                                    result_size = buf.len;
                                    result = strbuf_detach(&buf, NULL);
                                    elem->mode = canon_mode(st.st_mode);
                            } else if (S_ISDIR(st.st_mode)) {
                                    struct object_id oid;
                                    if (repo_resolve_gitlink_ref(the_repository, elem->path,
                                                            "HEAD", &oid) < 0)
                                            result = grab_blob(opt->repo, &elem->oid,
                                                            elem->mode, &result_size,
                                                            NULL, NULL);
                                    else
                                            result = grab_blob(opt->repo, &oid, elem->mode,
                                                            &result_size, NULL, NULL);
                            } else if (textconv) {
                                    struct diff_filespec *df = alloc_filespec(elem->path);
                                    fill_filespec(df, null_oid(), 0, st.st_mode);
                                    result_size = fill_textconv(opt->repo, textconv, df, &result);
                                    free_filespec(df);
                            } else if (0 <= (fd = open(elem->path, O_RDONLY))) {
                                    size_t len = xsize_t(st.st_size);
                                    ssize_t done;
                                    int is_file, i;

                                    elem->mode = canon_mode(st.st_mode);
                                    /* if symlinks don't work, assume symlink if all parents
                                    * are symlinks
                                    */
                                    is_file = has_symlinks;
                                    for (i = 0; !is_file && i < num_parent; i++)
                                            is_file = !S_ISLNK(elem->parent[i].mode);
                                    if (!is_file)
                                            elem->mode = canon_mode(S_IFLNK);

                                    result_size = len;
                                    result = xmallocz(len);

                                    done = read_in_full(fd, result, len);
                                    if (done < 0)
                                            die_errno("read error '%s'", elem->path);
                                    else if (done < len)
                                            die("early EOF '%s'", elem->path);

                                    /* If not a fake symlink, apply filters, e.g. autocrlf */
                                    if (is_file) {
                                            struct strbuf buf = STRBUF_INIT;

                                            if (convert_to_git(rev->diffopt.repo->index,
                                                            elem->path, result, len, &buf, global_conv_flags_eol)) {
                                                    free(result);
                                                    result = strbuf_detach(&buf, &len);
                                                    result_size = len;
                                            }
                                    }
                            }
                            else {
                            deleted_file:
                                    result_deleted = 1;
                                    result_size = 0;
                                    elem->mode = 0;
                                    result = xcalloc(1, 1);
                            }

                            if (0 <= fd)
                                    close(fd);
                    }

                    for (i = 0; i < num_parent; i++) {
                            if (elem->parent[i].mode != elem->mode) {
                                    mode_differs = 1;
                                    break;
                            }
                    }

                    if (textconv)
                            is_binary = 0;
                    else if (userdiff->binary != -1)
                            is_binary = userdiff->binary;
                    else {
                            is_binary = buffer_is_binary(result, result_size);
                            for (i = 0; !is_binary && i < num_parent; i++) {
                                    char *buf;
                                    unsigned long size;
                                    buf = grab_blob(opt->repo,
                                                    &elem->parent[i].oid,
                                                    elem->parent[i].mode,
                                                    &size, NULL, NULL);
                                    if (buffer_is_binary(buf, size))
                                            is_binary = 1;
                                    free(buf);
                            }
                    }
                    if (is_binary) {
                            show_combined_header(elem, num_parent, rev,
                                            line_prefix, mode_differs, 0);
                            printf("Binary files differ\n");
                            free(result);
                            return;
                    }

                    for (cnt = 0, cp = result; cp < result + result_size; cp++) {
                            if (*cp == '\n')
                                    cnt++;
                    }
                    if (result_size && result[result_size-1] != '\n')
                            cnt++; /* incomplete line */

                    CALLOC_ARRAY(sline, st_add(cnt, 2));
                    sline[0].bol = result;
                    for (lno = 0, cp = result; cp < result + result_size; cp++) {
                            if (*cp == '\n') {
                                    sline[lno].len = cp - sline[lno].bol;
                                    lno++;
                                    if (lno < cnt)
                                            sline[lno].bol = cp + 1;
                            }
                    }
                    if (result_size && result[result_size-1] != '\n')
                            sline[cnt-1].len = result_size - (sline[cnt-1].bol - result);

                    result_file.ptr = result;
                    result_file.size = result_size;

                    /*
                    * Even p_lno[cnt+1] is valid -- that is for the end line number
                    * for deletion hunk at the end.
                    */
                    CALLOC_ARRAY(sline[0].p_lno, st_mult(st_add(cnt, 2), num_parent));
                    for (lno = 0; lno <= cnt; lno++)
                            sline[lno+1].p_lno = sline[lno].p_lno + num_parent;

                    for (i = 0; i < num_parent; i++) {
                            int j;
                            for (j = 0; j < i; j++) {
                                    if (oideq(&elem->parent[i].oid,
                                            &elem->parent[j].oid)) {
                                            reuse_combine_diff(sline, cnt, i, j);
                                            break;
                                    }
                            }
                            if (i <= j)
                                    combine_diff(opt->repo,
                                            &elem->parent[i].oid,
                                            elem->parent[i].mode,
                                            &result_file, sline,
                                            cnt, i, num_parent, result_deleted,
                                            textconv, elem->path, opt->xdl_opts);
                    }

                    show_hunks = make_hunks(sline, cnt, num_parent, rev->dense_combined_merges);

                    if (show_hunks || mode_differs || working_tree_file) {
                            show_combined_header(elem, num_parent, rev,
                                            line_prefix, mode_differs, 1);
                            dump_sline(sline, line_prefix, cnt, num_parent,
                                    opt->use_color, result_deleted);
                    }
                    free(result);

                    for (lno = 0; lno < cnt + 2; lno++) {
                            if (sline[lno].lost) {
                                    struct lline *ll = sline[lno].lost;
                                    while (ll) {
                                            struct lline *tmp = ll;
                                            ll = ll->next;
                                            free(tmp);
                                    }
                            }
                    }
                    free(sline[0].p_lno);
                    free(sline);
            }

            static void show_raw_diff(struct combine_diff_path *p, int num_parent, struct rev_info *rev)
            {
                    struct diff_options *opt = &rev->diffopt;
                    int line_termination, inter_name_termination, i;
                    const char *line_prefix = diff_line_prefix(opt);

                    line_termination = opt->line_termination;
                    inter_name_termination = '\t';
                    if (!line_termination)
                            inter_name_termination = 0;

                    if (rev->loginfo && !rev->no_commit_id)
                            show_log(rev);


                    if (opt->output_format & DIFF_FORMAT_RAW) {
                            printf("%s", line_prefix);

                            /* As many colons as there are parents */
                            for (i = 0; i < num_parent; i++)
                                    putchar(':');

                            /* Show the modes */
                            for (i = 0; i < num_parent; i++)
                                    printf("%06o ", p->parent[i].mode);
                            printf("%06o", p->mode);

                            /* Show sha1's */
                            for (i = 0; i < num_parent; i++)
                                    printf(" %s", diff_aligned_abbrev(&p->parent[i].oid,
                                                                    opt->abbrev));
                            printf(" %s ", diff_aligned_abbrev(&p->oid, opt->abbrev));
                    }

                    if (opt->output_format & (DIFF_FORMAT_RAW | DIFF_FORMAT_NAME_STATUS)) {
                            for (i = 0; i < num_parent; i++)
                                    putchar(p->parent[i].status);
                            putchar(inter_name_termination);
                    }

                    for (i = 0; i < num_parent; i++)
                            if (rev->combined_all_paths) {
                                    if (filename_changed(p->parent[i].status))
                                            write_name_quoted(p->parent[i].path.buf, stdout,
                                                            inter_name_termination);
                                    else
                                            write_name_quoted(p->path, stdout,
                                                            inter_name_termination);
                            }
                    write_name_quoted(p->path, stdout, line_termination);
            }

            /*
            * The result (p->elem) is from the working tree and their
            * parents are typically from multiple stages during a merge
            * (i.e. diff-files) or the state in HEAD and in the index
            * (i.e. diff-index).
            */
            void show_combined_diff(struct combine_diff_path *p,
                            int num_parent,
                            struct rev_info *rev)
            {
                    struct diff_options *opt = &rev->diffopt;

                    if (opt->output_format & (DIFF_FORMAT_RAW |
                                            DIFF_FORMAT_NAME |
                                            DIFF_FORMAT_NAME_STATUS))
                            show_raw_diff(p, num_parent, rev);
                    else if (opt->output_format & DIFF_FORMAT_PATCH)
                            show_patch_diff(p, num_parent, 1, rev);
            }

            static void free_combined_pair(struct diff_filepair *pair)
            {
                    free(pair->two);
                    free(pair);
            }

            /*
            * A combine_diff_path expresses N parents on the LHS against 1 merge
            * result. Synthesize a diff_filepair that has N entries on the "one"
            * side and 1 entry on the "two" side.
            *
            * In the future, we might want to add more data to combine_diff_path
            * so that we can fill fields we are ignoring (most notably, size) here,
            * but currently nobody uses it, so this should suffice for now.
            */
            static struct diff_filepair *combined_pair(struct combine_diff_path *p,
                                                    int num_parent)
            {
                    int i;
                    struct diff_filepair *pair;
                    struct diff_filespec *pool;

                    pair = xmalloc(sizeof(*pair));
                    CALLOC_ARRAY(pool, st_add(num_parent, 1));
                    pair->one = pool + 1;
                    pair->two = pool;

                    for (i = 0; i < num_parent; i++) {
                            pair->one[i].path = p->path;
                            pair->one[i].mode = p->parent[i].mode;
                            oidcpy(&pair->one[i].oid, &p->parent[i].oid);
                            pair->one[i].oid_valid = !is_null_oid(&p->parent[i].oid);
                            pair->one[i].has_more_entries = 1;
                    }
                    pair->one[num_parent - 1].has_more_entries = 0;

                    pair->two->path = p->path;
                    pair->two->mode = p->mode;
                    oidcpy(&pair->two->oid, &p->oid);
                    pair->two->oid_valid = !is_null_oid(&p->oid);
                    return pair;
            }

            static void handle_combined_callback(struct diff_options *opt,
                                            struct combine_diff_path *paths,
                                            int num_parent,
                                            int num_paths)
            {
                    struct combine_diff_path *p;
                    struct diff_queue_struct q;
                    int i;

                    CALLOC_ARRAY(q.queue, num_paths);
                    q.alloc = num_paths;
                    q.nr = num_paths;
                    for (i = 0, p = paths; p; p = p->next)
                            q.queue[i++] = combined_pair(p, num_parent);
                    opt->format_callback(&q, opt, opt->format_callback_data);
                    for (i = 0; i < num_paths; i++)
                            free_combined_pair(q.queue[i]);
                    free(q.queue);
            }

            static const char *path_path(void *obj)
            {
                    struct combine_diff_path *path = (struct combine_diff_path *)obj;

                    return path->path;
            }

            /*
            * Diff stat formats which we always compute solely against the first parent.
            */
            #define STAT_FORMAT_MASK (DIFF_FORMAT_NUMSTAT \
                                    | DIFF_FORMAT_SHORTSTAT \
                                    | DIFF_FORMAT_SUMMARY \
                                    | DIFF_FORMAT_DIRSTAT \
                                    | DIFF_FORMAT_DIFFSTAT)

            /* find set of paths that every parent touches */
            static struct combine_diff_path *find_paths_generic(const struct object_id *oid,
                    const struct oid_array *parents,
                    struct diff_options *opt,
                    int combined_all_paths)
            {
                    struct combine_diff_path *paths = NULL;
                    int i, num_parent = parents->nr;
                    int output_format = opt->output_format;
                    char *orderfile = opt->orderfile;

                    opt->output_format = DIFF_FORMAT_NO_OUTPUT;
                    /* tell diff_tree to emit paths in sorted (=tree) order */
                    opt->orderfile = NULL;

                    /* D(A,P1...Pn) = D(A,P1) ^ ... ^ D(A,Pn)  (wrt paths) */
                    for (i = 0; i < num_parent; i++) {
                            /*
                            * show stat against the first parent even when doing
                            * combined diff.
                            */
                            int stat_opt = output_format & STAT_FORMAT_MASK;
                            if (i == 0 && stat_opt)
                                    opt->output_format = stat_opt;
                            else
                                    opt->output_format = DIFF_FORMAT_NO_OUTPUT;
                            diff_tree_oid(&parents->oid[i], oid, "", opt);
                            diffcore_std(opt);
                            paths = intersect_paths(paths, i, num_parent,
                                                    combined_all_paths);

                            /* if showing diff, show it in requested order */
                            if (opt->output_format != DIFF_FORMAT_NO_OUTPUT &&
                            orderfile) {
                                    diffcore_order(orderfile);
                            }

                            diff_flush(opt);
                    }

                    opt->output_format = output_format;
                    opt->orderfile = orderfile;
                    return paths;
            }


            /*
            * find set of paths that everybody touches, assuming diff is run without
            * rename/copy detection, etc, comparing all trees simultaneously (= faster).
            */
            static struct combine_diff_path *find_paths_multitree(
                    const struct object_id *oid, const struct oid_array *parents,
                    struct diff_options *opt)
            {
                    int i, nparent = parents->nr;
                    const struct object_id **parents_oid;
                    struct combine_diff_path paths_head;
                    struct strbuf base;

                    ALLOC_ARRAY(parents_oid, nparent);
                    for (i = 0; i < nparent; i++)
                            parents_oid[i] = &parents->oid[i];

                    /* fake list head, so worker can assume it is non-NULL */
                    paths_head.next = NULL;

                    strbuf_init(&base, PATH_MAX);
                    diff_tree_paths(&paths_head, oid, parents_oid, nparent, &base, opt);

                    strbuf_release(&base);
                    free(parents_oid);
                    return paths_head.next;
            }

            static int match_objfind(struct combine_diff_path *path,
                                    int num_parent,
                                    const struct oidset *set)
            {
                    int i;
                    if (oidset_contains(set, &path->oid))
                            return 1;
                    for (i = 0; i < num_parent; i++) {
                            if (oidset_contains(set, &path->parent[i].oid))
                                    return 1;
                    }
                    return 0;
            }

            static struct combine_diff_path *combined_objfind(struct diff_options *opt,
                                                            struct combine_diff_path *paths,
                                                            int num_parent)
            {
                    struct combine_diff_path *ret = NULL, **tail = &ret;
                    struct combine_diff_path *p = paths;

                    while (p) {
                            struct combine_diff_path *next = p->next;

                            if (match_objfind(p, num_parent, opt->objfind)) {
                                    p->next = NULL;
                                    *tail = p;
                                    tail = &p->next;
                            } else {
                                    free(p);
                            }
                            p = next;
                    }

                    return ret;
            }

            void diff_tree_combined(const struct object_id *oid,
                                    const struct oid_array *parents,
                                    struct rev_info *rev)
            {
                    struct diff_options *opt = &rev->diffopt;
                    struct diff_options diffopts;
                    struct combine_diff_path *p, *paths;
                    int i, num_paths, needsep, show_log_first, num_parent = parents->nr;
                    int need_generic_pathscan;

                    if (opt->ignore_regex_nr)
                            die("combined diff and '%s' cannot be used together",
                            "--ignore-matching-lines");
                    if (opt->close_file)
                            die("combined diff and '%s' cannot be used together",
                            "--output");

                    /* nothing to do, if no parents */
                    if (!num_parent)
                            return;

                    show_log_first = !!rev->loginfo && !rev->no_commit_id;
                    needsep = 0;
                    if (show_log_first) {
                            show_log(rev);

                            if (rev->verbose_header && opt->output_format &&
                            opt->output_format != DIFF_FORMAT_NO_OUTPUT &&
                            !commit_format_is_empty(rev->commit_format))
                                    printf("%s%c", diff_line_prefix(opt),
                                    opt->line_termination);
                    }

                    diffopts = *opt;
                    copy_pathspec(&diffopts.pathspec, &opt->pathspec);
                    diffopts.flags.recursive = 1;
                    diffopts.flags.allow_external = 0;

                    /* find set of paths that everybody touches
                    *
                    * NOTE
                    *
                    * Diffcore transformations are bound to diff_filespec and logic
                    * comparing two entries - i.e. they do not apply directly to combine
                    * diff.
                    *
                    * If some of such transformations is requested - we launch generic
                    * path scanning, which works significantly slower compared to
                    * simultaneous all-trees-in-one-go scan in find_paths_multitree().
                    *
                    * TODO some of the filters could be ported to work on
                    * combine_diff_paths - i.e. all functionality that skips paths, so in
                    * theory, we could end up having only multitree path scanning.
                    *
                    * NOTE please keep this semantically in sync with diffcore_std()
                    */
                    need_generic_pathscan = opt->skip_stat_unmatch  ||
                                    opt->flags.follow_renames       ||
                                    opt->break_opt != -1    ||
                                    opt->detect_rename      ||
                                    (opt->pickaxe_opts &
                                    (DIFF_PICKAXE_KINDS_MASK & ~DIFF_PICKAXE_KIND_OBJFIND)) ||
                                    opt->filter;

                    if (need_generic_pathscan) {
                            /*
                            * NOTE generic case also handles --stat, as it computes
                            * diff(sha1,parent_i) for all i to do the job, specifically
                            * for parent0.
                            */
                            paths = find_paths_generic(oid, parents, &diffopts,
                                                    rev->combined_all_paths);
                    }
                    else {
                            int stat_opt;
                            paths = find_paths_multitree(oid, parents, &diffopts);

                            if (opt->pickaxe_opts & DIFF_PICKAXE_KIND_OBJFIND)
                                    paths = combined_objfind(opt, paths, num_parent);

                            /*
                            * show stat against the first parent even
                            * when doing combined diff.
                            */
                            stat_opt = opt->output_format & STAT_FORMAT_MASK;
                            if (stat_opt) {
                                    diffopts.output_format = stat_opt;

                                    diff_tree_oid(&parents->oid[0], oid, "", &diffopts);
                                    diffcore_std(&diffopts);
                                    if (opt->orderfile)
                                            diffcore_order(opt->orderfile);
                                    diff_flush(&diffopts);
                            }
                    }

                    /* find out number of surviving paths */
                    for (num_paths = 0, p = paths; p; p = p->next)
                            num_paths++;

                    /* order paths according to diffcore_order */
                    if (opt->orderfile && num_paths) {
                            struct obj_order *o;

                            ALLOC_ARRAY(o, num_paths);
                            for (i = 0, p = paths; p; p = p->next, i++)
                                    o[i].obj = p;
                            order_objects(opt->orderfile, path_path, o, num_paths);
                            for (i = 0; i < num_paths - 1; i++) {
                                    p = o[i].obj;
                                    p->next = o[i+1].obj;
                            }

                            p = o[num_paths-1].obj;
                            p->next = NULL;
                            paths = o[0].obj;
                            free(o);
                    }


                    if (num_paths) {
                            if (opt->output_format & (DIFF_FORMAT_RAW |
                                                    DIFF_FORMAT_NAME |
                                                    DIFF_FORMAT_NAME_STATUS)) {
                                    for (p = paths; p; p = p->next)
                                            show_raw_diff(p, num_parent, rev);
                                    needsep = 1;
                            }
                            else if (opt->output_format & STAT_FORMAT_MASK)
                                    needsep = 1;
                            else if (opt->output_format & DIFF_FORMAT_CALLBACK)
                                    handle_combined_callback(opt, paths, num_parent, num_paths);

                            if (opt->output_format & DIFF_FORMAT_PATCH) {
                                    if (needsep)
                                            printf("%s%c", diff_line_prefix(opt),
                                            opt->line_termination);
                                    for (p = paths; p; p = p->next)
                                            show_patch_diff(p, num_parent, 0, rev);
                            }
                    }

                    /* Clean things up */
                    while (paths) {
                            struct combine_diff_path *tmp = paths;
                            paths = paths->next;
                            for (i = 0; i < num_parent; i++)
                                    if (rev->combined_all_paths &&
                                    filename_changed(tmp->parent[i].status))
                                            strbuf_release(&tmp->parent[i].path);
                            free(tmp);
                    }

                    clear_pathspec(&diffopts.pathspec);
            }

            void diff_tree_combined_merge(const struct commit *commit,
                                    struct rev_info *rev)
            {
                    struct commit_list *parent = get_saved_parents(rev, commit);
                    struct oid_array parents = OID_ARRAY_INIT;

                    while (parent) {
                            oid_array_append(&parents, &parent->item->object.oid);
                            parent = parent->next;
                    }
                    diff_tree_combined(&commit->object.oid, &parents, rev);
                    oid_array_clear(&parents);
            }
        """,

        "error":"On z/OS, automatic character conversion (such as from EBCDIC to ASCII) may happen when reading or
                 writing files. This could cause issues when handling binary files or files that need to retain their exact
                 byte-for-byte content.The __disableautocvt() function disables this automatic conversion for the given file
                 descriptor, ensuring that the file is handled as-is without any unintended modification to its content.",
        "error Category":"Fuctionality Patch",

        "Corrected Code"
        """

                    #define USE_THE_REPOSITORY_VARIABLE
            #define DISABLE_SIGN_COMPARE_WARNINGS

            #include "git-compat-util.h"
            #include "object-store-ll.h"
            #include "commit.h"
            #include "convert.h"
            #include "diff.h"
            #include "diffcore.h"
            #include "environment.h"
            #include "hex.h"
            #include "object-name.h"
            #include "quote.h"
            #include "xdiff-interface.h"
            #include "xdiff/xmacros.h"
            #include "log-tree.h"
            #include "refs.h"
            #include "tree.h"
            #include "userdiff.h"
            #include "oid-array.h"
            #include "revision.h"

            static int compare_paths(const struct combine_diff_path *one,
                                    const struct diff_filespec *two)
            {
                    if (!S_ISDIR(one->mode) && !S_ISDIR(two->mode))
                            return strcmp(one->path, two->path);

                    return base_name_compare(one->path, strlen(one->path), one->mode,
                                            two->path, strlen(two->path), two->mode);
            }

            static int filename_changed(char status)
            {
                    return status == 'R' || status == 'C';
            }

            static struct combine_diff_path *intersect_paths(
                    struct combine_diff_path *curr,
                    int n,
                    int num_parent,
                    int combined_all_paths)
            {
                    struct diff_queue_struct *q = &diff_queued_diff;
                    struct combine_diff_path *p, **tail = &curr;
                    int i, j, cmp;

                    if (!n) {
                            for (i = 0; i < q->nr; i++) {
                                    int len;
                                    const char *path;
                                    if (diff_unmodified_pair(q->queue[i]))
                                            continue;
                                    path = q->queue[i]->two->path;
                                    len = strlen(path);
                                    p = xmalloc(combine_diff_path_size(num_parent, len));
                                    p->path = (char *) &(p->parent[num_parent]);
                                    memcpy(p->path, path, len);
                                    p->path[len] = 0;
                                    p->next = NULL;
                                    memset(p->parent, 0,
                                    sizeof(p->parent[0]) * num_parent);

                                    oidcpy(&p->oid, &q->queue[i]->two->oid);
                                    p->mode = q->queue[i]->two->mode;
                                    oidcpy(&p->parent[n].oid, &q->queue[i]->one->oid);
                                    p->parent[n].mode = q->queue[i]->one->mode;
                                    p->parent[n].status = q->queue[i]->status;

                                    if (combined_all_paths &&
                                    filename_changed(p->parent[n].status)) {
                                            strbuf_init(&p->parent[n].path, 0);
                                            strbuf_addstr(&p->parent[n].path,
                                                    q->queue[i]->one->path);
                                    }
                                    *tail = p;
                                    tail = &p->next;
                            }
                            return curr;
                    }

                    /*
                    * paths in curr (linked list) and q->queue[] (array) are
                    * both sorted in the tree order.
                    */
                    i = 0;
                    while ((p = *tail) != NULL) {
                            cmp = ((i >= q->nr)
                            ? -1 : compare_paths(p, q->queue[i]->two));

                            if (cmp < 0) {
                                    /* p->path not in q->queue[]; drop it */
                                    *tail = p->next;
                                    for (j = 0; j < num_parent; j++)
                                            if (combined_all_paths &&
                                            filename_changed(p->parent[j].status))
                                                    strbuf_release(&p->parent[j].path);
                                    free(p);
                                    continue;
                            }

                            if (cmp > 0) {
                                    /* q->queue[i] not in p->path; skip it */
                                    i++;
                                    continue;
                            }

                            oidcpy(&p->parent[n].oid, &q->queue[i]->one->oid);
                            p->parent[n].mode = q->queue[i]->one->mode;
                            p->parent[n].status = q->queue[i]->status;
                            if (combined_all_paths &&
                            filename_changed(p->parent[n].status))
                                    strbuf_addstr(&p->parent[n].path,
                                            q->queue[i]->one->path);

                            tail = &p->next;
                            i++;
                    }
                    return curr;
            }

            /* Lines lost from parent */
            struct lline {
                    struct lline *next, *prev;
                    int len;
                    unsigned long parent_map;
                    char line[FLEX_ARRAY];
            };

            /* Lines lost from current parent (before coalescing) */
            struct plost {
                    struct lline *lost_head, *lost_tail;
                    int len;
            };

            /* Lines surviving in the merge result */
            struct sline {
                    /* Accumulated and coalesced lost lines */
                    struct lline *lost;
                    int lenlost;
                    struct plost plost;
                    char *bol;
                    int len;
                    /* bit 0 up to (N-1) are on if the parent has this line (i.e.
                    * we did not change it).
                    * bit N is used for "interesting" lines, including context.
                    * bit (N+1) is used for "do not show deletion before this".
                    */
                    unsigned long flag;
                    unsigned long *p_lno;
            };

            static int match_string_spaces(const char *line1, int len1,
                                    const char *line2, int len2,
                                    long flags)
            {
                    if (flags & XDF_WHITESPACE_FLAGS) {
                            for (; len1 > 0 && XDL_ISSPACE(line1[len1 - 1]); len1--);
                            for (; len2 > 0 && XDL_ISSPACE(line2[len2 - 1]); len2--);
                    }

                    if (!(flags & (XDF_IGNORE_WHITESPACE | XDF_IGNORE_WHITESPACE_CHANGE)))
                            return (len1 == len2 && !memcmp(line1, line2, len1));

                    while (len1 > 0 && len2 > 0) {
                            len1--;
                            len2--;
                            if (XDL_ISSPACE(line1[len1]) || XDL_ISSPACE(line2[len2])) {
                                    if ((flags & XDF_IGNORE_WHITESPACE_CHANGE) &&
                                    (!XDL_ISSPACE(line1[len1]) || !XDL_ISSPACE(line2[len2])))
                                            return 0;

                                    for (; len1 > 0 && XDL_ISSPACE(line1[len1]); len1--);
                                    for (; len2 > 0 && XDL_ISSPACE(line2[len2]); len2--);
                            }
                            if (line1[len1] != line2[len2])
                                    return 0;
                    }

                    if (flags & XDF_IGNORE_WHITESPACE) {
                            /* Consume remaining spaces */
                            for (; len1 > 0 && XDL_ISSPACE(line1[len1 - 1]); len1--);
                            for (; len2 > 0 && XDL_ISSPACE(line2[len2 - 1]); len2--);
                    }

                    /* We matched full line1 and line2 */
                    if (!len1 && !len2)
                            return 1;

                    return 0;
            }

            enum coalesce_direction { MATCH, BASE, NEW };

            /* Coalesce new lines into base by finding LCS */
            static struct lline *coalesce_lines(struct lline *base, int *lenbase,
                                            struct lline *newline, int lennew,
                                            unsigned long parent, long flags)
            {
                    int **lcs;
                    enum coalesce_direction **directions;
                    struct lline *baseend, *newend = NULL;
                    int i, j, origbaselen = *lenbase;

                    if (!newline)
                            return base;

                    if (!base) {
                            *lenbase = lennew;
                            return newline;
                    }

                    /*
                    * Coalesce new lines into base by finding the LCS
                    * - Create the table to run dynamic programming
                    * - Compute the LCS
                    * - Then reverse read the direction structure:
                    *   - If we have MATCH, assign parent to base flag, and consume
                    *   both baseend and newend
                    *   - Else if we have BASE, consume baseend
                    *   - Else if we have NEW, insert newend lline into base and
                    *   consume newend
                    */
                    CALLOC_ARRAY(lcs, st_add(origbaselen, 1));
                    CALLOC_ARRAY(directions, st_add(origbaselen, 1));
                    for (i = 0; i < origbaselen + 1; i++) {
                            CALLOC_ARRAY(lcs[i], st_add(lennew, 1));
                            CALLOC_ARRAY(directions[i], st_add(lennew, 1));
                            directions[i][0] = BASE;
                    }
                    for (j = 1; j < lennew + 1; j++)
                            directions[0][j] = NEW;

                    for (i = 1, baseend = base; i < origbaselen + 1; i++) {
                            for (j = 1, newend = newline; j < lennew + 1; j++) {
                                    if (match_string_spaces(baseend->line, baseend->len,
                                                            newend->line, newend->len, flags)) {
                                            lcs[i][j] = lcs[i - 1][j - 1] + 1;
                                            directions[i][j] = MATCH;
                                    } else if (lcs[i][j - 1] >= lcs[i - 1][j]) {
                                            lcs[i][j] = lcs[i][j - 1];
                                            directions[i][j] = NEW;
                                    } else {
                                            lcs[i][j] = lcs[i - 1][j];
                                            directions[i][j] = BASE;
                                    }
                                    if (newend->next)
                                            newend = newend->next;
                            }
                            if (baseend->next)
                                    baseend = baseend->next;
                    }

                    for (i = 0; i < origbaselen + 1; i++)
                            free(lcs[i]);
                    free(lcs);

                    /* At this point, baseend and newend point to the end of each lists */
                    i--;
                    j--;
                    while (i != 0 || j != 0) {
                            if (directions[i][j] == MATCH) {
                                    baseend->parent_map |= 1<<parent;
                                    baseend = baseend->prev;
                                    newend = newend->prev;
                                    i--;
                                    j--;
                            } else if (directions[i][j] == NEW) {
                                    struct lline *lline;

                                    lline = newend;
                                    /* Remove lline from new list and update newend */
                                    if (lline->prev)
                                            lline->prev->next = lline->next;
                                    else
                                            newline = lline->next;
                                    if (lline->next)
                                            lline->next->prev = lline->prev;

                                    newend = lline->prev;
                                    j--;

                                    /* Add lline to base list */
                                    if (baseend) {
                                            lline->next = baseend->next;
                                            lline->prev = baseend;
                                            if (lline->prev)
                                                    lline->prev->next = lline;
                                    }
                                    else {
                                            lline->next = base;
                                            base = lline;
                                    }
                                    (*lenbase)++;

                                    if (lline->next)
                                            lline->next->prev = lline;

                            } else {
                                    baseend = baseend->prev;
                                    i--;
                            }
                    }

                    newend = newline;
                    while (newend) {
                            struct lline *lline = newend;
                            newend = newend->next;
                            free(lline);
                    }

                    for (i = 0; i < origbaselen + 1; i++)
                            free(directions[i]);
                    free(directions);

                    return base;
            }

            static char *grab_blob(struct repository *r,
                            const struct object_id *oid, unsigned int mode,
                            unsigned long *size, struct userdiff_driver *textconv,
                            const char *path)
            {
                    char *blob;
                    enum object_type type;

                    if (S_ISGITLINK(mode)) {
                            struct strbuf buf = STRBUF_INIT;
                            strbuf_addf(&buf, "Subproject commit %s\n", oid_to_hex(oid));
                            *size = buf.len;
                            blob = strbuf_detach(&buf, NULL);
                    } else if (is_null_oid(oid)) {
                            /* deleted blob */
                            *size = 0;
                            return xcalloc(1, 1);
                    } else if (textconv) {
                            struct diff_filespec *df = alloc_filespec(path);
                            fill_filespec(df, oid, 1, mode);
                            *size = fill_textconv(r, textconv, df, &blob);
                            free_filespec(df);
                    } else {
                            blob = repo_read_object_file(r, oid, &type, size);
                            if (!blob)
                                    die(_("unable to read %s"), oid_to_hex(oid));
                            if (type != OBJ_BLOB)
                                    die("object '%s' is not a blob!", oid_to_hex(oid));
                    }
                    return blob;
            }

            static void append_lost(struct sline *sline, int n, const char *line, int len)
            {
                    struct lline *lline;
                    unsigned long this_mask = (1UL<<n);
                    if (line[len-1] == '\n')
                            len--;

                    FLEX_ALLOC_MEM(lline, line, line, len);
                    lline->len = len;
                    lline->next = NULL;
                    lline->prev = sline->plost.lost_tail;
                    if (lline->prev)
                            lline->prev->next = lline;
                    else
                            sline->plost.lost_head = lline;
                    sline->plost.lost_tail = lline;
                    sline->plost.len++;
                    lline->parent_map = this_mask;
            }

            struct combine_diff_state {
                    unsigned int lno;
                    int ob, on, nb, nn;
                    unsigned long nmask;
                    int num_parent;
                    int n;
                    struct sline *sline;
                    struct sline *lost_bucket;
            };

            static void consume_hunk(void *state_,
                                    long ob, long on,
                                    long nb, long nn,
                                    const char *func UNUSED, long funclen UNUSED)
            {
                    struct combine_diff_state *state = state_;

                    state->ob = ob;
                    state->on = on;
                    state->nb = nb;
                    state->nn = nn;
                    state->lno = state->nb;
                    if (state->nn == 0) {
                            /* @@ -X,Y +N,0 @@ removed Y lines
                            * that would have come *after* line N
                            * in the result.  Our lost buckets hang
                            * to the line after the removed lines,
                            *
                            * Note that this is correct even when N == 0,
                            * in which case the hunk removes the first
                            * line in the file.
                            */
                            state->lost_bucket = &state->sline[state->nb];
                            if (!state->nb)
                                    state->nb = 1;
                    } else {
                            state->lost_bucket = &state->sline[state->nb-1];
                    }
                    if (!state->sline[state->nb-1].p_lno)
                            CALLOC_ARRAY(state->sline[state->nb - 1].p_lno,
                                    state->num_parent);
                    state->sline[state->nb-1].p_lno[state->n] = state->ob;
            }

            static int consume_line(void *state_, char *line, unsigned long len)
            {
                    struct combine_diff_state *state = state_;
                    if (!state->lost_bucket)
                            return 0; /* not in any hunk yet */
                    switch (line[0]) {
                    case '-':
                            append_lost(state->lost_bucket, state->n, line+1, len-1);
                            break;
                    case '+':
                            state->sline[state->lno-1].flag |= state->nmask;
                            state->lno++;
                            break;
                    }
                    return 0;
            }

            static void combine_diff(struct repository *r,
                                    const struct object_id *parent, unsigned int mode,
                                    mmfile_t *result_file,
                                    struct sline *sline, unsigned int cnt, int n,
                                    int num_parent, int result_deleted,
                                    struct userdiff_driver *textconv,
                                    const char *path, long flags)
            {
                    unsigned int p_lno, lno;
                    unsigned long nmask = (1UL << n);
                    xpparam_t xpp;
                    xdemitconf_t xecfg;
                    mmfile_t parent_file;
                    struct combine_diff_state state;
                    unsigned long sz;

                    if (result_deleted)
                            return; /* result deleted */

                    parent_file.ptr = grab_blob(r, parent, mode, &sz, textconv, path);
                    parent_file.size = sz;
                    memset(&xpp, 0, sizeof(xpp));
                    xpp.flags = flags;
                    memset(&xecfg, 0, sizeof(xecfg));
                    memset(&state, 0, sizeof(state));
                    state.nmask = nmask;
                    state.sline = sline;
                    state.lno = 1;
                    state.num_parent = num_parent;
                    state.n = n;

                    if (xdi_diff_outf(&parent_file, result_file, consume_hunk,
                                    consume_line, &state, &xpp, &xecfg))
                            die("unable to generate combined diff for %s",
                            oid_to_hex(parent));
                    free(parent_file.ptr);

                    /* Assign line numbers for this parent.
                    *
                    * sline[lno].p_lno[n] records the first line number
                    * (counting from 1) for parent N if the final hunk display
                    * started by showing sline[lno] (possibly showing the lost
                    * lines attached to it first).
                    */
                    for (lno = 0,  p_lno = 1; lno <= cnt; lno++) {
                            struct lline *ll;
                            sline[lno].p_lno[n] = p_lno;

                            /* Coalesce new lines */
                            if (sline[lno].plost.lost_head) {
                                    struct sline *sl = &sline[lno];
                                    sl->lost = coalesce_lines(sl->lost, &sl->lenlost,
                                                            sl->plost.lost_head,
                                                            sl->plost.len, n, flags);
                                    sl->plost.lost_head = sl->plost.lost_tail = NULL;
                                    sl->plost.len = 0;
                            }

                            /* How many lines would this sline advance the p_lno? */
                            ll = sline[lno].lost;
                            while (ll) {
                                    if (ll->parent_map & nmask)
                                            p_lno++; /* '-' means parent had it */
                                    ll = ll->next;
                            }
                            if (lno < cnt && !(sline[lno].flag & nmask))
                                    p_lno++; /* no '+' means parent had it */
                    }
                    sline[lno].p_lno[n] = p_lno; /* trailer */
            }

            static unsigned long context = 3;
            static char combine_marker = '@';

            static int interesting(struct sline *sline, unsigned long all_mask)
            {
                    /* If some parents lost lines here, or if we have added to
                    * some parent, it is interesting.
                    */
                    return ((sline->flag & all_mask) || sline->lost);
            }

            static unsigned long adjust_hunk_tail(struct sline *sline,
                                            unsigned long all_mask,
                                            unsigned long hunk_begin,
                                            unsigned long i)
            {
                    /* i points at the first uninteresting line.  If the last line
                    * of the hunk was interesting only because it has some
                    * deletion, then it is not all that interesting for the
                    * purpose of giving trailing context lines.  This is because
                    * we output '-' line and then unmodified sline[i-1] itself in
                    * that case which gives us one extra context line.
                    */
                    if ((hunk_begin + 1 <= i) && !(sline[i-1].flag & all_mask))
                            i--;
                    return i;
            }

            static unsigned long find_next(struct sline *sline,
                                    unsigned long mark,
                                    unsigned long i,
                                    unsigned long cnt,
                                    int look_for_uninteresting)
            {
                    /* We have examined up to i-1 and are about to look at i.
                    * Find next interesting or uninteresting line.  Here,
                    * "interesting" does not mean interesting(), but marked by
                    * the give_context() function below (i.e. it includes context
                    * lines that are not interesting to interesting() function
                    * that are surrounded by interesting() ones.
                    */
                    while (i <= cnt)
                            if (look_for_uninteresting
                            ? !(sline[i].flag & mark)
                            : (sline[i].flag & mark))
                                    return i;
                            else
                                    i++;
                    return i;
            }

            static int give_context(struct sline *sline, unsigned long cnt, int num_parent)
            {
                    unsigned long all_mask = (1UL<<num_parent) - 1;
                    unsigned long mark = (1UL<<num_parent);
                    unsigned long no_pre_delete = (2UL<<num_parent);
                    unsigned long i;

                    /* Two groups of interesting lines may have a short gap of
                    * uninteresting lines.  Connect such groups to give them a
                    * bit of context.
                    *
                    * We first start from what the interesting() function says,
                    * and mark them with "mark", and paint context lines with the
                    * mark.  So interesting() would still say false for such context
                    * lines but they are treated as "interesting" in the end.
                    */
                    i = find_next(sline, mark, 0, cnt, 0);
                    if (cnt < i)
                            return 0;

                    while (i <= cnt) {
                            unsigned long j = (context < i) ? (i - context) : 0;
                            unsigned long k;

                            /* Paint a few lines before the first interesting line. */
                            while (j < i) {
                                    if (!(sline[j].flag & mark))
                                            sline[j].flag |= no_pre_delete;
                                    sline[j++].flag |= mark;
                            }

                    again:
                            /* we know up to i is to be included.  where does the
                            * next uninteresting one start?
                            */
                            j = find_next(sline, mark, i, cnt, 1);
                            if (cnt < j)
                                    break; /* the rest are all interesting */

                            /* lookahead context lines */
                            k = find_next(sline, mark, j, cnt, 0);
                            j = adjust_hunk_tail(sline, all_mask, i, j);

                            if (k < j + context) {
                                    /* k is interesting and [j,k) are not, but
                                    * paint them interesting because the gap is small.
                                    */
                                    while (j < k)
                                            sline[j++].flag |= mark;
                                    i = k;
                                    goto again;
                            }

                            /* j is the first uninteresting line and there is
                            * no overlap beyond it within context lines.  Paint
                            * the trailing edge a bit.
                            */
                            i = k;
                            k = (j + context < cnt+1) ? j + context : cnt+1;
                            while (j < k)
                                    sline[j++].flag |= mark;
                    }
                    return 1;
            }

            static int make_hunks(struct sline *sline, unsigned long cnt,
                            int num_parent, int dense)
            {
                    unsigned long all_mask = (1UL<<num_parent) - 1;
                    unsigned long mark = (1UL<<num_parent);
                    unsigned long i;
                    int has_interesting = 0;

                    for (i = 0; i <= cnt; i++) {
                            if (interesting(&sline[i], all_mask))
                                    sline[i].flag |= mark;
                            else
                                    sline[i].flag &= ~mark;
                    }
                    if (!dense)
                            return give_context(sline, cnt, num_parent);

                    /* Look at each hunk, and if we have changes from only one
                    * parent, or the changes are the same from all but one
                    * parent, mark that uninteresting.
                    */
                    i = 0;
                    while (i <= cnt) {
                            unsigned long j, hunk_begin, hunk_end;
                            unsigned long same_diff;
                            while (i <= cnt && !(sline[i].flag & mark))
                                    i++;
                            if (cnt < i)
                                    break; /* No more interesting hunks */
                            hunk_begin = i;
                            for (j = i + 1; j <= cnt; j++) {
                                    if (!(sline[j].flag & mark)) {
                                            /* Look beyond the end to see if there
                                            * is an interesting line after this
                                            * hunk within context span.
                                            */
                                            unsigned long la; /* lookahead */
                                            int contin = 0;
                                            la = adjust_hunk_tail(sline, all_mask,
                                                            hunk_begin, j);
                                            la = (la + context < cnt + 1) ?
                                                    (la + context) : cnt + 1;
                                            while (la && j <= --la) {
                                                    if (sline[la].flag & mark) {
                                                            contin = 1;
                                                            break;
                                                    }
                                            }
                                            if (!contin)
                                                    break;
                                            j = la;
                                    }
                            }
                            hunk_end = j;

                            /* [i..hunk_end) are interesting.  Now is it really
                            * interesting?  We check if there are only two versions
                            * and the result matches one of them.  That is, we look
                            * at:
                            *   (+) line, which records lines added to which parents;
                            *       this line appears in the result.
                            *   (-) line, which records from what parents the line
                            *       was removed; this line does not appear in the result.
                            * then check the set of parents the result has difference
                            * from, from all lines.  If there are lines that has
                            * different set of parents that the result has differences
                            * from, that means we have more than two versions.
                            *
                            * Even when we have only two versions, if the result does
                            * not match any of the parents, the it should be considered
                            * interesting.  In such a case, we would have all '+' line.
                            * After passing the above "two versions" test, that would
                            * appear as "the same set of parents" to be "all parents".
                            */
                            same_diff = 0;
                            has_interesting = 0;
                            for (j = i; j < hunk_end && !has_interesting; j++) {
                                    unsigned long this_diff = sline[j].flag & all_mask;
                                    struct lline *ll = sline[j].lost;
                                    if (this_diff) {
                                            /* This has some changes.  Is it the
                                            * same as others?
                                            */
                                            if (!same_diff)
                                                    same_diff = this_diff;
                                            else if (same_diff != this_diff) {
                                                    has_interesting = 1;
                                                    break;
                                            }
                                    }
                                    while (ll && !has_interesting) {
                                            /* Lost this line from these parents;
                                            * who are they?  Are they the same?
                                            */
                                            this_diff = ll->parent_map;
                                            if (!same_diff)
                                                    same_diff = this_diff;
                                            else if (same_diff != this_diff) {
                                                    has_interesting = 1;
                                            }
                                            ll = ll->next;
                                    }
                            }

                            if (!has_interesting && same_diff != all_mask) {
                                    /* This hunk is not that interesting after all */
                                    for (j = hunk_begin; j < hunk_end; j++)
                                            sline[j].flag &= ~mark;
                            }
                            i = hunk_end;
                    }

                    has_interesting = give_context(sline, cnt, num_parent);
                    return has_interesting;
            }

            static void show_parent_lno(struct sline *sline, unsigned long l0, unsigned long l1, int n, unsigned long null_context)
            {
                    l0 = sline[l0].p_lno[n];
                    l1 = sline[l1].p_lno[n];
                    printf(" -%lu,%lu", l0, l1-l0-null_context);
            }

            static int hunk_comment_line(const char *bol)
            {
                    int ch;

                    if (!bol)
                            return 0;
                    ch = *bol & 0xff;
                    return (isalpha(ch) || ch == '_' || ch == '$');
            }

            static void show_line_to_eol(const char *line, int len, const char *reset)
            {
                    int saw_cr_at_eol = 0;
                    if (len < 0)
                            len = strlen(line);
                    saw_cr_at_eol = (len && line[len-1] == '\r');

                    printf("%.*s%s%s\n", len - saw_cr_at_eol, line,
                    reset,
                    saw_cr_at_eol ? "\r" : "");
            }

            static void dump_sline(struct sline *sline, const char *line_prefix,
                            unsigned long cnt, int num_parent,
                            int use_color, int result_deleted)
            {
                    unsigned long mark = (1UL<<num_parent);
                    unsigned long no_pre_delete = (2UL<<num_parent);
                    int i;
                    unsigned long lno = 0;
                    const char *c_frag = diff_get_color(use_color, DIFF_FRAGINFO);
                    const char *c_func = diff_get_color(use_color, DIFF_FUNCINFO);
                    const char *c_new = diff_get_color(use_color, DIFF_FILE_NEW);
                    const char *c_old = diff_get_color(use_color, DIFF_FILE_OLD);
                    const char *c_context = diff_get_color(use_color, DIFF_CONTEXT);
                    const char *c_reset = diff_get_color(use_color, DIFF_RESET);

                    if (result_deleted)
                            return; /* result deleted */

                    while (1) {
                            unsigned long hunk_end;
                            unsigned long rlines;
                            const char *hunk_comment = NULL;
                            unsigned long null_context = 0;

                            while (lno <= cnt && !(sline[lno].flag & mark)) {
                                    if (hunk_comment_line(sline[lno].bol))
                                            hunk_comment = sline[lno].bol;
                                    lno++;
                            }
                            if (cnt < lno)
                                    break;
                            else {
                                    for (hunk_end = lno + 1; hunk_end <= cnt; hunk_end++)
                                            if (!(sline[hunk_end].flag & mark))
                                                    break;
                            }
                            rlines = hunk_end - lno;
                            if (cnt < hunk_end)
                                    rlines--; /* pointing at the last delete hunk */

                            if (!context) {
                                    /*
                                    * Even when running with --unified=0, all
                                    * lines in the hunk needs to be processed in
                                    * the loop below in order to show the
                                    * deletion recorded in lost_head.  However,
                                    * we do not want to show the resulting line
                                    * with all blank context markers in such a
                                    * case.  Compensate.
                                    */
                                    unsigned long j;
                                    for (j = lno; j < hunk_end; j++)
                                            if (!(sline[j].flag & (mark-1)))
                                                    null_context++;
                                    rlines -= null_context;
                            }

                            printf("%s%s", line_prefix, c_frag);
                            for (i = 0; i <= num_parent; i++) putchar(combine_marker);
                            for (i = 0; i < num_parent; i++)
                                    show_parent_lno(sline, lno, hunk_end, i, null_context);
                            printf(" +%lu,%lu ", lno+1, rlines);
                            for (i = 0; i <= num_parent; i++) putchar(combine_marker);

                            if (hunk_comment) {
                                    int comment_end = 0;
                                    for (i = 0; i < 40; i++) {
                                            int ch = hunk_comment[i] & 0xff;
                                            if (!ch || ch == '\n')
                                                    break;
                                            if (!isspace(ch))
                                            comment_end = i;
                                    }
                                    if (comment_end)
                                            printf("%s%s %s%s", c_reset,
                                                            c_context, c_reset,
                                                            c_func);
                                    for (i = 0; i < comment_end; i++)
                                            putchar(hunk_comment[i]);
                            }

                            printf("%s\n", c_reset);
                            while (lno < hunk_end) {
                                    struct lline *ll;
                                    int j;
                                    unsigned long p_mask;
                                    struct sline *sl = &sline[lno++];
                                    ll = (sl->flag & no_pre_delete) ? NULL : sl->lost;
                                    while (ll) {
                                            printf("%s%s", line_prefix, c_old);
                                            for (j = 0; j < num_parent; j++) {
                                                    if (ll->parent_map & (1UL<<j))
                                                            putchar('-');
                                                    else
                                                            putchar(' ');
                                            }
                                            show_line_to_eol(ll->line, -1, c_reset);
                                            ll = ll->next;
                                    }
                                    if (cnt < lno)
                                            break;
                                    p_mask = 1;
                                    fputs(line_prefix, stdout);
                                    if (!(sl->flag & (mark-1))) {
                                            /*
                                            * This sline was here to hang the
                                            * lost lines in front of it.
                                            */
                                            if (!context)
                                                    continue;
                                            fputs(c_context, stdout);
                                    }
                                    else
                                            fputs(c_new, stdout);
                                    for (j = 0; j < num_parent; j++) {
                                            if (p_mask & sl->flag)
                                                    putchar('+');
                                            else
                                                    putchar(' ');
                                            p_mask <<= 1;
                                    }
                                    show_line_to_eol(sl->bol, sl->len, c_reset);
                            }
                    }
            }

            static void reuse_combine_diff(struct sline *sline, unsigned long cnt,
                                    int i, int j)
            {
                    /* We have already examined parent j and we know parent i
                    * and parent j are the same, so reuse the combined result
                    * of parent j for parent i.
                    */
                    unsigned long lno, imask, jmask;
                    imask = (1UL<<i);
                    jmask = (1UL<<j);

                    for (lno = 0; lno <= cnt; lno++) {
                            struct lline *ll = sline->lost;
                            sline->p_lno[i] = sline->p_lno[j];
                            while (ll) {
                                    if (ll->parent_map & jmask)
                                            ll->parent_map |= imask;
                                    ll = ll->next;
                            }
                            if (sline->flag & jmask)
                                    sline->flag |= imask;
                            sline++;
                    }
                    /* the overall size of the file (sline[cnt]) */
                    sline->p_lno[i] = sline->p_lno[j];
            }

            static void dump_quoted_path(const char *head,
                                    const char *prefix,
                                    const char *path,
                                    const char *line_prefix,
                                    const char *c_meta, const char *c_reset)
            {
                    static struct strbuf buf = STRBUF_INIT;

                    strbuf_reset(&buf);
                    strbuf_addstr(&buf, line_prefix);
                    strbuf_addstr(&buf, c_meta);
                    strbuf_addstr(&buf, head);
                    quote_two_c_style(&buf, prefix, path, 0);
                    strbuf_addstr(&buf, c_reset);
                    puts(buf.buf);
            }

            static void show_combined_header(struct combine_diff_path *elem,
                                            int num_parent,
                                            struct rev_info *rev,
                                            const char *line_prefix,
                                            int mode_differs,
                                            int show_file_header)
            {
                    struct diff_options *opt = &rev->diffopt;
                    int abbrev = opt->flags.full_index ? the_hash_algo->hexsz : DEFAULT_ABBREV;
                    const char *a_prefix = opt->a_prefix ? opt->a_prefix : "a/";
                    const char *b_prefix = opt->b_prefix ? opt->b_prefix : "b/";
                    const char *c_meta = diff_get_color_opt(opt, DIFF_METAINFO);
                    const char *c_reset = diff_get_color_opt(opt, DIFF_RESET);
                    const char *abb;
                    int added = 0;
                    int deleted = 0;
                    int i;
                    int dense = rev->dense_combined_merges;

                    if (rev->loginfo && !rev->no_commit_id)
                            show_log(rev);

                    dump_quoted_path(dense ? "diff --cc " : "diff --combined ",
                                    "", elem->path, line_prefix, c_meta, c_reset);
                    printf("%s%sindex ", line_prefix, c_meta);
                    for (i = 0; i < num_parent; i++) {
                            abb = repo_find_unique_abbrev(the_repository,
                                                    &elem->parent[i].oid, abbrev);
                            printf("%s%s", i ? "," : "", abb);
                    }
                    abb = repo_find_unique_abbrev(the_repository, &elem->oid, abbrev);
                    printf("..%s%s\n", abb, c_reset);

                    if (mode_differs) {
                            deleted = !elem->mode;

                            /* We say it was added if nobody had it */
                            added = !deleted;
                            for (i = 0; added && i < num_parent; i++)
                                    if (elem->parent[i].status !=
                                    DIFF_STATUS_ADDED)
                                            added = 0;
                            if (added)
                                    printf("%s%snew file mode %06o",
                                    line_prefix, c_meta, elem->mode);
                            else {
                                    if (deleted)
                                            printf("%s%sdeleted file ",
                                            line_prefix, c_meta);
                                    printf("mode ");
                                    for (i = 0; i < num_parent; i++) {
                                            printf("%s%06o", i ? "," : "",
                                            elem->parent[i].mode);
                                    }
                                    if (elem->mode)
                                            printf("..%06o", elem->mode);
                            }
                            printf("%s\n", c_reset);
                    }

                    if (!show_file_header)
                            return;

                    if (rev->combined_all_paths) {
                            for (i = 0; i < num_parent; i++) {
                                    char *path = filename_changed(elem->parent[i].status)
                                            ? elem->parent[i].path.buf : elem->path;
                                    if (elem->parent[i].status == DIFF_STATUS_ADDED)
                                            dump_quoted_path("--- ", "", "/dev/null",
                                                            line_prefix, c_meta, c_reset);
                                    else
                                            dump_quoted_path("--- ", a_prefix, path,
                                                            line_prefix, c_meta, c_reset);
                            }
                    } else {
                            if (added)
                                    dump_quoted_path("--- ", "", "/dev/null",
                                                    line_prefix, c_meta, c_reset);
                            else
                                    dump_quoted_path("--- ", a_prefix, elem->path,
                                                    line_prefix, c_meta, c_reset);
                    }
                    if (deleted)
                            dump_quoted_path("+++ ", "", "/dev/null",
                                            line_prefix, c_meta, c_reset);
                    else
                            dump_quoted_path("+++ ", b_prefix, elem->path,
                                            line_prefix, c_meta, c_reset);
            }

            static void show_patch_diff(struct combine_diff_path *elem, int num_parent,
                                    int working_tree_file,
                                    struct rev_info *rev)
            {
                    struct diff_options *opt = &rev->diffopt;
                    unsigned long result_size, cnt, lno;
                    int result_deleted = 0;
                    char *result, *cp;
                    struct sline *sline; /* survived lines */
                    int mode_differs = 0;
                    int i, show_hunks;
                    mmfile_t result_file;
                    struct userdiff_driver *userdiff;
                    struct userdiff_driver *textconv = NULL;
                    int is_binary;
                    const char *line_prefix = diff_line_prefix(opt);

                    context = opt->context;
                    userdiff = userdiff_find_by_path(opt->repo->index, elem->path);
                    if (!userdiff)
                            userdiff = userdiff_find_by_name("default");
                    if (opt->flags.allow_textconv)
                            textconv = userdiff_get_textconv(opt->repo, userdiff);

                    /* Read the result of merge first */
                    if (!working_tree_file)
                            result = grab_blob(opt->repo, &elem->oid, elem->mode, &result_size,
                                            textconv, elem->path);
                    else {
                            /* Used by diff-tree to read from the working tree */
                            struct stat st;
                            int fd = -1;

                            if (lstat(elem->path, &st) < 0)
                                    goto deleted_file;

                            if (S_ISLNK(st.st_mode)) {
                                    struct strbuf buf = STRBUF_INIT;

                                    if (strbuf_readlink(&buf, elem->path, st.st_size) < 0) {
                                            error_errno("readlink(%s)", elem->path);
                                            return;
                                    }
                                    result_size = buf.len;
                                    result = strbuf_detach(&buf, NULL);
                                    elem->mode = canon_mode(st.st_mode);
                            } else if (S_ISDIR(st.st_mode)) {
                                    struct object_id oid;
                                    if (repo_resolve_gitlink_ref(the_repository, elem->path,
                                                            "HEAD", &oid) < 0)
                                            result = grab_blob(opt->repo, &elem->oid,
                                                            elem->mode, &result_size,
                                                            NULL, NULL);
                                    else
                                            result = grab_blob(opt->repo, &oid, elem->mode,
                                                            &result_size, NULL, NULL);
                            } else if (textconv) {
                                    struct diff_filespec *df = alloc_filespec(elem->path);
                                    fill_filespec(df, null_oid(), 0, st.st_mode);
                                    result_size = fill_textconv(opt->repo, textconv, df, &result);
                                    free_filespec(df);
                            } else if (0 <= (fd = open(elem->path, O_RDONLY))) {
                                    size_t len = xsize_t(st.st_size);
                                    ssize_t done;
                                    int is_file, i;

            #ifdef __MVS__
            __disableautocvt(fd);
            #endif

                                    elem->mode = canon_mode(st.st_mode);
                                    /* if symlinks don't work, assume symlink if all parents
                                    * are symlinks
                                    */
                                    is_file = has_symlinks;
                                    for (i = 0; !is_file && i < num_parent; i++)
                                            is_file = !S_ISLNK(elem->parent[i].mode);
                                    if (!is_file)
                                            elem->mode = canon_mode(S_IFLNK);

                                    result_size = len;
                                    result = xmallocz(len);

                                    done = read_in_full(fd, result, len);
                                    if (done < 0)
                                            die_errno("read error '%s'", elem->path);
                                    else if (done < len)
                                            die("early EOF '%s'", elem->path);

                                    /* If not a fake symlink, apply filters, e.g. autocrlf */
                                    if (is_file) {
                                            struct strbuf buf = STRBUF_INIT;

                                            if (convert_to_git(rev->diffopt.repo->index,
                                                            elem->path, result, len, &buf, global_conv_flags_eol)) {
                                                    free(result);
                                                    result = strbuf_detach(&buf, &len);
                                                    result_size = len;
                                            }
                                    }
                            }
                            else {
                            deleted_file:
                                    result_deleted = 1;
                                    result_size = 0;
                                    elem->mode = 0;
                                    result = xcalloc(1, 1);
                            }

                            if (0 <= fd)
                                    close(fd);
                    }

                    for (i = 0; i < num_parent; i++) {
                            if (elem->parent[i].mode != elem->mode) {
                                    mode_differs = 1;
                                    break;
                            }
                    }

                    if (textconv)
                            is_binary = 0;
                    else if (userdiff->binary != -1)
                            is_binary = userdiff->binary;
                    else {
                            is_binary = buffer_is_binary(result, result_size);
                            for (i = 0; !is_binary && i < num_parent; i++) {
                                    char *buf;
                                    unsigned long size;
                                    buf = grab_blob(opt->repo,
                                                    &elem->parent[i].oid,
                                                    elem->parent[i].mode,
                                                    &size, NULL, NULL);
                                    if (buffer_is_binary(buf, size))
                                            is_binary = 1;
                                    free(buf);
                            }
                    }
                    if (is_binary) {
                            show_combined_header(elem, num_parent, rev,
                                            line_prefix, mode_differs, 0);
                            printf("Binary files differ\n");
                            free(result);
                            return;
                    }

                    for (cnt = 0, cp = result; cp < result + result_size; cp++) {
                            if (*cp == '\n')
                                    cnt++;
                    }
                    if (result_size && result[result_size-1] != '\n')
                            cnt++; /* incomplete line */

                    CALLOC_ARRAY(sline, st_add(cnt, 2));
                    sline[0].bol = result;
                    for (lno = 0, cp = result; cp < result + result_size; cp++) {
                            if (*cp == '\n') {
                                    sline[lno].len = cp - sline[lno].bol;
                                    lno++;
                                    if (lno < cnt)
                                            sline[lno].bol = cp + 1;
                            }
                    }
                    if (result_size && result[result_size-1] != '\n')
                            sline[cnt-1].len = result_size - (sline[cnt-1].bol - result);

                    result_file.ptr = result;
                    result_file.size = result_size;

                    /*
                    * Even p_lno[cnt+1] is valid -- that is for the end line number
                    * for deletion hunk at the end.
                    */
                    CALLOC_ARRAY(sline[0].p_lno, st_mult(st_add(cnt, 2), num_parent));
                    for (lno = 0; lno <= cnt; lno++)
                            sline[lno+1].p_lno = sline[lno].p_lno + num_parent;

                    for (i = 0; i < num_parent; i++) {
                            int j;
                            for (j = 0; j < i; j++) {
                                    if (oideq(&elem->parent[i].oid,
                                            &elem->parent[j].oid)) {
                                            reuse_combine_diff(sline, cnt, i, j);
                                            break;
                                    }
                            }
                            if (i <= j)
                                    combine_diff(opt->repo,
                                            &elem->parent[i].oid,
                                            elem->parent[i].mode,
                                            &result_file, sline,
                                            cnt, i, num_parent, result_deleted,
                                            textconv, elem->path, opt->xdl_opts);
                    }

                    show_hunks = make_hunks(sline, cnt, num_parent, rev->dense_combined_merges);

                    if (show_hunks || mode_differs || working_tree_file) {
                            show_combined_header(elem, num_parent, rev,
                                            line_prefix, mode_differs, 1);
                            dump_sline(sline, line_prefix, cnt, num_parent,
                                    opt->use_color, result_deleted);
                    }
                    free(result);

                    for (lno = 0; lno < cnt + 2; lno++) {
                            if (sline[lno].lost) {
                                    struct lline *ll = sline[lno].lost;
                                    while (ll) {
                                            struct lline *tmp = ll;
                                            ll = ll->next;
                                            free(tmp);
                                    }
                            }
                    }
                    free(sline[0].p_lno);
                    free(sline);
            }

            static void show_raw_diff(struct combine_diff_path *p, int num_parent, struct rev_info *rev)
            {
                    struct diff_options *opt = &rev->diffopt;
                    int line_termination, inter_name_termination, i;
                    const char *line_prefix = diff_line_prefix(opt);

                    line_termination = opt->line_termination;
                    inter_name_termination = '\t';
                    if (!line_termination)
                            inter_name_termination = 0;

                    if (rev->loginfo && !rev->no_commit_id)
                            show_log(rev);


                    if (opt->output_format & DIFF_FORMAT_RAW) {
                            printf("%s", line_prefix);

                            /* As many colons as there are parents */
                            for (i = 0; i < num_parent; i++)
                                    putchar(':');

                            /* Show the modes */
                            for (i = 0; i < num_parent; i++)
                                    printf("%06o ", p->parent[i].mode);
                            printf("%06o", p->mode);

                            /* Show sha1's */
                            for (i = 0; i < num_parent; i++)
                                    printf(" %s", diff_aligned_abbrev(&p->parent[i].oid,
                                                                    opt->abbrev));
                            printf(" %s ", diff_aligned_abbrev(&p->oid, opt->abbrev));
                    }

                    if (opt->output_format & (DIFF_FORMAT_RAW | DIFF_FORMAT_NAME_STATUS)) {
                            for (i = 0; i < num_parent; i++)
                                    putchar(p->parent[i].status);
                            putchar(inter_name_termination);
                    }

                    for (i = 0; i < num_parent; i++)
                            if (rev->combined_all_paths) {
                                    if (filename_changed(p->parent[i].status))
                                            write_name_quoted(p->parent[i].path.buf, stdout,
                                                            inter_name_termination);
                                    else
                                            write_name_quoted(p->path, stdout,
                                                            inter_name_termination);
                            }
                    write_name_quoted(p->path, stdout, line_termination);
            }

            /*
            * The result (p->elem) is from the working tree and their
            * parents are typically from multiple stages during a merge
            * (i.e. diff-files) or the state in HEAD and in the index
            * (i.e. diff-index).
            */
            void show_combined_diff(struct combine_diff_path *p,
                            int num_parent,
                            struct rev_info *rev)
            {
                    struct diff_options *opt = &rev->diffopt;

                    if (opt->output_format & (DIFF_FORMAT_RAW |
                                            DIFF_FORMAT_NAME |
                                            DIFF_FORMAT_NAME_STATUS))
                            show_raw_diff(p, num_parent, rev);
                    else if (opt->output_format & DIFF_FORMAT_PATCH)
                            show_patch_diff(p, num_parent, 1, rev);
            }

            static void free_combined_pair(struct diff_filepair *pair)
            {
                    free(pair->two);
                    free(pair);
            }

            /*
            * A combine_diff_path expresses N parents on the LHS against 1 merge
            * result. Synthesize a diff_filepair that has N entries on the "one"
            * side and 1 entry on the "two" side.
            *
            * In the future, we might want to add more data to combine_diff_path
            * so that we can fill fields we are ignoring (most notably, size) here,
            * but currently nobody uses it, so this should suffice for now.
            */
            static struct diff_filepair *combined_pair(struct combine_diff_path *p,
                                                    int num_parent)
            {
                    int i;
                    struct diff_filepair *pair;
                    struct diff_filespec *pool;

                    pair = xmalloc(sizeof(*pair));
                    CALLOC_ARRAY(pool, st_add(num_parent, 1));
                    pair->one = pool + 1;
                    pair->two = pool;

                    for (i = 0; i < num_parent; i++) {
                            pair->one[i].path = p->path;
                            pair->one[i].mode = p->parent[i].mode;
                            oidcpy(&pair->one[i].oid, &p->parent[i].oid);
                            pair->one[i].oid_valid = !is_null_oid(&p->parent[i].oid);
                            pair->one[i].has_more_entries = 1;
                    }
                    pair->one[num_parent - 1].has_more_entries = 0;

                    pair->two->path = p->path;
                    pair->two->mode = p->mode;
                    oidcpy(&pair->two->oid, &p->oid);
                    pair->two->oid_valid = !is_null_oid(&p->oid);
                    return pair;
            }

            static void handle_combined_callback(struct diff_options *opt,
                                            struct combine_diff_path *paths,
                                            int num_parent,
                                            int num_paths)
            {
                    struct combine_diff_path *p;
                    struct diff_queue_struct q;
                    int i;

                    CALLOC_ARRAY(q.queue, num_paths);
                    q.alloc = num_paths;
                    q.nr = num_paths;
                    for (i = 0, p = paths; p; p = p->next)
                            q.queue[i++] = combined_pair(p, num_parent);
                    opt->format_callback(&q, opt, opt->format_callback_data);
                    for (i = 0; i < num_paths; i++)
                            free_combined_pair(q.queue[i]);
                    free(q.queue);
            }

            static const char *path_path(void *obj)
            {
                    struct combine_diff_path *path = (struct combine_diff_path *)obj;

                    return path->path;
            }

            /*
            * Diff stat formats which we always compute solely against the first parent.
            */
            #define STAT_FORMAT_MASK (DIFF_FORMAT_NUMSTAT \
                                    | DIFF_FORMAT_SHORTSTAT \
                                    | DIFF_FORMAT_SUMMARY \
                                    | DIFF_FORMAT_DIRSTAT \
                                    | DIFF_FORMAT_DIFFSTAT)

            /* find set of paths that every parent touches */
            static struct combine_diff_path *find_paths_generic(const struct object_id *oid,
                    const struct oid_array *parents,
                    struct diff_options *opt,
                    int combined_all_paths)
            {
                    struct combine_diff_path *paths = NULL;
                    int i, num_parent = parents->nr;
                    int output_format = opt->output_format;
                    char *orderfile = opt->orderfile;

                    opt->output_format = DIFF_FORMAT_NO_OUTPUT;
                    /* tell diff_tree to emit paths in sorted (=tree) order */
                    opt->orderfile = NULL;

                    /* D(A,P1...Pn) = D(A,P1) ^ ... ^ D(A,Pn)  (wrt paths) */
                    for (i = 0; i < num_parent; i++) {
                            /*
                            * show stat against the first parent even when doing
                            * combined diff.
                            */
                            int stat_opt = output_format & STAT_FORMAT_MASK;
                            if (i == 0 && stat_opt)
                                    opt->output_format = stat_opt;
                            else
                                    opt->output_format = DIFF_FORMAT_NO_OUTPUT;
                            diff_tree_oid(&parents->oid[i], oid, "", opt);
                            diffcore_std(opt);
                            paths = intersect_paths(paths, i, num_parent,
                                                    combined_all_paths);

                            /* if showing diff, show it in requested order */
                            if (opt->output_format != DIFF_FORMAT_NO_OUTPUT &&
                            orderfile) {
                                    diffcore_order(orderfile);
                            }

                            diff_flush(opt);
                    }

                    opt->output_format = output_format;
                    opt->orderfile = orderfile;
                    return paths;
            }


            /*
            * find set of paths that everybody touches, assuming diff is run without
            * rename/copy detection, etc, comparing all trees simultaneously (= faster).
            */
            static struct combine_diff_path *find_paths_multitree(
                    const struct object_id *oid, const struct oid_array *parents,
                    struct diff_options *opt)
            {
                    int i, nparent = parents->nr;
                    const struct object_id **parents_oid;
                    struct combine_diff_path paths_head;
                    struct strbuf base;

                    ALLOC_ARRAY(parents_oid, nparent);
                    for (i = 0; i < nparent; i++)
                            parents_oid[i] = &parents->oid[i];

                    /* fake list head, so worker can assume it is non-NULL */
                    paths_head.next = NULL;

                    strbuf_init(&base, PATH_MAX);
                    diff_tree_paths(&paths_head, oid, parents_oid, nparent, &base, opt);

                    strbuf_release(&base);
                    free(parents_oid);
                    return paths_head.next;
            }

            static int match_objfind(struct combine_diff_path *path,
                                    int num_parent,
                                    const struct oidset *set)
            {
                    int i;
                    if (oidset_contains(set, &path->oid))
                            return 1;
                    for (i = 0; i < num_parent; i++) {
                            if (oidset_contains(set, &path->parent[i].oid))
                                    return 1;
                    }
                    return 0;
            }

            static struct combine_diff_path *combined_objfind(struct diff_options *opt,
                                                            struct combine_diff_path *paths,
                                                            int num_parent)
            {
                    struct combine_diff_path *ret = NULL, **tail = &ret;
                    struct combine_diff_path *p = paths;

                    while (p) {
                            struct combine_diff_path *next = p->next;

                            if (match_objfind(p, num_parent, opt->objfind)) {
                                    p->next = NULL;
                                    *tail = p;
                                    tail = &p->next;
                            } else {
                                    free(p);
                            }
                            p = next;
                    }

                    return ret;
            }

            void diff_tree_combined(const struct object_id *oid,
                                    const struct oid_array *parents,
                                    struct rev_info *rev)
            {
                    struct diff_options *opt = &rev->diffopt;
                    struct diff_options diffopts;
                    struct combine_diff_path *p, *paths;
                    int i, num_paths, needsep, show_log_first, num_parent = parents->nr;
                    int need_generic_pathscan;

                    if (opt->ignore_regex_nr)
                            die("combined diff and '%s' cannot be used together",
                            "--ignore-matching-lines");
                    if (opt->close_file)
                            die("combined diff and '%s' cannot be used together",
                            "--output");

                    /* nothing to do, if no parents */
                    if (!num_parent)
                            return;

                    show_log_first = !!rev->loginfo && !rev->no_commit_id;
                    needsep = 0;
                    if (show_log_first) {
                            show_log(rev);

                            if (rev->verbose_header && opt->output_format &&
                            opt->output_format != DIFF_FORMAT_NO_OUTPUT &&
                            !commit_format_is_empty(rev->commit_format))
                                    printf("%s%c", diff_line_prefix(opt),
                                    opt->line_termination);
                    }

                    diffopts = *opt;
                    copy_pathspec(&diffopts.pathspec, &opt->pathspec);
                    diffopts.flags.recursive = 1;
                    diffopts.flags.allow_external = 0;

                    /* find set of paths that everybody touches
                    *
                    * NOTE
                    *
                    * Diffcore transformations are bound to diff_filespec and logic
                    * comparing two entries - i.e. they do not apply directly to combine
                    * diff.
                    *
                    * If some of such transformations is requested - we launch generic
                    * path scanning, which works significantly slower compared to
                    * simultaneous all-trees-in-one-go scan in find_paths_multitree().
                    *
                    * TODO some of the filters could be ported to work on
                    * combine_diff_paths - i.e. all functionality that skips paths, so in
                    * theory, we could end up having only multitree path scanning.
                    *
                    * NOTE please keep this semantically in sync with diffcore_std()
                    */
                    need_generic_pathscan = opt->skip_stat_unmatch  ||
                                    opt->flags.follow_renames       ||
                                    opt->break_opt != -1    ||
                                    opt->detect_rename      ||
                                    (opt->pickaxe_opts &
                                    (DIFF_PICKAXE_KINDS_MASK & ~DIFF_PICKAXE_KIND_OBJFIND)) ||
                                    opt->filter;

                    if (need_generic_pathscan) {
                            /*
                            * NOTE generic case also handles --stat, as it computes
                            * diff(sha1,parent_i) for all i to do the job, specifically
                            * for parent0.
                            */
                            paths = find_paths_generic(oid, parents, &diffopts,
                                                    rev->combined_all_paths);
                    }
                    else {
                            int stat_opt;
                            paths = find_paths_multitree(oid, parents, &diffopts);

                            if (opt->pickaxe_opts & DIFF_PICKAXE_KIND_OBJFIND)
                                    paths = combined_objfind(opt, paths, num_parent);

                            /*
                            * show stat against the first parent even
                            * when doing combined diff.
                            */
                            stat_opt = opt->output_format & STAT_FORMAT_MASK;
                            if (stat_opt) {
                                    diffopts.output_format = stat_opt;

                                    diff_tree_oid(&parents->oid[0], oid, "", &diffopts);
                                    diffcore_std(&diffopts);
                                    if (opt->orderfile)
                                            diffcore_order(opt->orderfile);
                                    diff_flush(&diffopts);
                            }
                    }

                    /* find out number of surviving paths */
                    for (num_paths = 0, p = paths; p; p = p->next)
                            num_paths++;

                    /* order paths according to diffcore_order */
                    if (opt->orderfile && num_paths) {
                            struct obj_order *o;

                            ALLOC_ARRAY(o, num_paths);
                            for (i = 0, p = paths; p; p = p->next, i++)
                                    o[i].obj = p;
                            order_objects(opt->orderfile, path_path, o, num_paths);
                            for (i = 0; i < num_paths - 1; i++) {
                                    p = o[i].obj;
                                    p->next = o[i+1].obj;
                            }

                            p = o[num_paths-1].obj;
                            p->next = NULL;
                            paths = o[0].obj;
                            free(o);
                    }


                    if (num_paths) {
                            if (opt->output_format & (DIFF_FORMAT_RAW |
                                                    DIFF_FORMAT_NAME |
                                                    DIFF_FORMAT_NAME_STATUS)) {
                                    for (p = paths; p; p = p->next)
                                            show_raw_diff(p, num_parent, rev);
                                    needsep = 1;
                            }
                            else if (opt->output_format & STAT_FORMAT_MASK)
                                    needsep = 1;
                            else if (opt->output_format & DIFF_FORMAT_CALLBACK)
                                    handle_combined_callback(opt, paths, num_parent, num_paths);

                            if (opt->output_format & DIFF_FORMAT_PATCH) {
                                    if (needsep)
                                            printf("%s%c", diff_line_prefix(opt),
                                            opt->line_termination);
                                    for (p = paths; p; p = p->next)
                                            show_patch_diff(p, num_parent, 0, rev);
                            }
                    }

                    /* Clean things up */
                    while (paths) {
                            struct combine_diff_path *tmp = paths;
                            paths = paths->next;
                            for (i = 0; i < num_parent; i++)
                                    if (rev->combined_all_paths &&
                                    filename_changed(tmp->parent[i].status))
                                            strbuf_release(&tmp->parent[i].path);
                            free(tmp);
                    }

                    clear_pathspec(&diffopts.pathspec);
            }

            void diff_tree_combined_merge(const struct commit *commit,
                                    struct rev_info *rev)
            {
                    struct commit_list *parent = get_saved_parents(rev, commit);
                    struct oid_array parents = OID_ARRAY_INIT;

                    while (parent) {
                            oid_array_append(&parents, &parent->item->object.oid);
                            parent = parent->next;
                    }
                    diff_tree_combined(&commit->object.oid, &parents, rev);
                    oid_array_clear(&parents);
            }
        """,
        "Patche":
        """
                    diff --git a/combine-diff.c b/combine-diff.c
            index b0ece95..9e5ed73 100644
            --- a/combine-diff.c
            +++ b/combine-diff.c
            @@ -1077,6 +1077,10 @@ static void show_patch_diff(struct combine_diff_path *elem, int num_parent,
                                    ssize_t done;
                                    int is_file, i;

            +#ifdef __MVS__
            +      __disableautocvt(fd);
            +#endif
            +
                                    elem->mode = canon_mode(st.st_mode);
                                    /* if symlinks don't work, assume symlink if all parents
                                    * are symlinks
        """,

    },

    {

        "wrongCode":
        """
                    /*
            * GIT - The information manager from hell
            *
            * Copyright (C) Linus Torvalds, 2005
            * Copyright (C) Johannes Schindelin, 2005
            *
            */

            #define USE_THE_REPOSITORY_VARIABLE
            #define DISABLE_SIGN_COMPARE_WARNINGS

            #include "git-compat-util.h"
            #include "abspath.h"
            #include "advice.h"
            #include "date.h"
            #include "branch.h"
            #include "config.h"
            #include "parse.h"
            #include "convert.h"
            #include "environment.h"
            #include "gettext.h"
            #include "ident.h"
            #include "repository.h"
            #include "lockfile.h"
            #include "mailmap.h"
            #include "attr.h"
            #include "exec-cmd.h"
            #include "strbuf.h"
            #include "quote.h"
            #include "hashmap.h"
            #include "string-list.h"
            #include "object-name.h"
            #include "object-store-ll.h"
            #include "pager.h"
            #include "path.h"
            #include "utf8.h"
            #include "color.h"
            #include "refs.h"
            #include "setup.h"
            #include "strvec.h"
            #include "trace2.h"
            #include "wildmatch.h"
            #include "ws.h"
            #include "write-or-die.h"

            struct config_source {
                    struct config_source *prev;
                    union {
                            FILE *file;
                            struct config_buf {
                                    const char *buf;
                                    size_t len;
                                    size_t pos;
                            } buf;
                    } u;
                    enum config_origin_type origin_type;
                    const char *name;
                    const char *path;
                    enum config_error_action default_error_action;
                    int linenr;
                    int eof;
                    size_t total_len;
                    struct strbuf value;
                    struct strbuf var;
                    unsigned subsection_case_sensitive : 1;

                    int (*do_fgetc)(struct config_source *c);
                    int (*do_ungetc)(int c, struct config_source *conf);
                    long (*do_ftell)(struct config_source *c);
            };
            #define CONFIG_SOURCE_INIT { 0 }

            static int pack_compression_seen;
            static int zlib_compression_seen;

            /*
            * Config that comes from trusted scopes, namely:
            * - CONFIG_SCOPE_SYSTEM (e.g. /etc/gitconfig)
            * - CONFIG_SCOPE_GLOBAL (e.g. $HOME/.gitconfig, $XDG_CONFIG_HOME/git)
            * - CONFIG_SCOPE_COMMAND (e.g. "-c" option, environment variables)
            *
            * This is declared here for code cleanliness, but unlike the other
            * static variables, this does not hold config parser state.
            */
            static struct config_set protected_config;

            static int config_file_fgetc(struct config_source *conf)
            {
                    return getc_unlocked(conf->u.file);
            }

            static int config_file_ungetc(int c, struct config_source *conf)
            {
                    return ungetc(c, conf->u.file);
            }

            static long config_file_ftell(struct config_source *conf)
            {
                    return ftell(conf->u.file);
            }

            static int config_buf_fgetc(struct config_source *conf)
            {
                    if (conf->u.buf.pos < conf->u.buf.len)
                            return conf->u.buf.buf[conf->u.buf.pos++];

                    return EOF;
            }

            static int config_buf_ungetc(int c, struct config_source *conf)
            {
                    if (conf->u.buf.pos > 0) {
                            conf->u.buf.pos--;
                            if (conf->u.buf.buf[conf->u.buf.pos] != c)
                                    BUG("config_buf can only ungetc the same character");
                            return c;
                    }

                    return EOF;
            }

            static long config_buf_ftell(struct config_source *conf)
            {
                    return conf->u.buf.pos;
            }

            struct config_include_data {
                    int depth;
                    config_fn_t fn;
                    void *data;
                    const struct config_options *opts;
                    const struct git_config_source *config_source;
                    struct repository *repo;

                    /*
                    * All remote URLs discovered when reading all config files.
                    */
                    struct string_list *remote_urls;
            };
            #define CONFIG_INCLUDE_INIT { 0 }

            static int git_config_include(const char *var, const char *value,
                                    const struct config_context *ctx, void *data);

            #define MAX_INCLUDE_DEPTH 10
            static const char include_depth_advice[] = N_(
            "exceeded maximum include depth (%d) while including\n"
            "       %s\n"
            "from\n"
            "       %s\n"
            "This might be due to circular includes.");
            static int handle_path_include(const struct key_value_info *kvi,
                                    const char *path,
                                    struct config_include_data *inc)
            {
                    int ret = 0;
                    struct strbuf buf = STRBUF_INIT;
                    char *expanded;

                    if (!path)
                            return config_error_nonbool("include.path");

                    expanded = interpolate_path(path, 0);
                    if (!expanded)
                            return error(_("could not expand include path '%s'"), path);
                    path = expanded;

                    /*
                    * Use an absolute path as-is, but interpret relative paths
                    * based on the including config file.
                    */
                    if (!is_absolute_path(path)) {
                            char *slash;

                            if (!kvi || !kvi->path) {
                                    ret = error(_("relative config includes must come from files"));
                                    goto cleanup;
                            }

                            slash = find_last_dir_sep(kvi->path);
                            if (slash)
                                    strbuf_add(&buf, kvi->path, slash - kvi->path + 1);
                            strbuf_addstr(&buf, path);
                            path = buf.buf;
                    }

                    if (!access_or_die(path, R_OK, 0)) {
                            if (++inc->depth > MAX_INCLUDE_DEPTH)
                                    die(_(include_depth_advice), MAX_INCLUDE_DEPTH, path,
                                    !kvi ? "<unknown>" :
                                    kvi->filename ? kvi->filename :
                                    "the command line");
                            ret = git_config_from_file_with_options(git_config_include, path, inc,
                                                                    kvi->scope, NULL);
                            inc->depth--;
                    }
            cleanup:
                    strbuf_release(&buf);
                    free(expanded);
                    return ret;
            }

            static void add_trailing_starstar_for_dir(struct strbuf *pat)
            {
                    if (pat->len && is_dir_sep(pat->buf[pat->len - 1]))
                            strbuf_addstr(pat, "**");
            }

            static int prepare_include_condition_pattern(const struct key_value_info *kvi,
                                                    struct strbuf *pat)
            {
                    struct strbuf path = STRBUF_INIT;
                    char *expanded;
                    int prefix = 0;

                    expanded = interpolate_path(pat->buf, 1);
                    if (expanded) {
                            strbuf_reset(pat);
                            strbuf_addstr(pat, expanded);
                            free(expanded);
                    }

                    if (pat->buf[0] == '.' && is_dir_sep(pat->buf[1])) {
                            const char *slash;

                            if (!kvi || !kvi->path)
                                    return error(_("relative config include "
                                            "conditionals must come from files"));

                            strbuf_realpath(&path, kvi->path, 1);
                            slash = find_last_dir_sep(path.buf);
                            if (!slash)
                                    BUG("how is this possible?");
                            strbuf_splice(pat, 0, 1, path.buf, slash - path.buf);
                            prefix = slash - path.buf + 1 /* slash */;
                    } else if (!is_absolute_path(pat->buf))
                            strbuf_insertstr(pat, 0, "**/");

                    add_trailing_starstar_for_dir(pat);

                    strbuf_release(&path);
                    return prefix;
            }

            static int include_by_gitdir(const struct key_value_info *kvi,
                                    const struct config_options *opts,
                                    const char *cond, size_t cond_len, int icase)
            {
                    struct strbuf text = STRBUF_INIT;
                    struct strbuf pattern = STRBUF_INIT;
                    int ret = 0, prefix;
                    const char *git_dir;
                    int already_tried_absolute = 0;

                    if (opts->git_dir)
                            git_dir = opts->git_dir;
                    else
                            goto done;

                    strbuf_realpath(&text, git_dir, 1);
                    strbuf_add(&pattern, cond, cond_len);
                    prefix = prepare_include_condition_pattern(kvi, &pattern);

            again:
                    if (prefix < 0)
                            goto done;

                    if (prefix > 0) {
                            /*
                            * perform literal matching on the prefix part so that
                            * any wildcard character in it can't create side effects.
                            */
                            if (text.len < prefix)
                                    goto done;
                            if (!icase && strncmp(pattern.buf, text.buf, prefix))
                                    goto done;
                            if (icase && strncasecmp(pattern.buf, text.buf, prefix))
                                    goto done;
                    }

                    ret = !wildmatch(pattern.buf + prefix, text.buf + prefix,
                                    WM_PATHNAME | (icase ? WM_CASEFOLD : 0));

                    if (!ret && !already_tried_absolute) {
                            /*
                            * We've tried e.g. matching gitdir:~/work, but if
                            * ~/work is a symlink to /mnt/storage/work
                            * strbuf_realpath() will expand it, so the rule won't
                            * match. Let's match against a
                            * strbuf_add_absolute_path() version of the path,
                            * which'll do the right thing
                            */
                            strbuf_reset(&text);
                            strbuf_add_absolute_path(&text, git_dir);
                            already_tried_absolute = 1;
                            goto again;
                    }
            done:
                    strbuf_release(&pattern);
                    strbuf_release(&text);
                    return ret;
            }

            static int include_by_branch(struct config_include_data *data,
                                    const char *cond, size_t cond_len)
            {
                    int flags;
                    int ret;
                    struct strbuf pattern = STRBUF_INIT;
                    const char *refname, *shortname;

                    if (!data->repo || data->repo->ref_storage_format == REF_STORAGE_FORMAT_UNKNOWN)
                            return 0;

                    refname = refs_resolve_ref_unsafe(get_main_ref_store(data->repo),
                                                    "HEAD", 0, NULL, &flags);
                    if (!refname ||
                    !(flags & REF_ISSYMREF) ||
                    !skip_prefix(refname, "refs/heads/", &shortname))
                            return 0;

                    strbuf_add(&pattern, cond, cond_len);
                    add_trailing_starstar_for_dir(&pattern);
                    ret = !wildmatch(pattern.buf, shortname, WM_PATHNAME);
                    strbuf_release(&pattern);
                    return ret;
            }

            static int add_remote_url(const char *var, const char *value,
                                    const struct config_context *ctx UNUSED, void *data)
            {
                    struct string_list *remote_urls = data;
                    const char *remote_name;
                    size_t remote_name_len;
                    const char *key;

                    if (!parse_config_key(var, "remote", &remote_name, &remote_name_len,
                                    &key) &&
                    remote_name &&
                    !strcmp(key, "url"))
                            string_list_append(remote_urls, value);
                    return 0;
            }

            static void populate_remote_urls(struct config_include_data *inc)
            {
                    struct config_options opts;

                    opts = *inc->opts;
                    opts.unconditional_remote_url = 1;

                    inc->remote_urls = xmalloc(sizeof(*inc->remote_urls));
                    string_list_init_dup(inc->remote_urls);
                    config_with_options(add_remote_url, inc->remote_urls,
                                    inc->config_source, inc->repo, &opts);
            }

            static int forbid_remote_url(const char *var, const char *value UNUSED,
                                    const struct config_context *ctx UNUSED,
                                    void *data UNUSED)
            {
                    const char *remote_name;
                    size_t remote_name_len;
                    const char *key;

                    if (!parse_config_key(var, "remote", &remote_name, &remote_name_len,
                                    &key) &&
                    remote_name &&
                    !strcmp(key, "url"))
                            die(_("remote URLs cannot be configured in file directly or indirectly included by includeIf.hasconfig:remote.*.url"));
                    return 0;
            }

            static int at_least_one_url_matches_glob(const char *glob, int glob_len,
                                                    struct string_list *remote_urls)
            {
                    struct strbuf pattern = STRBUF_INIT;
                    struct string_list_item *url_item;
                    int found = 0;

                    strbuf_add(&pattern, glob, glob_len);
                    for_each_string_list_item(url_item, remote_urls) {
                            if (!wildmatch(pattern.buf, url_item->string, WM_PATHNAME)) {
                                    found = 1;
                                    break;
                            }
                    }
                    strbuf_release(&pattern);
                    return found;
            }

            static int include_by_remote_url(struct config_include_data *inc,
                            const char *cond, size_t cond_len)
            {
                    if (inc->opts->unconditional_remote_url)
                            return 1;
                    if (!inc->remote_urls)
                            populate_remote_urls(inc);
                    return at_least_one_url_matches_glob(cond, cond_len,
                                                    inc->remote_urls);
            }

            static int include_condition_is_true(const struct key_value_info *kvi,
                                            struct config_include_data *inc,
                                            const char *cond, size_t cond_len)
            {
                    const struct config_options *opts = inc->opts;

                    if (skip_prefix_mem(cond, cond_len, "gitdir:", &cond, &cond_len))
                            return include_by_gitdir(kvi, opts, cond, cond_len, 0);
                    else if (skip_prefix_mem(cond, cond_len, "gitdir/i:", &cond, &cond_len))
                            return include_by_gitdir(kvi, opts, cond, cond_len, 1);
                    else if (skip_prefix_mem(cond, cond_len, "onbranch:", &cond, &cond_len))
                            return include_by_branch(inc, cond, cond_len);
                    else if (skip_prefix_mem(cond, cond_len, "hasconfig:remote.*.url:", &cond,
                                            &cond_len))
                            return include_by_remote_url(inc, cond, cond_len);

                    /* unknown conditionals are always false */
                    return 0;
            }

            static int git_config_include(const char *var, const char *value,
                                    const struct config_context *ctx,
                                    void *data)
            {
                    struct config_include_data *inc = data;
                    const char *cond, *key;
                    size_t cond_len;
                    int ret;

                    /*
                    * Pass along all values, including "include" directives; this makes it
                    * possible to query information on the includes themselves.
                    */
                    ret = inc->fn(var, value, ctx, inc->data);
                    if (ret < 0)
                            return ret;

                    if (!strcmp(var, "include.path"))
                            ret = handle_path_include(ctx->kvi, value, inc);

                    if (!parse_config_key(var, "includeif", &cond, &cond_len, &key) &&
                    cond && include_condition_is_true(ctx->kvi, inc, cond, cond_len) &&
                    !strcmp(key, "path")) {
                            config_fn_t old_fn = inc->fn;

                            if (inc->opts->unconditional_remote_url)
                                    inc->fn = forbid_remote_url;
                            ret = handle_path_include(ctx->kvi, value, inc);
                            inc->fn = old_fn;
                    }

                    return ret;
            }

            static void git_config_push_split_parameter(const char *key, const char *value)
            {
                    struct strbuf env = STRBUF_INIT;
                    const char *old = getenv(CONFIG_DATA_ENVIRONMENT);
                    if (old && *old) {
                            strbuf_addstr(&env, old);
                            strbuf_addch(&env, ' ');
                    }
                    sq_quote_buf(&env, key);
                    strbuf_addch(&env, '=');
                    if (value)
                            sq_quote_buf(&env, value);
                    setenv(CONFIG_DATA_ENVIRONMENT, env.buf, 1);
                    strbuf_release(&env);
            }

            void git_config_push_parameter(const char *text)
            {
                    const char *value;

                    /*
                    * When we see:
                    *
                    *   section.subsection=with=equals.key=value
                    *
                    * we cannot tell if it means:
                    *
                    *   [section "subsection=with=equals"]
                    *   key = value
                    *
                    * or:
                    *
                    *   [section]
                    *   subsection = with=equals.key=value
                    *
                    * We parse left-to-right for the first "=", meaning we'll prefer to
                    * keep the value intact over the subsection. This is historical, but
                    * also sensible since values are more likely to contain odd or
                    * untrusted input than a section name.
                    *
                    * A missing equals is explicitly allowed (as a bool-only entry).
                    */
                    value = strchr(text, '=');
                    if (value) {
                            char *key = xmemdupz(text, value - text);
                            git_config_push_split_parameter(key, value + 1);
                            free(key);
                    } else {
                            git_config_push_split_parameter(text, NULL);
                    }
            }

            void git_config_push_env(const char *spec)
            {
                    char *key;
                    const char *env_name;
                    const char *env_value;

                    env_name = strrchr(spec, '=');
                    if (!env_name)
                            die(_("invalid config format: %s"), spec);
                    key = xmemdupz(spec, env_name - spec);
                    env_name++;
                    if (!*env_name)
                            die(_("missing environment variable name for configuration '%.*s'"),
                            (int)(env_name - spec - 1), spec);

                    env_value = getenv(env_name);
                    if (!env_value)
                            die(_("missing environment variable '%s' for configuration '%.*s'"),
                            env_name, (int)(env_name - spec - 1), spec);

                    git_config_push_split_parameter(key, env_value);
                    free(key);
            }

            static inline int iskeychar(int c)
            {
                    return isalnum(c) || c == '-';
            }

            /*
            * Auxiliary function to sanity-check and split the key into the section
            * identifier and variable name.
            *
            * Returns 0 on success, -1 when there is an invalid character in the key and
            * -2 if there is no section name in the key.
            *
            * store_key - pointer to char* which will hold a copy of the key with
            *             lowercase section and variable name
            * baselen - pointer to size_t which will hold the length of the
            *           section + subsection part, can be NULL
            */
            int git_config_parse_key(const char *key, char **store_key, size_t *baselen_)
            {
                    size_t i, baselen;
                    int dot;
                    const char *last_dot = strrchr(key, '.');

                    /*
                    * Since "key" actually contains the section name and the real
                    * key name separated by a dot, we have to know where the dot is.
                    */

                    if (last_dot == NULL || last_dot == key) {
                            error(_("key does not contain a section: %s"), key);
                            return -CONFIG_NO_SECTION_OR_NAME;
                    }

                    if (!last_dot[1]) {
                            error(_("key does not contain variable name: %s"), key);
                            return -CONFIG_NO_SECTION_OR_NAME;
                    }

                    baselen = last_dot - key;
                    if (baselen_)
                            *baselen_ = baselen;

                    /*
                    * Validate the key and while at it, lower case it for matching.
                    */
                    *store_key = xmallocz(strlen(key));

                    dot = 0;
                    for (i = 0; key[i]; i++) {
                            unsigned char c = key[i];
                            if (c == '.')
                                    dot = 1;
                            /* Leave the extended basename untouched.. */
                            if (!dot || i > baselen) {
                                    if (!iskeychar(c) ||
                                    (i == baselen + 1 && !isalpha(c))) {
                                            error(_("invalid key: %s"), key);
                                            goto out_free_ret_1;
                                    }
                                    c = tolower(c);
                            } else if (c == '\n') {
                                    error(_("invalid key (newline): %s"), key);
                                    goto out_free_ret_1;
                            }
                            (*store_key)[i] = c;
                    }

                    return 0;

            out_free_ret_1:
                    FREE_AND_NULL(*store_key);
                    return -CONFIG_INVALID_KEY;
            }

            static int config_parse_pair(const char *key, const char *value,
                                    struct key_value_info *kvi,
                                    config_fn_t fn, void *data)
            {
                    char *canonical_name;
                    int ret;
                    struct config_context ctx = {
                            .kvi = kvi,
                    };

                    if (!strlen(key))
                            return error(_("empty config key"));
                    if (git_config_parse_key(key, &canonical_name, NULL))
                            return -1;

                    ret = (fn(canonical_name, value, &ctx, data) < 0) ? -1 : 0;
                    free(canonical_name);
                    return ret;
            }


            /* for values read from `git_config_from_parameters()` */
            void kvi_from_param(struct key_value_info *out)
            {
                    out->filename = NULL;
                    out->linenr = -1;
                    out->origin_type = CONFIG_ORIGIN_CMDLINE;
                    out->scope = CONFIG_SCOPE_COMMAND;
                    out->path = NULL;
            }

            int git_config_parse_parameter(const char *text,
                                    config_fn_t fn, void *data)
            {
                    const char *value;
                    struct strbuf **pair;
                    int ret;
                    struct key_value_info kvi = KVI_INIT;

                    kvi_from_param(&kvi);

                    pair = strbuf_split_str(text, '=', 2);
                    if (!pair[0])
                            return error(_("bogus config parameter: %s"), text);

                    if (pair[0]->len && pair[0]->buf[pair[0]->len - 1] == '=') {
                            strbuf_setlen(pair[0], pair[0]->len - 1);
                            value = pair[1] ? pair[1]->buf : "";
                    } else {
                            value = NULL;
                    }

                    strbuf_trim(pair[0]);
                    if (!pair[0]->len) {
                            strbuf_list_free(pair);
                            return error(_("bogus config parameter: %s"), text);
                    }

                    ret = config_parse_pair(pair[0]->buf, value, &kvi, fn, data);
                    strbuf_list_free(pair);
                    return ret;
            }

            static int parse_config_env_list(char *env, struct key_value_info *kvi,
                                            config_fn_t fn, void *data)
            {
                    char *cur = env;
                    while (cur && *cur) {
                            const char *key = sq_dequote_step(cur, &cur);
                            if (!key)
                                    return error(_("bogus format in %s"),
                                            CONFIG_DATA_ENVIRONMENT);

                            if (!cur || isspace(*cur)) {
                                    /* old-style 'key=value' */
                                    if (git_config_parse_parameter(key, fn, data) < 0)
                                            return -1;
                            }
                            else if (*cur == '=') {
                                    /* new-style 'key'='value' */
                                    const char *value;

                                    cur++;
                                    if (*cur == '\'') {
                                            /* quoted value */
                                            value = sq_dequote_step(cur, &cur);
                                            if (!value || (cur && !isspace(*cur))) {
                                                    return error(_("bogus format in %s"),
                                                            CONFIG_DATA_ENVIRONMENT);
                                            }
                                    } else if (!*cur || isspace(*cur)) {
                                            /* implicit bool: 'key'= */
                                            value = NULL;
                                    } else {
                                            return error(_("bogus format in %s"),
                                                    CONFIG_DATA_ENVIRONMENT);
                                    }

                                    if (config_parse_pair(key, value, kvi, fn, data) < 0)
                                            return -1;
                            }
                            else {
                                    /* unknown format */
                                    return error(_("bogus format in %s"),
                                            CONFIG_DATA_ENVIRONMENT);
                            }

                            if (cur) {
                                    while (isspace(*cur))
                                            cur++;
                            }
                    }
                    return 0;
            }

            int git_config_from_parameters(config_fn_t fn, void *data)
            {
                    const char *env;
                    struct strbuf envvar = STRBUF_INIT;
                    struct strvec to_free = STRVEC_INIT;
                    int ret = 0;
                    char *envw = NULL;
                    struct key_value_info kvi = KVI_INIT;

                    kvi_from_param(&kvi);
                    env = getenv(CONFIG_COUNT_ENVIRONMENT);
                    if (env) {
                            unsigned long count;
                            char *endp;
                            int i;

                            count = strtoul(env, &endp, 10);
                            if (*endp) {
                                    ret = error(_("bogus count in %s"), CONFIG_COUNT_ENVIRONMENT);
                                    goto out;
                            }
                            if (count > INT_MAX) {
                                    ret = error(_("too many entries in %s"), CONFIG_COUNT_ENVIRONMENT);
                                    goto out;
                            }

                            for (i = 0; i < count; i++) {
                                    const char *key, *value;

                                    strbuf_addf(&envvar, "GIT_CONFIG_KEY_%d", i);
                                    key = getenv_safe(&to_free, envvar.buf);
                                    if (!key) {
                                            ret = error(_("missing config key %s"), envvar.buf);
                                            goto out;
                                    }
                                    strbuf_reset(&envvar);

                                    strbuf_addf(&envvar, "GIT_CONFIG_VALUE_%d", i);
                                    value = getenv_safe(&to_free, envvar.buf);
                                    if (!value) {
                                            ret = error(_("missing config value %s"), envvar.buf);
                                            goto out;
                                    }
                                    strbuf_reset(&envvar);

                                    if (config_parse_pair(key, value, &kvi, fn, data) < 0) {
                                            ret = -1;
                                            goto out;
                                    }
                            }
                    }

                    env = getenv(CONFIG_DATA_ENVIRONMENT);
                    if (env) {
                            /* sq_dequote will write over it */
                            envw = xstrdup(env);
                            if (parse_config_env_list(envw, &kvi, fn, data) < 0) {
                                    ret = -1;
                                    goto out;
                            }
                    }

            out:
                    strbuf_release(&envvar);
                    strvec_clear(&to_free);
                    free(envw);
                    return ret;
            }

            static int get_next_char(struct config_source *cs)
            {
                    int c = cs->do_fgetc(cs);

                    if (c == '\r') {
                            /* DOS like systems */
                            c = cs->do_fgetc(cs);
                            if (c != '\n') {
                                    if (c != EOF)
                                            cs->do_ungetc(c, cs);
                                    c = '\r';
                            }
                    }

                    if (c != EOF && ++cs->total_len > INT_MAX) {
                            /*
                            * This is an absurdly long config file; refuse to parse
                            * further in order to protect downstream code from integer
                            * overflows. Note that we can't return an error specifically,
                            * but we can mark EOF and put trash in the return value,
                            * which will trigger a parse error.
                            */
                            cs->eof = 1;
                            return 0;
                    }

                    if (c == '\n')
                            cs->linenr++;
                    if (c == EOF) {
                            cs->eof = 1;
                            cs->linenr++;
                            c = '\n';
                    }
                    return c;
            }

            static char *parse_value(struct config_source *cs)
            {
                    int quote = 0, comment = 0;
                    size_t trim_len = 0;

                    strbuf_reset(&cs->value);
                    for (;;) {
                            int c = get_next_char(cs);
                            if (c == '\n') {
                                    if (quote) {
                                            cs->linenr--;
                                            return NULL;
                                    }
                                    if (trim_len)
                                            strbuf_setlen(&cs->value, trim_len);
                                    return cs->value.buf;
                            }
                            if (comment)
                                    continue;
                            if (isspace(c) && !quote) {
                                    if (!trim_len)
                                            trim_len = cs->value.len;
                                    if (cs->value.len)
                                            strbuf_addch(&cs->value, c);
                                    continue;
                            }
                            if (!quote) {
                                    if (c == ';' || c == '#') {
                                            comment = 1;
                                            continue;
                                    }
                            }
                            if (trim_len)
                                    trim_len = 0;
                            if (c == '\\') {
                                    c = get_next_char(cs);
                                    switch (c) {
                                    case '\n':
                                            continue;
                                    case 't':
                                            c = '\t';
                                            break;
                                    case 'b':
                                            c = '\b';
                                            break;
                                    case 'n':
                                            c = '\n';
                                            break;
                                    /* Some characters escape as themselves */
                                    case '\\': case '"':
                                            break;
                                    /* Reject unknown escape sequences */
                                    default:
                                            return NULL;
                                    }
                                    strbuf_addch(&cs->value, c);
                                    continue;
                            }
                            if (c == '"') {
                                    quote = 1 - quote;
                                    continue;
                            }
                            strbuf_addch(&cs->value, c);
                    }
            }

            static int get_value(struct config_source *cs, struct key_value_info *kvi,
                            config_fn_t fn, void *data, struct strbuf *name)
            {
                    int c;
                    char *value;
                    int ret;
                    struct config_context ctx = {
                            .kvi = kvi,
                    };

                    /* Get the full name */
                    for (;;) {
                            c = get_next_char(cs);
                            if (cs->eof)
                                    break;
                            if (!iskeychar(c))
                                    break;
                            strbuf_addch(name, tolower(c));
                    }

                    while (c == ' ' || c == '\t')
                            c = get_next_char(cs);

                    value = NULL;
                    if (c != '\n') {
                            if (c != '=')
                                    return -1;
                            value = parse_value(cs);
                            if (!value)
                                    return -1;
                    }
                    /*
                    * We already consumed the \n, but we need linenr to point to
                    * the line we just parsed during the call to fn to get
                    * accurate line number in error messages.
                    */
                    cs->linenr--;
                    kvi->linenr = cs->linenr;
                    ret = fn(name->buf, value, &ctx, data);
                    if (ret >= 0)
                            cs->linenr++;
                    return ret;
            }

            static int get_extended_base_var(struct config_source *cs, struct strbuf *name,
                                            int c)
            {
                    cs->subsection_case_sensitive = 0;
                    do {
                            if (c == '\n')
                                    goto error_incomplete_line;
                            c = get_next_char(cs);
                    } while (isspace(c));

                    /* We require the format to be '[base "extension"]' */
                    if (c != '"')
                            return -1;
                    strbuf_addch(name, '.');

                    for (;;) {
                            int c = get_next_char(cs);
                            if (c == '\n')
                                    goto error_incomplete_line;
                            if (c == '"')
                                    break;
                            if (c == '\\') {
                                    c = get_next_char(cs);
                                    if (c == '\n')
                                            goto error_incomplete_line;
                            }
                            strbuf_addch(name, c);
                    }

                    /* Final ']' */
                    if (get_next_char(cs) != ']')
                            return -1;
                    return 0;
            error_incomplete_line:
                    cs->linenr--;
                    return -1;
            }

            static int get_base_var(struct config_source *cs, struct strbuf *name)
            {
                    cs->subsection_case_sensitive = 1;
                    for (;;) {
                            int c = get_next_char(cs);
                            if (cs->eof)
                                    return -1;
                            if (c == ']')
                                    return 0;
                            if (isspace(c))
                                    return get_extended_base_var(cs, name, c);
                            if (!iskeychar(c) && c != '.')
                                    return -1;
                            strbuf_addch(name, tolower(c));
                    }
            }

            struct parse_event_data {
                    enum config_event_t previous_type;
                    size_t previous_offset;
                    const struct config_options *opts;
            };

            static int do_event(struct config_source *cs, enum config_event_t type,
                            struct parse_event_data *data)
            {
                    size_t offset;

                    if (!data->opts || !data->opts->event_fn)
                            return 0;

                    if (type == CONFIG_EVENT_WHITESPACE &&
                    data->previous_type == type)
                            return 0;

                    offset = cs->do_ftell(cs);
                    /*
                    * At EOF, the parser always "inserts" an extra '\n', therefore
                    * the end offset of the event is the current file position, otherwise
                    * we will already have advanced to the next event.
                    */
                    if (type != CONFIG_EVENT_EOF)
                            offset--;

                    if (data->previous_type != CONFIG_EVENT_EOF &&
                    data->opts->event_fn(data->previous_type, data->previous_offset,
                                            offset, cs, data->opts->event_fn_data) < 0)
                            return -1;

                    data->previous_type = type;
                    data->previous_offset = offset;

                    return 0;
            }

            static void kvi_from_source(struct config_source *cs,
                                    enum config_scope scope,
                                    struct key_value_info *out)
            {
                    out->filename = strintern(cs->name);
                    out->origin_type = cs->origin_type;
                    out->linenr = cs->linenr;
                    out->scope = scope;
                    out->path = cs->path;
            }

            static int git_parse_source(struct config_source *cs, config_fn_t fn,
                                    struct key_value_info *kvi, void *data,
                                    const struct config_options *opts)
            {
                    int comment = 0;
                    size_t baselen = 0;
                    struct strbuf *var = &cs->var;
                    int error_return = 0;
                    char *error_msg = NULL;

                    /* U+FEFF Byte Order Mark in UTF8 */
                    const char *bomptr = utf8_bom;

                    /* For the parser event callback */
                    struct parse_event_data event_data = {
                            CONFIG_EVENT_EOF, 0, opts
                    };

                    for (;;) {
                            int c;

                            c = get_next_char(cs);
                            if (bomptr && *bomptr) {
                                    /* We are at the file beginning; skip UTF8-encoded BOM
                                    * if present. Sane editors won't put this in on their
                                    * own, but e.g. Windows Notepad will do it happily. */
                                    if (c == (*bomptr & 0377)) {
                                            bomptr++;
                                            continue;
                                    } else {
                                            /* Do not tolerate partial BOM. */
                                            if (bomptr != utf8_bom)
                                                    break;
                                            /* No BOM at file beginning. Cool. */
                                            bomptr = NULL;
                                    }
                            }
                            if (c == '\n') {
                                    if (cs->eof) {
                                            if (do_event(cs, CONFIG_EVENT_EOF, &event_data) < 0)
                                                    return -1;
                                            return 0;
                                    }
                                    if (do_event(cs, CONFIG_EVENT_WHITESPACE, &event_data) < 0)
                                            return -1;
                                    comment = 0;
                                    continue;
                            }
                            if (comment)
                                    continue;
                            if (isspace(c)) {
                                    if (do_event(cs, CONFIG_EVENT_WHITESPACE, &event_data) < 0)
                                                    return -1;
                                    continue;
                            }
                            if (c == '#' || c == ';') {
                                    if (do_event(cs, CONFIG_EVENT_COMMENT, &event_data) < 0)
                                                    return -1;
                                    comment = 1;
                                    continue;
                            }
                            if (c == '[') {
                                    if (do_event(cs, CONFIG_EVENT_SECTION, &event_data) < 0)
                                                    return -1;

                                    /* Reset prior to determining a new stem */
                                    strbuf_reset(var);
                                    if (get_base_var(cs, var) < 0 || var->len < 1)
                                            break;
                                    strbuf_addch(var, '.');
                                    baselen = var->len;
                                    continue;
                            }
                            if (!isalpha(c))
                                    break;

                            if (do_event(cs, CONFIG_EVENT_ENTRY, &event_data) < 0)
                                    return -1;

                            /*
                            * Truncate the var name back to the section header
                            * stem prior to grabbing the suffix part of the name
                            * and the value.
                            */
                            strbuf_setlen(var, baselen);
                            strbuf_addch(var, tolower(c));
                            if (get_value(cs, kvi, fn, data, var) < 0)
                                    break;
                    }

                    if (do_event(cs, CONFIG_EVENT_ERROR, &event_data) < 0)
                            return -1;

                    switch (cs->origin_type) {
                    case CONFIG_ORIGIN_BLOB:
                            error_msg = xstrfmt(_("bad config line %d in blob %s"),
                                            cs->linenr, cs->name);
                            break;
                    case CONFIG_ORIGIN_FILE:
                            error_msg = xstrfmt(_("bad config line %d in file %s"),
                                            cs->linenr, cs->name);
                            break;
                    case CONFIG_ORIGIN_STDIN:
                            error_msg = xstrfmt(_("bad config line %d in standard input"),
                                            cs->linenr);
                            break;
                    case CONFIG_ORIGIN_SUBMODULE_BLOB:
                            error_msg = xstrfmt(_("bad config line %d in submodule-blob %s"),
                                            cs->linenr, cs->name);
                            break;
                    case CONFIG_ORIGIN_CMDLINE:
                            error_msg = xstrfmt(_("bad config line %d in command line %s"),
                                            cs->linenr, cs->name);
                            break;
                    default:
                            error_msg = xstrfmt(_("bad config line %d in %s"),
                                            cs->linenr, cs->name);
                    }

                    switch (opts && opts->error_action ?
                            opts->error_action :
                            cs->default_error_action) {
                    case CONFIG_ERROR_DIE:
                            die("%s", error_msg);
                            break;
                    case CONFIG_ERROR_ERROR:
                            error_return = error("%s", error_msg);
                            break;
                    case CONFIG_ERROR_SILENT:
                            error_return = -1;
                            break;
                    case CONFIG_ERROR_UNSET:
                            BUG("config error action unset");
                    }

                    free(error_msg);
                    return error_return;
            }

            NORETURN
            static void die_bad_number(const char *name, const char *value,
                                    const struct key_value_info *kvi)
            {
                    const char *error_type = (errno == ERANGE) ?
                            N_("out of range") : N_("invalid unit");
                    const char *bad_numeric = N_("bad numeric config value '%s' for '%s': %s");

                    if (!kvi)
                            BUG("kvi should not be NULL");

                    if (!value)
                            value = "";

                    if (!kvi->filename)
                            die(_(bad_numeric), value, name, _(error_type));

                    switch (kvi->origin_type) {
                    case CONFIG_ORIGIN_BLOB:
                            die(_("bad numeric config value '%s' for '%s' in blob %s: %s"),
                            value, name, kvi->filename, _(error_type));
                    case CONFIG_ORIGIN_FILE:
                            die(_("bad numeric config value '%s' for '%s' in file %s: %s"),
                            value, name, kvi->filename, _(error_type));
                    case CONFIG_ORIGIN_STDIN:
                            die(_("bad numeric config value '%s' for '%s' in standard input: %s"),
                            value, name, _(error_type));
                    case CONFIG_ORIGIN_SUBMODULE_BLOB:
                            die(_("bad numeric config value '%s' for '%s' in submodule-blob %s: %s"),
                            value, name, kvi->filename, _(error_type));
                    case CONFIG_ORIGIN_CMDLINE:
                            die(_("bad numeric config value '%s' for '%s' in command line %s: %s"),
                            value, name, kvi->filename, _(error_type));
                    default:
                            die(_("bad numeric config value '%s' for '%s' in %s: %s"),
                            value, name, kvi->filename, _(error_type));
                    }
            }

            int git_config_int(const char *name, const char *value,
                            const struct key_value_info *kvi)
            {
                    int ret;
                    if (!git_parse_int(value, &ret))
                            die_bad_number(name, value, kvi);
                    return ret;
            }

            int64_t git_config_int64(const char *name, const char *value,
                                    const struct key_value_info *kvi)
            {
                    int64_t ret;
                    if (!git_parse_int64(value, &ret))
                            die_bad_number(name, value, kvi);
                    return ret;
            }

            unsigned long git_config_ulong(const char *name, const char *value,
                                    const struct key_value_info *kvi)
            {
                    unsigned long ret;
                    if (!git_parse_ulong(value, &ret))
                            die_bad_number(name, value, kvi);
                    return ret;
            }

            ssize_t git_config_ssize_t(const char *name, const char *value,
                                    const struct key_value_info *kvi)
            {
                    ssize_t ret;
                    if (!git_parse_ssize_t(value, &ret))
                            die_bad_number(name, value, kvi);
                    return ret;
            }

            double git_config_double(const char *name, const char *value,
                                    const struct key_value_info *kvi)
            {
                    double ret;
                    if (!git_parse_double(value, &ret))
                            die_bad_number(name, value, kvi);
                    return ret;
            }

            static const struct fsync_component_name {
                    const char *name;
                    enum fsync_component component_bits;
            } fsync_component_names[] = {
                    { "loose-object", FSYNC_COMPONENT_LOOSE_OBJECT },
                    { "pack", FSYNC_COMPONENT_PACK },
                    { "pack-metadata", FSYNC_COMPONENT_PACK_METADATA },
                    { "commit-graph", FSYNC_COMPONENT_COMMIT_GRAPH },
                    { "index", FSYNC_COMPONENT_INDEX },
                    { "objects", FSYNC_COMPONENTS_OBJECTS },
                    { "reference", FSYNC_COMPONENT_REFERENCE },
                    { "derived-metadata", FSYNC_COMPONENTS_DERIVED_METADATA },
                    { "committed", FSYNC_COMPONENTS_COMMITTED },
                    { "added", FSYNC_COMPONENTS_ADDED },
                    { "all", FSYNC_COMPONENTS_ALL },
            };

            static enum fsync_component parse_fsync_components(const char *var, const char *string)
            {
                    enum fsync_component current = FSYNC_COMPONENTS_PLATFORM_DEFAULT;
                    enum fsync_component positive = 0, negative = 0;

                    while (string) {
                            int i;
                            size_t len;
                            const char *ep;
                            int negated = 0;
                            int found = 0;

                            string = string + strspn(string, ", \t\n\r");
                            ep = strchrnul(string, ',');
                            len = ep - string;
                            if (!strcmp(string, "none")) {
                                    current = FSYNC_COMPONENT_NONE;
                                    goto next_name;
                            }

                            if (*string == '-') {
                                    negated = 1;
                                    string++;
                                    len--;
                                    if (!len)
                                            warning(_("invalid value for variable %s"), var);
                            }

                            if (!len)
                                    break;

                            for (i = 0; i < ARRAY_SIZE(fsync_component_names); ++i) {
                                    const struct fsync_component_name *n = &fsync_component_names[i];

                                    if (strncmp(n->name, string, len))
                                            continue;

                                    found = 1;
                                    if (negated)
                                            negative |= n->component_bits;
                                    else
                                            positive |= n->component_bits;
                            }

                            if (!found) {
                                    char *component = xstrndup(string, len);
                                    warning(_("ignoring unknown core.fsync component '%s'"), component);
                                    free(component);
                            }

            next_name:
                            string = ep;
                    }

                    return (current & ~negative) | positive;
            }

            int git_config_bool_or_int(const char *name, const char *value,
                                    const struct key_value_info *kvi, int *is_bool)
            {
                    int v = git_parse_maybe_bool_text(value);
                    if (0 <= v) {
                            *is_bool = 1;
                            return v;
                    }
                    *is_bool = 0;
                    return git_config_int(name, value, kvi);
            }

            int git_config_bool(const char *name, const char *value)
            {
                    int v = git_parse_maybe_bool(value);
                    if (v < 0)
                            die(_("bad boolean config value '%s' for '%s'"), value, name);
                    return v;
            }

            int git_config_string(char **dest, const char *var, const char *value)
            {
                    if (!value)
                            return config_error_nonbool(var);
                    *dest = xstrdup(value);
                    return 0;
            }

            int git_config_pathname(char **dest, const char *var, const char *value)
            {
                    if (!value)
                            return config_error_nonbool(var);
                    *dest = interpolate_path(value, 0);
                    if (!*dest)
                            die(_("failed to expand user dir in: '%s'"), value);
                    return 0;
            }

            int git_config_expiry_date(timestamp_t *timestamp, const char *var, const char *value)
            {
                    if (!value)
                            return config_error_nonbool(var);
                    if (parse_expiry_date(value, timestamp))
                            return error(_("'%s' for '%s' is not a valid timestamp"),
                                    value, var);
                    return 0;
            }

            int git_config_color(char *dest, const char *var, const char *value)
            {
                    if (!value)
                            return config_error_nonbool(var);
                    if (color_parse(value, dest) < 0)
                            return -1;
                    return 0;
            }

            static int git_default_core_config(const char *var, const char *value,
                                            const struct config_context *ctx, void *cb)
            {
                    /* This needs a better name */
                    if (!strcmp(var, "core.filemode")) {
                            trust_executable_bit = git_config_bool(var, value);
                            return 0;
                    }
                    if (!strcmp(var, "core.trustctime")) {
                            trust_ctime = git_config_bool(var, value);
                            return 0;
                    }
                    if (!strcmp(var, "core.checkstat")) {
                            if (!value)
                                    return config_error_nonbool(var);
                            if (!strcasecmp(value, "default"))
                                    check_stat = 1;
                            else if (!strcasecmp(value, "minimal"))
                                    check_stat = 0;
                            else
                                    return error(_("invalid value for '%s': '%s'"),
                                            var, value);
                    }

                    if (!strcmp(var, "core.quotepath")) {
                            quote_path_fully = git_config_bool(var, value);
                            return 0;
                    }

                    if (!strcmp(var, "core.symlinks")) {
                            has_symlinks = git_config_bool(var, value);
                            return 0;
                    }

                    if (!strcmp(var, "core.ignorecase")) {
                            ignore_case = git_config_bool(var, value);
                            return 0;
                    }

                    if (!strcmp(var, "core.attributesfile")) {
                            FREE_AND_NULL(git_attributes_file);
                            return git_config_pathname(&git_attributes_file, var, value);
                    }

                    if (!strcmp(var, "core.hookspath")) {
                            FREE_AND_NULL(git_hooks_path);
                            return git_config_pathname(&git_hooks_path, var, value);
                    }

                    if (!strcmp(var, "core.bare")) {
                            is_bare_repository_cfg = git_config_bool(var, value);
                            return 0;
                    }

                    if (!strcmp(var, "core.ignorestat")) {
                            assume_unchanged = git_config_bool(var, value);
                            return 0;
                    }

                    if (!strcmp(var, "core.abbrev")) {
                            if (!value)
                                    return config_error_nonbool(var);
                            if (!strcasecmp(value, "auto"))
                                    default_abbrev = -1;
                            else if (!git_parse_maybe_bool_text(value))
                                    default_abbrev = GIT_MAX_HEXSZ;
                            else {
                                    int abbrev = git_config_int(var, value, ctx->kvi);
                                    if (abbrev < minimum_abbrev)
                                            return error(_("abbrev length out of range: %d"), abbrev);
                                    default_abbrev = abbrev;
                            }
                            return 0;
                    }

                    if (!strcmp(var, "core.disambiguate"))
                            return set_disambiguate_hint_config(var, value);

                    if (!strcmp(var, "core.loosecompression")) {
                            int level = git_config_int(var, value, ctx->kvi);
                            if (level == -1)
                                    level = Z_DEFAULT_COMPRESSION;
                            else if (level < 0 || level > Z_BEST_COMPRESSION)
                                    die(_("bad zlib compression level %d"), level);
                            zlib_compression_level = level;
                            zlib_compression_seen = 1;
                            return 0;
                    }

                    if (!strcmp(var, "core.compression")) {
                            int level = git_config_int(var, value, ctx->kvi);
                            if (level == -1)
                                    level = Z_DEFAULT_COMPRESSION;
                            else if (level < 0 || level > Z_BEST_COMPRESSION)
                                    die(_("bad zlib compression level %d"), level);
                            if (!zlib_compression_seen)
                                    zlib_compression_level = level;
                            if (!pack_compression_seen)
                                    pack_compression_level = level;
                            return 0;
                    }

                    if (!strcmp(var, "core.bigfilethreshold")) {
                            big_file_threshold = git_config_ulong(var, value, ctx->kvi);
                            return 0;
                    }

                    if (!strcmp(var, "core.autocrlf")) {
                            if (value && !strcasecmp(value, "input")) {
                                    auto_crlf = AUTO_CRLF_INPUT;
                                    return 0;
                            }
                            auto_crlf = git_config_bool(var, value);
                            return 0;
                    }

                    if (!strcmp(var, "core.safecrlf")) {
                            int eol_rndtrp_die;
                            if (value && !strcasecmp(value, "warn")) {
                                    global_conv_flags_eol = CONV_EOL_RNDTRP_WARN;
                                    return 0;
                            }
                            eol_rndtrp_die = git_config_bool(var, value);
                            global_conv_flags_eol = eol_rndtrp_die ?
                                    CONV_EOL_RNDTRP_DIE : 0;
                            return 0;
                    }

                    if (!strcmp(var, "core.eol")) {
                            if (value && !strcasecmp(value, "lf"))
                                    core_eol = EOL_LF;
                            else if (value && !strcasecmp(value, "crlf"))
                                    core_eol = EOL_CRLF;
                            else if (value && !strcasecmp(value, "native"))
                                    core_eol = EOL_NATIVE;
                            else
                                    core_eol = EOL_UNSET;
                            return 0;
                    }

                    if (!strcmp(var, "core.checkroundtripencoding")) {
                            FREE_AND_NULL(check_roundtrip_encoding);
                            return git_config_string(&check_roundtrip_encoding, var, value);
                    }

                    if (!strcmp(var, "core.editor")) {
                            FREE_AND_NULL(editor_program);
                            return git_config_string(&editor_program, var, value);
                    }

                    if (!strcmp(var, "core.commentchar") ||
                    !strcmp(var, "core.commentstring")) {
                            if (!value)
                                    return config_error_nonbool(var);
                            else if (!strcasecmp(value, "auto"))
                                    auto_comment_line_char = 1;
                            else if (value[0]) {
                                    if (strchr(value, '\n'))
                                            return error(_("%s cannot contain newline"), var);
                                    comment_line_str = value;
                                    FREE_AND_NULL(comment_line_str_to_free);
                                    auto_comment_line_char = 0;
                            } else
                                    return error(_("%s must have at least one character"), var);
                            return 0;
                    }

                    if (!strcmp(var, "core.askpass")) {
                            FREE_AND_NULL(askpass_program);
                            return git_config_string(&askpass_program, var, value);
                    }

                    if (!strcmp(var, "core.excludesfile")) {
                            FREE_AND_NULL(excludes_file);
                            return git_config_pathname(&excludes_file, var, value);
                    }

                    if (!strcmp(var, "core.whitespace")) {
                            if (!value)
                                    return config_error_nonbool(var);
                            whitespace_rule_cfg = parse_whitespace_rule(value);
                            return 0;
                    }

                    if (!strcmp(var, "core.fsync")) {
                            if (!value)
                                    return config_error_nonbool(var);
                            fsync_components = parse_fsync_components(var, value);
                            return 0;
                    }

                    if (!strcmp(var, "core.fsyncmethod")) {
                            if (!value)
                                    return config_error_nonbool(var);
                            if (!strcmp(value, "fsync"))
                                    fsync_method = FSYNC_METHOD_FSYNC;
                            else if (!strcmp(value, "writeout-only"))
                                    fsync_method = FSYNC_METHOD_WRITEOUT_ONLY;
                            else if (!strcmp(value, "batch"))
                                    fsync_method = FSYNC_METHOD_BATCH;
                            else
                                    warning(_("ignoring unknown core.fsyncMethod value '%s'"), value);

                    }

                    if (!strcmp(var, "core.fsyncobjectfiles")) {
                            if (fsync_object_files < 0)
                                    warning(_("core.fsyncObjectFiles is deprecated; use core.fsync instead"));
                            fsync_object_files = git_config_bool(var, value);
                            return 0;
                    }

                    if (!strcmp(var, "core.preloadindex")) {
                            core_preload_index = git_config_bool(var, value);
                            return 0;
                    }

                    if (!strcmp(var, "core.createobject")) {
                            if (!value)
                                    return config_error_nonbool(var);
                            if (!strcmp(value, "rename"))
                                    object_creation_mode = OBJECT_CREATION_USES_RENAMES;
                            else if (!strcmp(value, "link"))
                                    object_creation_mode = OBJECT_CREATION_USES_HARDLINKS;
                            else
                                    die(_("invalid mode for object creation: %s"), value);
                            return 0;
                    }

                    if (!strcmp(var, "core.sparsecheckout")) {
                            core_apply_sparse_checkout = git_config_bool(var, value);
                            return 0;
                    }

                    if (!strcmp(var, "core.sparsecheckoutcone")) {
                            core_sparse_checkout_cone = git_config_bool(var, value);
                            return 0;
                    }

                    if (!strcmp(var, "core.precomposeunicode")) {
                            precomposed_unicode = git_config_bool(var, value);
                            return 0;
                    }

                    if (!strcmp(var, "core.protecthfs")) {
                            protect_hfs = git_config_bool(var, value);
                            return 0;
                    }

                    if (!strcmp(var, "core.protectntfs")) {
                            protect_ntfs = git_config_bool(var, value);
                            return 0;
                    }

                    if (!strcmp(var, "core.maxtreedepth")) {
                            max_allowed_tree_depth = git_config_int(var, value, ctx->kvi);
                            return 0;
                    }

                    /* Add other config variables here and to Documentation/config.txt. */
                    return platform_core_config(var, value, ctx, cb);
            }

            static int git_default_sparse_config(const char *var, const char *value)
            {
                    if (!strcmp(var, "sparse.expectfilesoutsideofpatterns")) {
                            sparse_expect_files_outside_of_patterns = git_config_bool(var, value);
                            return 0;
                    }

                    /* Add other config variables here and to Documentation/config/sparse.txt. */
                    return 0;
            }

            static int git_default_i18n_config(const char *var, const char *value)
            {
                    if (!strcmp(var, "i18n.commitencoding")) {
                            FREE_AND_NULL(git_commit_encoding);
                            return git_config_string(&git_commit_encoding, var, value);
                    }

                    if (!strcmp(var, "i18n.logoutputencoding")) {
                            FREE_AND_NULL(git_log_output_encoding);
                            return git_config_string(&git_log_output_encoding, var, value);
                    }

                    /* Add other config variables here and to Documentation/config.txt. */
                    return 0;
            }

            static int git_default_branch_config(const char *var, const char *value)
            {
                    if (!strcmp(var, "branch.autosetupmerge")) {
                            if (value && !strcmp(value, "always")) {
                                    git_branch_track = BRANCH_TRACK_ALWAYS;
                                    return 0;
                            } else if (value && !strcmp(value, "inherit")) {
                                    git_branch_track = BRANCH_TRACK_INHERIT;
                                    return 0;
                            } else if (value && !strcmp(value, "simple")) {
                                    git_branch_track = BRANCH_TRACK_SIMPLE;
                                    return 0;
                            }
                            git_branch_track = git_config_bool(var, value);
                            return 0;
                    }
                    if (!strcmp(var, "branch.autosetuprebase")) {
                            if (!value)
                                    return config_error_nonbool(var);
                            else if (!strcmp(value, "never"))
                                    autorebase = AUTOREBASE_NEVER;
                            else if (!strcmp(value, "local"))
                                    autorebase = AUTOREBASE_LOCAL;
                            else if (!strcmp(value, "remote"))
                                    autorebase = AUTOREBASE_REMOTE;
                            else if (!strcmp(value, "always"))
                                    autorebase = AUTOREBASE_ALWAYS;
                            else
                                    return error(_("malformed value for %s"), var);
                            return 0;
                    }

                    /* Add other config variables here and to Documentation/config.txt. */
                    return 0;
            }

            static int git_default_push_config(const char *var, const char *value)
            {
                    if (!strcmp(var, "push.default")) {
                            if (!value)
                                    return config_error_nonbool(var);
                            else if (!strcmp(value, "nothing"))
                                    push_default = PUSH_DEFAULT_NOTHING;
                            else if (!strcmp(value, "matching"))
                                    push_default = PUSH_DEFAULT_MATCHING;
                            else if (!strcmp(value, "simple"))
                                    push_default = PUSH_DEFAULT_SIMPLE;
                            else if (!strcmp(value, "upstream"))
                                    push_default = PUSH_DEFAULT_UPSTREAM;
                            else if (!strcmp(value, "tracking")) /* deprecated */
                                    push_default = PUSH_DEFAULT_UPSTREAM;
                            else if (!strcmp(value, "current"))
                                    push_default = PUSH_DEFAULT_CURRENT;
                            else {
                                    error(_("malformed value for %s: %s"), var, value);
                                    return error(_("must be one of nothing, matching, simple, "
                                            "upstream or current"));
                            }
                            return 0;
                    }

                    /* Add other config variables here and to Documentation/config.txt. */
                    return 0;
            }

            static int git_default_mailmap_config(const char *var, const char *value)
            {
                    if (!strcmp(var, "mailmap.file")) {
                            FREE_AND_NULL(git_mailmap_file);
                            return git_config_pathname(&git_mailmap_file, var, value);
                    }

                    if (!strcmp(var, "mailmap.blob")) {
                            FREE_AND_NULL(git_mailmap_blob);
                            return git_config_string(&git_mailmap_blob, var, value);
                    }

                    /* Add other config variables here and to Documentation/config.txt. */
                    return 0;
            }

            static int git_default_attr_config(const char *var, const char *value)
            {
                    if (!strcmp(var, "attr.tree")) {
                            FREE_AND_NULL(git_attr_tree);
                            return git_config_string(&git_attr_tree, var, value);
                    }

                    /*
                    * Add other attribute related config variables here and to
                    * Documentation/config/attr.txt.
                    */
                    return 0;
            }

            int git_default_config(const char *var, const char *value,
                            const struct config_context *ctx, void *cb)
            {
                    if (starts_with(var, "core."))
                            return git_default_core_config(var, value, ctx, cb);

                    if (starts_with(var, "user.") ||
                    starts_with(var, "author.") ||
                    starts_with(var, "committer."))
                            return git_ident_config(var, value, ctx, cb);

                    if (starts_with(var, "i18n."))
                            return git_default_i18n_config(var, value);

                    if (starts_with(var, "branch."))
                            return git_default_branch_config(var, value);

                    if (starts_with(var, "push."))
                            return git_default_push_config(var, value);

                    if (starts_with(var, "mailmap."))
                            return git_default_mailmap_config(var, value);

                    if (starts_with(var, "attr."))
                            return git_default_attr_config(var, value);

                    if (starts_with(var, "advice.") || starts_with(var, "color.advice"))
                            return git_default_advice_config(var, value);

                    if (!strcmp(var, "pager.color") || !strcmp(var, "color.pager")) {
                            pager_use_color = git_config_bool(var,value);
                            return 0;
                    }

                    if (!strcmp(var, "pack.packsizelimit")) {
                            pack_size_limit_cfg = git_config_ulong(var, value, ctx->kvi);
                            return 0;
                    }

                    if (!strcmp(var, "pack.compression")) {
                            int level = git_config_int(var, value, ctx->kvi);
                            if (level == -1)
                                    level = Z_DEFAULT_COMPRESSION;
                            else if (level < 0 || level > Z_BEST_COMPRESSION)
                                    die(_("bad pack compression level %d"), level);
                            pack_compression_level = level;
                            pack_compression_seen = 1;
                            return 0;
                    }

                    if (starts_with(var, "sparse."))
                            return git_default_sparse_config(var, value);

                    /* Add other config variables here and to Documentation/config.txt. */
                    return 0;
            }

            /*
            * All source specific fields in the union, die_on_error, name and the callbacks
            * fgetc, ungetc, ftell of top need to be initialized before calling
            * this function.
            */
            static int do_config_from(struct config_source *top, config_fn_t fn,
                                    void *data, enum config_scope scope,
                                    const struct config_options *opts)
            {
                    struct key_value_info kvi = KVI_INIT;
                    int ret;

                    /* push config-file parsing state stack */
                    top->linenr = 1;
                    top->eof = 0;
                    top->total_len = 0;
                    strbuf_init(&top->value, 1024);
                    strbuf_init(&top->var, 1024);
                    kvi_from_source(top, scope, &kvi);

                    ret = git_parse_source(top, fn, &kvi, data, opts);

                    strbuf_release(&top->value);
                    strbuf_release(&top->var);

                    return ret;
            }

            static int do_config_from_file(config_fn_t fn,
                                    const enum config_origin_type origin_type,
                                    const char *name, const char *path, FILE *f,
                                    void *data, enum config_scope scope,
                                    const struct config_options *opts)
            {
                    struct config_source top = CONFIG_SOURCE_INIT;
                    int ret;

                    top.u.file = f;
                    top.origin_type = origin_type;
                    top.name = name;
                    top.path = path;
                    top.default_error_action = CONFIG_ERROR_DIE;
                    top.do_fgetc = config_file_fgetc;
                    top.do_ungetc = config_file_ungetc;
                    top.do_ftell = config_file_ftell;

                    flockfile(f);
                    ret = do_config_from(&top, fn, data, scope, opts);
                    funlockfile(f);
                    return ret;
            }

            static int git_config_from_stdin(config_fn_t fn, void *data,
                                            enum config_scope scope)
            {
                    return do_config_from_file(fn, CONFIG_ORIGIN_STDIN, "", NULL, stdin,
                                            data, scope, NULL);
            }

            int git_config_from_file_with_options(config_fn_t fn, const char *filename,
                                            void *data, enum config_scope scope,
                                            const struct config_options *opts)
            {
                    int ret = -1;
                    FILE *f;

                    if (!filename)
                            BUG("filename cannot be NULL");
                    f = fopen_or_warn(filename, "r");
                    if (f) {
                            ret = do_config_from_file(fn, CONFIG_ORIGIN_FILE, filename,
                                                    filename, f, data, scope, opts);
                            fclose(f);
                    }
                    return ret;
            }

            int git_config_from_file(config_fn_t fn, const char *filename, void *data)
            {
                    return git_config_from_file_with_options(fn, filename, data,
                                                            CONFIG_SCOPE_UNKNOWN, NULL);
            }

            int git_config_from_mem(config_fn_t fn,
                                    const enum config_origin_type origin_type,
                                    const char *name, const char *buf, size_t len,
                                    void *data, enum config_scope scope,
                                    const struct config_options *opts)
            {
                    struct config_source top = CONFIG_SOURCE_INIT;

                    top.u.buf.buf = buf;
                    top.u.buf.len = len;
                    top.u.buf.pos = 0;
                    top.origin_type = origin_type;
                    top.name = name;
                    top.path = NULL;
                    top.default_error_action = CONFIG_ERROR_ERROR;
                    top.do_fgetc = config_buf_fgetc;
                    top.do_ungetc = config_buf_ungetc;
                    top.do_ftell = config_buf_ftell;

                    return do_config_from(&top, fn, data, scope, opts);
            }

            int git_config_from_blob_oid(config_fn_t fn,
                                    const char *name,
                                    struct repository *repo,
                                    const struct object_id *oid,
                                    void *data,
                                    enum config_scope scope)
            {
                    enum object_type type;
                    char *buf;
                    unsigned long size;
                    int ret;

                    buf = repo_read_object_file(repo, oid, &type, &size);
                    if (!buf)
                            return error(_("unable to load config blob object '%s'"), name);
                    if (type != OBJ_BLOB) {
                            free(buf);
                            return error(_("reference '%s' does not point to a blob"), name);
                    }

                    ret = git_config_from_mem(fn, CONFIG_ORIGIN_BLOB, name, buf, size,
                                            data, scope, NULL);
                    free(buf);

                    return ret;
            }

            static int git_config_from_blob_ref(config_fn_t fn,
                                            struct repository *repo,
                                            const char *name,
                                            void *data,
                                            enum config_scope scope)
            {
                    struct object_id oid;

                    if (repo_get_oid(repo, name, &oid) < 0)
                            return error(_("unable to resolve config blob '%s'"), name);
                    return git_config_from_blob_oid(fn, name, repo, &oid, data, scope);
            }

            char *git_system_config(void)
            {
                    char *system_config = xstrdup_or_null(getenv("GIT_CONFIG_SYSTEM"));
                    if (!system_config)
                            system_config = system_path(ETC_GITCONFIG);
                    normalize_path_copy(system_config, system_config);
                    return system_config;
            }

            char *git_global_config(void)
            {
                    char *user_config, *xdg_config;

                    git_global_config_paths(&user_config, &xdg_config);
                    if (!user_config) {
                            free(xdg_config);
                            return NULL;
                    }

                    if (access_or_warn(user_config, R_OK, 0) && xdg_config &&
                    !access_or_warn(xdg_config, R_OK, 0)) {
                            free(user_config);
                            return xdg_config;
                    } else {
                            free(xdg_config);
                            return user_config;
                    }
            }

            void git_global_config_paths(char **user_out, char **xdg_out)
            {
                    char *user_config = xstrdup_or_null(getenv("GIT_CONFIG_GLOBAL"));
                    char *xdg_config = NULL;

                    if (!user_config) {
                            user_config = interpolate_path("~/.gitconfig", 0);
                            xdg_config = xdg_config_home("config");
                    }

                    *user_out = user_config;
                    *xdg_out = xdg_config;
            }

            int git_config_system(void)
            {
                    return !git_env_bool("GIT_CONFIG_NOSYSTEM", 0);
            }

            static int do_git_config_sequence(const struct config_options *opts,
                                            const struct repository *repo,
                                            config_fn_t fn, void *data)
            {
                    int ret = 0;
                    char *system_config = git_system_config();
                    char *xdg_config = NULL;
                    char *user_config = NULL;
                    char *repo_config;
                    char *worktree_config;

                    /*
                    * Ensure that either:
                    * - the git_dir and commondir are both set, or
                    * - the git_dir and commondir are both NULL
                    */
                    if (!opts->git_dir != !opts->commondir)
                            BUG("only one of commondir and git_dir is non-NULL");

                    if (opts->commondir) {
                            repo_config = mkpathdup("%s/config", opts->commondir);
                            worktree_config = mkpathdup("%s/config.worktree", opts->git_dir);
                    } else {
                            repo_config = NULL;
                            worktree_config = NULL;
                    }

                    if (git_config_system() && system_config &&
                    !access_or_die(system_config, R_OK,
                                    opts->system_gently ? ACCESS_EACCES_OK : 0))
                            ret += git_config_from_file_with_options(fn, system_config,
                                                                    data, CONFIG_SCOPE_SYSTEM,
                                                                    NULL);

                    git_global_config_paths(&user_config, &xdg_config);

                    if (xdg_config && !access_or_die(xdg_config, R_OK, ACCESS_EACCES_OK))
                            ret += git_config_from_file_with_options(fn, xdg_config, data,
                                                                    CONFIG_SCOPE_GLOBAL, NULL);

                    if (user_config && !access_or_die(user_config, R_OK, ACCESS_EACCES_OK))
                            ret += git_config_from_file_with_options(fn, user_config, data,
                                                                    CONFIG_SCOPE_GLOBAL, NULL);

                    if (!opts->ignore_repo && repo_config &&
                    !access_or_die(repo_config, R_OK, 0))
                            ret += git_config_from_file_with_options(fn, repo_config, data,
                                                                    CONFIG_SCOPE_LOCAL, NULL);

                    if (!opts->ignore_worktree && worktree_config &&
                    repo && repo->repository_format_worktree_config &&
                    !access_or_die(worktree_config, R_OK, 0)) {
                                    ret += git_config_from_file_with_options(fn, worktree_config, data,
                                                                            CONFIG_SCOPE_WORKTREE,
                                                                            NULL);
                    }

                    if (!opts->ignore_cmdline && git_config_from_parameters(fn, data) < 0)
                            die(_("unable to parse command-line config"));

                    free(system_config);
                    free(xdg_config);
                    free(user_config);
                    free(repo_config);
                    free(worktree_config);
                    return ret;
            }

            int config_with_options(config_fn_t fn, void *data,
                                    const struct git_config_source *config_source,
                                    struct repository *repo,
                                    const struct config_options *opts)
            {
                    struct config_include_data inc = CONFIG_INCLUDE_INIT;
                    int ret;

                    if (opts->respect_includes) {
                            inc.fn = fn;
                            inc.data = data;
                            inc.opts = opts;
                            inc.repo = repo;
                            inc.config_source = config_source;
                            fn = git_config_include;
                            data = &inc;
                    }

                    /*
                    * If we have a specific filename, use it. Otherwise, follow the
                    * regular lookup sequence.
                    */
                    if (config_source && config_source->use_stdin) {
                            ret = git_config_from_stdin(fn, data, config_source->scope);
                    } else if (config_source && config_source->file) {
                            ret = git_config_from_file_with_options(fn, config_source->file,
                                                                    data, config_source->scope,
                                                                    NULL);
                    } else if (config_source && config_source->blob) {
                            ret = git_config_from_blob_ref(fn, repo, config_source->blob,
                                                    data, config_source->scope);
                    } else {
                            ret = do_git_config_sequence(opts, repo, fn, data);
                    }

                    if (inc.remote_urls) {
                            string_list_clear(inc.remote_urls, 0);
                            FREE_AND_NULL(inc.remote_urls);
                    }
                    return ret;
            }

            static void configset_iter(struct config_set *set, config_fn_t fn, void *data)
            {
                    int i, value_index;
                    struct string_list *values;
                    struct config_set_element *entry;
                    struct configset_list *list = &set->list;
                    struct config_context ctx = CONFIG_CONTEXT_INIT;

                    for (i = 0; i < list->nr; i++) {
                            entry = list->items[i].e;
                            value_index = list->items[i].value_index;
                            values = &entry->value_list;

                            ctx.kvi = values->items[value_index].util;
                            if (fn(entry->key, values->items[value_index].string, &ctx, data) < 0)
                                    git_die_config_linenr(entry->key,
                                                    ctx.kvi->filename,
                                                    ctx.kvi->linenr);
                    }
            }

            void read_early_config(struct repository *repo, config_fn_t cb, void *data)
            {
                    struct config_options opts = {0};
                    struct strbuf commondir = STRBUF_INIT;
                    struct strbuf gitdir = STRBUF_INIT;

                    opts.respect_includes = 1;

                    if (repo && repo->gitdir) {
                            opts.commondir = repo_get_common_dir(repo);
                            opts.git_dir = repo_get_git_dir(repo);
                    /*
                    * When setup_git_directory() was not yet asked to discover the
                    * GIT_DIR, we ask discover_git_directory() to figure out whether there
                    * is any repository config we should use (but unlike
                    * setup_git_directory_gently(), no global state is changed, most
                    * notably, the current working directory is still the same after the
                    * call).
                    */
                    } else if (!discover_git_directory(&commondir, &gitdir)) {
                            opts.commondir = commondir.buf;
                            opts.git_dir = gitdir.buf;
                    }

                    config_with_options(cb, data, NULL, NULL, &opts);

                    strbuf_release(&commondir);
                    strbuf_release(&gitdir);
            }

            void read_very_early_config(config_fn_t cb, void *data)
            {
                    struct config_options opts = { 0 };

                    opts.respect_includes = 1;
                    opts.ignore_repo = 1;
                    opts.ignore_worktree = 1;
                    opts.ignore_cmdline = 1;
                    opts.system_gently = 1;

                    config_with_options(cb, data, NULL, NULL, &opts);
            }

            RESULT_MUST_BE_USED
            static int configset_find_element(struct config_set *set, const char *key,
                                            struct config_set_element **dest)
            {
                    struct config_set_element k;
                    struct config_set_element *found_entry;
                    char *normalized_key;
                    int ret;

                    /*
                    * `key` may come from the user, so normalize it before using it
                    * for querying entries from the hashmap.
                    */
                    ret = git_config_parse_key(key, &normalized_key, NULL);
                    if (ret)
                            return ret;

                    hashmap_entry_init(&k.ent, strhash(normalized_key));
                    k.key = normalized_key;
                    found_entry = hashmap_get_entry(&set->config_hash, &k, ent, NULL);
                    free(normalized_key);
                    *dest = found_entry;
                    return 0;
            }

            static int configset_add_value(const struct key_value_info *kvi_p,
                                    struct config_set *set, const char *key,
                                    const char *value)
            {
                    struct config_set_element *e;
                    struct string_list_item *si;
                    struct configset_list_item *l_item;
                    struct key_value_info *kv_info = xmalloc(sizeof(*kv_info));
                    int ret;

                    ret = configset_find_element(set, key, &e);
                    if (ret)
                            return ret;
                    /*
                    * Since the keys are being fed by git_config*() callback mechanism, they
                    * are already normalized. So simply add them without any further munging.
                    */
                    if (!e) {
                            e = xmalloc(sizeof(*e));
                            hashmap_entry_init(&e->ent, strhash(key));
                            e->key = xstrdup(key);
                            string_list_init_dup(&e->value_list);
                            hashmap_add(&set->config_hash, &e->ent);
                    }
                    si = string_list_append_nodup(&e->value_list, xstrdup_or_null(value));

                    ALLOC_GROW(set->list.items, set->list.nr + 1, set->list.alloc);
                    l_item = &set->list.items[set->list.nr++];
                    l_item->e = e;
                    l_item->value_index = e->value_list.nr - 1;

                    *kv_info = *kvi_p;
                    si->util = kv_info;

                    return 0;
            }

            static int config_set_element_cmp(const void *cmp_data UNUSED,
                                            const struct hashmap_entry *eptr,
                                            const struct hashmap_entry *entry_or_key,
                                            const void *keydata UNUSED)
            {
                    const struct config_set_element *e1, *e2;

                    e1 = container_of(eptr, const struct config_set_element, ent);
                    e2 = container_of(entry_or_key, const struct config_set_element, ent);

                    return strcmp(e1->key, e2->key);
            }

            void git_configset_init(struct config_set *set)
            {
                    hashmap_init(&set->config_hash, config_set_element_cmp, NULL, 0);
                    set->hash_initialized = 1;
                    set->list.nr = 0;
                    set->list.alloc = 0;
                    set->list.items = NULL;
            }

            void git_configset_clear(struct config_set *set)
            {
                    struct config_set_element *entry;
                    struct hashmap_iter iter;
                    if (!set->hash_initialized)
                            return;

                    hashmap_for_each_entry(&set->config_hash, &iter, entry,
                                            ent /* member name */) {
                            free(entry->key);
                            string_list_clear(&entry->value_list, 1);
                    }
                    hashmap_clear_and_free(&set->config_hash, struct config_set_element, ent);
                    set->hash_initialized = 0;
                    free(set->list.items);
                    set->list.nr = 0;
                    set->list.alloc = 0;
                    set->list.items = NULL;
            }

            static int config_set_callback(const char *key, const char *value,
                                    const struct config_context *ctx,
                                    void *cb)
            {
                    struct config_set *set = cb;
                    configset_add_value(ctx->kvi, set, key, value);
                    return 0;
            }

            int git_configset_add_file(struct config_set *set, const char *filename)
            {
                    return git_config_from_file(config_set_callback, filename, set);
            }

            int git_configset_get_value(struct config_set *set, const char *key,
                                    const char **value, struct key_value_info *kvi)
            {
                    const struct string_list *values = NULL;
                    int ret;
                    struct string_list_item item;
                    /*
                    * Follows "last one wins" semantic, i.e., if there are multiple matches for the
                    * queried key in the files of the configset, the value returned will be the last
                    * value in the value list for that key.
                    */
                    if ((ret = git_configset_get_value_multi(set, key, &values)))
                            return ret;

                    assert(values->nr > 0);
                    item = values->items[values->nr - 1];
                    *value = item.string;
                    if (kvi)
                            *kvi = *((struct key_value_info *)item.util);
                    return 0;
            }

            int git_configset_get_value_multi(struct config_set *set, const char *key,
                                            const struct string_list **dest)
            {
                    struct config_set_element *e;
                    int ret;

                    if ((ret = configset_find_element(set, key, &e)))
                            return ret;
                    else if (!e)
                            return 1;
                    *dest = &e->value_list;

                    return 0;
            }

            static int check_multi_string(struct string_list_item *item, void *util)
            {
                    return item->string ? 0 : config_error_nonbool(util);
            }

            int git_configset_get_string_multi(struct config_set *cs, const char *key,
                                            const struct string_list **dest)
            {
                    int ret;

                    if ((ret = git_configset_get_value_multi(cs, key, dest)))
                            return ret;
                    if ((ret = for_each_string_list((struct string_list *)*dest,
                                                    check_multi_string, (void *)key)))
                            return ret;

                    return 0;
            }

            int git_configset_get(struct config_set *set, const char *key)
            {
                    struct config_set_element *e;
                    int ret;

                    if ((ret = configset_find_element(set, key, &e)))
                            return ret;
                    else if (!e)
                            return 1;
                    return 0;
            }

            int git_configset_get_string(struct config_set *set, const char *key, char **dest)
            {
                    const char *value;
                    if (!git_configset_get_value(set, key, &value, NULL))
                            return git_config_string(dest, key, value);
                    else
                            return 1;
            }

            static int git_configset_get_string_tmp(struct config_set *set, const char *key,
                                                    const char **dest)
            {
                    const char *value;
                    if (!git_configset_get_value(set, key, &value, NULL)) {
                            if (!value)
                                    return config_error_nonbool(key);
                            *dest = value;
                            return 0;
                    } else {
                            return 1;
                    }
            }

            int git_configset_get_int(struct config_set *set, const char *key, int *dest)
            {
                    const char *value;
                    struct key_value_info kvi;

                    if (!git_configset_get_value(set, key, &value, &kvi)) {
                            *dest = git_config_int(key, value, &kvi);
                            return 0;
                    } else
                            return 1;
            }

            int git_configset_get_ulong(struct config_set *set, const char *key, unsigned long *dest)
            {
                    const char *value;
                    struct key_value_info kvi;

                    if (!git_configset_get_value(set, key, &value, &kvi)) {
                            *dest = git_config_ulong(key, value, &kvi);
                            return 0;
                    } else
                            return 1;
            }

            int git_configset_get_bool(struct config_set *set, const char *key, int *dest)
            {
                    const char *value;
                    if (!git_configset_get_value(set, key, &value, NULL)) {
                            *dest = git_config_bool(key, value);
                            return 0;
                    } else
                            return 1;
            }

            int git_configset_get_bool_or_int(struct config_set *set, const char *key,
                                            int *is_bool, int *dest)
            {
                    const char *value;
                    struct key_value_info kvi;

                    if (!git_configset_get_value(set, key, &value, &kvi)) {
                            *dest = git_config_bool_or_int(key, value, &kvi, is_bool);
                            return 0;
                    } else
                            return 1;
            }

            int git_configset_get_maybe_bool(struct config_set *set, const char *key, int *dest)
            {
                    const char *value;
                    if (!git_configset_get_value(set, key, &value, NULL)) {
                            *dest = git_parse_maybe_bool(value);
                            if (*dest == -1)
                                    return -1;
                            return 0;
                    } else
                            return 1;
            }

            int git_configset_get_pathname(struct config_set *set, const char *key, char **dest)
            {
                    const char *value;
                    if (!git_configset_get_value(set, key, &value, NULL))
                            return git_config_pathname(dest, key, value);
                    else
                            return 1;
            }

            /* Functions use to read configuration from a repository */
            static void repo_read_config(struct repository *repo)
            {
                    struct config_options opts = { 0 };

                    opts.respect_includes = 1;
                    opts.commondir = repo->commondir;
                    opts.git_dir = repo->gitdir;

                    if (!repo->config)
                            CALLOC_ARRAY(repo->config, 1);
                    else
                            git_configset_clear(repo->config);

                    git_configset_init(repo->config);
                    if (config_with_options(config_set_callback, repo->config, NULL,
                                            repo, &opts) < 0)
                            /*
                            * config_with_options() normally returns only
                            * zero, as most errors are fatal, and
                            * non-fatal potential errors are guarded by "if"
                            * statements that are entered only when no error is
                            * possible.
                            *
                            * If we ever encounter a non-fatal error, it means
                            * something went really wrong and we should stop
                            * immediately.
                            */
                            die(_("unknown error occurred while reading the configuration files"));
            }

            static void git_config_check_init(struct repository *repo)
            {
                    if (repo->config && repo->config->hash_initialized)
                            return;
                    repo_read_config(repo);
            }

            void repo_config_clear(struct repository *repo)
            {
                    if (!repo->config || !repo->config->hash_initialized)
                            return;
                    git_configset_clear(repo->config);
            }

            void repo_config(struct repository *repo, config_fn_t fn, void *data)
            {
                    git_config_check_init(repo);
                    configset_iter(repo->config, fn, data);
            }

            int repo_config_get(struct repository *repo, const char *key)
            {
                    git_config_check_init(repo);
                    return git_configset_get(repo->config, key);
            }

            int repo_config_get_value(struct repository *repo,
                                    const char *key, const char **value)
            {
                    git_config_check_init(repo);
                    return git_configset_get_value(repo->config, key, value, NULL);
            }

            int repo_config_get_value_multi(struct repository *repo, const char *key,
                                            const struct string_list **dest)
            {
                    git_config_check_init(repo);
                    return git_configset_get_value_multi(repo->config, key, dest);
            }

            int repo_config_get_string_multi(struct repository *repo, const char *key,
                                            const struct string_list **dest)
            {
                    git_config_check_init(repo);
                    return git_configset_get_string_multi(repo->config, key, dest);
            }

            int repo_config_get_string(struct repository *repo,
                                    const char *key, char **dest)
            {
                    int ret;
                    git_config_check_init(repo);
                    ret = git_configset_get_string(repo->config, key, dest);
                    if (ret < 0)
                            git_die_config(repo, key, NULL);
                    return ret;
            }

            int repo_config_get_string_tmp(struct repository *repo,
                                    const char *key, const char **dest)
            {
                    int ret;
                    git_config_check_init(repo);
                    ret = git_configset_get_string_tmp(repo->config, key, dest);
                    if (ret < 0)
                            git_die_config(repo, key, NULL);
                    return ret;
            }

            int repo_config_get_int(struct repository *repo,
                                    const char *key, int *dest)
            {
                    git_config_check_init(repo);
                    return git_configset_get_int(repo->config, key, dest);
            }

            int repo_config_get_ulong(struct repository *repo,
                                    const char *key, unsigned long *dest)
            {
                    git_config_check_init(repo);
                    return git_configset_get_ulong(repo->config, key, dest);
            }

            int repo_config_get_bool(struct repository *repo,
                                    const char *key, int *dest)
            {
                    git_config_check_init(repo);
                    return git_configset_get_bool(repo->config, key, dest);
            }

            int repo_config_get_bool_or_int(struct repository *repo,
                                            const char *key, int *is_bool, int *dest)
            {
                    git_config_check_init(repo);
                    return git_configset_get_bool_or_int(repo->config, key, is_bool, dest);
            }

            int repo_config_get_maybe_bool(struct repository *repo,
                                    const char *key, int *dest)
            {
                    git_config_check_init(repo);
                    return git_configset_get_maybe_bool(repo->config, key, dest);
            }

            int repo_config_get_pathname(struct repository *repo,
                                    const char *key, char **dest)
            {
                    int ret;
                    git_config_check_init(repo);
                    ret = git_configset_get_pathname(repo->config, key, dest);
                    if (ret < 0)
                            git_die_config(repo, key, NULL);
                    return ret;
            }

            /* Read values into protected_config. */
            static void read_protected_config(void)
            {
                    struct config_options opts = {
                            .respect_includes = 1,
                            .ignore_repo = 1,
                            .ignore_worktree = 1,
                            .system_gently = 1,
                    };

                    git_configset_init(&protected_config);
                    config_with_options(config_set_callback, &protected_config, NULL,
                                    NULL, &opts);
            }

            void git_protected_config(config_fn_t fn, void *data)
            {
                    if (!protected_config.hash_initialized)
                            read_protected_config();
                    configset_iter(&protected_config, fn, data);
            }

            int repo_config_get_expiry(struct repository *r, const char *key, char **output)
            {
                    int ret = repo_config_get_string(r, key, output);

                    if (ret)
                            return ret;
                    if (strcmp(*output, "now")) {
                            timestamp_t now = approxidate("now");
                            if (approxidate(*output) >= now)
                                    git_die_config(r, key, _("Invalid %s: '%s'"), key, *output);
                    }
                    return ret;
            }

            int repo_config_get_expiry_in_days(struct repository *r, const char *key,
                                            timestamp_t *expiry, timestamp_t now)
            {
                    const char *expiry_string;
                    intmax_t days;
                    timestamp_t when;

                    if (repo_config_get_string_tmp(r, key, &expiry_string))
                            return 1; /* no such thing */

                    if (git_parse_signed(expiry_string, &days, maximum_signed_value_of_type(int))) {
                            const int scale = 86400;
                            *expiry = now - days * scale;
                            return 0;
                    }

                    if (!parse_expiry_date(expiry_string, &when)) {
                            *expiry = when;
                            return 0;
                    }
                    return -1; /* thing exists but cannot be parsed */
            }

            int repo_config_get_split_index(struct repository *r)
            {
                    int val;

                    if (!repo_config_get_maybe_bool(r, "core.splitindex", &val))
                            return val;

                    return -1; /* default value */
            }

            int repo_config_get_max_percent_split_change(struct repository *r)
            {
                    int val = -1;

                    if (!repo_config_get_int(r, "splitindex.maxpercentchange", &val)) {
                            if (0 <= val && val <= 100)
                                    return val;

                            return error(_("splitIndex.maxPercentChange value '%d' "
                                    "should be between 0 and 100"), val);
                    }

                    return -1; /* default value */
            }

            int repo_config_get_index_threads(struct repository *r, int *dest)
            {
                    int is_bool, val;

                    val = git_env_ulong("GIT_TEST_INDEX_THREADS", 0);
                    if (val) {
                            *dest = val;
                            return 0;
                    }

                    if (!repo_config_get_bool_or_int(r, "index.threads", &is_bool, &val)) {
                            if (is_bool)
                                    *dest = val ? 0 : 1;
                            else
                                    *dest = val;
                            return 0;
                    }

                    return 1;
            }

            NORETURN
            void git_die_config_linenr(const char *key, const char *filename, int linenr)
            {
                    if (!filename)
                            die(_("unable to parse '%s' from command-line config"), key);
                    else
                            die(_("bad config variable '%s' in file '%s' at line %d"),
                            key, filename, linenr);
            }

            void git_die_config(struct repository *r, const char *key, const char *err, ...)
            {
                    const struct string_list *values;
                    struct key_value_info *kv_info;
                    report_fn error_fn = get_error_routine();

                    if (err) {
                            va_list params;
                            va_start(params, err);
                            error_fn(err, params);
                            va_end(params);
                    }
                    if (repo_config_get_value_multi(r, key, &values))
                            BUG("for key '%s' we must have a value to report on", key);
                    kv_info = values->items[values->nr - 1].util;
                    git_die_config_linenr(key, kv_info->filename, kv_info->linenr);
            }

            /*
            * Find all the stuff for git_config_set() below.
            */

            struct config_store_data {
                    size_t baselen;
                    char *key;
                    int do_not_match;
                    const char *fixed_value;
                    regex_t *value_pattern;
                    int multi_replace;
                    struct {
                            size_t begin, end;
                            enum config_event_t type;
                            int is_keys_section;
                    } *parsed;
                    unsigned int parsed_nr, parsed_alloc, *seen, seen_nr, seen_alloc;
                    unsigned int key_seen:1, section_seen:1, is_keys_section:1;
            };
            #define CONFIG_STORE_INIT { 0 }

            static void config_store_data_clear(struct config_store_data *store)
            {
                    free(store->key);
                    if (store->value_pattern != NULL &&
                    store->value_pattern != CONFIG_REGEX_NONE) {
                            regfree(store->value_pattern);
                            free(store->value_pattern);
                    }
                    free(store->parsed);
                    free(store->seen);
                    memset(store, 0, sizeof(*store));
            }

            static int matches(const char *key, const char *value,
                            const struct config_store_data *store)
            {
                    if (strcmp(key, store->key))
                            return 0; /* not ours */
                    if (store->fixed_value && value)
                            return !strcmp(store->fixed_value, value);
                    if (!store->value_pattern)
                            return 1; /* always matches */
                    if (store->value_pattern == CONFIG_REGEX_NONE)
                            return 0; /* never matches */

                    return store->do_not_match ^
                            (value && !regexec(store->value_pattern, value, 0, NULL, 0));
            }

            static int store_aux_event(enum config_event_t type, size_t begin, size_t end,
                                    struct config_source *cs, void *data)
            {
                    struct config_store_data *store = data;

                    ALLOC_GROW(store->parsed, store->parsed_nr + 1, store->parsed_alloc);
                    store->parsed[store->parsed_nr].begin = begin;
                    store->parsed[store->parsed_nr].end = end;
                    store->parsed[store->parsed_nr].type = type;

                    if (type == CONFIG_EVENT_SECTION) {
                            int (*cmpfn)(const char *, const char *, size_t);

                            if (cs->var.len < 2 || cs->var.buf[cs->var.len - 1] != '.')
                                    return error(_("invalid section name '%s'"), cs->var.buf);

                            if (cs->subsection_case_sensitive)
                                    cmpfn = strncasecmp;
                            else
                                    cmpfn = strncmp;

                            /* Is this the section we were looking for? */
                            store->is_keys_section =
                                    store->parsed[store->parsed_nr].is_keys_section =
                                    cs->var.len - 1 == store->baselen &&
                                    !cmpfn(cs->var.buf, store->key, store->baselen);
                            if (store->is_keys_section) {
                                    store->section_seen = 1;
                                    ALLOC_GROW(store->seen, store->seen_nr + 1,
                                            store->seen_alloc);
                                    store->seen[store->seen_nr] = store->parsed_nr;
                            }
                    }

                    store->parsed_nr++;

                    return 0;
            }

            static int store_aux(const char *key, const char *value,
                            const struct config_context *ctx UNUSED, void *cb)
            {
                    struct config_store_data *store = cb;

                    if (store->key_seen) {
                            if (matches(key, value, store)) {
                                    if (store->seen_nr == 1 && store->multi_replace == 0) {
                                            warning(_("%s has multiple values"), key);
                                    }

                                    ALLOC_GROW(store->seen, store->seen_nr + 1,
                                            store->seen_alloc);

                                    store->seen[store->seen_nr] = store->parsed_nr;
                                    store->seen_nr++;
                            }
                    } else if (store->is_keys_section) {
                            /*
                            * Do not increment matches yet: this may not be a match, but we
                            * are in the desired section.
                            */
                            ALLOC_GROW(store->seen, store->seen_nr + 1, store->seen_alloc);
                            store->seen[store->seen_nr] = store->parsed_nr;
                            store->section_seen = 1;

                            if (matches(key, value, store)) {
                                    store->seen_nr++;
                                    store->key_seen = 1;
                            }
                    }

                    return 0;
            }

            static int write_error(const char *filename)
            {
                    error(_("failed to write new configuration file %s"), filename);

                    /* Same error code as "failed to rename". */
                    return 4;
            }

            static struct strbuf store_create_section(const char *key,
                                                    const struct config_store_data *store)
            {
                    const char *dot;
                    size_t i;
                    struct strbuf sb = STRBUF_INIT;

                    dot = memchr(key, '.', store->baselen);
                    if (dot) {
                            strbuf_addf(&sb, "[%.*s \"", (int)(dot - key), key);
                            for (i = dot - key + 1; i < store->baselen; i++) {
                                    if (key[i] == '"' || key[i] == '\\')
                                            strbuf_addch(&sb, '\\');
                                    strbuf_addch(&sb, key[i]);
                            }
                            strbuf_addstr(&sb, "\"]\n");
                    } else {
                            strbuf_addch(&sb, '[');
                            strbuf_add(&sb, key, store->baselen);
                            strbuf_addstr(&sb, "]\n");
                    }

                    return sb;
            }

            static ssize_t write_section(int fd, const char *key,
                                    const struct config_store_data *store)
            {
                    struct strbuf sb = store_create_section(key, store);
                    ssize_t ret;

                    ret = write_in_full(fd, sb.buf, sb.len);
                    strbuf_release(&sb);

                    return ret;
            }

            static ssize_t write_pair(int fd, const char *key, const char *value,
                                    const char *comment,
                                    const struct config_store_data *store)
            {
                    int i;
                    ssize_t ret;
                    const char *quote = "";
                    struct strbuf sb = STRBUF_INIT;

                    /*
                    * Check to see if the value needs to be surrounded with a dq pair.
                    * Note that problematic characters are always backslash-quoted; this
                    * check is about not losing leading or trailing SP and strings that
                    * follow beginning-of-comment characters (i.e. ';' and '#') by the
                    * configuration parser.
                    */
                    if (value[0] == ' ')
                            quote = "\"";
                    for (i = 0; value[i]; i++)
                            if (value[i] == ';' || value[i] == '#')
                                    quote = "\"";
                    if (i && value[i - 1] == ' ')
                            quote = "\"";

                    strbuf_addf(&sb, "\t%s = %s", key + store->baselen + 1, quote);

                    for (i = 0; value[i]; i++)
                            switch (value[i]) {
                            case '\n':
                                    strbuf_addstr(&sb, "\\n");
                                    break;
                            case '\t':
                                    strbuf_addstr(&sb, "\\t");
                                    break;
                            case '"':
                            case '\\':
                                    strbuf_addch(&sb, '\\');
                                    /* fallthrough */
                            default:
                                    strbuf_addch(&sb, value[i]);
                                    break;
                            }

                    if (comment)
                            strbuf_addf(&sb, "%s%s\n", quote, comment);
                    else
                            strbuf_addf(&sb, "%s\n", quote);

                    ret = write_in_full(fd, sb.buf, sb.len);
                    strbuf_release(&sb);

                    return ret;
            }

            /*
            * If we are about to unset the last key(s) in a section, and if there are
            * no comments surrounding (or included in) the section, we will want to
            * extend begin/end to remove the entire section.
            *
            * Note: the parameter `seen_ptr` points to the index into the store.seen
            * array.  * This index may be incremented if a section has more than one
            * entry (which all are to be removed).
            */
            static void maybe_remove_section(struct config_store_data *store,
                                            size_t *begin_offset, size_t *end_offset,
                                            int *seen_ptr)
            {
                    size_t begin;
                    int i, seen, section_seen = 0;

                    /*
                    * First, ensure that this is the first key, and that there are no
                    * comments before the entry nor before the section header.
                    */
                    seen = *seen_ptr;
                    for (i = store->seen[seen]; i > 0; i--) {
                            enum config_event_t type = store->parsed[i - 1].type;

                            if (type == CONFIG_EVENT_COMMENT)
                                    /* There is a comment before this entry or section */
                                    return;
                            if (type == CONFIG_EVENT_ENTRY) {
                                    if (!section_seen)
                                            /* This is not the section's first entry. */
                                            return;
                                    /* We encountered no comment before the section. */
                                    break;
                            }
                            if (type == CONFIG_EVENT_SECTION) {
                                    if (!store->parsed[i - 1].is_keys_section)
                                            break;
                                    section_seen = 1;
                            }
                    }
                    begin = store->parsed[i].begin;

                    /*
                    * Next, make sure that we are removing the last key(s) in the section,
                    * and that there are no comments that are possibly about the current
                    * section.
                    */
                    for (i = store->seen[seen] + 1; i < store->parsed_nr; i++) {
                            enum config_event_t type = store->parsed[i].type;

                            if (type == CONFIG_EVENT_COMMENT)
                                    return;
                            if (type == CONFIG_EVENT_SECTION) {
                                    if (store->parsed[i].is_keys_section)
                                            continue;
                                    break;
                            }
                            if (type == CONFIG_EVENT_ENTRY) {
                                    if (++seen < store->seen_nr &&
                                    i == store->seen[seen])
                                            /* We want to remove this entry, too */
                                            continue;
                                    /* There is another entry in this section. */
                                    return;
                            }
                    }

                    /*
                    * We are really removing the last entry/entries from this section, and
                    * there are no enclosed or surrounding comments. Remove the entire,
                    * now-empty section.
                    */
                    *seen_ptr = seen;
                    *begin_offset = begin;
                    if (i < store->parsed_nr)
                            *end_offset = store->parsed[i].begin;
                    else
                            *end_offset = store->parsed[store->parsed_nr - 1].end;
            }

            int repo_config_set_in_file_gently(struct repository *r, const char *config_filename,
                                            const char *key, const char *comment, const char *value)
            {
                    return repo_config_set_multivar_in_file_gently(r, config_filename, key, value, NULL, comment, 0);
            }

            void repo_config_set_in_file(struct repository *r, const char *config_filename,
                                    const char *key, const char *value)
            {
                    repo_config_set_multivar_in_file(r, config_filename, key, value, NULL, 0);
            }

            int repo_config_set_gently(struct repository *r, const char *key, const char *value)
            {
                    return repo_config_set_multivar_gently(r, key, value, NULL, 0);
            }

            int repo_config_set_worktree_gently(struct repository *r,
                                            const char *key, const char *value)
            {
                    /* Only use worktree-specific config if it is already enabled. */
                    if (r->repository_format_worktree_config) {
                            char *file = repo_git_path(r, "config.worktree");
                            int ret = repo_config_set_multivar_in_file_gently(
                                                    r, file, key, value, NULL, NULL, 0);
                            free(file);
                            return ret;
                    }
                    return repo_config_set_multivar_gently(r, key, value, NULL, 0);
            }

            void repo_config_set(struct repository *r, const char *key, const char *value)
            {
                    repo_config_set_multivar(r, key, value, NULL, 0);

                    trace2_cmd_set_config(key, value);
            }

            char *git_config_prepare_comment_string(const char *comment)
            {
                    size_t leading_blanks;
                    char *prepared;

                    if (!comment)
                            return NULL;

                    if (strchr(comment, '\n'))
                            die(_("no multi-line comment allowed: '%s'"), comment);

                    /*
                    * If it begins with one or more leading whitespace characters
                    * followed by '#", the comment string is used as-is.
                    *
                    * If it begins with '#', a SP is inserted between the comment
                    * and the value the comment is about.
                    *
                    * Otherwise, the value is followed by a SP followed by '#'
                    * followed by SP and then the comment string comes.
                    */

                    leading_blanks = strspn(comment, " \t");
                    if (leading_blanks && comment[leading_blanks] == '#')
                            prepared = xstrdup(comment); /* use it as-is */
                    else if (comment[0] == '#')
                            prepared = xstrfmt(" %s", comment);
                    else
                            prepared = xstrfmt(" # %s", comment);

                    return prepared;
            }

            static void validate_comment_string(const char *comment)
            {
                    size_t leading_blanks;

                    if (!comment)
                            return;
                    /*
                    * The front-end must have massaged the comment string
                    * properly before calling us.
                    */
                    if (strchr(comment, '\n'))
                            BUG("multi-line comments are not permitted: '%s'", comment);

                    leading_blanks = strspn(comment, " \t");
                    if (!leading_blanks || comment[leading_blanks] != '#')
                            BUG("comment must begin with one or more SP followed by '#': '%s'",
                            comment);
            }

            /*
            * If value==NULL, unset in (remove from) config,
            * if value_pattern!=NULL, disregard key/value pairs where value does not match.
            * if value_pattern==CONFIG_REGEX_NONE, do not match any existing values
            *     (only add a new one)
            * if flags contains the CONFIG_FLAGS_MULTI_REPLACE flag, all matching
            *     key/values are removed before a single new pair is written. If the
            *     flag is not present, then replace only the first match.
            *
            * Returns 0 on success.
            *
            * This function does this:
            *
            * - it locks the config file by creating ".git/config.lock"
            *
            * - it then parses the config using store_aux() as validator to find
            *   the position on the key/value pair to replace. If it is to be unset,
            *   it must be found exactly once.
            *
            * - the config file is mmap()ed and the part before the match (if any) is
            *   written to the lock file, then the changed part and the rest.
            *
            * - the config file is removed and the lock file rename()d to it.
            *
            */
            int repo_config_set_multivar_in_file_gently(struct repository *r,
                                                    const char *config_filename,
                                                    const char *key, const char *value,
                                                    const char *value_pattern,
                                                    const char *comment,
                                                    unsigned flags)
            {
                    int fd = -1, in_fd = -1;
                    int ret;
                    struct lock_file lock = LOCK_INIT;
                    char *filename_buf = NULL;
                    char *contents = NULL;
                    size_t contents_sz;
                    struct config_store_data store = CONFIG_STORE_INIT;

                    validate_comment_string(comment);

                    /* parse-key returns negative; flip the sign to feed exit(3) */
                    ret = 0 - git_config_parse_key(key, &store.key, &store.baselen);
                    if (ret)
                            goto out_free;

                    store.multi_replace = (flags & CONFIG_FLAGS_MULTI_REPLACE) != 0;

                    if (!config_filename)
                            config_filename = filename_buf = repo_git_path(r, "config");

                    /*
                    * The lock serves a purpose in addition to locking: the new
                    * contents of .git/config will be written into it.
                    */
                    fd = hold_lock_file_for_update(&lock, config_filename, 0);
                    if (fd < 0) {
                            error_errno(_("could not lock config file %s"), config_filename);
                            ret = CONFIG_NO_LOCK;
                            goto out_free;
                    }

                    /*
                    * If .git/config does not exist yet, write a minimal version.
                    */
                    in_fd = open(config_filename, O_RDONLY);
                    if ( in_fd < 0 ) {
                            if ( ENOENT != errno ) {
                                    error_errno(_("opening %s"), config_filename);
                                    ret = CONFIG_INVALID_FILE; /* same as "invalid config file" */
                                    goto out_free;
                            }
                            /* if nothing to unset, error out */
                            if (!value) {
                                    ret = CONFIG_NOTHING_SET;
                                    goto out_free;
                            }

                            free(store.key);
                            store.key = xstrdup(key);
                            if (write_section(fd, key, &store) < 0 ||
                            write_pair(fd, key, value, comment, &store) < 0)
                                    goto write_err_out;
                    } else {
                            struct stat st;
                            size_t copy_begin, copy_end;
                            int i, new_line = 0;
                            struct config_options opts;

                            if (!value_pattern)
                                    store.value_pattern = NULL;
                            else if (value_pattern == CONFIG_REGEX_NONE)
                                    store.value_pattern = CONFIG_REGEX_NONE;
                            else if (flags & CONFIG_FLAGS_FIXED_VALUE)
                                    store.fixed_value = value_pattern;
                            else {
                                    if (value_pattern[0] == '!') {
                                            store.do_not_match = 1;
                                            value_pattern++;
                                    } else
                                            store.do_not_match = 0;

                                    store.value_pattern = (regex_t*)xmalloc(sizeof(regex_t));
                                    if (regcomp(store.value_pattern, value_pattern,
                                                    REG_EXTENDED)) {
                                            error(_("invalid pattern: %s"), value_pattern);
                                            FREE_AND_NULL(store.value_pattern);
                                            ret = CONFIG_INVALID_PATTERN;
                                            goto out_free;
                                    }
                            }

                            ALLOC_GROW(store.parsed, 1, store.parsed_alloc);
                            store.parsed[0].end = 0;

                            memset(&opts, 0, sizeof(opts));
                            opts.event_fn = store_aux_event;
                            opts.event_fn_data = &store;

                            /*
                            * After this, store.parsed will contain offsets of all the
                            * parsed elements, and store.seen will contain a list of
                            * matches, as indices into store.parsed.
                            *
                            * As a side effect, we make sure to transform only a valid
                            * existing config file.
                            */
                            if (git_config_from_file_with_options(store_aux,
                                                            config_filename,
                                                            &store, CONFIG_SCOPE_UNKNOWN,
                                                            &opts)) {
                                    error(_("invalid config file %s"), config_filename);
                                    ret = CONFIG_INVALID_FILE;
                                    goto out_free;
                            }

                            /* if nothing to unset, or too many matches, error out */
                            if ((store.seen_nr == 0 && value == NULL) ||
                            (store.seen_nr > 1 && !store.multi_replace)) {
                                    ret = CONFIG_NOTHING_SET;
                                    goto out_free;
                            }

                            if (fstat(in_fd, &st) == -1) {
                                    error_errno(_("fstat on %s failed"), config_filename);
                                    ret = CONFIG_INVALID_FILE;
                                    goto out_free;
                            }

                            contents_sz = xsize_t(st.st_size);
                            contents = xmmap_gently(NULL, contents_sz, PROT_READ,
                                                    MAP_PRIVATE, in_fd, 0);
                            if (contents == MAP_FAILED) {
                                    if (errno == ENODEV && S_ISDIR(st.st_mode))
                                            errno = EISDIR;
                                    error_errno(_("unable to mmap '%s'%s"),
                                                    config_filename, mmap_os_err());
                                    ret = CONFIG_INVALID_FILE;
                                    contents = NULL;
                                    goto out_free;
                            }
                            close(in_fd);
                            in_fd = -1;

                            if (chmod(get_lock_file_path(&lock), st.st_mode & 07777) < 0) {
                                    error_errno(_("chmod on %s failed"), get_lock_file_path(&lock));
                                    ret = CONFIG_NO_WRITE;
                                    goto out_free;
                            }

                            if (store.seen_nr == 0) {
                                    if (!store.seen_alloc) {
                                            /* Did not see key nor section */
                                            ALLOC_GROW(store.seen, 1, store.seen_alloc);
                                            store.seen[0] = store.parsed_nr
                                                    - !!store.parsed_nr;
                                    }
                                    store.seen_nr = 1;
                            }

                            for (i = 0, copy_begin = 0; i < store.seen_nr; i++) {
                                    size_t replace_end;
                                    int j = store.seen[i];

                                    new_line = 0;
                                    if (!store.key_seen) {
                                            copy_end = store.parsed[j].end;
                                            /* include '\n' when copying section header */
                                            if (copy_end > 0 && copy_end < contents_sz &&
                                            contents[copy_end - 1] != '\n' &&
                                            contents[copy_end] == '\n')
                                                    copy_end++;
                                            replace_end = copy_end;
                                    } else {
                                            replace_end = store.parsed[j].end;
                                            copy_end = store.parsed[j].begin;
                                            if (!value)
                                                    maybe_remove_section(&store,
                                                                    &copy_end,
                                                                    &replace_end, &i);
                                            /*
                                            * Swallow preceding white-space on the same
                                            * line.
                                            */
                                            while (copy_end > 0 ) {
                                                    char c = contents[copy_end - 1];

                                                    if (isspace(c) && c != '\n')
                                                            copy_end--;
                                                    else
                                                            break;
                                            }
                                    }

                                    if (copy_end > 0 && contents[copy_end-1] != '\n')
                                            new_line = 1;

                                    /* write the first part of the config */
                                    if (copy_end > copy_begin) {
                                            if (write_in_full(fd, contents + copy_begin,
                                                            copy_end - copy_begin) < 0)
                                                    goto write_err_out;
                                            if (new_line &&
                                            write_str_in_full(fd, "\n") < 0)
                                                    goto write_err_out;
                                    }
                                    copy_begin = replace_end;
                            }

                            /* write the pair (value == NULL means unset) */
                            if (value) {
                                    if (!store.section_seen) {
                                            if (write_section(fd, key, &store) < 0)
                                                    goto write_err_out;
                                    }
                                    if (write_pair(fd, key, value, comment, &store) < 0)
                                            goto write_err_out;
                            }

                            /* write the rest of the config */
                            if (copy_begin < contents_sz)
                                    if (write_in_full(fd, contents + copy_begin,
                                                    contents_sz - copy_begin) < 0)
                                            goto write_err_out;

                            munmap(contents, contents_sz);
                            contents = NULL;
                    }

                    if (commit_lock_file(&lock) < 0) {
                            error_errno(_("could not write config file %s"), config_filename);
                            ret = CONFIG_NO_WRITE;
                            goto out_free;
                    }

                    ret = 0;

                    /* Invalidate the config cache */
                    repo_config_clear(r);

            out_free:
                    rollback_lock_file(&lock);
                    free(filename_buf);
                    if (contents)
                            munmap(contents, contents_sz);
                    if (in_fd >= 0)
                            close(in_fd);
                    config_store_data_clear(&store);
                    return ret;

            write_err_out:
                    ret = write_error(get_lock_file_path(&lock));
                    goto out_free;
            }

            void repo_config_set_multivar_in_file(struct repository *r,
                                            const char *config_filename,
                                            const char *key, const char *value,
                                            const char *value_pattern, unsigned flags)
            {
                    if (!repo_config_set_multivar_in_file_gently(r, config_filename, key, value,
                                                            value_pattern, NULL, flags))
                            return;
                    if (value)
                            die(_("could not set '%s' to '%s'"), key, value);
                    else
                            die(_("could not unset '%s'"), key);
            }

            int repo_config_set_multivar_gently(struct repository *r, const char *key,
                                            const char *value,
                                            const char *value_pattern, unsigned flags)
            {
                    char *file = repo_git_path(r, "config");
                    int res = repo_config_set_multivar_in_file_gently(r, file,
                                                                    key, value,
                                                                    value_pattern,
                                                                    NULL, flags);
                    free(file);
                    return res;
            }

            void repo_config_set_multivar(struct repository *r,
                                    const char *key, const char *value,
                                    const char *value_pattern, unsigned flags)
            {
                    char *file = repo_git_path(r, "config");
                    repo_config_set_multivar_in_file(r, file, key, value,
                                                    value_pattern, flags);
                    free(file);
            }

            static size_t section_name_match (const char *buf, const char *name)
            {
                    size_t i = 0, j = 0;
                    int dot = 0;
                    if (buf[i] != '[')
                            return 0;
                    for (i = 1; buf[i] && buf[i] != ']'; i++) {
                            if (!dot && isspace(buf[i])) {
                                    dot = 1;
                                    if (name[j++] != '.')
                                            break;
                                    for (i++; isspace(buf[i]); i++)
                                            ; /* do nothing */
                                    if (buf[i] != '"')
                                            break;
                                    continue;
                            }
                            if (buf[i] == '\\' && dot)
                                    i++;
                            else if (buf[i] == '"' && dot) {
                                    for (i++; isspace(buf[i]); i++)
                                            ; /* do_nothing */
                                    break;
                            }
                            if (buf[i] != name[j++])
                                    break;
                    }
                    if (buf[i] == ']' && name[j] == 0) {
                            /*
                            * We match, now just find the right length offset by
                            * gobbling up any whitespace after it, as well
                            */
                            i++;
                            for (; buf[i] && isspace(buf[i]); i++)
                                    ; /* do nothing */
                            return i;
                    }
                    return 0;
            }

            static int section_name_is_ok(const char *name)
            {
                    /* Empty section names are bogus. */
                    if (!*name)
                            return 0;

                    /*
                    * Before a dot, we must be alphanumeric or dash. After the first dot,
                    * anything goes, so we can stop checking.
                    */
                    for (; *name && *name != '.'; name++)
                            if (*name != '-' && !isalnum(*name))
                                    return 0;
                    return 1;
            }

            #define GIT_CONFIG_MAX_LINE_LEN (512 * 1024)

            /* if new_name == NULL, the section is removed instead */
            static int repo_config_copy_or_rename_section_in_file(
                    struct repository *r,
                    const char *config_filename,
                    const char *old_name,
                    const char *new_name, int copy)
            {
                    int ret = 0, remove = 0;
                    char *filename_buf = NULL;
                    struct lock_file lock = LOCK_INIT;
                    int out_fd;
                    struct strbuf buf = STRBUF_INIT;
                    FILE *config_file = NULL;
                    struct stat st;
                    struct strbuf copystr = STRBUF_INIT;
                    struct config_store_data store;
                    uint32_t line_nr = 0;

                    memset(&store, 0, sizeof(store));

                    if (new_name && !section_name_is_ok(new_name)) {
                            ret = error(_("invalid section name: %s"), new_name);
                            goto out_no_rollback;
                    }

                    if (!config_filename)
                            config_filename = filename_buf = repo_git_path(r, "config");

                    out_fd = hold_lock_file_for_update(&lock, config_filename, 0);
                    if (out_fd < 0) {
                            ret = error(_("could not lock config file %s"), config_filename);
                            goto out;
                    }

                    if (!(config_file = fopen(config_filename, "rb"))) {
                            ret = warn_on_fopen_errors(config_filename);
                            if (ret)
                                    goto out;
                            /* no config file means nothing to rename, no error */
                            goto commit_and_out;
                    }

                    if (fstat(fileno(config_file), &st) == -1) {
                            ret = error_errno(_("fstat on %s failed"), config_filename);
                            goto out;
                    }

                    if (chmod(get_lock_file_path(&lock), st.st_mode & 07777) < 0) {
                            ret = error_errno(_("chmod on %s failed"),
                                            get_lock_file_path(&lock));
                            goto out;
                    }

                    while (!strbuf_getwholeline(&buf, config_file, '\n')) {
                            size_t i, length;
                            int is_section = 0;
                            char *output = buf.buf;

                            line_nr++;

                            if (buf.len >= GIT_CONFIG_MAX_LINE_LEN) {
                                    ret = error(_("refusing to work with overly long line "
                                            "in '%s' on line %"PRIuMAX),
                                            config_filename, (uintmax_t)line_nr);
                                    goto out;
                            }

                            for (i = 0; buf.buf[i] && isspace(buf.buf[i]); i++)
                                    ; /* do nothing */
                            if (buf.buf[i] == '[') {
                                    /* it's a section */
                                    size_t offset;
                                    is_section = 1;

                                    /*
                                    * When encountering a new section under -c we
                                    * need to flush out any section we're already
                                    * coping and begin anew. There might be
                                    * multiple [branch "$name"] sections.
                                    */
                                    if (copystr.len > 0) {
                                            if (write_in_full(out_fd, copystr.buf, copystr.len) < 0) {
                                                    ret = write_error(get_lock_file_path(&lock));
                                                    goto out;
                                            }
                                            strbuf_reset(&copystr);
                                    }

                                    offset = section_name_match(&buf.buf[i], old_name);
                                    if (offset > 0) {
                                            ret++;
                                            if (!new_name) {
                                                    remove = 1;
                                                    continue;
                                            }
                                            store.baselen = strlen(new_name);
                                            if (!copy) {
                                                    if (write_section(out_fd, new_name, &store) < 0) {
                                                            ret = write_error(get_lock_file_path(&lock));
                                                            goto out;
                                                    }
                                                    /*
                                                    * We wrote out the new section, with
                                                    * a newline, now skip the old
                                                    * section's length
                                                    */
                                                    output += offset + i;
                                                    if (strlen(output) > 0) {
                                                            /*
                                                            * More content means there's
                                                            * a declaration to put on the
                                                            * next line; indent with a
                                                            * tab
                                                            */
                                                            output -= 1;
                                                            output[0] = '\t';
                                                    }
                                            } else {
                                                    strbuf_release(&copystr);
                                                    copystr = store_create_section(new_name, &store);
                                            }
                                    }
                                    remove = 0;
                            }
                            if (remove)
                                    continue;
                            length = strlen(output);

                            if (!is_section && copystr.len > 0) {
                                    strbuf_add(&copystr, output, length);
                            }

                            if (write_in_full(out_fd, output, length) < 0) {
                                    ret = write_error(get_lock_file_path(&lock));
                                    goto out;
                            }
                    }

                    /*
                    * Copy a trailing section at the end of the config, won't be
                    * flushed by the usual "flush because we have a new section
                    * logic in the loop above.
                    */
                    if (copystr.len > 0) {
                            if (write_in_full(out_fd, copystr.buf, copystr.len) < 0) {
                                    ret = write_error(get_lock_file_path(&lock));
                                    goto out;
                            }
                            strbuf_reset(&copystr);
                    }

                    fclose(config_file);
                    config_file = NULL;
            commit_and_out:
                    if (commit_lock_file(&lock) < 0)
                            ret = error_errno(_("could not write config file %s"),
                                            config_filename);
            out:
                    if (config_file)
                            fclose(config_file);
                    rollback_lock_file(&lock);
            out_no_rollback:
                    free(filename_buf);
                    config_store_data_clear(&store);
                    strbuf_release(&buf);
                    strbuf_release(&copystr);
                    return ret;
            }

            int repo_config_rename_section_in_file(struct repository *r, const char *config_filename,
                                            const char *old_name, const char *new_name)
            {
                    return repo_config_copy_or_rename_section_in_file(r, config_filename,
                                                    old_name, new_name, 0);
            }

            int repo_config_rename_section(struct repository *r, const char *old_name, const char *new_name)
            {
                    return repo_config_rename_section_in_file(r, NULL, old_name, new_name);
            }

            int repo_config_copy_section_in_file(struct repository *r, const char *config_filename,
                                            const char *old_name, const char *new_name)
            {
                    return repo_config_copy_or_rename_section_in_file(r, config_filename,
                                                    old_name, new_name, 1);
            }

            int repo_config_copy_section(struct repository *r, const char *old_name, const char *new_name)
            {
                    return repo_config_copy_section_in_file(r, NULL, old_name, new_name);
            }

            /*
            * Call this to report error for your variable that should not
            * get a boolean value (i.e. "[my] var" means "true").
            */
            #undef config_error_nonbool
            int config_error_nonbool(const char *var)
            {
                    return error(_("missing value for '%s'"), var);
            }

            int parse_config_key(const char *var,
                            const char *section,
                            const char **subsection, size_t *subsection_len,
                            const char **key)
            {
                    const char *dot;

                    /* Does it start with "section." ? */
                    if (!skip_prefix(var, section, &var) || *var != '.')
                            return -1;

                    /*
                    * Find the key; we don't know yet if we have a subsection, but we must
                    * parse backwards from the end, since the subsection may have dots in
                    * it, too.
                    */
                    dot = strrchr(var, '.');
                    *key = dot + 1;

                    /* Did we have a subsection at all? */
                    if (dot == var) {
                            if (subsection) {
                                    *subsection = NULL;
                                    *subsection_len = 0;
                            }
                    }
                    else {
                            if (!subsection)
                                    return -1;
                            *subsection = var + 1;
                            *subsection_len = dot - *subsection;
                    }

                    return 0;
            }

            const char *config_origin_type_name(enum config_origin_type type)
            {
                    switch (type) {
                    case CONFIG_ORIGIN_BLOB:
                            return "blob";
                    case CONFIG_ORIGIN_FILE:
                            return "file";
                    case CONFIG_ORIGIN_STDIN:
                            return "standard input";
                    case CONFIG_ORIGIN_SUBMODULE_BLOB:
                            return "submodule-blob";
                    case CONFIG_ORIGIN_CMDLINE:
                            return "command line";
                    default:
                            BUG("unknown config origin type");
                    }
            }

            const char *config_scope_name(enum config_scope scope)
            {
                    switch (scope) {
                    case CONFIG_SCOPE_SYSTEM:
                            return "system";
                    case CONFIG_SCOPE_GLOBAL:
                            return "global";
                    case CONFIG_SCOPE_LOCAL:
                            return "local";
                    case CONFIG_SCOPE_WORKTREE:
                            return "worktree";
                    case CONFIG_SCOPE_COMMAND:
                            return "command";
                    case CONFIG_SCOPE_SUBMODULE:
                            return "submodule";
                    default:
                            return "unknown";
                    }
            }

            int lookup_config(const char **mapping, int nr_mapping, const char *var)
            {
                    int i;

                    for (i = 0; i < nr_mapping; i++) {
                            const char *name = mapping[i];

                            if (name && !strcasecmp(var, name))
                                    return i;
                    }
                    return -1;
            }

        """,

        "error":"z/OS uses specific file tags and metadata that are different from typical systems like Linux or Windows.
                 The core.ignorefiletags configuration option allows users to control whether these file tags should be ignored during
                 Git operations. /OS may use EBCDIC, and the patch introduces the core.utf8ccsid option to handle UTF-8 encoding properly
                 by specifying the appropriate CCSID. This ensures that files are correctly interpreted and processed with the right
                 encoding, reducing the risk of data corruption or misinterpretation.",
        "error Category":"Functionality Patch",

        "Corrected Code"
        """
                    /*
            * GIT - The information manager from hell
            *
            * Copyright (C) Linus Torvalds, 2005
            * Copyright (C) Johannes Schindelin, 2005
            *
            */

            #define USE_THE_REPOSITORY_VARIABLE
            #define DISABLE_SIGN_COMPARE_WARNINGS

            #include "git-compat-util.h"
            #include "abspath.h"
            #include "advice.h"
            #include "date.h"
            #include "branch.h"
            #include "config.h"
            #include "parse.h"
            #include "convert.h"
            #include "environment.h"
            #include "gettext.h"
            #include "ident.h"
            #include "repository.h"
            #include "lockfile.h"
            #include "mailmap.h"
            #include "attr.h"
            #include "exec-cmd.h"
            #include "strbuf.h"
            #include "quote.h"
            #include "hashmap.h"
            #include "string-list.h"
            #include "object-name.h"
            #include "object-store-ll.h"
            #include "pager.h"
            #include "path.h"
            #ifdef __MVS__
            #include "read-cache-ll.h"
            #endif
            #include "utf8.h"
            #include "color.h"
            #include "refs.h"
            #include "setup.h"
            #include "strvec.h"
            #include "trace2.h"
            #include "wildmatch.h"
            #include "ws.h"
            #include "write-or-die.h"

            struct config_source {
                    struct config_source *prev;
                    union {
                            FILE *file;
                            struct config_buf {
                                    const char *buf;
                                    size_t len;
                                    size_t pos;
                            } buf;
                    } u;
                    enum config_origin_type origin_type;
                    const char *name;
                    const char *path;
                    enum config_error_action default_error_action;
                    int linenr;
                    int eof;
                    size_t total_len;
                    struct strbuf value;
                    struct strbuf var;
                    unsigned subsection_case_sensitive : 1;

                    int (*do_fgetc)(struct config_source *c);
                    int (*do_ungetc)(int c, struct config_source *conf);
                    long (*do_ftell)(struct config_source *c);
            };
            #define CONFIG_SOURCE_INIT { 0 }

            static int pack_compression_seen;
            static int zlib_compression_seen;

            /*
            * Config that comes from trusted scopes, namely:
            * - CONFIG_SCOPE_SYSTEM (e.g. /etc/gitconfig)
            * - CONFIG_SCOPE_GLOBAL (e.g. $HOME/.gitconfig, $XDG_CONFIG_HOME/git)
            * - CONFIG_SCOPE_COMMAND (e.g. "-c" option, environment variables)
            *
            * This is declared here for code cleanliness, but unlike the other
            * static variables, this does not hold config parser state.
            */
            static struct config_set protected_config;

            static int config_file_fgetc(struct config_source *conf)
            {
                    return getc_unlocked(conf->u.file);
            }

            static int config_file_ungetc(int c, struct config_source *conf)
            {
                    return ungetc(c, conf->u.file);
            }

            static long config_file_ftell(struct config_source *conf)
            {
                    return ftell(conf->u.file);
            }

            static int config_buf_fgetc(struct config_source *conf)
            {
                    if (conf->u.buf.pos < conf->u.buf.len)
                            return conf->u.buf.buf[conf->u.buf.pos++];

                    return EOF;
            }

            static int config_buf_ungetc(int c, struct config_source *conf)
            {
                    if (conf->u.buf.pos > 0) {
                            conf->u.buf.pos--;
                            if (conf->u.buf.buf[conf->u.buf.pos] != c)
                                    BUG("config_buf can only ungetc the same character");
                            return c;
                    }

                    return EOF;
            }

            static long config_buf_ftell(struct config_source *conf)
            {
                    return conf->u.buf.pos;
            }

            struct config_include_data {
                    int depth;
                    config_fn_t fn;
                    void *data;
                    const struct config_options *opts;
                    const struct git_config_source *config_source;
                    struct repository *repo;

                    /*
                    * All remote URLs discovered when reading all config files.
                    */
                    struct string_list *remote_urls;
            };
            #define CONFIG_INCLUDE_INIT { 0 }

            static int git_config_include(const char *var, const char *value,
                                    const struct config_context *ctx, void *data);

            #define MAX_INCLUDE_DEPTH 10
            static const char include_depth_advice[] = N_(
            "exceeded maximum include depth (%d) while including\n"
            "       %s\n"
            "from\n"
            "       %s\n"
            "This might be due to circular includes.");
            static int handle_path_include(const struct key_value_info *kvi,
                                    const char *path,
                                    struct config_include_data *inc)
            {
                    int ret = 0;
                    struct strbuf buf = STRBUF_INIT;
                    char *expanded;

                    if (!path)
                            return config_error_nonbool("include.path");

                    expanded = interpolate_path(path, 0);
                    if (!expanded)
                            return error(_("could not expand include path '%s'"), path);
                    path = expanded;

                    /*
                    * Use an absolute path as-is, but interpret relative paths
                    * based on the including config file.
                    */
                    if (!is_absolute_path(path)) {
                            char *slash;

                            if (!kvi || !kvi->path) {
                                    ret = error(_("relative config includes must come from files"));
                                    goto cleanup;
                            }

                            slash = find_last_dir_sep(kvi->path);
                            if (slash)
                                    strbuf_add(&buf, kvi->path, slash - kvi->path + 1);
                            strbuf_addstr(&buf, path);
                            path = buf.buf;
                    }

                    if (!access_or_die(path, R_OK, 0)) {
                            if (++inc->depth > MAX_INCLUDE_DEPTH)
                                    die(_(include_depth_advice), MAX_INCLUDE_DEPTH, path,
                                    !kvi ? "<unknown>" :
                                    kvi->filename ? kvi->filename :
                                    "the command line");
                            ret = git_config_from_file_with_options(git_config_include, path, inc,
                                                                    kvi->scope, NULL);
                            inc->depth--;
                    }
            cleanup:
                    strbuf_release(&buf);
                    free(expanded);
                    return ret;
            }

            static void add_trailing_starstar_for_dir(struct strbuf *pat)
            {
                    if (pat->len && is_dir_sep(pat->buf[pat->len - 1]))
                            strbuf_addstr(pat, "**");
            }

            static int prepare_include_condition_pattern(const struct key_value_info *kvi,
                                                    struct strbuf *pat)
            {
                    struct strbuf path = STRBUF_INIT;
                    char *expanded;
                    int prefix = 0;

                    expanded = interpolate_path(pat->buf, 1);
                    if (expanded) {
                            strbuf_reset(pat);
                            strbuf_addstr(pat, expanded);
                            free(expanded);
                    }

                    if (pat->buf[0] == '.' && is_dir_sep(pat->buf[1])) {
                            const char *slash;

                            if (!kvi || !kvi->path)
                                    return error(_("relative config include "
                                            "conditionals must come from files"));

                            strbuf_realpath(&path, kvi->path, 1);
                            slash = find_last_dir_sep(path.buf);
                            if (!slash)
                                    BUG("how is this possible?");
                            strbuf_splice(pat, 0, 1, path.buf, slash - path.buf);
                            prefix = slash - path.buf + 1 /* slash */;
                    } else if (!is_absolute_path(pat->buf))
                            strbuf_insertstr(pat, 0, "**/");

                    add_trailing_starstar_for_dir(pat);

                    strbuf_release(&path);
                    return prefix;
            }

            static int include_by_gitdir(const struct key_value_info *kvi,
                                    const struct config_options *opts,
                                    const char *cond, size_t cond_len, int icase)
            {
                    struct strbuf text = STRBUF_INIT;
                    struct strbuf pattern = STRBUF_INIT;
                    int ret = 0, prefix;
                    const char *git_dir;
                    int already_tried_absolute = 0;

                    if (opts->git_dir)
                            git_dir = opts->git_dir;
                    else
                            goto done;

                    strbuf_realpath(&text, git_dir, 1);
                    strbuf_add(&pattern, cond, cond_len);
                    prefix = prepare_include_condition_pattern(kvi, &pattern);

            again:
                    if (prefix < 0)
                            goto done;

                    if (prefix > 0) {
                            /*
                            * perform literal matching on the prefix part so that
                            * any wildcard character in it can't create side effects.
                            */
                            if (text.len < prefix)
                                    goto done;
                            if (!icase && strncmp(pattern.buf, text.buf, prefix))
                                    goto done;
                            if (icase && strncasecmp(pattern.buf, text.buf, prefix))
                                    goto done;
                    }

                    ret = !wildmatch(pattern.buf + prefix, text.buf + prefix,
                                    WM_PATHNAME | (icase ? WM_CASEFOLD : 0));

                    if (!ret && !already_tried_absolute) {
                            /*
                            * We've tried e.g. matching gitdir:~/work, but if
                            * ~/work is a symlink to /mnt/storage/work
                            * strbuf_realpath() will expand it, so the rule won't
                            * match. Let's match against a
                            * strbuf_add_absolute_path() version of the path,
                            * which'll do the right thing
                            */
                            strbuf_reset(&text);
                            strbuf_add_absolute_path(&text, git_dir);
                            already_tried_absolute = 1;
                            goto again;
                    }
            done:
                    strbuf_release(&pattern);
                    strbuf_release(&text);
                    return ret;
            }

            static int include_by_branch(struct config_include_data *data,
                                    const char *cond, size_t cond_len)
            {
                    int flags;
                    int ret;
                    struct strbuf pattern = STRBUF_INIT;
                    const char *refname, *shortname;

                    if (!data->repo || data->repo->ref_storage_format == REF_STORAGE_FORMAT_UNKNOWN)
                            return 0;

                    refname = refs_resolve_ref_unsafe(get_main_ref_store(data->repo),
                                                    "HEAD", 0, NULL, &flags);
                    if (!refname ||
                    !(flags & REF_ISSYMREF) ||
                    !skip_prefix(refname, "refs/heads/", &shortname))
                            return 0;

                    strbuf_add(&pattern, cond, cond_len);
                    add_trailing_starstar_for_dir(&pattern);
                    ret = !wildmatch(pattern.buf, shortname, WM_PATHNAME);
                    strbuf_release(&pattern);
                    return ret;
            }

            static int add_remote_url(const char *var, const char *value,
                                    const struct config_context *ctx UNUSED, void *data)
            {
                    struct string_list *remote_urls = data;
                    const char *remote_name;
                    size_t remote_name_len;
                    const char *key;

                    if (!parse_config_key(var, "remote", &remote_name, &remote_name_len,
                                    &key) &&
                    remote_name &&
                    !strcmp(key, "url"))
                            string_list_append(remote_urls, value);
                    return 0;
            }

            static void populate_remote_urls(struct config_include_data *inc)
            {
                    struct config_options opts;

                    opts = *inc->opts;
                    opts.unconditional_remote_url = 1;

                    inc->remote_urls = xmalloc(sizeof(*inc->remote_urls));
                    string_list_init_dup(inc->remote_urls);
                    config_with_options(add_remote_url, inc->remote_urls,
                                    inc->config_source, inc->repo, &opts);
            }

            static int forbid_remote_url(const char *var, const char *value UNUSED,
                                    const struct config_context *ctx UNUSED,
                                    void *data UNUSED)
            {
                    const char *remote_name;
                    size_t remote_name_len;
                    const char *key;

                    if (!parse_config_key(var, "remote", &remote_name, &remote_name_len,
                                    &key) &&
                    remote_name &&
                    !strcmp(key, "url"))
                            die(_("remote URLs cannot be configured in file directly or indirectly included by includeIf.hasconfig:remote.*.url"));
                    return 0;
            }

            static int at_least_one_url_matches_glob(const char *glob, int glob_len,
                                                    struct string_list *remote_urls)
            {
                    struct strbuf pattern = STRBUF_INIT;
                    struct string_list_item *url_item;
                    int found = 0;

                    strbuf_add(&pattern, glob, glob_len);
                    for_each_string_list_item(url_item, remote_urls) {
                            if (!wildmatch(pattern.buf, url_item->string, WM_PATHNAME)) {
                                    found = 1;
                                    break;
                            }
                    }
                    strbuf_release(&pattern);
                    return found;
            }

            static int include_by_remote_url(struct config_include_data *inc,
                            const char *cond, size_t cond_len)
            {
                    if (inc->opts->unconditional_remote_url)
                            return 1;
                    if (!inc->remote_urls)
                            populate_remote_urls(inc);
                    return at_least_one_url_matches_glob(cond, cond_len,
                                                    inc->remote_urls);
            }

            static int include_condition_is_true(const struct key_value_info *kvi,
                                            struct config_include_data *inc,
                                            const char *cond, size_t cond_len)
            {
                    const struct config_options *opts = inc->opts;

                    if (skip_prefix_mem(cond, cond_len, "gitdir:", &cond, &cond_len))
                            return include_by_gitdir(kvi, opts, cond, cond_len, 0);
                    else if (skip_prefix_mem(cond, cond_len, "gitdir/i:", &cond, &cond_len))
                            return include_by_gitdir(kvi, opts, cond, cond_len, 1);
                    else if (skip_prefix_mem(cond, cond_len, "onbranch:", &cond, &cond_len))
                            return include_by_branch(inc, cond, cond_len);
                    else if (skip_prefix_mem(cond, cond_len, "hasconfig:remote.*.url:", &cond,
                                            &cond_len))
                            return include_by_remote_url(inc, cond, cond_len);

                    /* unknown conditionals are always false */
                    return 0;
            }

            static int git_config_include(const char *var, const char *value,
                                    const struct config_context *ctx,
                                    void *data)
            {
                    struct config_include_data *inc = data;
                    const char *cond, *key;
                    size_t cond_len;
                    int ret;

                    /*
                    * Pass along all values, including "include" directives; this makes it
                    * possible to query information on the includes themselves.
                    */
                    ret = inc->fn(var, value, ctx, inc->data);
                    if (ret < 0)
                            return ret;

                    if (!strcmp(var, "include.path"))
                            ret = handle_path_include(ctx->kvi, value, inc);

                    if (!parse_config_key(var, "includeif", &cond, &cond_len, &key) &&
                    cond && include_condition_is_true(ctx->kvi, inc, cond, cond_len) &&
                    !strcmp(key, "path")) {
                            config_fn_t old_fn = inc->fn;

                            if (inc->opts->unconditional_remote_url)
                                    inc->fn = forbid_remote_url;
                            ret = handle_path_include(ctx->kvi, value, inc);
                            inc->fn = old_fn;
                    }

                    return ret;
            }

            static void git_config_push_split_parameter(const char *key, const char *value)
            {
                    struct strbuf env = STRBUF_INIT;
                    const char *old = getenv(CONFIG_DATA_ENVIRONMENT);
                    if (old && *old) {
                            strbuf_addstr(&env, old);
                            strbuf_addch(&env, ' ');
                    }
                    sq_quote_buf(&env, key);
                    strbuf_addch(&env, '=');
                    if (value)
                            sq_quote_buf(&env, value);
                    setenv(CONFIG_DATA_ENVIRONMENT, env.buf, 1);
                    strbuf_release(&env);
            }

            void git_config_push_parameter(const char *text)
            {
                    const char *value;

                    /*
                    * When we see:
                    *
                    *   section.subsection=with=equals.key=value
                    *
                    * we cannot tell if it means:
                    *
                    *   [section "subsection=with=equals"]
                    *   key = value
                    *
                    * or:
                    *
                    *   [section]
                    *   subsection = with=equals.key=value
                    *
                    * We parse left-to-right for the first "=", meaning we'll prefer to
                    * keep the value intact over the subsection. This is historical, but
                    * also sensible since values are more likely to contain odd or
                    * untrusted input than a section name.
                    *
                    * A missing equals is explicitly allowed (as a bool-only entry).
                    */
                    value = strchr(text, '=');
                    if (value) {
                            char *key = xmemdupz(text, value - text);
                            git_config_push_split_parameter(key, value + 1);
                            free(key);
                    } else {
                            git_config_push_split_parameter(text, NULL);
                    }
            }

            void git_config_push_env(const char *spec)
            {
                    char *key;
                    const char *env_name;
                    const char *env_value;

                    env_name = strrchr(spec, '=');
                    if (!env_name)
                            die(_("invalid config format: %s"), spec);
                    key = xmemdupz(spec, env_name - spec);
                    env_name++;
                    if (!*env_name)
                            die(_("missing environment variable name for configuration '%.*s'"),
                            (int)(env_name - spec - 1), spec);

                    env_value = getenv(env_name);
                    if (!env_value)
                            die(_("missing environment variable '%s' for configuration '%.*s'"),
                            env_name, (int)(env_name - spec - 1), spec);

                    git_config_push_split_parameter(key, env_value);
                    free(key);
            }

            static inline int iskeychar(int c)
            {
                    return isalnum(c) || c == '-';
            }

            /*
            * Auxiliary function to sanity-check and split the key into the section
            * identifier and variable name.
            *
            * Returns 0 on success, -1 when there is an invalid character in the key and
            * -2 if there is no section name in the key.
            *
            * store_key - pointer to char* which will hold a copy of the key with
            *             lowercase section and variable name
            * baselen - pointer to size_t which will hold the length of the
            *           section + subsection part, can be NULL
            */
            int git_config_parse_key(const char *key, char **store_key, size_t *baselen_)
            {
                    size_t i, baselen;
                    int dot;
                    const char *last_dot = strrchr(key, '.');

                    /*
                    * Since "key" actually contains the section name and the real
                    * key name separated by a dot, we have to know where the dot is.
                    */

                    if (last_dot == NULL || last_dot == key) {
                            error(_("key does not contain a section: %s"), key);
                            return -CONFIG_NO_SECTION_OR_NAME;
                    }

                    if (!last_dot[1]) {
                            error(_("key does not contain variable name: %s"), key);
                            return -CONFIG_NO_SECTION_OR_NAME;
                    }

                    baselen = last_dot - key;
                    if (baselen_)
                            *baselen_ = baselen;

                    /*
                    * Validate the key and while at it, lower case it for matching.
                    */
                    *store_key = xmallocz(strlen(key));

                    dot = 0;
                    for (i = 0; key[i]; i++) {
                            unsigned char c = key[i];
                            if (c == '.')
                                    dot = 1;
                            /* Leave the extended basename untouched.. */
                            if (!dot || i > baselen) {
                                    if (!iskeychar(c) ||
                                    (i == baselen + 1 && !isalpha(c))) {
                                            error(_("invalid key: %s"), key);
                                            goto out_free_ret_1;
                                    }
                                    c = tolower(c);
                            } else if (c == '\n') {
                                    error(_("invalid key (newline): %s"), key);
                                    goto out_free_ret_1;
                            }
                            (*store_key)[i] = c;
                    }

                    return 0;

            out_free_ret_1:
                    FREE_AND_NULL(*store_key);
                    return -CONFIG_INVALID_KEY;
            }

            static int config_parse_pair(const char *key, const char *value,
                                    struct key_value_info *kvi,
                                    config_fn_t fn, void *data)
            {
                    char *canonical_name;
                    int ret;
                    struct config_context ctx = {
                            .kvi = kvi,
                    };

                    if (!strlen(key))
                            return error(_("empty config key"));
                    if (git_config_parse_key(key, &canonical_name, NULL))
                            return -1;

                    ret = (fn(canonical_name, value, &ctx, data) < 0) ? -1 : 0;
                    free(canonical_name);
                    return ret;
            }


            /* for values read from `git_config_from_parameters()` */
            void kvi_from_param(struct key_value_info *out)
            {
                    out->filename = NULL;
                    out->linenr = -1;
                    out->origin_type = CONFIG_ORIGIN_CMDLINE;
                    out->scope = CONFIG_SCOPE_COMMAND;
                    out->path = NULL;
            }

            int git_config_parse_parameter(const char *text,
                                    config_fn_t fn, void *data)
            {
                    const char *value;
                    struct strbuf **pair;
                    int ret;
                    struct key_value_info kvi = KVI_INIT;

                    kvi_from_param(&kvi);

                    pair = strbuf_split_str(text, '=', 2);
                    if (!pair[0])
                            return error(_("bogus config parameter: %s"), text);

                    if (pair[0]->len && pair[0]->buf[pair[0]->len - 1] == '=') {
                            strbuf_setlen(pair[0], pair[0]->len - 1);
                            value = pair[1] ? pair[1]->buf : "";
                    } else {
                            value = NULL;
                    }

                    strbuf_trim(pair[0]);
                    if (!pair[0]->len) {
                            strbuf_list_free(pair);
                            return error(_("bogus config parameter: %s"), text);
                    }

                    ret = config_parse_pair(pair[0]->buf, value, &kvi, fn, data);
                    strbuf_list_free(pair);
                    return ret;
            }

            static int parse_config_env_list(char *env, struct key_value_info *kvi,
                                            config_fn_t fn, void *data)
            {
                    char *cur = env;
                    while (cur && *cur) {
                            const char *key = sq_dequote_step(cur, &cur);
                            if (!key)
                                    return error(_("bogus format in %s"),
                                            CONFIG_DATA_ENVIRONMENT);

                            if (!cur || isspace(*cur)) {
                                    /* old-style 'key=value' */
                                    if (git_config_parse_parameter(key, fn, data) < 0)
                                            return -1;
                            }
                            else if (*cur == '=') {
                                    /* new-style 'key'='value' */
                                    const char *value;

                                    cur++;
                                    if (*cur == '\'') {
                                            /* quoted value */
                                            value = sq_dequote_step(cur, &cur);
                                            if (!value || (cur && !isspace(*cur))) {
                                                    return error(_("bogus format in %s"),
                                                            CONFIG_DATA_ENVIRONMENT);
                                            }
                                    } else if (!*cur || isspace(*cur)) {
                                            /* implicit bool: 'key'= */
                                            value = NULL;
                                    } else {
                                            return error(_("bogus format in %s"),
                                                    CONFIG_DATA_ENVIRONMENT);
                                    }

                                    if (config_parse_pair(key, value, kvi, fn, data) < 0)
                                            return -1;
                            }
                            else {
                                    /* unknown format */
                                    return error(_("bogus format in %s"),
                                            CONFIG_DATA_ENVIRONMENT);
                            }

                            if (cur) {
                                    while (isspace(*cur))
                                            cur++;
                            }
                    }
                    return 0;
            }

            int git_config_from_parameters(config_fn_t fn, void *data)
            {
                    const char *env;
                    struct strbuf envvar = STRBUF_INIT;
                    struct strvec to_free = STRVEC_INIT;
                    int ret = 0;
                    char *envw = NULL;
                    struct key_value_info kvi = KVI_INIT;

                    kvi_from_param(&kvi);
                    env = getenv(CONFIG_COUNT_ENVIRONMENT);
                    if (env) {
                            unsigned long count;
                            char *endp;
                            int i;

                            count = strtoul(env, &endp, 10);
                            if (*endp) {
                                    ret = error(_("bogus count in %s"), CONFIG_COUNT_ENVIRONMENT);
                                    goto out;
                            }
                            if (count > INT_MAX) {
                                    ret = error(_("too many entries in %s"), CONFIG_COUNT_ENVIRONMENT);
                                    goto out;
                            }

                            for (i = 0; i < count; i++) {
                                    const char *key, *value;

                                    strbuf_addf(&envvar, "GIT_CONFIG_KEY_%d", i);
                                    key = getenv_safe(&to_free, envvar.buf);
                                    if (!key) {
                                            ret = error(_("missing config key %s"), envvar.buf);
                                            goto out;
                                    }
                                    strbuf_reset(&envvar);

                                    strbuf_addf(&envvar, "GIT_CONFIG_VALUE_%d", i);
                                    value = getenv_safe(&to_free, envvar.buf);
                                    if (!value) {
                                            ret = error(_("missing config value %s"), envvar.buf);
                                            goto out;
                                    }
                                    strbuf_reset(&envvar);

                                    if (config_parse_pair(key, value, &kvi, fn, data) < 0) {
                                            ret = -1;
                                            goto out;
                                    }
                            }
                    }

                    env = getenv(CONFIG_DATA_ENVIRONMENT);
                    if (env) {
                            /* sq_dequote will write over it */
                            envw = xstrdup(env);
                            if (parse_config_env_list(envw, &kvi, fn, data) < 0) {
                                    ret = -1;
                                    goto out;
                            }
                    }

            out:
                    strbuf_release(&envvar);
                    strvec_clear(&to_free);
                    free(envw);
                    return ret;
            }

            static int get_next_char(struct config_source *cs)
            {
                    int c = cs->do_fgetc(cs);

                    if (c == '\r') {
                            /* DOS like systems */
                            c = cs->do_fgetc(cs);
                            if (c != '\n') {
                                    if (c != EOF)
                                            cs->do_ungetc(c, cs);
                                    c = '\r';
                            }
                    }

                    if (c != EOF && ++cs->total_len > INT_MAX) {
                            /*
                            * This is an absurdly long config file; refuse to parse
                            * further in order to protect downstream code from integer
                            * overflows. Note that we can't return an error specifically,
                            * but we can mark EOF and put trash in the return value,
                            * which will trigger a parse error.
                            */
                            cs->eof = 1;
                            return 0;
                    }

                    if (c == '\n')
                            cs->linenr++;
                    if (c == EOF) {
                            cs->eof = 1;
                            cs->linenr++;
                            c = '\n';
                    }
                    return c;
            }

            static char *parse_value(struct config_source *cs)
            {
                    int quote = 0, comment = 0;
                    size_t trim_len = 0;

                    strbuf_reset(&cs->value);
                    for (;;) {
                            int c = get_next_char(cs);
                            if (c == '\n') {
                                    if (quote) {
                                            cs->linenr--;
                                            return NULL;
                                    }
                                    if (trim_len)
                                            strbuf_setlen(&cs->value, trim_len);
                                    return cs->value.buf;
                            }
                            if (comment)
                                    continue;
                            if (isspace(c) && !quote) {
                                    if (!trim_len)
                                            trim_len = cs->value.len;
                                    if (cs->value.len)
                                            strbuf_addch(&cs->value, c);
                                    continue;
                            }
                            if (!quote) {
                                    if (c == ';' || c == '#') {
                                            comment = 1;
                                            continue;
                                    }
                            }
                            if (trim_len)
                                    trim_len = 0;
                            if (c == '\\') {
                                    c = get_next_char(cs);
                                    switch (c) {
                                    case '\n':
                                            continue;
                                    case 't':
                                            c = '\t';
                                            break;
                                    case 'b':
                                            c = '\b';
                                            break;
                                    case 'n':
                                            c = '\n';
                                            break;
                                    /* Some characters escape as themselves */
                                    case '\\': case '"':
                                            break;
                                    /* Reject unknown escape sequences */
                                    default:
                                            return NULL;
                                    }
                                    strbuf_addch(&cs->value, c);
                                    continue;
                            }
                            if (c == '"') {
                                    quote = 1 - quote;
                                    continue;
                            }
                            strbuf_addch(&cs->value, c);
                    }
            }

            static int get_value(struct config_source *cs, struct key_value_info *kvi,
                            config_fn_t fn, void *data, struct strbuf *name)
            {
                    int c;
                    char *value;
                    int ret;
                    struct config_context ctx = {
                            .kvi = kvi,
                    };

                    /* Get the full name */
                    for (;;) {
                            c = get_next_char(cs);
                            if (cs->eof)
                                    break;
                            if (!iskeychar(c))
                                    break;
                            strbuf_addch(name, tolower(c));
                    }

                    while (c == ' ' || c == '\t')
                            c = get_next_char(cs);

                    value = NULL;
                    if (c != '\n') {
                            if (c != '=')
                                    return -1;
                            value = parse_value(cs);
                            if (!value)
                                    return -1;
                    }
                    /*
                    * We already consumed the \n, but we need linenr to point to
                    * the line we just parsed during the call to fn to get
                    * accurate line number in error messages.
                    */
                    cs->linenr--;
                    kvi->linenr = cs->linenr;
                    ret = fn(name->buf, value, &ctx, data);
                    if (ret >= 0)
                            cs->linenr++;
                    return ret;
            }

            static int get_extended_base_var(struct config_source *cs, struct strbuf *name,
                                            int c)
            {
                    cs->subsection_case_sensitive = 0;
                    do {
                            if (c == '\n')
                                    goto error_incomplete_line;
                            c = get_next_char(cs);
                    } while (isspace(c));

                    /* We require the format to be '[base "extension"]' */
                    if (c != '"')
                            return -1;
                    strbuf_addch(name, '.');

                    for (;;) {
                            int c = get_next_char(cs);
                            if (c == '\n')
                                    goto error_incomplete_line;
                            if (c == '"')
                                    break;
                            if (c == '\\') {
                                    c = get_next_char(cs);
                                    if (c == '\n')
                                            goto error_incomplete_line;
                            }
                            strbuf_addch(name, c);
                    }

                    /* Final ']' */
                    if (get_next_char(cs) != ']')
                            return -1;
                    return 0;
            error_incomplete_line:
                    cs->linenr--;
                    return -1;
            }

            static int get_base_var(struct config_source *cs, struct strbuf *name)
            {
                    cs->subsection_case_sensitive = 1;
                    for (;;) {
                            int c = get_next_char(cs);
                            if (cs->eof)
                                    return -1;
                            if (c == ']')
                                    return 0;
                            if (isspace(c))
                                    return get_extended_base_var(cs, name, c);
                            if (!iskeychar(c) && c != '.')
                                    return -1;
                            strbuf_addch(name, tolower(c));
                    }
            }

            struct parse_event_data {
                    enum config_event_t previous_type;
                    size_t previous_offset;
                    const struct config_options *opts;
            };

            static int do_event(struct config_source *cs, enum config_event_t type,
                            struct parse_event_data *data)
            {
                    size_t offset;

                    if (!data->opts || !data->opts->event_fn)
                            return 0;

                    if (type == CONFIG_EVENT_WHITESPACE &&
                    data->previous_type == type)
                            return 0;

                    offset = cs->do_ftell(cs);
                    /*
                    * At EOF, the parser always "inserts" an extra '\n', therefore
                    * the end offset of the event is the current file position, otherwise
                    * we will already have advanced to the next event.
                    */
                    if (type != CONFIG_EVENT_EOF)
                            offset--;

                    if (data->previous_type != CONFIG_EVENT_EOF &&
                    data->opts->event_fn(data->previous_type, data->previous_offset,
                                            offset, cs, data->opts->event_fn_data) < 0)
                            return -1;

                    data->previous_type = type;
                    data->previous_offset = offset;

                    return 0;
            }

            static void kvi_from_source(struct config_source *cs,
                                    enum config_scope scope,
                                    struct key_value_info *out)
            {
                    out->filename = strintern(cs->name);
                    out->origin_type = cs->origin_type;
                    out->linenr = cs->linenr;
                    out->scope = scope;
                    out->path = cs->path;
            }

            static int git_parse_source(struct config_source *cs, config_fn_t fn,
                                    struct key_value_info *kvi, void *data,
                                    const struct config_options *opts)
            {
                    int comment = 0;
                    size_t baselen = 0;
                    struct strbuf *var = &cs->var;
                    int error_return = 0;
                    char *error_msg = NULL;

                    /* U+FEFF Byte Order Mark in UTF8 */
                    const char *bomptr = utf8_bom;

                    /* For the parser event callback */
                    struct parse_event_data event_data = {
                            CONFIG_EVENT_EOF, 0, opts
                    };

                    for (;;) {
                            int c;

                            c = get_next_char(cs);
                            if (bomptr && *bomptr) {
                                    /* We are at the file beginning; skip UTF8-encoded BOM
                                    * if present. Sane editors won't put this in on their
                                    * own, but e.g. Windows Notepad will do it happily. */
                                    if (c == (*bomptr & 0377)) {
                                            bomptr++;
                                            continue;
                                    } else {
                                            /* Do not tolerate partial BOM. */
                                            if (bomptr != utf8_bom)
                                                    break;
                                            /* No BOM at file beginning. Cool. */
                                            bomptr = NULL;
                                    }
                            }
                            if (c == '\n') {
                                    if (cs->eof) {
                                            if (do_event(cs, CONFIG_EVENT_EOF, &event_data) < 0)
                                                    return -1;
                                            return 0;
                                    }
                                    if (do_event(cs, CONFIG_EVENT_WHITESPACE, &event_data) < 0)
                                            return -1;
                                    comment = 0;
                                    continue;
                            }
                            if (comment)
                                    continue;
                            if (isspace(c)) {
                                    if (do_event(cs, CONFIG_EVENT_WHITESPACE, &event_data) < 0)
                                                    return -1;
                                    continue;
                            }
                            if (c == '#' || c == ';') {
                                    if (do_event(cs, CONFIG_EVENT_COMMENT, &event_data) < 0)
                                                    return -1;
                                    comment = 1;
                                    continue;
                            }
                            if (c == '[') {
                                    if (do_event(cs, CONFIG_EVENT_SECTION, &event_data) < 0)
                                                    return -1;

                                    /* Reset prior to determining a new stem */
                                    strbuf_reset(var);
                                    if (get_base_var(cs, var) < 0 || var->len < 1)
                                            break;
                                    strbuf_addch(var, '.');
                                    baselen = var->len;
                                    continue;
                            }
                            if (!isalpha(c))
                                    break;

                            if (do_event(cs, CONFIG_EVENT_ENTRY, &event_data) < 0)
                                    return -1;

                            /*
                            * Truncate the var name back to the section header
                            * stem prior to grabbing the suffix part of the name
                            * and the value.
                            */
                            strbuf_setlen(var, baselen);
                            strbuf_addch(var, tolower(c));
                            if (get_value(cs, kvi, fn, data, var) < 0)
                                    break;
                    }

                    if (do_event(cs, CONFIG_EVENT_ERROR, &event_data) < 0)
                            return -1;

                    switch (cs->origin_type) {
                    case CONFIG_ORIGIN_BLOB:
                            error_msg = xstrfmt(_("bad config line %d in blob %s"),
                                            cs->linenr, cs->name);
                            break;
                    case CONFIG_ORIGIN_FILE:
                            error_msg = xstrfmt(_("bad config line %d in file %s"),
                                            cs->linenr, cs->name);
                            break;
                    case CONFIG_ORIGIN_STDIN:
                            error_msg = xstrfmt(_("bad config line %d in standard input"),
                                            cs->linenr);
                            break;
                    case CONFIG_ORIGIN_SUBMODULE_BLOB:
                            error_msg = xstrfmt(_("bad config line %d in submodule-blob %s"),
                                            cs->linenr, cs->name);
                            break;
                    case CONFIG_ORIGIN_CMDLINE:
                            error_msg = xstrfmt(_("bad config line %d in command line %s"),
                                            cs->linenr, cs->name);
                            break;
                    default:
                            error_msg = xstrfmt(_("bad config line %d in %s"),
                                            cs->linenr, cs->name);
                    }

                    switch (opts && opts->error_action ?
                            opts->error_action :
                            cs->default_error_action) {
                    case CONFIG_ERROR_DIE:
                            die("%s", error_msg);
                            break;
                    case CONFIG_ERROR_ERROR:
                            error_return = error("%s", error_msg);
                            break;
                    case CONFIG_ERROR_SILENT:
                            error_return = -1;
                            break;
                    case CONFIG_ERROR_UNSET:
                            BUG("config error action unset");
                    }

                    free(error_msg);
                    return error_return;
            }

            NORETURN
            static void die_bad_number(const char *name, const char *value,
                                    const struct key_value_info *kvi)
            {
                    const char *error_type = (errno == ERANGE) ?
                            N_("out of range") : N_("invalid unit");
                    const char *bad_numeric = N_("bad numeric config value '%s' for '%s': %s");

                    if (!kvi)
                            BUG("kvi should not be NULL");

                    if (!value)
                            value = "";

                    if (!kvi->filename)
                            die(_(bad_numeric), value, name, _(error_type));

                    switch (kvi->origin_type) {
                    case CONFIG_ORIGIN_BLOB:
                            die(_("bad numeric config value '%s' for '%s' in blob %s: %s"),
                            value, name, kvi->filename, _(error_type));
                    case CONFIG_ORIGIN_FILE:
                            die(_("bad numeric config value '%s' for '%s' in file %s: %s"),
                            value, name, kvi->filename, _(error_type));
                    case CONFIG_ORIGIN_STDIN:
                            die(_("bad numeric config value '%s' for '%s' in standard input: %s"),
                            value, name, _(error_type));
                    case CONFIG_ORIGIN_SUBMODULE_BLOB:
                            die(_("bad numeric config value '%s' for '%s' in submodule-blob %s: %s"),
                            value, name, kvi->filename, _(error_type));
                    case CONFIG_ORIGIN_CMDLINE:
                            die(_("bad numeric config value '%s' for '%s' in command line %s: %s"),
                            value, name, kvi->filename, _(error_type));
                    default:
                            die(_("bad numeric config value '%s' for '%s' in %s: %s"),
                            value, name, kvi->filename, _(error_type));
                    }
            }

            int git_config_int(const char *name, const char *value,
                            const struct key_value_info *kvi)
            {
                    int ret;
                    if (!git_parse_int(value, &ret))
                            die_bad_number(name, value, kvi);
                    return ret;
            }

            int64_t git_config_int64(const char *name, const char *value,
                                    const struct key_value_info *kvi)
            {
                    int64_t ret;
                    if (!git_parse_int64(value, &ret))
                            die_bad_number(name, value, kvi);
                    return ret;
            }

            unsigned long git_config_ulong(const char *name, const char *value,
                                    const struct key_value_info *kvi)
            {
                    unsigned long ret;
                    if (!git_parse_ulong(value, &ret))
                            die_bad_number(name, value, kvi);
                    return ret;
            }

            ssize_t git_config_ssize_t(const char *name, const char *value,
                                    const struct key_value_info *kvi)
            {
                    ssize_t ret;
                    if (!git_parse_ssize_t(value, &ret))
                            die_bad_number(name, value, kvi);
                    return ret;
            }

            double git_config_double(const char *name, const char *value,
                                    const struct key_value_info *kvi)
            {
                    double ret;
                    if (!git_parse_double(value, &ret))
                            die_bad_number(name, value, kvi);
                    return ret;
            }

            static const struct fsync_component_name {
                    const char *name;
                    enum fsync_component component_bits;
            } fsync_component_names[] = {
                    { "loose-object", FSYNC_COMPONENT_LOOSE_OBJECT },
                    { "pack", FSYNC_COMPONENT_PACK },
                    { "pack-metadata", FSYNC_COMPONENT_PACK_METADATA },
                    { "commit-graph", FSYNC_COMPONENT_COMMIT_GRAPH },
                    { "index", FSYNC_COMPONENT_INDEX },
                    { "objects", FSYNC_COMPONENTS_OBJECTS },
                    { "reference", FSYNC_COMPONENT_REFERENCE },
                    { "derived-metadata", FSYNC_COMPONENTS_DERIVED_METADATA },
                    { "committed", FSYNC_COMPONENTS_COMMITTED },
                    { "added", FSYNC_COMPONENTS_ADDED },
                    { "all", FSYNC_COMPONENTS_ALL },
            };

            static enum fsync_component parse_fsync_components(const char *var, const char *string)
            {
                    enum fsync_component current = FSYNC_COMPONENTS_PLATFORM_DEFAULT;
                    enum fsync_component positive = 0, negative = 0;

                    while (string) {
                            int i;
                            size_t len;
                            const char *ep;
                            int negated = 0;
                            int found = 0;

                            string = string + strspn(string, ", \t\n\r");
                            ep = strchrnul(string, ',');
                            len = ep - string;
                            if (!strcmp(string, "none")) {
                                    current = FSYNC_COMPONENT_NONE;
                                    goto next_name;
                            }

                            if (*string == '-') {
                                    negated = 1;
                                    string++;
                                    len--;
                                    if (!len)
                                            warning(_("invalid value for variable %s"), var);
                            }

                            if (!len)
                                    break;

                            for (i = 0; i < ARRAY_SIZE(fsync_component_names); ++i) {
                                    const struct fsync_component_name *n = &fsync_component_names[i];

                                    if (strncmp(n->name, string, len))
                                            continue;

                                    found = 1;
                                    if (negated)
                                            negative |= n->component_bits;
                                    else
                                            positive |= n->component_bits;
                            }

                            if (!found) {
                                    char *component = xstrndup(string, len);
                                    warning(_("ignoring unknown core.fsync component '%s'"), component);
                                    free(component);
                            }

            next_name:
                            string = ep;
                    }

                    return (current & ~negative) | positive;
            }

            int git_config_bool_or_int(const char *name, const char *value,
                                    const struct key_value_info *kvi, int *is_bool)
            {
                    int v = git_parse_maybe_bool_text(value);
                    if (0 <= v) {
                            *is_bool = 1;
                            return v;
                    }
                    *is_bool = 0;
                    return git_config_int(name, value, kvi);
            }

            int git_config_bool(const char *name, const char *value)
            {
                    int v = git_parse_maybe_bool(value);
                    if (v < 0)
                            die(_("bad boolean config value '%s' for '%s'"), value, name);
                    return v;
            }

            int git_config_string(char **dest, const char *var, const char *value)
            {
                    if (!value)
                            return config_error_nonbool(var);
                    *dest = xstrdup(value);
                    return 0;
            }

            int git_config_pathname(char **dest, const char *var, const char *value)
            {
                    if (!value)
                            return config_error_nonbool(var);
                    *dest = interpolate_path(value, 0);
                    if (!*dest)
                            die(_("failed to expand user dir in: '%s'"), value);
                    return 0;
            }

            int git_config_expiry_date(timestamp_t *timestamp, const char *var, const char *value)
            {
                    if (!value)
                            return config_error_nonbool(var);
                    if (parse_expiry_date(value, timestamp))
                            return error(_("'%s' for '%s' is not a valid timestamp"),
                                    value, var);
                    return 0;
            }

            int git_config_color(char *dest, const char *var, const char *value)
            {
                    if (!value)
                            return config_error_nonbool(var);
                    if (color_parse(value, dest) < 0)
                            return -1;
                    return 0;
            }

            static int git_default_core_config(const char *var, const char *value,
                                            const struct config_context *ctx, void *cb)
            {
                    /* This needs a better name */
                    if (!strcmp(var, "core.filemode")) {
                            trust_executable_bit = git_config_bool(var, value);
                            return 0;
                    }
                    if (!strcmp(var, "core.trustctime")) {
                            trust_ctime = git_config_bool(var, value);
                            return 0;
                    }
                    if (!strcmp(var, "core.checkstat")) {
                            if (!value)
                                    return config_error_nonbool(var);
                            if (!strcasecmp(value, "default"))
                                    check_stat = 1;
                            else if (!strcasecmp(value, "minimal"))
                                    check_stat = 0;
                            else
                                    return error(_("invalid value for '%s': '%s'"),
                                            var, value);
                    }

                    if (!strcmp(var, "core.quotepath")) {
                            quote_path_fully = git_config_bool(var, value);
                            return 0;
                    }

                    if (!strcmp(var, "core.symlinks")) {
                            has_symlinks = git_config_bool(var, value);
                            return 0;
                    }

                    if (!strcmp(var, "core.ignorecase")) {
                            ignore_case = git_config_bool(var, value);
                            return 0;
                    }

                    if (!strcmp(var, "core.attributesfile")) {
                            FREE_AND_NULL(git_attributes_file);
                            return git_config_pathname(&git_attributes_file, var, value);
                    }

                    if (!strcmp(var, "core.hookspath")) {
                            FREE_AND_NULL(git_hooks_path);
                            return git_config_pathname(&git_hooks_path, var, value);
                    }

                    if (!strcmp(var, "core.bare")) {
                            is_bare_repository_cfg = git_config_bool(var, value);
                            return 0;
                    }

                    if (!strcmp(var, "core.ignorestat")) {
                            assume_unchanged = git_config_bool(var, value);
                            return 0;
                    }

                    if (!strcmp(var, "core.abbrev")) {
                            if (!value)
                                    return config_error_nonbool(var);
                            if (!strcasecmp(value, "auto"))
                                    default_abbrev = -1;
                            else if (!git_parse_maybe_bool_text(value))
                                    default_abbrev = GIT_MAX_HEXSZ;
                            else {
                                    int abbrev = git_config_int(var, value, ctx->kvi);
                                    if (abbrev < minimum_abbrev)
                                            return error(_("abbrev length out of range: %d"), abbrev);
                                    default_abbrev = abbrev;
                            }
                            return 0;
                    }

                    if (!strcmp(var, "core.disambiguate"))
                            return set_disambiguate_hint_config(var, value);

                    if (!strcmp(var, "core.loosecompression")) {
                            int level = git_config_int(var, value, ctx->kvi);
                            if (level == -1)
                                    level = Z_DEFAULT_COMPRESSION;
                            else if (level < 0 || level > Z_BEST_COMPRESSION)
                                    die(_("bad zlib compression level %d"), level);
                            zlib_compression_level = level;
                            zlib_compression_seen = 1;
                            return 0;
                    }

                    if (!strcmp(var, "core.compression")) {
                            int level = git_config_int(var, value, ctx->kvi);
                            if (level == -1)
                                    level = Z_DEFAULT_COMPRESSION;
                            else if (level < 0 || level > Z_BEST_COMPRESSION)
                                    die(_("bad zlib compression level %d"), level);
                            if (!zlib_compression_seen)
                                    zlib_compression_level = level;
                            if (!pack_compression_seen)
                                    pack_compression_level = level;
                            return 0;
                    }

                    if (!strcmp(var, "core.bigfilethreshold")) {
                            big_file_threshold = git_config_ulong(var, value, ctx->kvi);
                            return 0;
                    }

                    if (!strcmp(var, "core.autocrlf")) {
                            if (value && !strcasecmp(value, "input")) {
                                    auto_crlf = AUTO_CRLF_INPUT;
                                    return 0;
                            }
                            auto_crlf = git_config_bool(var, value);
                            return 0;
                    }

            #ifdef __MVS__
                    if (!strcmp(var, "core.ignorefiletags")) {
                            ignore_file_tags = git_config_bool(var, value);
                            return 0;
                    }

                    if (!strcmp(var, "core.utf8ccsid")) {
                            utf8_ccsid = git_config_ulong(var, value, ctx->kvi);
                            return 0;
                    }
            #endif

                    if (!strcmp(var, "core.safecrlf")) {
                            int eol_rndtrp_die;
                            if (value && !strcasecmp(value, "warn")) {
                                    global_conv_flags_eol = CONV_EOL_RNDTRP_WARN;
                                    return 0;
                            }
                            eol_rndtrp_die = git_config_bool(var, value);
                            global_conv_flags_eol = eol_rndtrp_die ?
                                    CONV_EOL_RNDTRP_DIE : 0;
                            return 0;
                    }

                    if (!strcmp(var, "core.eol")) {
                            if (value && !strcasecmp(value, "lf"))
                                    core_eol = EOL_LF;
                            else if (value && !strcasecmp(value, "crlf"))
                                    core_eol = EOL_CRLF;
                            else if (value && !strcasecmp(value, "native"))
                                    core_eol = EOL_NATIVE;
                            else
                                    core_eol = EOL_UNSET;
                            return 0;
                    }

                    if (!strcmp(var, "core.checkroundtripencoding")) {
                            FREE_AND_NULL(check_roundtrip_encoding);
                            return git_config_string(&check_roundtrip_encoding, var, value);
                    }

                    if (!strcmp(var, "core.editor")) {
                            FREE_AND_NULL(editor_program);
                            return git_config_string(&editor_program, var, value);
                    }

                    if (!strcmp(var, "core.commentchar") ||
                    !strcmp(var, "core.commentstring")) {
                            if (!value)
                                    return config_error_nonbool(var);
                            else if (!strcasecmp(value, "auto"))
                                    auto_comment_line_char = 1;
                            else if (value[0]) {
                                    if (strchr(value, '\n'))
                                            return error(_("%s cannot contain newline"), var);
                                    comment_line_str = value;
                                    FREE_AND_NULL(comment_line_str_to_free);
                                    auto_comment_line_char = 0;
                            } else
                                    return error(_("%s must have at least one character"), var);
                            return 0;
                    }

                    if (!strcmp(var, "core.askpass")) {
                            FREE_AND_NULL(askpass_program);
                            return git_config_string(&askpass_program, var, value);
                    }

                    if (!strcmp(var, "core.excludesfile")) {
                            FREE_AND_NULL(excludes_file);
                            return git_config_pathname(&excludes_file, var, value);
                    }

                    if (!strcmp(var, "core.whitespace")) {
                            if (!value)
                                    return config_error_nonbool(var);
                            whitespace_rule_cfg = parse_whitespace_rule(value);
                            return 0;
                    }

                    if (!strcmp(var, "core.fsync")) {
                            if (!value)
                                    return config_error_nonbool(var);
                            fsync_components = parse_fsync_components(var, value);
                            return 0;
                    }

                    if (!strcmp(var, "core.fsyncmethod")) {
                            if (!value)
                                    return config_error_nonbool(var);
                            if (!strcmp(value, "fsync"))
                                    fsync_method = FSYNC_METHOD_FSYNC;
                            else if (!strcmp(value, "writeout-only"))
                                    fsync_method = FSYNC_METHOD_WRITEOUT_ONLY;
                            else if (!strcmp(value, "batch"))
                                    fsync_method = FSYNC_METHOD_BATCH;
                            else
                                    warning(_("ignoring unknown core.fsyncMethod value '%s'"), value);

                    }

                    if (!strcmp(var, "core.fsyncobjectfiles")) {
                            if (fsync_object_files < 0)
                                    warning(_("core.fsyncObjectFiles is deprecated; use core.fsync instead"));
                            fsync_object_files = git_config_bool(var, value);
                            return 0;
                    }

                    if (!strcmp(var, "core.preloadindex")) {
                            core_preload_index = git_config_bool(var, value);
                            return 0;
                    }

                    if (!strcmp(var, "core.createobject")) {
                            if (!value)
                                    return config_error_nonbool(var);
                            if (!strcmp(value, "rename"))
                                    object_creation_mode = OBJECT_CREATION_USES_RENAMES;
                            else if (!strcmp(value, "link"))
                                    object_creation_mode = OBJECT_CREATION_USES_HARDLINKS;
                            else
                                    die(_("invalid mode for object creation: %s"), value);
                            return 0;
                    }

                    if (!strcmp(var, "core.sparsecheckout")) {
                            core_apply_sparse_checkout = git_config_bool(var, value);
                            return 0;
                    }

                    if (!strcmp(var, "core.sparsecheckoutcone")) {
                            core_sparse_checkout_cone = git_config_bool(var, value);
                            return 0;
                    }

                    if (!strcmp(var, "core.precomposeunicode")) {
                            precomposed_unicode = git_config_bool(var, value);
                            return 0;
                    }

                    if (!strcmp(var, "core.protecthfs")) {
                            protect_hfs = git_config_bool(var, value);
                            return 0;
                    }

                    if (!strcmp(var, "core.protectntfs")) {
                            protect_ntfs = git_config_bool(var, value);
                            return 0;
                    }

                    if (!strcmp(var, "core.maxtreedepth")) {
                            max_allowed_tree_depth = git_config_int(var, value, ctx->kvi);
                            return 0;
                    }

                    /* Add other config variables here and to Documentation/config.txt. */
                    return platform_core_config(var, value, ctx, cb);
            }

            static int git_default_sparse_config(const char *var, const char *value)
            {
                    if (!strcmp(var, "sparse.expectfilesoutsideofpatterns")) {
                            sparse_expect_files_outside_of_patterns = git_config_bool(var, value);
                            return 0;
                    }

                    /* Add other config variables here and to Documentation/config/sparse.txt. */
                    return 0;
            }

            static int git_default_i18n_config(const char *var, const char *value)
            {
                    if (!strcmp(var, "i18n.commitencoding")) {
                            FREE_AND_NULL(git_commit_encoding);
                            return git_config_string(&git_commit_encoding, var, value);
                    }

                    if (!strcmp(var, "i18n.logoutputencoding")) {
                            FREE_AND_NULL(git_log_output_encoding);
                            return git_config_string(&git_log_output_encoding, var, value);
                    }

                    /* Add other config variables here and to Documentation/config.txt. */
                    return 0;
            }

            static int git_default_branch_config(const char *var, const char *value)
            {
                    if (!strcmp(var, "branch.autosetupmerge")) {
                            if (value && !strcmp(value, "always")) {
                                    git_branch_track = BRANCH_TRACK_ALWAYS;
                                    return 0;
                            } else if (value && !strcmp(value, "inherit")) {
                                    git_branch_track = BRANCH_TRACK_INHERIT;
                                    return 0;
                            } else if (value && !strcmp(value, "simple")) {
                                    git_branch_track = BRANCH_TRACK_SIMPLE;
                                    return 0;
                            }
                            git_branch_track = git_config_bool(var, value);
                            return 0;
                    }
                    if (!strcmp(var, "branch.autosetuprebase")) {
                            if (!value)
                                    return config_error_nonbool(var);
                            else if (!strcmp(value, "never"))
                                    autorebase = AUTOREBASE_NEVER;
                            else if (!strcmp(value, "local"))
                                    autorebase = AUTOREBASE_LOCAL;
                            else if (!strcmp(value, "remote"))
                                    autorebase = AUTOREBASE_REMOTE;
                            else if (!strcmp(value, "always"))
                                    autorebase = AUTOREBASE_ALWAYS;
                            else
                                    return error(_("malformed value for %s"), var);
                            return 0;
                    }

                    /* Add other config variables here and to Documentation/config.txt. */
                    return 0;
            }

            static int git_default_push_config(const char *var, const char *value)
            {
                    if (!strcmp(var, "push.default")) {
                            if (!value)
                                    return config_error_nonbool(var);
                            else if (!strcmp(value, "nothing"))
                                    push_default = PUSH_DEFAULT_NOTHING;
                            else if (!strcmp(value, "matching"))
                                    push_default = PUSH_DEFAULT_MATCHING;
                            else if (!strcmp(value, "simple"))
                                    push_default = PUSH_DEFAULT_SIMPLE;
                            else if (!strcmp(value, "upstream"))
                                    push_default = PUSH_DEFAULT_UPSTREAM;
                            else if (!strcmp(value, "tracking")) /* deprecated */
                                    push_default = PUSH_DEFAULT_UPSTREAM;
                            else if (!strcmp(value, "current"))
                                    push_default = PUSH_DEFAULT_CURRENT;
                            else {
                                    error(_("malformed value for %s: %s"), var, value);
                                    return error(_("must be one of nothing, matching, simple, "
                                            "upstream or current"));
                            }
                            return 0;
                    }

                    /* Add other config variables here and to Documentation/config.txt. */
                    return 0;
            }

            static int git_default_mailmap_config(const char *var, const char *value)
            {
                    if (!strcmp(var, "mailmap.file")) {
                            FREE_AND_NULL(git_mailmap_file);
                            return git_config_pathname(&git_mailmap_file, var, value);
                    }

                    if (!strcmp(var, "mailmap.blob")) {
                            FREE_AND_NULL(git_mailmap_blob);
                            return git_config_string(&git_mailmap_blob, var, value);
                    }

                    /* Add other config variables here and to Documentation/config.txt. */
                    return 0;
            }

            static int git_default_attr_config(const char *var, const char *value)
            {
                    if (!strcmp(var, "attr.tree")) {
                            FREE_AND_NULL(git_attr_tree);
                            return git_config_string(&git_attr_tree, var, value);
                    }

                    /*
                    * Add other attribute related config variables here and to
                    * Documentation/config/attr.txt.
                    */
                    return 0;
            }

            int git_default_config(const char *var, const char *value,
                            const struct config_context *ctx, void *cb)
            {
                    if (starts_with(var, "core."))
                            return git_default_core_config(var, value, ctx, cb);

                    if (starts_with(var, "user.") ||
                    starts_with(var, "author.") ||
                    starts_with(var, "committer."))
                            return git_ident_config(var, value, ctx, cb);

                    if (starts_with(var, "i18n."))
                            return git_default_i18n_config(var, value);

                    if (starts_with(var, "branch."))
                            return git_default_branch_config(var, value);

                    if (starts_with(var, "push."))
                            return git_default_push_config(var, value);

                    if (starts_with(var, "mailmap."))
                            return git_default_mailmap_config(var, value);

                    if (starts_with(var, "attr."))
                            return git_default_attr_config(var, value);

                    if (starts_with(var, "advice.") || starts_with(var, "color.advice"))
                            return git_default_advice_config(var, value);

                    if (!strcmp(var, "pager.color") || !strcmp(var, "color.pager")) {
                            pager_use_color = git_config_bool(var,value);
                            return 0;
                    }

                    if (!strcmp(var, "pack.packsizelimit")) {
                            pack_size_limit_cfg = git_config_ulong(var, value, ctx->kvi);
                            return 0;
                    }

                    if (!strcmp(var, "pack.compression")) {
                            int level = git_config_int(var, value, ctx->kvi);
                            if (level == -1)
                                    level = Z_DEFAULT_COMPRESSION;
                            else if (level < 0 || level > Z_BEST_COMPRESSION)
                                    die(_("bad pack compression level %d"), level);
                            pack_compression_level = level;
                            pack_compression_seen = 1;
                            return 0;
                    }

                    if (starts_with(var, "sparse."))
                            return git_default_sparse_config(var, value);

                    /* Add other config variables here and to Documentation/config.txt. */
                    return 0;
            }

            /*
            * All source specific fields in the union, die_on_error, name and the callbacks
            * fgetc, ungetc, ftell of top need to be initialized before calling
            * this function.
            */
            static int do_config_from(struct config_source *top, config_fn_t fn,
                                    void *data, enum config_scope scope,
                                    const struct config_options *opts)
            {
                    struct key_value_info kvi = KVI_INIT;
                    int ret;

                    /* push config-file parsing state stack */
                    top->linenr = 1;
                    top->eof = 0;
                    top->total_len = 0;
                    strbuf_init(&top->value, 1024);
                    strbuf_init(&top->var, 1024);
                    kvi_from_source(top, scope, &kvi);

                    ret = git_parse_source(top, fn, &kvi, data, opts);

                    strbuf_release(&top->value);
                    strbuf_release(&top->var);

                    return ret;
            }

            static int do_config_from_file(config_fn_t fn,
                                    const enum config_origin_type origin_type,
                                    const char *name, const char *path, FILE *f,
                                    void *data, enum config_scope scope,
                                    const struct config_options *opts)
            {
                    struct config_source top = CONFIG_SOURCE_INIT;
                    int ret;

                    top.u.file = f;
                    top.origin_type = origin_type;
                    top.name = name;
                    top.path = path;
                    top.default_error_action = CONFIG_ERROR_DIE;
                    top.do_fgetc = config_file_fgetc;
                    top.do_ungetc = config_file_ungetc;
                    top.do_ftell = config_file_ftell;

                    flockfile(f);
                    ret = do_config_from(&top, fn, data, scope, opts);
                    funlockfile(f);
                    return ret;
            }

            static int git_config_from_stdin(config_fn_t fn, void *data,
                                            enum config_scope scope)
            {
                    return do_config_from_file(fn, CONFIG_ORIGIN_STDIN, "", NULL, stdin,
                                            data, scope, NULL);
            }

            int git_config_from_file_with_options(config_fn_t fn, const char *filename,
                                            void *data, enum config_scope scope,
                                            const struct config_options *opts)
            {
                    int ret = -1;
                    FILE *f;

                    if (!filename)
                            BUG("filename cannot be NULL");
                    f = fopen_or_warn(filename, "r");
                    if (f) {
                            ret = do_config_from_file(fn, CONFIG_ORIGIN_FILE, filename,
                                                    filename, f, data, scope, opts);
                            fclose(f);
                    }
                    return ret;
            }

            int git_config_from_file(config_fn_t fn, const char *filename, void *data)
            {
                    return git_config_from_file_with_options(fn, filename, data,
                                                            CONFIG_SCOPE_UNKNOWN, NULL);
            }

            int git_config_from_mem(config_fn_t fn,
                                    const enum config_origin_type origin_type,
                                    const char *name, const char *buf, size_t len,
                                    void *data, enum config_scope scope,
                                    const struct config_options *opts)
            {
                    struct config_source top = CONFIG_SOURCE_INIT;

                    top.u.buf.buf = buf;
                    top.u.buf.len = len;
                    top.u.buf.pos = 0;
                    top.origin_type = origin_type;
                    top.name = name;
                    top.path = NULL;
                    top.default_error_action = CONFIG_ERROR_ERROR;
                    top.do_fgetc = config_buf_fgetc;
                    top.do_ungetc = config_buf_ungetc;
                    top.do_ftell = config_buf_ftell;

                    return do_config_from(&top, fn, data, scope, opts);
            }

            int git_config_from_blob_oid(config_fn_t fn,
                                    const char *name,
                                    struct repository *repo,
                                    const struct object_id *oid,
                                    void *data,
                                    enum config_scope scope)
            {
                    enum object_type type;
                    char *buf;
                    unsigned long size;
                    int ret;

                    buf = repo_read_object_file(repo, oid, &type, &size);
                    if (!buf)
                            return error(_("unable to load config blob object '%s'"), name);
                    if (type != OBJ_BLOB) {
                            free(buf);
                            return error(_("reference '%s' does not point to a blob"), name);
                    }

                    ret = git_config_from_mem(fn, CONFIG_ORIGIN_BLOB, name, buf, size,
                                            data, scope, NULL);
                    free(buf);

                    return ret;
            }

            static int git_config_from_blob_ref(config_fn_t fn,
                                            struct repository *repo,
                                            const char *name,
                                            void *data,
                                            enum config_scope scope)
            {
                    struct object_id oid;

                    if (repo_get_oid(repo, name, &oid) < 0)
                            return error(_("unable to resolve config blob '%s'"), name);
                    return git_config_from_blob_oid(fn, name, repo, &oid, data, scope);
            }

            char *git_system_config(void)
            {
                    char *system_config = xstrdup_or_null(getenv("GIT_CONFIG_SYSTEM"));
                    if (!system_config)
                            system_config = system_path(ETC_GITCONFIG);
                    normalize_path_copy(system_config, system_config);
                    return system_config;
            }

            char *git_global_config(void)
            {
                    char *user_config, *xdg_config;

                    git_global_config_paths(&user_config, &xdg_config);
                    if (!user_config) {
                            free(xdg_config);
                            return NULL;
                    }

                    if (access_or_warn(user_config, R_OK, 0) && xdg_config &&
                    !access_or_warn(xdg_config, R_OK, 0)) {
                            free(user_config);
                            return xdg_config;
                    } else {
                            free(xdg_config);
                            return user_config;
                    }
            }

            void git_global_config_paths(char **user_out, char **xdg_out)
            {
                    char *user_config = xstrdup_or_null(getenv("GIT_CONFIG_GLOBAL"));
                    char *xdg_config = NULL;

                    if (!user_config) {
                            user_config = interpolate_path("~/.gitconfig", 0);
                            xdg_config = xdg_config_home("config");
                    }

                    *user_out = user_config;
                    *xdg_out = xdg_config;
            }

            int git_config_system(void)
            {
                    return !git_env_bool("GIT_CONFIG_NOSYSTEM", 0);
            }

            static int do_git_config_sequence(const struct config_options *opts,
                                            const struct repository *repo,
                                            config_fn_t fn, void *data)
            {
                    int ret = 0;
                    char *system_config = git_system_config();
                    char *xdg_config = NULL;
                    char *user_config = NULL;
                    char *repo_config;
                    char *worktree_config;

                    /*
                    * Ensure that either:
                    * - the git_dir and commondir are both set, or
                    * - the git_dir and commondir are both NULL
                    */
                    if (!opts->git_dir != !opts->commondir)
                            BUG("only one of commondir and git_dir is non-NULL");

                    if (opts->commondir) {
                            repo_config = mkpathdup("%s/config", opts->commondir);
                            worktree_config = mkpathdup("%s/config.worktree", opts->git_dir);
                    } else {
                            repo_config = NULL;
                            worktree_config = NULL;
                    }

                    if (git_config_system() && system_config &&
                    !access_or_die(system_config, R_OK,
                                    opts->system_gently ? ACCESS_EACCES_OK : 0))
                            ret += git_config_from_file_with_options(fn, system_config,
                                                                    data, CONFIG_SCOPE_SYSTEM,
                                                                    NULL);

                    git_global_config_paths(&user_config, &xdg_config);

                    if (xdg_config && !access_or_die(xdg_config, R_OK, ACCESS_EACCES_OK))
                            ret += git_config_from_file_with_options(fn, xdg_config, data,
                                                                    CONFIG_SCOPE_GLOBAL, NULL);

                    if (user_config && !access_or_die(user_config, R_OK, ACCESS_EACCES_OK))
                            ret += git_config_from_file_with_options(fn, user_config, data,
                                                                    CONFIG_SCOPE_GLOBAL, NULL);

                    if (!opts->ignore_repo && repo_config &&
                    !access_or_die(repo_config, R_OK, 0))
                            ret += git_config_from_file_with_options(fn, repo_config, data,
                                                                    CONFIG_SCOPE_LOCAL, NULL);

                    if (!opts->ignore_worktree && worktree_config &&
                    repo && repo->repository_format_worktree_config &&
                    !access_or_die(worktree_config, R_OK, 0)) {
                                    ret += git_config_from_file_with_options(fn, worktree_config, data,
                                                                            CONFIG_SCOPE_WORKTREE,
                                                                            NULL);
                    }

                    if (!opts->ignore_cmdline && git_config_from_parameters(fn, data) < 0)
                            die(_("unable to parse command-line config"));

                    free(system_config);
                    free(xdg_config);
                    free(user_config);
                    free(repo_config);
                    free(worktree_config);
                    return ret;
            }

            int config_with_options(config_fn_t fn, void *data,
                                    const struct git_config_source *config_source,
                                    struct repository *repo,
                                    const struct config_options *opts)
            {
                    struct config_include_data inc = CONFIG_INCLUDE_INIT;
                    int ret;

                    if (opts->respect_includes) {
                            inc.fn = fn;
                            inc.data = data;
                            inc.opts = opts;
                            inc.repo = repo;
                            inc.config_source = config_source;
                            fn = git_config_include;
                            data = &inc;
                    }

                    /*
                    * If we have a specific filename, use it. Otherwise, follow the
                    * regular lookup sequence.
                    */
                    if (config_source && config_source->use_stdin) {
                            ret = git_config_from_stdin(fn, data, config_source->scope);
                    } else if (config_source && config_source->file) {
                            ret = git_config_from_file_with_options(fn, config_source->file,
                                                                    data, config_source->scope,
                                                                    NULL);
                    } else if (config_source && config_source->blob) {
                            ret = git_config_from_blob_ref(fn, repo, config_source->blob,
                                                    data, config_source->scope);
                    } else {
                            ret = do_git_config_sequence(opts, repo, fn, data);
                    }

                    if (inc.remote_urls) {
                            string_list_clear(inc.remote_urls, 0);
                            FREE_AND_NULL(inc.remote_urls);
                    }
                    return ret;
            }

            static void configset_iter(struct config_set *set, config_fn_t fn, void *data)
            {
                    int i, value_index;
                    struct string_list *values;
                    struct config_set_element *entry;
                    struct configset_list *list = &set->list;
                    struct config_context ctx = CONFIG_CONTEXT_INIT;

                    for (i = 0; i < list->nr; i++) {
                            entry = list->items[i].e;
                            value_index = list->items[i].value_index;
                            values = &entry->value_list;

                            ctx.kvi = values->items[value_index].util;
                            if (fn(entry->key, values->items[value_index].string, &ctx, data) < 0)
                                    git_die_config_linenr(entry->key,
                                                    ctx.kvi->filename,
                                                    ctx.kvi->linenr);
                    }
            }

            void read_early_config(struct repository *repo, config_fn_t cb, void *data)
            {
                    struct config_options opts = {0};
                    struct strbuf commondir = STRBUF_INIT;
                    struct strbuf gitdir = STRBUF_INIT;

                    opts.respect_includes = 1;

                    if (repo && repo->gitdir) {
                            opts.commondir = repo_get_common_dir(repo);
                            opts.git_dir = repo_get_git_dir(repo);
                    /*
                    * When setup_git_directory() was not yet asked to discover the
                    * GIT_DIR, we ask discover_git_directory() to figure out whether there
                    * is any repository config we should use (but unlike
                    * setup_git_directory_gently(), no global state is changed, most
                    * notably, the current working directory is still the same after the
                    * call).
                    */
                    } else if (!discover_git_directory(&commondir, &gitdir)) {
                            opts.commondir = commondir.buf;
                            opts.git_dir = gitdir.buf;
                    }

                    config_with_options(cb, data, NULL, NULL, &opts);

                    strbuf_release(&commondir);
                    strbuf_release(&gitdir);
            }

            void read_very_early_config(config_fn_t cb, void *data)
            {
                    struct config_options opts = { 0 };

                    opts.respect_includes = 1;
                    opts.ignore_repo = 1;
                    opts.ignore_worktree = 1;
                    opts.ignore_cmdline = 1;
                    opts.system_gently = 1;

                    config_with_options(cb, data, NULL, NULL, &opts);
            }

            RESULT_MUST_BE_USED
            static int configset_find_element(struct config_set *set, const char *key,
                                            struct config_set_element **dest)
            {
                    struct config_set_element k;
                    struct config_set_element *found_entry;
                    char *normalized_key;
                    int ret;

                    /*
                    * `key` may come from the user, so normalize it before using it
                    * for querying entries from the hashmap.
                    */
                    ret = git_config_parse_key(key, &normalized_key, NULL);
                    if (ret)
                            return ret;

                    hashmap_entry_init(&k.ent, strhash(normalized_key));
                    k.key = normalized_key;
                    found_entry = hashmap_get_entry(&set->config_hash, &k, ent, NULL);
                    free(normalized_key);
                    *dest = found_entry;
                    return 0;
            }

            static int configset_add_value(const struct key_value_info *kvi_p,
                                    struct config_set *set, const char *key,
                                    const char *value)
            {
                    struct config_set_element *e;
                    struct string_list_item *si;
                    struct configset_list_item *l_item;
                    struct key_value_info *kv_info = xmalloc(sizeof(*kv_info));
                    int ret;

                    ret = configset_find_element(set, key, &e);
                    if (ret)
                            return ret;
                    /*
                    * Since the keys are being fed by git_config*() callback mechanism, they
                    * are already normalized. So simply add them without any further munging.
                    */
                    if (!e) {
                            e = xmalloc(sizeof(*e));
                            hashmap_entry_init(&e->ent, strhash(key));
                            e->key = xstrdup(key);
                            string_list_init_dup(&e->value_list);
                            hashmap_add(&set->config_hash, &e->ent);
                    }
                    si = string_list_append_nodup(&e->value_list, xstrdup_or_null(value));

                    ALLOC_GROW(set->list.items, set->list.nr + 1, set->list.alloc);
                    l_item = &set->list.items[set->list.nr++];
                    l_item->e = e;
                    l_item->value_index = e->value_list.nr - 1;

                    *kv_info = *kvi_p;
                    si->util = kv_info;

                    return 0;
            }

            static int config_set_element_cmp(const void *cmp_data UNUSED,
                                            const struct hashmap_entry *eptr,
                                            const struct hashmap_entry *entry_or_key,
                                            const void *keydata UNUSED)
            {
                    const struct config_set_element *e1, *e2;

                    e1 = container_of(eptr, const struct config_set_element, ent);
                    e2 = container_of(entry_or_key, const struct config_set_element, ent);

                    return strcmp(e1->key, e2->key);
            }

            void git_configset_init(struct config_set *set)
            {
                    hashmap_init(&set->config_hash, config_set_element_cmp, NULL, 0);
                    set->hash_initialized = 1;
                    set->list.nr = 0;
                    set->list.alloc = 0;
                    set->list.items = NULL;
            }

            void git_configset_clear(struct config_set *set)
            {
                    struct config_set_element *entry;
                    struct hashmap_iter iter;
                    if (!set->hash_initialized)
                            return;

                    hashmap_for_each_entry(&set->config_hash, &iter, entry,
                                            ent /* member name */) {
                            free(entry->key);
                            string_list_clear(&entry->value_list, 1);
                    }
                    hashmap_clear_and_free(&set->config_hash, struct config_set_element, ent);
                    set->hash_initialized = 0;
                    free(set->list.items);
                    set->list.nr = 0;
                    set->list.alloc = 0;
                    set->list.items = NULL;
            }

            static int config_set_callback(const char *key, const char *value,
                                    const struct config_context *ctx,
                                    void *cb)
            {
                    struct config_set *set = cb;
                    configset_add_value(ctx->kvi, set, key, value);
                    return 0;
            }

            int git_configset_add_file(struct config_set *set, const char *filename)
            {
                    return git_config_from_file(config_set_callback, filename, set);
            }

            int git_configset_get_value(struct config_set *set, const char *key,
                                    const char **value, struct key_value_info *kvi)
            {
                    const struct string_list *values = NULL;
                    int ret;
                    struct string_list_item item;
                    /*
                    * Follows "last one wins" semantic, i.e., if there are multiple matches for the
                    * queried key in the files of the configset, the value returned will be the last
                    * value in the value list for that key.
                    */
                    if ((ret = git_configset_get_value_multi(set, key, &values)))
                            return ret;

                    assert(values->nr > 0);
                    item = values->items[values->nr - 1];
                    *value = item.string;
                    if (kvi)
                            *kvi = *((struct key_value_info *)item.util);
                    return 0;
            }

            int git_configset_get_value_multi(struct config_set *set, const char *key,
                                            const struct string_list **dest)
            {
                    struct config_set_element *e;
                    int ret;

                    if ((ret = configset_find_element(set, key, &e)))
                            return ret;
                    else if (!e)
                            return 1;
                    *dest = &e->value_list;

                    return 0;
            }

            static int check_multi_string(struct string_list_item *item, void *util)
            {
                    return item->string ? 0 : config_error_nonbool(util);
            }

            int git_configset_get_string_multi(struct config_set *cs, const char *key,
                                            const struct string_list **dest)
            {
                    int ret;

                    if ((ret = git_configset_get_value_multi(cs, key, dest)))
                            return ret;
                    if ((ret = for_each_string_list((struct string_list *)*dest,
                                                    check_multi_string, (void *)key)))
                            return ret;

                    return 0;
            }

            int git_configset_get(struct config_set *set, const char *key)
            {
                    struct config_set_element *e;
                    int ret;

                    if ((ret = configset_find_element(set, key, &e)))
                            return ret;
                    else if (!e)
                            return 1;
                    return 0;
            }

            int git_configset_get_string(struct config_set *set, const char *key, char **dest)
            {
                    const char *value;
                    if (!git_configset_get_value(set, key, &value, NULL))
                            return git_config_string(dest, key, value);
                    else
                            return 1;
            }

            static int git_configset_get_string_tmp(struct config_set *set, const char *key,
                                                    const char **dest)
            {
                    const char *value;
                    if (!git_configset_get_value(set, key, &value, NULL)) {
                            if (!value)
                                    return config_error_nonbool(key);
                            *dest = value;
                            return 0;
                    } else {
                            return 1;
                    }
            }

            int git_configset_get_int(struct config_set *set, const char *key, int *dest)
            {
                    const char *value;
                    struct key_value_info kvi;

                    if (!git_configset_get_value(set, key, &value, &kvi)) {
                            *dest = git_config_int(key, value, &kvi);
                            return 0;
                    } else
                            return 1;
            }

            int git_configset_get_ulong(struct config_set *set, const char *key, unsigned long *dest)
            {
                    const char *value;
                    struct key_value_info kvi;

                    if (!git_configset_get_value(set, key, &value, &kvi)) {
                            *dest = git_config_ulong(key, value, &kvi);
                            return 0;
                    } else
                            return 1;
            }

            int git_configset_get_bool(struct config_set *set, const char *key, int *dest)
            {
                    const char *value;
                    if (!git_configset_get_value(set, key, &value, NULL)) {
                            *dest = git_config_bool(key, value);
                            return 0;
                    } else
                            return 1;
            }

            int git_configset_get_bool_or_int(struct config_set *set, const char *key,
                                            int *is_bool, int *dest)
            {
                    const char *value;
                    struct key_value_info kvi;

                    if (!git_configset_get_value(set, key, &value, &kvi)) {
                            *dest = git_config_bool_or_int(key, value, &kvi, is_bool);
                            return 0;
                    } else
                            return 1;
            }

            int git_configset_get_maybe_bool(struct config_set *set, const char *key, int *dest)
            {
                    const char *value;
                    if (!git_configset_get_value(set, key, &value, NULL)) {
                            *dest = git_parse_maybe_bool(value);
                            if (*dest == -1)
                                    return -1;
                            return 0;
                    } else
                            return 1;
            }

            int git_configset_get_pathname(struct config_set *set, const char *key, char **dest)
            {
                    const char *value;
                    if (!git_configset_get_value(set, key, &value, NULL))
                            return git_config_pathname(dest, key, value);
                    else
                            return 1;
            }

            /* Functions use to read configuration from a repository */
            static void repo_read_config(struct repository *repo)
            {
                    struct config_options opts = { 0 };

                    opts.respect_includes = 1;
                    opts.commondir = repo->commondir;
                    opts.git_dir = repo->gitdir;

                    if (!repo->config)
                            CALLOC_ARRAY(repo->config, 1);
                    else
                            git_configset_clear(repo->config);

                    git_configset_init(repo->config);
                    if (config_with_options(config_set_callback, repo->config, NULL,
                                            repo, &opts) < 0)
                            /*
                            * config_with_options() normally returns only
                            * zero, as most errors are fatal, and
                            * non-fatal potential errors are guarded by "if"
                            * statements that are entered only when no error is
                            * possible.
                            *
                            * If we ever encounter a non-fatal error, it means
                            * something went really wrong and we should stop
                            * immediately.
                            */
                            die(_("unknown error occurred while reading the configuration files"));
            }

            static void git_config_check_init(struct repository *repo)
            {
                    if (repo->config && repo->config->hash_initialized)
                            return;
                    repo_read_config(repo);
            }

            void repo_config_clear(struct repository *repo)
            {
                    if (!repo->config || !repo->config->hash_initialized)
                            return;
                    git_configset_clear(repo->config);
            }

            void repo_config(struct repository *repo, config_fn_t fn, void *data)
            {
                    git_config_check_init(repo);
                    configset_iter(repo->config, fn, data);
            }

            int repo_config_get(struct repository *repo, const char *key)
            {
                    git_config_check_init(repo);
                    return git_configset_get(repo->config, key);
            }

            int repo_config_get_value(struct repository *repo,
                                    const char *key, const char **value)
            {
                    git_config_check_init(repo);
                    return git_configset_get_value(repo->config, key, value, NULL);
            }

            int repo_config_get_value_multi(struct repository *repo, const char *key,
                                            const struct string_list **dest)
            {
                    git_config_check_init(repo);
                    return git_configset_get_value_multi(repo->config, key, dest);
            }

            int repo_config_get_string_multi(struct repository *repo, const char *key,
                                            const struct string_list **dest)
            {
                    git_config_check_init(repo);
                    return git_configset_get_string_multi(repo->config, key, dest);
            }

            int repo_config_get_string(struct repository *repo,
                                    const char *key, char **dest)
            {
                    int ret;
                    git_config_check_init(repo);
                    ret = git_configset_get_string(repo->config, key, dest);
                    if (ret < 0)
                            git_die_config(repo, key, NULL);
                    return ret;
            }

            int repo_config_get_string_tmp(struct repository *repo,
                                    const char *key, const char **dest)
            {
                    int ret;
                    git_config_check_init(repo);
                    ret = git_configset_get_string_tmp(repo->config, key, dest);
                    if (ret < 0)
                            git_die_config(repo, key, NULL);
                    return ret;
            }

            int repo_config_get_int(struct repository *repo,
                                    const char *key, int *dest)
            {
                    git_config_check_init(repo);
                    return git_configset_get_int(repo->config, key, dest);
            }

            int repo_config_get_ulong(struct repository *repo,
                                    const char *key, unsigned long *dest)
            {
                    git_config_check_init(repo);
                    return git_configset_get_ulong(repo->config, key, dest);
            }

            int repo_config_get_bool(struct repository *repo,
                                    const char *key, int *dest)
            {
                    git_config_check_init(repo);
                    return git_configset_get_bool(repo->config, key, dest);
            }

            int repo_config_get_bool_or_int(struct repository *repo,
                                            const char *key, int *is_bool, int *dest)
            {
                    git_config_check_init(repo);
                    return git_configset_get_bool_or_int(repo->config, key, is_bool, dest);
            }

            int repo_config_get_maybe_bool(struct repository *repo,
                                    const char *key, int *dest)
            {
                    git_config_check_init(repo);
                    return git_configset_get_maybe_bool(repo->config, key, dest);
            }

            int repo_config_get_pathname(struct repository *repo,
                                    const char *key, char **dest)
            {
                    int ret;
                    git_config_check_init(repo);
                    ret = git_configset_get_pathname(repo->config, key, dest);
                    if (ret < 0)
                            git_die_config(repo, key, NULL);
                    return ret;
            }

            /* Read values into protected_config. */
            static void read_protected_config(void)
            {
                    struct config_options opts = {
                            .respect_includes = 1,
                            .ignore_repo = 1,
                            .ignore_worktree = 1,
                            .system_gently = 1,
                    };

                    git_configset_init(&protected_config);
                    config_with_options(config_set_callback, &protected_config, NULL,
                                    NULL, &opts);
            }

            void git_protected_config(config_fn_t fn, void *data)
            {
                    if (!protected_config.hash_initialized)
                            read_protected_config();
                    configset_iter(&protected_config, fn, data);
            }

            int repo_config_get_expiry(struct repository *r, const char *key, char **output)
            {
                    int ret = repo_config_get_string(r, key, output);

                    if (ret)
                            return ret;
                    if (strcmp(*output, "now")) {
                            timestamp_t now = approxidate("now");
                            if (approxidate(*output) >= now)
                                    git_die_config(r, key, _("Invalid %s: '%s'"), key, *output);
                    }
                    return ret;
            }

            int repo_config_get_expiry_in_days(struct repository *r, const char *key,
                                            timestamp_t *expiry, timestamp_t now)
            {
                    const char *expiry_string;
                    intmax_t days;
                    timestamp_t when;

                    if (repo_config_get_string_tmp(r, key, &expiry_string))
                            return 1; /* no such thing */

                    if (git_parse_signed(expiry_string, &days, maximum_signed_value_of_type(int))) {
                            const int scale = 86400;
                            *expiry = now - days * scale;
                            return 0;
                    }

                    if (!parse_expiry_date(expiry_string, &when)) {
                            *expiry = when;
                            return 0;
                    }
                    return -1; /* thing exists but cannot be parsed */
            }

            int repo_config_get_split_index(struct repository *r)
            {
                    int val;

                    if (!repo_config_get_maybe_bool(r, "core.splitindex", &val))
                            return val;

                    return -1; /* default value */
            }

            int repo_config_get_max_percent_split_change(struct repository *r)
            {
                    int val = -1;

                    if (!repo_config_get_int(r, "splitindex.maxpercentchange", &val)) {
                            if (0 <= val && val <= 100)
                                    return val;

                            return error(_("splitIndex.maxPercentChange value '%d' "
                                    "should be between 0 and 100"), val);
                    }

                    return -1; /* default value */
            }

            int repo_config_get_index_threads(struct repository *r, int *dest)
            {
                    int is_bool, val;

                    val = git_env_ulong("GIT_TEST_INDEX_THREADS", 0);
                    if (val) {
                            *dest = val;
                            return 0;
                    }

                    if (!repo_config_get_bool_or_int(r, "index.threads", &is_bool, &val)) {
                            if (is_bool)
                                    *dest = val ? 0 : 1;
                            else
                                    *dest = val;
                            return 0;
                    }

                    return 1;
            }

            NORETURN
            void git_die_config_linenr(const char *key, const char *filename, int linenr)
            {
                    if (!filename)
                            die(_("unable to parse '%s' from command-line config"), key);
                    else
                            die(_("bad config variable '%s' in file '%s' at line %d"),
                            key, filename, linenr);
            }

            void git_die_config(struct repository *r, const char *key, const char *err, ...)
            {
                    const struct string_list *values;
                    struct key_value_info *kv_info;
                    report_fn error_fn = get_error_routine();

                    if (err) {
                            va_list params;
                            va_start(params, err);
                            error_fn(err, params);
                            va_end(params);
                    }
                    if (repo_config_get_value_multi(r, key, &values))
                            BUG("for key '%s' we must have a value to report on", key);
                    kv_info = values->items[values->nr - 1].util;
                    git_die_config_linenr(key, kv_info->filename, kv_info->linenr);
            }

            /*
            * Find all the stuff for git_config_set() below.
            */

            struct config_store_data {
                    size_t baselen;
                    char *key;
                    int do_not_match;
                    const char *fixed_value;
                    regex_t *value_pattern;
                    int multi_replace;
                    struct {
                            size_t begin, end;
                            enum config_event_t type;
                            int is_keys_section;
                    } *parsed;
                    unsigned int parsed_nr, parsed_alloc, *seen, seen_nr, seen_alloc;
                    unsigned int key_seen:1, section_seen:1, is_keys_section:1;
            };
            #define CONFIG_STORE_INIT { 0 }

            static void config_store_data_clear(struct config_store_data *store)
            {
                    free(store->key);
                    if (store->value_pattern != NULL &&
                    store->value_pattern != CONFIG_REGEX_NONE) {
                            regfree(store->value_pattern);
                            free(store->value_pattern);
                    }
                    free(store->parsed);
                    free(store->seen);
                    memset(store, 0, sizeof(*store));
            }

            static int matches(const char *key, const char *value,
                            const struct config_store_data *store)
            {
                    if (strcmp(key, store->key))
                            return 0; /* not ours */
                    if (store->fixed_value && value)
                            return !strcmp(store->fixed_value, value);
                    if (!store->value_pattern)
                            return 1; /* always matches */
                    if (store->value_pattern == CONFIG_REGEX_NONE)
                            return 0; /* never matches */

                    return store->do_not_match ^
                            (value && !regexec(store->value_pattern, value, 0, NULL, 0));
            }

            static int store_aux_event(enum config_event_t type, size_t begin, size_t end,
                                    struct config_source *cs, void *data)
            {
                    struct config_store_data *store = data;

                    ALLOC_GROW(store->parsed, store->parsed_nr + 1, store->parsed_alloc);
                    store->parsed[store->parsed_nr].begin = begin;
                    store->parsed[store->parsed_nr].end = end;
                    store->parsed[store->parsed_nr].type = type;

                    if (type == CONFIG_EVENT_SECTION) {
                            int (*cmpfn)(const char *, const char *, size_t);

                            if (cs->var.len < 2 || cs->var.buf[cs->var.len - 1] != '.')
                                    return error(_("invalid section name '%s'"), cs->var.buf);

                            if (cs->subsection_case_sensitive)
                                    cmpfn = strncasecmp;
                            else
                                    cmpfn = strncmp;

                            /* Is this the section we were looking for? */
                            store->is_keys_section =
                                    store->parsed[store->parsed_nr].is_keys_section =
                                    cs->var.len - 1 == store->baselen &&
                                    !cmpfn(cs->var.buf, store->key, store->baselen);
                            if (store->is_keys_section) {
                                    store->section_seen = 1;
                                    ALLOC_GROW(store->seen, store->seen_nr + 1,
                                            store->seen_alloc);
                                    store->seen[store->seen_nr] = store->parsed_nr;
                            }
                    }

                    store->parsed_nr++;

                    return 0;
            }

            static int store_aux(const char *key, const char *value,
                            const struct config_context *ctx UNUSED, void *cb)
            {
                    struct config_store_data *store = cb;

                    if (store->key_seen) {
                            if (matches(key, value, store)) {
                                    if (store->seen_nr == 1 && store->multi_replace == 0) {
                                            warning(_("%s has multiple values"), key);
                                    }

                                    ALLOC_GROW(store->seen, store->seen_nr + 1,
                                            store->seen_alloc);

                                    store->seen[store->seen_nr] = store->parsed_nr;
                                    store->seen_nr++;
                            }
                    } else if (store->is_keys_section) {
                            /*
                            * Do not increment matches yet: this may not be a match, but we
                            * are in the desired section.
                            */
                            ALLOC_GROW(store->seen, store->seen_nr + 1, store->seen_alloc);
                            store->seen[store->seen_nr] = store->parsed_nr;
                            store->section_seen = 1;

                            if (matches(key, value, store)) {
                                    store->seen_nr++;
                                    store->key_seen = 1;
                            }
                    }

                    return 0;
            }

            static int write_error(const char *filename)
            {
                    error(_("failed to write new configuration file %s"), filename);

                    /* Same error code as "failed to rename". */
                    return 4;
            }

            static struct strbuf store_create_section(const char *key,
                                                    const struct config_store_data *store)
            {
                    const char *dot;
                    size_t i;
                    struct strbuf sb = STRBUF_INIT;

                    dot = memchr(key, '.', store->baselen);
                    if (dot) {
                            strbuf_addf(&sb, "[%.*s \"", (int)(dot - key), key);
                            for (i = dot - key + 1; i < store->baselen; i++) {
                                    if (key[i] == '"' || key[i] == '\\')
                                            strbuf_addch(&sb, '\\');
                                    strbuf_addch(&sb, key[i]);
                            }
                            strbuf_addstr(&sb, "\"]\n");
                    } else {
                            strbuf_addch(&sb, '[');
                            strbuf_add(&sb, key, store->baselen);
                            strbuf_addstr(&sb, "]\n");
                    }

                    return sb;
            }

            static ssize_t write_section(int fd, const char *key,
                                    const struct config_store_data *store)
            {
                    struct strbuf sb = store_create_section(key, store);
                    ssize_t ret;

                    ret = write_in_full(fd, sb.buf, sb.len);
                    strbuf_release(&sb);

                    return ret;
            }

            static ssize_t write_pair(int fd, const char *key, const char *value,
                                    const char *comment,
                                    const struct config_store_data *store)
            {
                    int i;
                    ssize_t ret;
                    const char *quote = "";
                    struct strbuf sb = STRBUF_INIT;

                    /*
                    * Check to see if the value needs to be surrounded with a dq pair.
                    * Note that problematic characters are always backslash-quoted; this
                    * check is about not losing leading or trailing SP and strings that
                    * follow beginning-of-comment characters (i.e. ';' and '#') by the
                    * configuration parser.
                    */
                    if (value[0] == ' ')
                            quote = "\"";
                    for (i = 0; value[i]; i++)
                            if (value[i] == ';' || value[i] == '#')
                                    quote = "\"";
                    if (i && value[i - 1] == ' ')
                            quote = "\"";

                    strbuf_addf(&sb, "\t%s = %s", key + store->baselen + 1, quote);

                    for (i = 0; value[i]; i++)
                            switch (value[i]) {
                            case '\n':
                                    strbuf_addstr(&sb, "\\n");
                                    break;
                            case '\t':
                                    strbuf_addstr(&sb, "\\t");
                                    break;
                            case '"':
                            case '\\':
                                    strbuf_addch(&sb, '\\');
                                    /* fallthrough */
                            default:
                                    strbuf_addch(&sb, value[i]);
                                    break;
                            }

                    if (comment)
                            strbuf_addf(&sb, "%s%s\n", quote, comment);
                    else
                            strbuf_addf(&sb, "%s\n", quote);

                    ret = write_in_full(fd, sb.buf, sb.len);
                    strbuf_release(&sb);

                    return ret;
            }

            /*
            * If we are about to unset the last key(s) in a section, and if there are
            * no comments surrounding (or included in) the section, we will want to
            * extend begin/end to remove the entire section.
            *
            * Note: the parameter `seen_ptr` points to the index into the store.seen
            * array.  * This index may be incremented if a section has more than one
            * entry (which all are to be removed).
            */
            static void maybe_remove_section(struct config_store_data *store,
                                            size_t *begin_offset, size_t *end_offset,
                                            int *seen_ptr)
            {
                    size_t begin;
                    int i, seen, section_seen = 0;

                    /*
                    * First, ensure that this is the first key, and that there are no
                    * comments before the entry nor before the section header.
                    */
                    seen = *seen_ptr;
                    for (i = store->seen[seen]; i > 0; i--) {
                            enum config_event_t type = store->parsed[i - 1].type;

                            if (type == CONFIG_EVENT_COMMENT)
                                    /* There is a comment before this entry or section */
                                    return;
                            if (type == CONFIG_EVENT_ENTRY) {
                                    if (!section_seen)
                                            /* This is not the section's first entry. */
                                            return;
                                    /* We encountered no comment before the section. */
                                    break;
                            }
                            if (type == CONFIG_EVENT_SECTION) {
                                    if (!store->parsed[i - 1].is_keys_section)
                                            break;
                                    section_seen = 1;
                            }
                    }
                    begin = store->parsed[i].begin;

                    /*
                    * Next, make sure that we are removing the last key(s) in the section,
                    * and that there are no comments that are possibly about the current
                    * section.
                    */
                    for (i = store->seen[seen] + 1; i < store->parsed_nr; i++) {
                            enum config_event_t type = store->parsed[i].type;

                            if (type == CONFIG_EVENT_COMMENT)
                                    return;
                            if (type == CONFIG_EVENT_SECTION) {
                                    if (store->parsed[i].is_keys_section)
                                            continue;
                                    break;
                            }
                            if (type == CONFIG_EVENT_ENTRY) {
                                    if (++seen < store->seen_nr &&
                                    i == store->seen[seen])
                                            /* We want to remove this entry, too */
                                            continue;
                                    /* There is another entry in this section. */
                                    return;
                            }
                    }

                    /*
                    * We are really removing the last entry/entries from this section, and
                    * there are no enclosed or surrounding comments. Remove the entire,
                    * now-empty section.
                    */
                    *seen_ptr = seen;
                    *begin_offset = begin;
                    if (i < store->parsed_nr)
                            *end_offset = store->parsed[i].begin;
                    else
                            *end_offset = store->parsed[store->parsed_nr - 1].end;
            }

            int repo_config_set_in_file_gently(struct repository *r, const char *config_filename,
                                            const char *key, const char *comment, const char *value)
            {
                    return repo_config_set_multivar_in_file_gently(r, config_filename, key, value, NULL, comment, 0);
            }

            void repo_config_set_in_file(struct repository *r, const char *config_filename,
                                    const char *key, const char *value)
            {
                    repo_config_set_multivar_in_file(r, config_filename, key, value, NULL, 0);
            }

            int repo_config_set_gently(struct repository *r, const char *key, const char *value)
            {
                    return repo_config_set_multivar_gently(r, key, value, NULL, 0);
            }

            int repo_config_set_worktree_gently(struct repository *r,
                                            const char *key, const char *value)
            {
                    /* Only use worktree-specific config if it is already enabled. */
                    if (r->repository_format_worktree_config) {
                            char *file = repo_git_path(r, "config.worktree");
                            int ret = repo_config_set_multivar_in_file_gently(
                                                    r, file, key, value, NULL, NULL, 0);
                            free(file);
                            return ret;
                    }
                    return repo_config_set_multivar_gently(r, key, value, NULL, 0);
            }

            void repo_config_set(struct repository *r, const char *key, const char *value)
            {
                    repo_config_set_multivar(r, key, value, NULL, 0);

                    trace2_cmd_set_config(key, value);
            }

            char *git_config_prepare_comment_string(const char *comment)
            {
                    size_t leading_blanks;
                    char *prepared;

                    if (!comment)
                            return NULL;

                    if (strchr(comment, '\n'))
                            die(_("no multi-line comment allowed: '%s'"), comment);

                    /*
                    * If it begins with one or more leading whitespace characters
                    * followed by '#", the comment string is used as-is.
                    *
                    * If it begins with '#', a SP is inserted between the comment
                    * and the value the comment is about.
                    *
                    * Otherwise, the value is followed by a SP followed by '#'
                    * followed by SP and then the comment string comes.
                    */

                    leading_blanks = strspn(comment, " \t");
                    if (leading_blanks && comment[leading_blanks] == '#')
                            prepared = xstrdup(comment); /* use it as-is */
                    else if (comment[0] == '#')
                            prepared = xstrfmt(" %s", comment);
                    else
                            prepared = xstrfmt(" # %s", comment);

                    return prepared;
            }

            static void validate_comment_string(const char *comment)
            {
                    size_t leading_blanks;

                    if (!comment)
                            return;
                    /*
                    * The front-end must have massaged the comment string
                    * properly before calling us.
                    */
                    if (strchr(comment, '\n'))
                            BUG("multi-line comments are not permitted: '%s'", comment);

                    leading_blanks = strspn(comment, " \t");
                    if (!leading_blanks || comment[leading_blanks] != '#')
                            BUG("comment must begin with one or more SP followed by '#': '%s'",
                            comment);
            }

            /*
            * If value==NULL, unset in (remove from) config,
            * if value_pattern!=NULL, disregard key/value pairs where value does not match.
            * if value_pattern==CONFIG_REGEX_NONE, do not match any existing values
            *     (only add a new one)
            * if flags contains the CONFIG_FLAGS_MULTI_REPLACE flag, all matching
            *     key/values are removed before a single new pair is written. If the
            *     flag is not present, then replace only the first match.
            *
            * Returns 0 on success.
            *
            * This function does this:
            *
            * - it locks the config file by creating ".git/config.lock"
            *
            * - it then parses the config using store_aux() as validator to find
            *   the position on the key/value pair to replace. If it is to be unset,
            *   it must be found exactly once.
            *
            * - the config file is mmap()ed and the part before the match (if any) is
            *   written to the lock file, then the changed part and the rest.
            *
            * - the config file is removed and the lock file rename()d to it.
            *
            */
            int repo_config_set_multivar_in_file_gently(struct repository *r,
                                                    const char *config_filename,
                                                    const char *key, const char *value,
                                                    const char *value_pattern,
                                                    const char *comment,
                                                    unsigned flags)
            {
                    int fd = -1, in_fd = -1;
                    int ret;
                    struct lock_file lock = LOCK_INIT;
                    char *filename_buf = NULL;
                    char *contents = NULL;
                    size_t contents_sz;
                    struct config_store_data store = CONFIG_STORE_INIT;

                    validate_comment_string(comment);

                    /* parse-key returns negative; flip the sign to feed exit(3) */
                    ret = 0 - git_config_parse_key(key, &store.key, &store.baselen);
                    if (ret)
                            goto out_free;

                    store.multi_replace = (flags & CONFIG_FLAGS_MULTI_REPLACE) != 0;

                    if (!config_filename)
                            config_filename = filename_buf = repo_git_path(r, "config");

                    /*
                    * The lock serves a purpose in addition to locking: the new
                    * contents of .git/config will be written into it.
                    */
                    fd = hold_lock_file_for_update(&lock, config_filename, 0);
                    if (fd < 0) {
                            error_errno(_("could not lock config file %s"), config_filename);
                            ret = CONFIG_NO_LOCK;
                            goto out_free;
                    }

                    /*
                    * If .git/config does not exist yet, write a minimal version.
                    */
                    in_fd = open(config_filename, O_RDONLY);
                    if ( in_fd < 0 ) {
                            if ( ENOENT != errno ) {
                                    error_errno(_("opening %s"), config_filename);
                                    ret = CONFIG_INVALID_FILE; /* same as "invalid config file" */
                                    goto out_free;
                            }
                            /* if nothing to unset, error out */
                            if (!value) {
                                    ret = CONFIG_NOTHING_SET;
                                    goto out_free;
                            }

                            free(store.key);
                            store.key = xstrdup(key);
                            if (write_section(fd, key, &store) < 0 ||
                            write_pair(fd, key, value, comment, &store) < 0)
                                    goto write_err_out;
                    } else {
                            struct stat st;
                            size_t copy_begin, copy_end;
                            int i, new_line = 0;
                            struct config_options opts;

                            if (!value_pattern)
                                    store.value_pattern = NULL;
                            else if (value_pattern == CONFIG_REGEX_NONE)
                                    store.value_pattern = CONFIG_REGEX_NONE;
                            else if (flags & CONFIG_FLAGS_FIXED_VALUE)
                                    store.fixed_value = value_pattern;
                            else {
                                    if (value_pattern[0] == '!') {
                                            store.do_not_match = 1;
                                            value_pattern++;
                                    } else
                                            store.do_not_match = 0;

                                    store.value_pattern = (regex_t*)xmalloc(sizeof(regex_t));
                                    if (regcomp(store.value_pattern, value_pattern,
                                                    REG_EXTENDED)) {
                                            error(_("invalid pattern: %s"), value_pattern);
                                            FREE_AND_NULL(store.value_pattern);
                                            ret = CONFIG_INVALID_PATTERN;
                                            goto out_free;
                                    }
                            }

                            ALLOC_GROW(store.parsed, 1, store.parsed_alloc);
                            store.parsed[0].end = 0;

                            memset(&opts, 0, sizeof(opts));
                            opts.event_fn = store_aux_event;
                            opts.event_fn_data = &store;

                            /*
                            * After this, store.parsed will contain offsets of all the
                            * parsed elements, and store.seen will contain a list of
                            * matches, as indices into store.parsed.
                            *
                            * As a side effect, we make sure to transform only a valid
                            * existing config file.
                            */
                            if (git_config_from_file_with_options(store_aux,
                                                            config_filename,
                                                            &store, CONFIG_SCOPE_UNKNOWN,
                                                            &opts)) {
                                    error(_("invalid config file %s"), config_filename);
                                    ret = CONFIG_INVALID_FILE;
                                    goto out_free;
                            }

                            /* if nothing to unset, or too many matches, error out */
                            if ((store.seen_nr == 0 && value == NULL) ||
                            (store.seen_nr > 1 && !store.multi_replace)) {
                                    ret = CONFIG_NOTHING_SET;
                                    goto out_free;
                            }

                            if (fstat(in_fd, &st) == -1) {
                                    error_errno(_("fstat on %s failed"), config_filename);
                                    ret = CONFIG_INVALID_FILE;
                                    goto out_free;
                            }

                            contents_sz = xsize_t(st.st_size);
                            contents = xmmap_gently(NULL, contents_sz, PROT_READ,
                                                    MAP_PRIVATE, in_fd, 0);
                            if (contents == MAP_FAILED) {
                                    if (errno == ENODEV && S_ISDIR(st.st_mode))
                                            errno = EISDIR;
                                    error_errno(_("unable to mmap '%s'%s"),
                                                    config_filename, mmap_os_err());
                                    ret = CONFIG_INVALID_FILE;
                                    contents = NULL;
                                    goto out_free;
                            }
                            close(in_fd);
                            in_fd = -1;

                            if (chmod(get_lock_file_path(&lock), st.st_mode & 07777) < 0) {
                                    error_errno(_("chmod on %s failed"), get_lock_file_path(&lock));
                                    ret = CONFIG_NO_WRITE;
                                    goto out_free;
                            }

                            if (store.seen_nr == 0) {
                                    if (!store.seen_alloc) {
                                            /* Did not see key nor section */
                                            ALLOC_GROW(store.seen, 1, store.seen_alloc);
                                            store.seen[0] = store.parsed_nr
                                                    - !!store.parsed_nr;
                                    }
                                    store.seen_nr = 1;
                            }

                            for (i = 0, copy_begin = 0; i < store.seen_nr; i++) {
                                    size_t replace_end;
                                    int j = store.seen[i];

                                    new_line = 0;
                                    if (!store.key_seen) {
                                            copy_end = store.parsed[j].end;
                                            /* include '\n' when copying section header */
                                            if (copy_end > 0 && copy_end < contents_sz &&
                                            contents[copy_end - 1] != '\n' &&
                                            contents[copy_end] == '\n')
                                                    copy_end++;
                                            replace_end = copy_end;
                                    } else {
                                            replace_end = store.parsed[j].end;
                                            copy_end = store.parsed[j].begin;
                                            if (!value)
                                                    maybe_remove_section(&store,
                                                                    &copy_end,
                                                                    &replace_end, &i);
                                            /*
                                            * Swallow preceding white-space on the same
                                            * line.
                                            */
                                            while (copy_end > 0 ) {
                                                    char c = contents[copy_end - 1];

                                                    if (isspace(c) && c != '\n')
                                                            copy_end--;
                                                    else
                                                            break;
                                            }
                                    }

                                    if (copy_end > 0 && contents[copy_end-1] != '\n')
                                            new_line = 1;

                                    /* write the first part of the config */
                                    if (copy_end > copy_begin) {
                                            if (write_in_full(fd, contents + copy_begin,
                                                            copy_end - copy_begin) < 0)
                                                    goto write_err_out;
                                            if (new_line &&
                                            write_str_in_full(fd, "\n") < 0)
                                                    goto write_err_out;
                                    }
                                    copy_begin = replace_end;
                            }

                            /* write the pair (value == NULL means unset) */
                            if (value) {
                                    if (!store.section_seen) {
                                            if (write_section(fd, key, &store) < 0)
                                                    goto write_err_out;
                                    }
                                    if (write_pair(fd, key, value, comment, &store) < 0)
                                            goto write_err_out;
                            }

                            /* write the rest of the config */
                            if (copy_begin < contents_sz)
                                    if (write_in_full(fd, contents + copy_begin,
                                                    contents_sz - copy_begin) < 0)
                                            goto write_err_out;

                            munmap(contents, contents_sz);
                            contents = NULL;
                    }

                    if (commit_lock_file(&lock) < 0) {
                            error_errno(_("could not write config file %s"), config_filename);
                            ret = CONFIG_NO_WRITE;
                            goto out_free;
                    }

                    ret = 0;

                    /* Invalidate the config cache */
                    repo_config_clear(r);

            out_free:
                    rollback_lock_file(&lock);
                    free(filename_buf);
                    if (contents)
                            munmap(contents, contents_sz);
                    if (in_fd >= 0)
                            close(in_fd);
                    config_store_data_clear(&store);
                    return ret;

            write_err_out:
                    ret = write_error(get_lock_file_path(&lock));
                    goto out_free;
            }

            void repo_config_set_multivar_in_file(struct repository *r,
                                            const char *config_filename,
                                            const char *key, const char *value,
                                            const char *value_pattern, unsigned flags)
            {
                    if (!repo_config_set_multivar_in_file_gently(r, config_filename, key, value,
                                                            value_pattern, NULL, flags))
                            return;
                    if (value)
                            die(_("could not set '%s' to '%s'"), key, value);
                    else
                            die(_("could not unset '%s'"), key);
            }

            int repo_config_set_multivar_gently(struct repository *r, const char *key,
                                            const char *value,
                                            const char *value_pattern, unsigned flags)
            {
                    char *file = repo_git_path(r, "config");
                    int res = repo_config_set_multivar_in_file_gently(r, file,
                                                                    key, value,
                                                                    value_pattern,
                                                                    NULL, flags);
                    free(file);
                    return res;
            }

            void repo_config_set_multivar(struct repository *r,
                                    const char *key, const char *value,
                                    const char *value_pattern, unsigned flags)
            {
                    char *file = repo_git_path(r, "config");
                    repo_config_set_multivar_in_file(r, file, key, value,
                                                    value_pattern, flags);
                    free(file);
            }

            static size_t section_name_match (const char *buf, const char *name)
            {
                    size_t i = 0, j = 0;
                    int dot = 0;
                    if (buf[i] != '[')
                            return 0;
                    for (i = 1; buf[i] && buf[i] != ']'; i++) {
                            if (!dot && isspace(buf[i])) {
                                    dot = 1;
                                    if (name[j++] != '.')
                                            break;
                                    for (i++; isspace(buf[i]); i++)
                                            ; /* do nothing */
                                    if (buf[i] != '"')
                                            break;
                                    continue;
                            }
                            if (buf[i] == '\\' && dot)
                                    i++;
                            else if (buf[i] == '"' && dot) {
                                    for (i++; isspace(buf[i]); i++)
                                            ; /* do_nothing */
                                    break;
                            }
                            if (buf[i] != name[j++])
                                    break;
                    }
                    if (buf[i] == ']' && name[j] == 0) {
                            /*
                            * We match, now just find the right length offset by
                            * gobbling up any whitespace after it, as well
                            */
                            i++;
                            for (; buf[i] && isspace(buf[i]); i++)
                                    ; /* do nothing */
                            return i;
                    }
                    return 0;
            }

            static int section_name_is_ok(const char *name)
            {
                    /* Empty section names are bogus. */
                    if (!*name)
                            return 0;

                    /*
                    * Before a dot, we must be alphanumeric or dash. After the first dot,
                    * anything goes, so we can stop checking.
                    */
                    for (; *name && *name != '.'; name++)
                            if (*name != '-' && !isalnum(*name))
                                    return 0;
                    return 1;
            }

            #define GIT_CONFIG_MAX_LINE_LEN (512 * 1024)

            /* if new_name == NULL, the section is removed instead */
            static int repo_config_copy_or_rename_section_in_file(
                    struct repository *r,
                    const char *config_filename,
                    const char *old_name,
                    const char *new_name, int copy)
            {
                    int ret = 0, remove = 0;
                    char *filename_buf = NULL;
                    struct lock_file lock = LOCK_INIT;
                    int out_fd;
                    struct strbuf buf = STRBUF_INIT;
                    FILE *config_file = NULL;
                    struct stat st;
                    struct strbuf copystr = STRBUF_INIT;
                    struct config_store_data store;
                    uint32_t line_nr = 0;

                    memset(&store, 0, sizeof(store));

                    if (new_name && !section_name_is_ok(new_name)) {
                            ret = error(_("invalid section name: %s"), new_name);
                            goto out_no_rollback;
                    }

                    if (!config_filename)
                            config_filename = filename_buf = repo_git_path(r, "config");

                    out_fd = hold_lock_file_for_update(&lock, config_filename, 0);
                    if (out_fd < 0) {
                            ret = error(_("could not lock config file %s"), config_filename);
                            goto out;
                    }

                    if (!(config_file = fopen(config_filename, "rb"))) {
                            ret = warn_on_fopen_errors(config_filename);
                            if (ret)
                                    goto out;
                            /* no config file means nothing to rename, no error */
                            goto commit_and_out;
                    }

                    if (fstat(fileno(config_file), &st) == -1) {
                            ret = error_errno(_("fstat on %s failed"), config_filename);
                            goto out;
                    }

                    if (chmod(get_lock_file_path(&lock), st.st_mode & 07777) < 0) {
                            ret = error_errno(_("chmod on %s failed"),
                                            get_lock_file_path(&lock));
                            goto out;
                    }

                    while (!strbuf_getwholeline(&buf, config_file, '\n')) {
                            size_t i, length;
                            int is_section = 0;
                            char *output = buf.buf;

                            line_nr++;

                            if (buf.len >= GIT_CONFIG_MAX_LINE_LEN) {
                                    ret = error(_("refusing to work with overly long line "
                                            "in '%s' on line %"PRIuMAX),
                                            config_filename, (uintmax_t)line_nr);
                                    goto out;
                            }

                            for (i = 0; buf.buf[i] && isspace(buf.buf[i]); i++)
                                    ; /* do nothing */
                            if (buf.buf[i] == '[') {
                                    /* it's a section */
                                    size_t offset;
                                    is_section = 1;

                                    /*
                                    * When encountering a new section under -c we
                                    * need to flush out any section we're already
                                    * coping and begin anew. There might be
                                    * multiple [branch "$name"] sections.
                                    */
                                    if (copystr.len > 0) {
                                            if (write_in_full(out_fd, copystr.buf, copystr.len) < 0) {
                                                    ret = write_error(get_lock_file_path(&lock));
                                                    goto out;
                                            }
                                            strbuf_reset(&copystr);
                                    }

                                    offset = section_name_match(&buf.buf[i], old_name);
                                    if (offset > 0) {
                                            ret++;
                                            if (!new_name) {
                                                    remove = 1;
                                                    continue;
                                            }
                                            store.baselen = strlen(new_name);
                                            if (!copy) {
                                                    if (write_section(out_fd, new_name, &store) < 0) {
                                                            ret = write_error(get_lock_file_path(&lock));
                                                            goto out;
                                                    }
                                                    /*
                                                    * We wrote out the new section, with
                                                    * a newline, now skip the old
                                                    * section's length
                                                    */
                                                    output += offset + i;
                                                    if (strlen(output) > 0) {
                                                            /*
                                                            * More content means there's
                                                            * a declaration to put on the
                                                            * next line; indent with a
                                                            * tab
                                                            */
                                                            output -= 1;
                                                            output[0] = '\t';
                                                    }
                                            } else {
                                                    strbuf_release(&copystr);
                                                    copystr = store_create_section(new_name, &store);
                                            }
                                    }
                                    remove = 0;
                            }
                            if (remove)
                                    continue;
                            length = strlen(output);

                            if (!is_section && copystr.len > 0) {
                                    strbuf_add(&copystr, output, length);
                            }

                            if (write_in_full(out_fd, output, length) < 0) {
                                    ret = write_error(get_lock_file_path(&lock));
                                    goto out;
                            }
                    }

                    /*
                    * Copy a trailing section at the end of the config, won't be
                    * flushed by the usual "flush because we have a new section
                    * logic in the loop above.
                    */
                    if (copystr.len > 0) {
                            if (write_in_full(out_fd, copystr.buf, copystr.len) < 0) {
                                    ret = write_error(get_lock_file_path(&lock));
                                    goto out;
                            }
                            strbuf_reset(&copystr);
                    }

                    fclose(config_file);
                    config_file = NULL;
            commit_and_out:
                    if (commit_lock_file(&lock) < 0)
                            ret = error_errno(_("could not write config file %s"),
                                            config_filename);
            out:
                    if (config_file)
                            fclose(config_file);
                    rollback_lock_file(&lock);
            out_no_rollback:
                    free(filename_buf);
                    config_store_data_clear(&store);
                    strbuf_release(&buf);
                    strbuf_release(&copystr);
                    return ret;
            }

            int repo_config_rename_section_in_file(struct repository *r, const char *config_filename,
                                            const char *old_name, const char *new_name)
            {
                    return repo_config_copy_or_rename_section_in_file(r, config_filename,
                                                    old_name, new_name, 0);
            }

            int repo_config_rename_section(struct repository *r, const char *old_name, const char *new_name)
            {
                    return repo_config_rename_section_in_file(r, NULL, old_name, new_name);
            }

            int repo_config_copy_section_in_file(struct repository *r, const char *config_filename,
                                            const char *old_name, const char *new_name)
            {
                    return repo_config_copy_or_rename_section_in_file(r, config_filename,
                                                    old_name, new_name, 1);
            }

            int repo_config_copy_section(struct repository *r, const char *old_name, const char *new_name)
            {
                    return repo_config_copy_section_in_file(r, NULL, old_name, new_name);
            }

            /*
            * Call this to report error for your variable that should not
            * get a boolean value (i.e. "[my] var" means "true").
            */
            #undef config_error_nonbool
            int config_error_nonbool(const char *var)
            {
                    return error(_("missing value for '%s'"), var);
            }

            int parse_config_key(const char *var,
                            const char *section,
                            const char **subsection, size_t *subsection_len,
                            const char **key)
            {
                    const char *dot;

                    /* Does it start with "section." ? */
                    if (!skip_prefix(var, section, &var) || *var != '.')
                            return -1;

                    /*
                    * Find the key; we don't know yet if we have a subsection, but we must
                    * parse backwards from the end, since the subsection may have dots in
                    * it, too.
                    */
                    dot = strrchr(var, '.');
                    *key = dot + 1;

                    /* Did we have a subsection at all? */
                    if (dot == var) {
                            if (subsection) {
                                    *subsection = NULL;
                                    *subsection_len = 0;
                            }
                    }
                    else {
                            if (!subsection)
                                    return -1;
                            *subsection = var + 1;
                            *subsection_len = dot - *subsection;
                    }

                    return 0;
            }

            const char *config_origin_type_name(enum config_origin_type type)
            {
                    switch (type) {
                    case CONFIG_ORIGIN_BLOB:
                            return "blob";
                    case CONFIG_ORIGIN_FILE:
                            return "file";
                    case CONFIG_ORIGIN_STDIN:
                            return "standard input";
                    case CONFIG_ORIGIN_SUBMODULE_BLOB:
                            return "submodule-blob";
                    case CONFIG_ORIGIN_CMDLINE:
                            return "command line";
                    default:
                            BUG("unknown config origin type");
                    }
            }

            const char *config_scope_name(enum config_scope scope)
            {
                    switch (scope) {
                    case CONFIG_SCOPE_SYSTEM:
                            return "system";
                    case CONFIG_SCOPE_GLOBAL:
                            return "global";
                    case CONFIG_SCOPE_LOCAL:
                            return "local";
                    case CONFIG_SCOPE_WORKTREE:
                            return "worktree";
                    case CONFIG_SCOPE_COMMAND:
                            return "command";
                    case CONFIG_SCOPE_SUBMODULE:
                            return "submodule";
                    default:
                            return "unknown";
                    }
            }

            int lookup_config(const char **mapping, int nr_mapping, const char *var)
            {
                    int i;

                    for (i = 0; i < nr_mapping; i++) {
                            const char *name = mapping[i];

                            if (name && !strcasecmp(var, name))
                                    return i;
                    }
                    return -1;
            }

        """,

        "Patche":
        """
                    diff --git a/config.c b/config.c
            index 50f2d17b39..8cc8aab4d2 100644
            --- a/config.c
            +++ b/config.c
            @@ -33,6 +33,9 @@
            #include "object-store-ll.h"
            #include "pager.h"
            #include "path.h"
            +#ifdef __MVS__
            +#include "read-cache-ll.h"
            +#endif
            #include "utf8.h"
            #include "color.h"
            #include "refs.h"
            @@ -1508,6 +1511,18 @@ static int git_default_core_config(const char *var, const char *value,
                            return 0;
                    }

            + #ifdef __MVS__
            +   if (!strcmp(var, "core.ignorefiletags")) {
            +       ignore_file_tags = git_config_bool(var, value);
            +       return 0;
            +   }
            +
            +   if (!strcmp(var, "core.utf8ccsid")) {
            +       utf8_ccsid = git_config_ulong(var, value, ctx->kvi);
            +       return 0;
            +   }
            +#endif
            +
                    if (!strcmp(var, "core.safecrlf")) {
                            int eol_rndtrp_die;
                            if (value && !strcasecmp(value, "warn")) {

    """,

    },

    {
        "WrongCode":
        """
                    # Platform specific Makefile tweaks based on uname detection

            # Define NO_SAFESEH if you need MSVC/Visual Studio to ignore the lack of
            # Microsoft's Safe Exception Handling in libraries (such as zlib).
            # Typically required for VS2013+/32-bit compilation on Vista+ versions.

            uname_S := $(shell sh -c 'uname -s 2>/dev/null || echo not')
            uname_M := $(shell sh -c 'uname -m 2>/dev/null || echo not')
            uname_O := $(shell sh -c 'uname -o 2>/dev/null || echo not')
            uname_R := $(shell sh -c 'uname -r 2>/dev/null || echo not')
            uname_V := $(shell sh -c 'uname -v 2>/dev/null || echo not')

            ifneq ($(findstring MINGW,$(uname_S)),)
                    uname_S := MINGW
            endif

            ifdef MSVC
                    # avoid the MingW and Cygwin configuration sections
                    uname_S := Windows
                    uname_O := Windows

                    # Generate and include makefile variables that point to the
                    # currently installed set of MSVC command line tools.
            compat/vcbuild/MSVC-DEFS-GEN: compat/vcbuild/find_vs_env.bat
                    @"$<" | tr '\\' / >"$@"
            include compat/vcbuild/MSVC-DEFS-GEN

                    # See if vcpkg and the vcpkg-build versions of the third-party
                    # libraries that we use are installed.  We include the result
                    # to get $(vcpkg_*) variables defined for the Makefile.
            ifeq (,$(SKIP_VCPKG))
            compat/vcbuild/VCPKG-DEFS: compat/vcbuild/vcpkg_install.bat
                    @"$<"
            include compat/vcbuild/VCPKG-DEFS
            endif
            endif

            # We choose to avoid "if .. else if .. else .. endif endif"
            # because maintaining the nesting to match is a pain.  If
            # we had "elif" things would have been much nicer...

            ifeq ($(uname_S),OSF1)
                    # Need this for u_short definitions et al
                    BASIC_CFLAGS += -D_OSF_SOURCE
                    SOCKLEN_T = int
                    NO_STRTOULL = YesPlease
                    NO_NSEC = YesPlease
            endif
            ifeq ($(uname_S),Linux)
                    HAVE_ALLOCA_H = YesPlease
                    NO_STRLCPY = YesPlease
                    HAVE_PATHS_H = YesPlease
                    LIBC_CONTAINS_LIBINTL = YesPlease
                    HAVE_DEV_TTY = YesPlease
                    HAVE_CLOCK_GETTIME = YesPlease
                    HAVE_CLOCK_MONOTONIC = YesPlease
                    # -lrt is needed for clock_gettime on glibc <= 2.16
                    NEEDS_LIBRT = YesPlease
                    HAVE_SYNC_FILE_RANGE = YesPlease
                    HAVE_GETDELIM = YesPlease
                    FREAD_READS_DIRECTORIES = UnfortunatelyYes
                    BASIC_CFLAGS += -DHAVE_SYSINFO
                    PROCFS_EXECUTABLE_PATH = /proc/self/exe
                    HAVE_PLATFORM_PROCINFO = YesPlease
                    COMPAT_OBJS += compat/linux/procinfo.o
                    # centos7/rhel7 provides gcc 4.8.5 and zlib 1.2.7.
                    ifneq ($(findstring .el7.,$(uname_R)),)
                            BASIC_CFLAGS += -std=c99
                    endif
                    LINK_FUZZ_PROGRAMS = YesPlease
            endif
            ifeq ($(uname_S),GNU/kFreeBSD)
                    HAVE_ALLOCA_H = YesPlease
                    NO_STRLCPY = YesPlease
                    HAVE_PATHS_H = YesPlease
                    DIR_HAS_BSD_GROUP_SEMANTICS = YesPlease
                    LIBC_CONTAINS_LIBINTL = YesPlease
                    FREAD_READS_DIRECTORIES = UnfortunatelyYes
            endif
            ifeq ($(uname_S),UnixWare)
                    CC = cc
                    NEEDS_SOCKET = YesPlease
                    NEEDS_NSL = YesPlease
                    NEEDS_SSL_WITH_CRYPTO = YesPlease
                    NEEDS_LIBICONV = YesPlease
                    SHELL_PATH = /usr/local/bin/bash
                    NO_IPV6 = YesPlease
                    NO_HSTRERROR = YesPlease
                    BASIC_CFLAGS += -Kthread
                    BASIC_CFLAGS += -I/usr/local/include
                    BASIC_LDFLAGS += -L/usr/local/lib
                    INSTALL = ginstall
                    TAR = gtar
                    NO_STRCASESTR = YesPlease
                    NO_MEMMEM = YesPlease
            endif
            ifeq ($(uname_S),SCO_SV)
                    ifeq ($(uname_R),3.2)
                            CFLAGS = -O2
                    endif
                    ifeq ($(uname_R),5)
                            CC = cc
                            BASIC_CFLAGS += -Kthread
                    endif
                    NEEDS_SOCKET = YesPlease
                    NEEDS_NSL = YesPlease
                    NEEDS_SSL_WITH_CRYPTO = YesPlease
                    NEEDS_LIBICONV = YesPlease
                    SHELL_PATH = /usr/bin/bash
                    NO_IPV6 = YesPlease
                    NO_HSTRERROR = YesPlease
                    BASIC_CFLAGS += -I/usr/local/include
                    BASIC_LDFLAGS += -L/usr/local/lib
                    NO_STRCASESTR = YesPlease
                    NO_MEMMEM = YesPlease
                    INSTALL = ginstall
                    TAR = gtar
            endif
            ifeq ($(uname_S),Darwin)
                    NEEDS_CRYPTO_WITH_SSL = YesPlease
                    NEEDS_SSL_WITH_CRYPTO = YesPlease
                    NEEDS_LIBICONV = YesPlease
                    # Note: $(uname_R) gives us the underlying Darwin version.
                    # - MacOS 10.0.* and MacOS 10.1.0 = Darwin 1.*
                    # - MacOS 10.x.* = Darwin (x+4).* for (1 <= x)
                    # i.e. "begins with [15678] and a dot" means "10.4.* or older".
                    ifeq ($(shell expr "$(uname_R)" : '[15678]\.'),2)
                            OLD_ICONV = UnfortunatelyYes
                            NO_APPLE_COMMON_CRYPTO = YesPlease
                    endif
                    ifeq ($(shell expr "$(uname_R)" : '[15]\.'),2)
                            NO_STRLCPY = YesPlease
                    endif
                    ifeq ($(shell test "`expr "$(uname_R)" : '\([0-9][0-9]*\)\.'`" -ge 11 && echo 1),1)
                            HAVE_GETDELIM = YesPlease
                    endif
                    ifeq ($(shell test "`expr "$(uname_R)" : '\([0-9][0-9]*\)\.'`" -ge 20 && echo 1),1)
                            OPEN_RETURNS_EINTR = UnfortunatelyYes
                    endif
                    NO_MEMMEM = YesPlease
                    USE_ST_TIMESPEC = YesPlease
                    HAVE_DEV_TTY = YesPlease
                    COMPAT_OBJS += compat/precompose_utf8.o
                    BASIC_CFLAGS += -DPRECOMPOSE_UNICODE
                    BASIC_CFLAGS += -DPROTECT_HFS_DEFAULT=1
                    HAVE_BSD_SYSCTL = YesPlease
                    FREAD_READS_DIRECTORIES = UnfortunatelyYes
                    HAVE_NS_GET_EXECUTABLE_PATH = YesPlease
                    CSPRNG_METHOD = arc4random
                    USE_ENHANCED_BASIC_REGULAR_EXPRESSIONS = YesPlease

                    # Workaround for `gettext` being keg-only and not even being linked via
                    # `brew link --force gettext`, should be obsolete as of
                    # https://github.com/Homebrew/homebrew-core/pull/53489
                    ifeq ($(shell test -d /usr/local/opt/gettext/ && echo y),y)
                            BASIC_CFLAGS += -I/usr/local/include -I/usr/local/opt/gettext/include
                            BASIC_LDFLAGS += -L/usr/local/lib -L/usr/local/opt/gettext/lib
                            ifeq ($(shell test -x /usr/local/opt/gettext/bin/msgfmt && echo y),y)
                                    MSGFMT = /usr/local/opt/gettext/bin/msgfmt
                            endif
                    # On newer ARM-based machines the default installation path has changed to
                    # /opt/homebrew. Include it in our search paths so that the user does not
                    # have to configure this manually.
                    #
                    # Note that we do not employ the same workaround as above where we manually
                    # add gettext. The issue was fixed more than three years ago by now, and at
                    # that point there haven't been any ARM-based Macs yet.
                    else ifeq ($(shell test -d /opt/homebrew/ && echo y),y)
                            BASIC_CFLAGS += -I/opt/homebrew/include
                            BASIC_LDFLAGS += -L/opt/homebrew/lib
                            ifeq ($(shell test -x /opt/homebrew/bin/msgfmt && echo y),y)
                                    MSGFMT = /opt/homebrew/bin/msgfmt
                            endif
                    endif

                    # The builtin FSMonitor on MacOS builds upon Simple-IPC.  Both require
                    # Unix domain sockets and PThreads.
                    ifndef NO_PTHREADS
                    ifndef NO_UNIX_SOCKETS
                    FSMONITOR_DAEMON_BACKEND = darwin
                    FSMONITOR_OS_SETTINGS = darwin
                    endif
                    endif

                    BASIC_LDFLAGS += -framework CoreServices
            endif
            ifeq ($(uname_S),SunOS)
                    NEEDS_SOCKET = YesPlease
                    NEEDS_NSL = YesPlease
                    SHELL_PATH = /bin/bash
                    SANE_TOOL_PATH = /usr/xpg6/bin:/usr/xpg4/bin
                    HAVE_ALLOCA_H = YesPlease
                    NO_STRCASESTR = YesPlease
                    NO_MEMMEM = YesPlease
                    NO_MKDTEMP = YesPlease
                    NO_REGEX = YesPlease
                    NO_MSGFMT_EXTENDED_OPTIONS = YesPlease
                    HAVE_DEV_TTY = YesPlease
                    ifeq ($(uname_R),5.6)
                            SOCKLEN_T = int
                            NO_HSTRERROR = YesPlease
                            NO_IPV6 = YesPlease
                            NO_SOCKADDR_STORAGE = YesPlease
                            NO_UNSETENV = YesPlease
                            NO_SETENV = YesPlease
                            NO_STRLCPY = YesPlease
                            NO_STRTOUMAX = YesPlease
                            GIT_TEST_CMP = cmp
                    endif
                    ifeq ($(uname_R),5.7)
                            NEEDS_RESOLV = YesPlease
                            NO_IPV6 = YesPlease
                            NO_SOCKADDR_STORAGE = YesPlease
                            NO_UNSETENV = YesPlease
                            NO_SETENV = YesPlease
                            NO_STRLCPY = YesPlease
                            NO_STRTOUMAX = YesPlease
                            GIT_TEST_CMP = cmp
                    endif
                    ifeq ($(uname_R),5.8)
                            NO_UNSETENV = YesPlease
                            NO_SETENV = YesPlease
                            NO_STRTOUMAX = YesPlease
                            GIT_TEST_CMP = cmp
                    endif
                    ifeq ($(uname_R),5.9)
                            NO_UNSETENV = YesPlease
                            NO_SETENV = YesPlease
                            NO_STRTOUMAX = YesPlease
                            GIT_TEST_CMP = cmp
                    endif
                    INSTALL = /usr/ucb/install
                    TAR = gtar
                    BASIC_CFLAGS += -D__EXTENSIONS__ -D__sun__
            endif
            ifeq ($(uname_O),Cygwin)
                    ifeq ($(shell expr "$(uname_R)" : '1\.[1-6]\.'),4)
                            NO_D_TYPE_IN_DIRENT = YesPlease
                            NO_STRCASESTR = YesPlease
                            NO_MEMMEM = YesPlease
                            NO_SYMLINK_HEAD = YesPlease
                            NO_IPV6 = YesPlease
                            OLD_ICONV = UnfortunatelyYes
                            # There are conflicting reports about this.
                            # On some boxes NO_MMAP is needed, and not so elsewhere.
                            # Try commenting this out if you suspect MMAP is more efficient
                            NO_MMAP = YesPlease
                    else
                            NO_REGEX = UnfortunatelyYes
                    endif
                    HAVE_DEV_TTY = YesPlease
                    HAVE_ALLOCA_H = YesPlease
                    NEEDS_LIBICONV = YesPlease
                    NO_FAST_WORKING_DIRECTORY = UnfortunatelyYes
                    NO_ST_BLOCKS_IN_STRUCT_STAT = YesPlease
                    X = .exe
                    UNRELIABLE_FSTAT = UnfortunatelyYes
                    OBJECT_CREATION_USES_RENAMES = UnfortunatelyNeedsTo
                    MMAP_PREVENTS_DELETE = UnfortunatelyYes
                    COMPAT_OBJS += compat/win32/path-utils.o
                    FREAD_READS_DIRECTORIES = UnfortunatelyYes
            endif
            ifeq ($(uname_S),FreeBSD)
                    NEEDS_LIBICONV = YesPlease
                    # Versions up to 10.1 require OLD_ICONV; 10.2 and beyond don't.
                    # A typical version string looks like "10.2-RELEASE".
                    ifeq ($(shell expr "$(uname_R)" : '[1-9]\.'),2)
                            OLD_ICONV = YesPlease
                    endif
                    ifeq ($(firstword $(subst -, ,$(uname_R))),10.0)
                            OLD_ICONV = YesPlease
                    endif
                    ifeq ($(firstword $(subst -, ,$(uname_R))),10.1)
                            OLD_ICONV = YesPlease
                    endif
                    NO_MEMMEM = YesPlease
                    BASIC_CFLAGS += -I/usr/local/include
                    BASIC_LDFLAGS += -L/usr/local/lib
                    DIR_HAS_BSD_GROUP_SEMANTICS = YesPlease
                    USE_ST_TIMESPEC = YesPlease
                    ifeq ($(shell expr "$(uname_R)" : '4\.'),2)
                            PTHREAD_LIBS = -pthread
                            NO_UINTMAX_T = YesPlease
                            NO_STRTOUMAX = YesPlease
                    endif
                    PYTHON_PATH = /usr/local/bin/python
                    PERL_PATH = /usr/local/bin/perl
                    HAVE_PATHS_H = YesPlease
                    HAVE_BSD_SYSCTL = YesPlease
                    HAVE_BSD_KERN_PROC_SYSCTL = YesPlease
                    CSPRNG_METHOD = arc4random
                    PAGER_ENV = LESS=FRX LV=-c MORE=FRX
                    FREAD_READS_DIRECTORIES = UnfortunatelyYes
                    FILENO_IS_A_MACRO = UnfortunatelyYes
            endif
            ifeq ($(uname_S),OpenBSD)
                    NO_STRCASESTR = YesPlease
                    NO_MEMMEM = YesPlease
                    USE_ST_TIMESPEC = YesPlease
                    NEEDS_LIBICONV = YesPlease
                    BASIC_CFLAGS += -I/usr/local/include
                    BASIC_LDFLAGS += -L/usr/local/lib
                    HAVE_PATHS_H = YesPlease
                    HAVE_BSD_SYSCTL = YesPlease
                    HAVE_BSD_KERN_PROC_SYSCTL = YesPlease
                    CSPRNG_METHOD = arc4random
                    PROCFS_EXECUTABLE_PATH = /proc/curproc/file
                    FREAD_READS_DIRECTORIES = UnfortunatelyYes
                    FILENO_IS_A_MACRO = UnfortunatelyYes
            endif
            ifeq ($(uname_S),MirBSD)
                    NO_STRCASESTR = YesPlease
                    NO_MEMMEM = YesPlease
                    USE_ST_TIMESPEC = YesPlease
                    NEEDS_LIBICONV = YesPlease
                    HAVE_PATHS_H = YesPlease
                    HAVE_BSD_SYSCTL = YesPlease
                    CSPRNG_METHOD = arc4random
            endif
            ifeq ($(uname_S),NetBSD)
                    ifeq ($(shell expr "$(uname_R)" : '[01]\.'),2)
                            NEEDS_LIBICONV = YesPlease
                    endif
                    BASIC_CFLAGS += -I/usr/pkg/include
                    BASIC_LDFLAGS += -L/usr/pkg/lib $(CC_LD_DYNPATH)/usr/pkg/lib
                    USE_ST_TIMESPEC = YesPlease
                    HAVE_PATHS_H = YesPlease
                    HAVE_BSD_SYSCTL = YesPlease
                    HAVE_BSD_KERN_PROC_SYSCTL = YesPlease
                    CSPRNG_METHOD = arc4random
                    PROCFS_EXECUTABLE_PATH = /proc/curproc/exe
            endif
            ifeq ($(uname_S),AIX)
                    DEFAULT_PAGER = more
                    NO_STRCASESTR = YesPlease
                    NO_MEMMEM = YesPlease
                    NO_MKDTEMP = YesPlease
                    NO_STRLCPY = YesPlease
                    NO_NSEC = YesPlease
                    NO_REGEX = NeedsStartEnd
                    FREAD_READS_DIRECTORIES = UnfortunatelyYes
                    INTERNAL_QSORT = UnfortunatelyYes
                    NEEDS_LIBICONV = YesPlease
                    BASIC_CFLAGS += -D_LARGE_FILES
                    FILENO_IS_A_MACRO = UnfortunatelyYes
                    NEED_ACCESS_ROOT_HANDLER = UnfortunatelyYes
                    ifeq ($(shell expr "$(uname_V)" : '[1234]'),1)
                            NO_PTHREADS = YesPlease
                    else
                            PTHREAD_LIBS = -lpthread
                    endif
                    ifeq ($(shell expr "$(uname_V).$(uname_R)" : '5\.1'),3)
                            INLINE = ''
                    endif
                    GIT_TEST_CMP = cmp
            endif
            ifeq ($(uname_S),GNU)
                    # GNU/Hurd
                    HAVE_ALLOCA_H = YesPlease
                    NO_STRLCPY = YesPlease
                    HAVE_PATHS_H = YesPlease
                    LIBC_CONTAINS_LIBINTL = YesPlease
                    FREAD_READS_DIRECTORIES = UnfortunatelyYes
            endif
            ifeq ($(uname_S),IRIX)
                    NO_SETENV = YesPlease
                    NO_UNSETENV = YesPlease
                    NO_STRCASESTR = YesPlease
                    NO_MEMMEM = YesPlease
                    NO_MKDTEMP = YesPlease
                    # When compiled with the MIPSpro 7.4.4m compiler, and without pthreads
                    # (i.e. NO_PTHREADS is set), and _with_ MMAP (i.e. NO_MMAP is not set),
                    # git dies with a segmentation fault when trying to access the first
                    # entry of a reflog.  The conservative choice is made to always set
                    # NO_MMAP.  If you suspect that your compiler is not affected by this
                    # issue, comment out the NO_MMAP statement.
                    NO_MMAP = YesPlease
                    NO_REGEX = YesPlease
                    SNPRINTF_RETURNS_BOGUS = YesPlease
                    SHELL_PATH = /usr/gnu/bin/bash
                    NEEDS_LIBGEN = YesPlease
            endif
            ifeq ($(uname_S),IRIX64)
                    NO_SETENV = YesPlease
                    NO_UNSETENV = YesPlease
                    NO_STRCASESTR = YesPlease
                    NO_MEMMEM = YesPlease
                    NO_MKDTEMP = YesPlease
                    # When compiled with the MIPSpro 7.4.4m compiler, and without pthreads
                    # (i.e. NO_PTHREADS is set), and _with_ MMAP (i.e. NO_MMAP is not set),
                    # git dies with a segmentation fault when trying to access the first
                    # entry of a reflog.  The conservative choice is made to always set
                    # NO_MMAP.  If you suspect that your compiler is not affected by this
                    # issue, comment out the NO_MMAP statement.
                    NO_MMAP = YesPlease
                    NO_REGEX = YesPlease
                    SNPRINTF_RETURNS_BOGUS = YesPlease
                    SHELL_PATH = /usr/gnu/bin/bash
                    NEEDS_LIBGEN = YesPlease
            endif
            ifeq ($(uname_S),HP-UX)
                    INLINE = __inline
                    NO_IPV6 = YesPlease
                    NO_SETENV = YesPlease
                    NO_STRCASESTR = YesPlease
                    NO_MEMMEM = YesPlease
                    NO_STRLCPY = YesPlease
                    NO_MKDTEMP = YesPlease
                    NO_UNSETENV = YesPlease
                    NO_HSTRERROR = YesPlease
                    NO_SYS_SELECT_H = YesPlease
                    SNPRINTF_RETURNS_BOGUS = YesPlease
                    NO_NSEC = YesPlease
                    ifeq ($(uname_R),B.11.00)
                            NO_INET_NTOP = YesPlease
                            NO_INET_PTON = YesPlease
                    endif
                    ifeq ($(uname_R),B.10.20)
                            # Override HP-UX 11.x setting:
                            INLINE =
                            SOCKLEN_T = size_t
                            NO_PREAD = YesPlease
                            NO_INET_NTOP = YesPlease
                            NO_INET_PTON = YesPlease
                    endif
                    GIT_TEST_CMP = cmp
            endif
            ifeq ($(uname_S),Windows)
                    GIT_VERSION := $(GIT_VERSION).MSVC
                    pathsep = ;
                    # Assume that this is built in Git for Windows' SDK
                    ifeq (MINGW32,$(MSYSTEM))
                            prefix = /mingw32
                    else
                            prefix = /mingw64
                    endif
                    # Prepend MSVC 64-bit tool-chain to PATH.
                    #
                    # A regular Git Bash *does not* have cl.exe in its $PATH. As there is a
                    # link.exe next to, and required by, cl.exe, we have to prepend this
                    # onto the existing $PATH.
                    #
                    SANE_TOOL_PATH ?= $(msvc_bin_dir_msys)
                    HAVE_ALLOCA_H = YesPlease
                    NO_PREAD = YesPlease
                    NEEDS_CRYPTO_WITH_SSL = YesPlease
                    NO_LIBGEN_H = YesPlease
                    NO_POLL = YesPlease
                    NO_SYMLINK_HEAD = YesPlease
                    NO_IPV6 = YesPlease
                    NO_SETENV = YesPlease
                    NO_STRCASESTR = YesPlease
                    NO_STRLCPY = YesPlease
                    NO_MEMMEM = YesPlease
                    NEEDS_LIBICONV = YesPlease
                    NO_STRTOUMAX = YesPlease
                    NO_MKDTEMP = YesPlease
                    NO_INTTYPES_H = YesPlease
                    CSPRNG_METHOD = rtlgenrandom
                    # VS2015 with UCRT claims that snprintf and friends are C99 compliant,
                    # so we don't need this:
                    #
                    #   SNPRINTF_RETURNS_BOGUS = YesPlease

                    # The builtin FSMonitor requires Named Pipes and Threads on Windows.
                    # These are always available, so we do not have to conditionally
                    # support it.
                    FSMONITOR_DAEMON_BACKEND = win32
                    FSMONITOR_OS_SETTINGS = win32

                    NO_SVN_TESTS = YesPlease
                    RUNTIME_PREFIX = YesPlease
                    HAVE_WPGMPTR = YesWeDo
                    NO_ST_BLOCKS_IN_STRUCT_STAT = YesPlease
                    USE_WIN32_IPC = YesPlease
                    USE_WIN32_MMAP = YesPlease
                    MMAP_PREVENTS_DELETE = UnfortunatelyYes
                    # USE_NED_ALLOCATOR = YesPlease
                    UNRELIABLE_FSTAT = UnfortunatelyYes
                    OBJECT_CREATION_USES_RENAMES = UnfortunatelyNeedsTo
                    NO_REGEX = YesPlease
                    NO_GETTEXT = YesPlease
                    NO_PYTHON = YesPlease
                    ETAGS_TARGET = ETAGS
                    NO_POSIX_GOODIES = UnfortunatelyYes
                    NATIVE_CRLF = YesPlease
                    DEFAULT_HELP_FORMAT = html
            ifeq (/mingw64,$(subst 32,64,$(prefix)))
                    # Move system config into top-level /etc/
                    ETC_GITCONFIG = ../etc/gitconfig
                    ETC_GITATTRIBUTES = ../etc/gitattributes
            endif

                    CC = compat/vcbuild/scripts/clink.pl
                    AR = compat/vcbuild/scripts/lib.pl
                    CFLAGS =
                    BASIC_CFLAGS = -nologo -I. -Icompat/vcbuild/include -DWIN32 -D_CONSOLE -DHAVE_STRING_H -D_CRT_SECURE_NO_WARNINGS -D_CRT_NONSTDC_NO_DEPRECATE
                    COMPAT_OBJS = compat/msvc.o compat/winansi.o \
                            compat/win32/flush.o \
                            compat/win32/path-utils.o \
                            compat/win32/pthread.o compat/win32/syslog.o \
                            compat/win32/trace2_win32_process_info.o \
                            compat/win32/dirent.o
                    COMPAT_CFLAGS = -D__USE_MINGW_ACCESS -DDETECT_MSYS_TTY -DNOGDI -DHAVE_STRING_H -Icompat -Icompat/regex -Icompat/win32 -DSTRIP_EXTENSION=\".exe\"
                    BASIC_LDFLAGS = -IGNORE:4217 -IGNORE:4049 -NOLOGO -ENTRY:wmainCRTStartup -SUBSYSTEM:CONSOLE
                    # invalidcontinue.obj allows Git's source code to close the same file
                    # handle twice, or to access the osfhandle of an already-closed stdout
                    # See https://msdn.microsoft.com/en-us/library/ms235330.aspx
                    EXTLIBS = user32.lib advapi32.lib shell32.lib wininet.lib ws2_32.lib invalidcontinue.obj kernel32.lib ntdll.lib
                    PTHREAD_LIBS =
                    lib =
                    BASIC_CFLAGS += $(vcpkg_inc) $(sdk_includes) $(msvc_includes)
            ifndef DEBUG
                    BASIC_CFLAGS += $(vcpkg_rel_lib)
            else
                    BASIC_CFLAGS += $(vcpkg_dbg_lib)
            endif
                    BASIC_CFLAGS += $(sdk_libs) $(msvc_libs)

            ifneq ($(USE_MSVC_CRTDBG),)
                    # Optionally enable memory leak reporting.
                    BASIC_CFLAGS += -DUSE_MSVC_CRTDBG
            endif
                    # Always give "-Zi" to the compiler and "-debug" to linker (even in
                    # release mode) to force a PDB to be generated (like RelWithDebInfo).
                    BASIC_CFLAGS += -Zi
                    BASIC_LDFLAGS += -debug -Zf

            ifdef NO_SAFESEH
                    LDFLAGS += -SAFESEH:NO
            endif

            ifndef DEBUG
                    BASIC_CFLAGS += -GL -Gy -O2 -Oy- -MD -DNDEBUG
                    BASIC_LDFLAGS += -release -LTCG /OPT:REF /OPT:ICF /INCREMENTAL:NO /DEBUGTYPE:CV,FIXUP
                    AR += -LTCG
            else
                    BASIC_CFLAGS += -MDd -DDEBUG -D_DEBUG
            endif
                    X = .exe

                    EXTRA_PROGRAMS += headless-git$X

            compat/msvc.o: compat/msvc.c compat/mingw.c GIT-CFLAGS
            endif
            ifeq ($(uname_S),Interix)
                    NO_INITGROUPS = YesPlease
                    NO_IPV6 = YesPlease
                    NO_MEMMEM = YesPlease
                    NO_MKDTEMP = YesPlease
                    NO_STRTOUMAX = YesPlease
                    NO_NSEC = YesPlease
                    ifeq ($(uname_R),3.5)
                            NO_INET_NTOP = YesPlease
                            NO_INET_PTON = YesPlease
                            NO_SOCKADDR_STORAGE = YesPlease
                    endif
                    ifeq ($(uname_R),5.2)
                            NO_INET_NTOP = YesPlease
                            NO_INET_PTON = YesPlease
                            NO_SOCKADDR_STORAGE = YesPlease
                    endif
            endif
            ifeq ($(uname_S),Minix)
                    NO_IPV6 = YesPlease
                    NO_ST_BLOCKS_IN_STRUCT_STAT = YesPlease
                    NO_NSEC = YesPlease
                    NEEDS_LIBGEN =
                    NEEDS_CRYPTO_WITH_SSL = YesPlease
                    NEEDS_RESOLV =
                    NO_HSTRERROR = YesPlease
                    NO_MMAP = YesPlease
                    NO_CURL =
                    NO_EXPAT =
            endif
            ifeq ($(uname_S),NONSTOP_KERNEL)
                    # Needs some C99 features, "inline" is just one of them.
                    # INLINE='' would just replace one set of warnings with another and
                    # still not compile in c89 mode, due to non-const array initializations.
                    CC = cc -c99
                    # Build down-rev compatible objects that don't use our new getopt_long.
                    ifeq ($(uname_R).$(uname_V),J06.21)
                            CC += -WRVU=J06.20
                    endif
                    ifeq ($(uname_R).$(uname_V),L17.02)
                            CC += -WRVU=L16.05
                    endif
                    # Disable all optimization, seems to result in bad code, with -O or -O2
                    # or even -O1 (default), /usr/local/libexec/git-core/git-pack-objects
                    # abends on "git push". Needs more investigation.
                    CFLAGS = -g -O0 -Winline
                    # We'd want it to be here.
                    prefix = /usr/local
                    # perl and python must be in /usr/bin on NonStop - supplied by HPE
                    # with operating system in that managed directory.
                    PERL_PATH = /usr/bin/perl
                    PYTHON_PATH = /usr/bin/python
                    # The current /usr/coreutils/rm at lowest support level does not work
                    # with the git test structure. Long paths as in
                    # 'trash directory...' cause rm to terminate prematurely without fully
                    # removing the directory at OS releases J06.21 and L17.02.
                    # Default to the older rm until those two releases are deprecated.
                    RM = /bin/rm -f
                    NEEDS_CRYPTO_WITH_SSL = YesPlease
                    HAVE_DEV_TTY = YesPlease
                    HAVE_LIBCHARSET_H = YesPlease
                    HAVE_STRINGS_H = YesPlease
                    NEEDS_LIBICONV = YesPlease
                    NEEDS_LIBINTL_BEFORE_LIBICONV = YesPlease
                    NO_SYS_SELECT_H = UnfortunatelyYes
                    NO_D_TYPE_IN_DIRENT = YesPlease
                    NO_GETTEXT = YesPlease
                    NO_HSTRERROR = YesPlease
                    NO_STRCASESTR = YesPlease
                    NO_MEMMEM = YesPlease
                    NO_STRLCPY = YesPlease
                    NO_SETENV = YesPlease
                    NO_UNSETENV = YesPlease
                    NO_MKDTEMP = YesPlease
                    # Currently libiconv-1.9.1.
                    OLD_ICONV = UnfortunatelyYes
                    NO_REGEX = NeedsStartEnd
                    NO_PTHREADS = UnfortunatelyYes
                    FREAD_READS_DIRECTORIES = UnfortunatelyYes

                    # Not detected (nor checked for) by './configure'.
                    # We don't have SA_RESTART on NonStop, unfortunalety.
                    COMPAT_CFLAGS += -DSA_RESTART=0
                    # Apparently needed in compat/fnmatch/fnmatch.c.
                    COMPAT_CFLAGS += -DHAVE_STRING_H=1
                    NO_ST_BLOCKS_IN_STRUCT_STAT = YesPlease
                    NO_NSEC = YesPlease
                    NO_PREAD = YesPlease
                    NO_MMAP = YesPlease
                    NO_POLL = YesPlease
                    NO_INTPTR_T = UnfortunatelyYes
                    CSPRNG_METHOD = openssl
                    SANE_TOOL_PATH = /usr/coreutils/bin:/usr/local/bin
                    SHELL_PATH = /usr/coreutils/bin/bash
            endif
            ifeq ($(uname_S),OS/390)
                    NO_SYS_POLL_H = YesPlease
                    NO_STRCASESTR = YesPlease
                    NO_REGEX = YesPlease
                    NO_MMAP = YesPlease
                    NO_NSEC = YesPlease
                    NO_STRLCPY = YesPlease
                    NO_MEMMEM = YesPlease
                    NO_GECOS_IN_PWENT = YesPlease
                    HAVE_STRINGS_H = YesPlease
                    NEEDS_MODE_TRANSLATION = YesPlease
                    HAVE_ZOS_GET_EXECUTABLE_PATH = YesPlease
            endif
            ifeq ($(uname_S),MINGW)
                    ifeq ($(shell expr "$(uname_R)" : '1\.'),2)
                            $(error "Building with MSys is no longer supported")
                    endif
                    pathsep = ;
                    HAVE_ALLOCA_H = YesPlease
                    NO_PREAD = YesPlease
                    NEEDS_CRYPTO_WITH_SSL = YesPlease
                    NO_LIBGEN_H = YesPlease
                    NO_POLL = YesPlease
                    NO_SYMLINK_HEAD = YesPlease
                    NO_SETENV = YesPlease
                    NO_STRCASESTR = YesPlease
                    NO_STRLCPY = YesPlease
                    NO_MEMMEM = YesPlease
                    NEEDS_LIBICONV = YesPlease
                    NO_STRTOUMAX = YesPlease
                    NO_MKDTEMP = YesPlease
                    NO_SVN_TESTS = YesPlease

                    # The builtin FSMonitor requires Named Pipes and Threads on Windows.
                    # These are always available, so we do not have to conditionally
                    # support it.
                    FSMONITOR_DAEMON_BACKEND = win32
                    FSMONITOR_OS_SETTINGS = win32

                    RUNTIME_PREFIX = YesPlease
                    HAVE_WPGMPTR = YesWeDo
                    NO_ST_BLOCKS_IN_STRUCT_STAT = YesPlease
                    USE_WIN32_IPC = YesPlease
                    USE_WIN32_MMAP = YesPlease
                    MMAP_PREVENTS_DELETE = UnfortunatelyYes
                    UNRELIABLE_FSTAT = UnfortunatelyYes
                    OBJECT_CREATION_USES_RENAMES = UnfortunatelyNeedsTo
                    NO_REGEX = YesPlease
                    ETAGS_TARGET = ETAGS
                    NO_POSIX_GOODIES = UnfortunatelyYes
                    DEFAULT_HELP_FORMAT = html
                    HAVE_PLATFORM_PROCINFO = YesPlease
                    CSPRNG_METHOD = rtlgenrandom
                    BASIC_LDFLAGS += -municode
                    COMPAT_CFLAGS += -DNOGDI -Icompat -Icompat/win32
                    COMPAT_CFLAGS += -DSTRIP_EXTENSION=\".exe\"
                    COMPAT_OBJS += compat/mingw.o compat/winansi.o \
                            compat/win32/trace2_win32_process_info.o \
                            compat/win32/flush.o \
                            compat/win32/path-utils.o \
                            compat/win32/pthread.o compat/win32/syslog.o \
                            compat/win32/dirent.o
                    BASIC_CFLAGS += -DWIN32
                    EXTLIBS += -lws2_32
                    GITLIBS += git.res
                    PTHREAD_LIBS =
                    RC = windres -O coff
                    NATIVE_CRLF = YesPlease
                    X = .exe
                    # MSys2
                    prefix = /usr/
                    # Enable DEP
                    BASIC_LDFLAGS += -Wl,--nxcompat
                    # Enable ASLR (unless debugging)
                    ifneq (,$(findstring -O,$(filter-out -O0 -Og,$(CFLAGS))))
                            BASIC_LDFLAGS += -Wl,--dynamicbase
                    endif
                    ifeq (MINGW32,$(MSYSTEM))
                            prefix = /mingw32
                            HOST_CPU = i686
                            BASIC_LDFLAGS += -Wl,--pic-executable,-e,_mainCRTStartup
                    endif
                    ifeq (MINGW64,$(MSYSTEM))
                            prefix = /mingw64
                            HOST_CPU = x86_64
                            BASIC_LDFLAGS += -Wl,--pic-executable,-e,mainCRTStartup
                    else
                            COMPAT_CFLAGS += -D_USE_32BIT_TIME_T
                            BASIC_LDFLAGS += -Wl,--large-address-aware
                    endif
                    CC = gcc
                    COMPAT_CFLAGS += -D__USE_MINGW_ANSI_STDIO=0 -DDETECT_MSYS_TTY \
                            -fstack-protector-strong
                    EXTLIBS += -lntdll
                    EXTRA_PROGRAMS += headless-git$X
                    INSTALL = /bin/install
                    INTERNAL_QSORT = YesPlease
                    HAVE_LIBCHARSET_H = YesPlease
                    USE_GETTEXT_SCHEME = fallthrough
                    USE_LIBPCRE = YesPlease
                    USE_NED_ALLOCATOR = YesPlease
                    ifeq (/mingw64,$(subst 32,64,$(prefix)))
                            # Move system config into top-level /etc/
                            ETC_GITCONFIG = ../etc/gitconfig
                            ETC_GITATTRIBUTES = ../etc/gitattributes
                    endif
            endif
            ifeq ($(uname_S),QNX)
                    COMPAT_CFLAGS += -DSA_RESTART=0
                    EXPAT_NEEDS_XMLPARSE_H = YesPlease
                    HAVE_STRINGS_H = YesPlease
                    NEEDS_SOCKET = YesPlease
                    NO_GETPAGESIZE = YesPlease
                    NO_ICONV = YesPlease
                    NO_MEMMEM = YesPlease
                    NO_MKDTEMP = YesPlease
                    NO_NSEC = YesPlease
                    NO_PTHREADS = YesPlease
                    NO_STRCASESTR = YesPlease
                    NO_STRLCPY = YesPlease
            endif

            vcxproj:
                    # Require clean work tree
                    git update-index -q --refresh && \
                    git diff-files --quiet && \
                    git diff-index --cached --quiet HEAD --

                    # Make .vcxproj files and add them
                    perl contrib/buildsystems/generate -g Vcxproj
                    git add -f git.sln {*,*/lib,t/helper/*}/*.vcxproj

                    # Generate the LinkOrCopyBuiltins.targets and LinkOrCopyRemoteHttp.targets file
                    (echo '<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">' && \
                    echo '  <Target Name="CopyBuiltins_AfterBuild" AfterTargets="AfterBuild">' && \
                    for name in $(BUILT_INS);\
                    do \
                    echo '    <Copy SourceFiles="$$(OutDir)\git.exe" DestinationFiles="$$(OutDir)\'"$$name"'" SkipUnchangedFiles="true" UseHardlinksIfPossible="true" />'; \
                    done && \
                    echo '  </Target>' && \
                    echo '</Project>') >git/LinkOrCopyBuiltins.targets
                    (echo '<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">' && \
                    echo '  <Target Name="CopyBuiltins_AfterBuild" AfterTargets="AfterBuild">' && \
                    for name in $(REMOTE_CURL_ALIASES); \
                    do \
                    echo '    <Copy SourceFiles="$$(OutDir)\'"$(REMOTE_CURL_PRIMARY)"'" DestinationFiles="$$(OutDir)\'"$$name"'" SkipUnchangedFiles="true" UseHardlinksIfPossible="true" />'; \
                    done && \
                    echo '  </Target>' && \
                    echo '</Project>') >git-remote-http/LinkOrCopyRemoteHttp.targets
                    git add -f git/LinkOrCopyBuiltins.targets git-remote-http/LinkOrCopyRemoteHttp.targets

                    # Add generated headers
                    $(MAKE) MSVC=1 SKIP_VCPKG=1 prefix=/mingw64 $(GENERATED_H)
                    git add -f $(GENERATED_H)

                    # Add scripts
                    rm -f perl/perl.mak
                    $(MAKE) MSVC=1 SKIP_VCPKG=1 prefix=/mingw64 $(SCRIPT_LIB) $(SCRIPTS)
                    # Strip out the sane tool path, needed only for building
                    sed -i '/^git_broken_path_fix ".*/d' git-sh-setup
                    git add -f $(SCRIPT_LIB) $(SCRIPTS)

                    # Add Perl module
                    $(MAKE) $(LIB_PERL_GEN)
                    git add -f perl/build

                    # Add bin-wrappers, for testing
                    rm -rf bin-wrappers/
                    $(MAKE) MSVC=1 SKIP_VCPKG=1 prefix=/mingw64 $(test_bindir_programs)
                    # Ensure that the GIT_EXEC_PATH is a Unix-y one, and that the absolute
                    # path of the repository is not hard-coded (GIT_EXEC_PATH will be set
                    # by test-lib.sh according to the current setup)
                    sed -i -e 's/^\(GIT_EXEC_PATH\)=.*/test -n "$${\1##*:*}" ||\
                                    \1="$$(cygpath -u "$$\1")"/' \
                            -e "s|'$$(pwd)|\"\$$GIT_EXEC_PATH\"'|g" bin-wrappers/*
                    # Ensure that test-* helpers find the .dll files copied to top-level
                    sed -i 's|^PATH=.*|&:"$$GIT_EXEC_PATH"|' bin-wrappers/test-*
                    # We do not want to force hard-linking builtins
                    sed -i 's|\(git\)-\([-a-z]*\)\.exe"|\1.exe" \2|g' \
                            bin-wrappers/git-{receive-pack,upload-archive}
                    git add -f $(test_bindir_programs)

                    # Add templates
                    $(MAKE) -C templates
                    git add -f templates/boilerplates.made templates/blt/

                    # Add the translated messages
                    make MSVC=1 SKIP_VCPKG=1 prefix=/mingw64 $(MOFILES)
                    git add -f $(MOFILES)

                    # Add build options
                    $(MAKE) MSVC=1 SKIP_VCPKG=1 prefix=/mingw64 GIT-BUILD-OPTIONS
                    git add -f GIT-BUILD-OPTIONS

                    # Commit the whole shebang
                    git commit -m "Generate Visual Studio solution" \
                            -m "Auto-generated by \`$(MAKE)$(MAKEFLAGS) $@\`"

        """,
        "error":"OS/390 doesn't have support for some of the common headers and libraries used by Git,
                 such as poll.h, regex.h, or strcasestr. The patch disables these features, allowing Git to build
                 without errors on OS/390.It explicitly sets paths to executables (Perl, Bash, Python) that are
                 compatible with OS/390. These paths ensure that Git scripts and operations that rely on these tools will work correctly."

        "error Category":"functionality Patch"

        "Corrected Code":
                    """
                    # Platform specific Makefile tweaks based on uname detection

            # Define NO_SAFESEH if you need MSVC/Visual Studio to ignore the lack of
            # Microsoft's Safe Exception Handling in libraries (such as zlib).
            # Typically required for VS2013+/32-bit compilation on Vista+ versions.

            uname_S := $(shell sh -c 'uname -s 2>/dev/null || echo not')
            uname_M := $(shell sh -c 'uname -m 2>/dev/null || echo not')
            uname_O := $(shell sh -c 'uname -o 2>/dev/null || echo not')
            uname_R := $(shell sh -c 'uname -r 2>/dev/null || echo not')
            uname_V := $(shell sh -c 'uname -v 2>/dev/null || echo not')

            ifneq ($(findstring MINGW,$(uname_S)),)
                    uname_S := MINGW
            endif

            ifdef MSVC
                    # avoid the MingW and Cygwin configuration sections
                    uname_S := Windows
                    uname_O := Windows

                    # Generate and include makefile variables that point to the
                    # currently installed set of MSVC command line tools.
            compat/vcbuild/MSVC-DEFS-GEN: compat/vcbuild/find_vs_env.bat
                    @"$<" | tr '\\' / >"$@"
            include compat/vcbuild/MSVC-DEFS-GEN

                    # See if vcpkg and the vcpkg-build versions of the third-party
                    # libraries that we use are installed.  We include the result
                    # to get $(vcpkg_*) variables defined for the Makefile.
            ifeq (,$(SKIP_VCPKG))
            compat/vcbuild/VCPKG-DEFS: compat/vcbuild/vcpkg_install.bat
                    @"$<"
            include compat/vcbuild/VCPKG-DEFS
            endif
            endif

            # We choose to avoid "if .. else if .. else .. endif endif"
            # because maintaining the nesting to match is a pain.  If
            # we had "elif" things would have been much nicer...

            ifeq ($(uname_S),OSF1)
                    # Need this for u_short definitions et al
                    BASIC_CFLAGS += -D_OSF_SOURCE
                    SOCKLEN_T = int
                    NO_STRTOULL = YesPlease
                    NO_NSEC = YesPlease
            endif
            ifeq ($(uname_S),Linux)
                    HAVE_ALLOCA_H = YesPlease
                    NO_STRLCPY = YesPlease
                    HAVE_PATHS_H = YesPlease
                    LIBC_CONTAINS_LIBINTL = YesPlease
                    HAVE_DEV_TTY = YesPlease
                    HAVE_CLOCK_GETTIME = YesPlease
                    HAVE_CLOCK_MONOTONIC = YesPlease
                    # -lrt is needed for clock_gettime on glibc <= 2.16
                    NEEDS_LIBRT = YesPlease
                    HAVE_SYNC_FILE_RANGE = YesPlease
                    HAVE_GETDELIM = YesPlease
                    FREAD_READS_DIRECTORIES = UnfortunatelyYes
                    BASIC_CFLAGS += -DHAVE_SYSINFO
                    PROCFS_EXECUTABLE_PATH = /proc/self/exe
                    HAVE_PLATFORM_PROCINFO = YesPlease
                    COMPAT_OBJS += compat/linux/procinfo.o
                    # centos7/rhel7 provides gcc 4.8.5 and zlib 1.2.7.
                    ifneq ($(findstring .el7.,$(uname_R)),)
                            BASIC_CFLAGS += -std=c99
                    endif
                    LINK_FUZZ_PROGRAMS = YesPlease
            endif
            ifeq ($(uname_S),GNU/kFreeBSD)
                    HAVE_ALLOCA_H = YesPlease
                    NO_STRLCPY = YesPlease
                    HAVE_PATHS_H = YesPlease
                    DIR_HAS_BSD_GROUP_SEMANTICS = YesPlease
                    LIBC_CONTAINS_LIBINTL = YesPlease
                    FREAD_READS_DIRECTORIES = UnfortunatelyYes
            endif
            ifeq ($(uname_S),UnixWare)
                    CC = cc
                    NEEDS_SOCKET = YesPlease
                    NEEDS_NSL = YesPlease
                    NEEDS_SSL_WITH_CRYPTO = YesPlease
                    NEEDS_LIBICONV = YesPlease
                    SHELL_PATH = /usr/local/bin/bash
                    NO_IPV6 = YesPlease
                    NO_HSTRERROR = YesPlease
                    BASIC_CFLAGS += -Kthread
                    BASIC_CFLAGS += -I/usr/local/include
                    BASIC_LDFLAGS += -L/usr/local/lib
                    INSTALL = ginstall
                    TAR = gtar
                    NO_STRCASESTR = YesPlease
                    NO_MEMMEM = YesPlease
            endif
            ifeq ($(uname_S),SCO_SV)
                    ifeq ($(uname_R),3.2)
                            CFLAGS = -O2
                    endif
                    ifeq ($(uname_R),5)
                            CC = cc
                            BASIC_CFLAGS += -Kthread
                    endif
                    NEEDS_SOCKET = YesPlease
                    NEEDS_NSL = YesPlease
                    NEEDS_SSL_WITH_CRYPTO = YesPlease
                    NEEDS_LIBICONV = YesPlease
                    SHELL_PATH = /usr/bin/bash
                    NO_IPV6 = YesPlease
                    NO_HSTRERROR = YesPlease
                    BASIC_CFLAGS += -I/usr/local/include
                    BASIC_LDFLAGS += -L/usr/local/lib
                    NO_STRCASESTR = YesPlease
                    NO_MEMMEM = YesPlease
                    INSTALL = ginstall
                    TAR = gtar
            endif
            ifeq ($(uname_S),Darwin)
                    NEEDS_CRYPTO_WITH_SSL = YesPlease
                    NEEDS_SSL_WITH_CRYPTO = YesPlease
                    NEEDS_LIBICONV = YesPlease
                    # Note: $(uname_R) gives us the underlying Darwin version.
                    # - MacOS 10.0.* and MacOS 10.1.0 = Darwin 1.*
                    # - MacOS 10.x.* = Darwin (x+4).* for (1 <= x)
                    # i.e. "begins with [15678] and a dot" means "10.4.* or older".
                    ifeq ($(shell expr "$(uname_R)" : '[15678]\.'),2)
                            OLD_ICONV = UnfortunatelyYes
                            NO_APPLE_COMMON_CRYPTO = YesPlease
                    endif
                    ifeq ($(shell expr "$(uname_R)" : '[15]\.'),2)
                            NO_STRLCPY = YesPlease
                    endif
                    ifeq ($(shell test "`expr "$(uname_R)" : '\([0-9][0-9]*\)\.'`" -ge 11 && echo 1),1)
                            HAVE_GETDELIM = YesPlease
                    endif
                    ifeq ($(shell test "`expr "$(uname_R)" : '\([0-9][0-9]*\)\.'`" -ge 20 && echo 1),1)
                            OPEN_RETURNS_EINTR = UnfortunatelyYes
                    endif
                    NO_MEMMEM = YesPlease
                    USE_ST_TIMESPEC = YesPlease
                    HAVE_DEV_TTY = YesPlease
                    COMPAT_OBJS += compat/precompose_utf8.o
                    BASIC_CFLAGS += -DPRECOMPOSE_UNICODE
                    BASIC_CFLAGS += -DPROTECT_HFS_DEFAULT=1
                    HAVE_BSD_SYSCTL = YesPlease
                    FREAD_READS_DIRECTORIES = UnfortunatelyYes
                    HAVE_NS_GET_EXECUTABLE_PATH = YesPlease
                    CSPRNG_METHOD = arc4random
                    USE_ENHANCED_BASIC_REGULAR_EXPRESSIONS = YesPlease

                    # Workaround for `gettext` being keg-only and not even being linked via
                    # `brew link --force gettext`, should be obsolete as of
                    # https://github.com/Homebrew/homebrew-core/pull/53489
                    ifeq ($(shell test -d /usr/local/opt/gettext/ && echo y),y)
                            BASIC_CFLAGS += -I/usr/local/include -I/usr/local/opt/gettext/include
                            BASIC_LDFLAGS += -L/usr/local/lib -L/usr/local/opt/gettext/lib
                            ifeq ($(shell test -x /usr/local/opt/gettext/bin/msgfmt && echo y),y)
                                    MSGFMT = /usr/local/opt/gettext/bin/msgfmt
                            endif
                    # On newer ARM-based machines the default installation path has changed to
                    # /opt/homebrew. Include it in our search paths so that the user does not
                    # have to configure this manually.
                    #
                    # Note that we do not employ the same workaround as above where we manually
                    # add gettext. The issue was fixed more than three years ago by now, and at
                    # that point there haven't been any ARM-based Macs yet.
                    else ifeq ($(shell test -d /opt/homebrew/ && echo y),y)
                            BASIC_CFLAGS += -I/opt/homebrew/include
                            BASIC_LDFLAGS += -L/opt/homebrew/lib
                            ifeq ($(shell test -x /opt/homebrew/bin/msgfmt && echo y),y)
                                    MSGFMT = /opt/homebrew/bin/msgfmt
                            endif
                    endif

                    # The builtin FSMonitor on MacOS builds upon Simple-IPC.  Both require
                    # Unix domain sockets and PThreads.
                    ifndef NO_PTHREADS
                    ifndef NO_UNIX_SOCKETS
                    FSMONITOR_DAEMON_BACKEND = darwin
                    FSMONITOR_OS_SETTINGS = darwin
                    endif
                    endif

                    BASIC_LDFLAGS += -framework CoreServices
            endif
            ifeq ($(uname_S),SunOS)
                    NEEDS_SOCKET = YesPlease
                    NEEDS_NSL = YesPlease
                    SHELL_PATH = /bin/bash
                    SANE_TOOL_PATH = /usr/xpg6/bin:/usr/xpg4/bin
                    HAVE_ALLOCA_H = YesPlease
                    NO_STRCASESTR = YesPlease
                    NO_MEMMEM = YesPlease
                    NO_MKDTEMP = YesPle

        """,

        "Patch":
        """
                    diff --git a/config.mak.uname b/config.mak.uname
            index d5112168a4..17716314c0 100644
            --- a/config.mak.uname
            +++ b/config.mak.uname
            @@ -639,12 +639,19 @@ ifeq ($(uname_S),NONSTOP_KERNEL)
                    SHELL_PATH = /usr/coreutils/bin/bash
            endif
            ifeq ($(uname_S),OS/390)
            +   PERL_PATH = perl
            +   PERL_PATH_FOR_SCRIPTS = /bin/env perl
            +   SHELL_PATH = bash
            +   SHELL_PATH_FOR_SCRIPTS = /bin/env bash
            +   PYTHON_PATH = python
                    NO_SYS_POLL_H = YesPlease
            +   RUNTIME_PREFIX = YesPlease
                    NO_STRCASESTR = YesPlease
                    NO_REGEX = YesPlease
                    NO_MMAP = YesPlease
                    NO_NSEC = YesPlease
                    NO_STRLCPY = YesPlease
            +   NO_MKDTEMP = YesPlease
                    NO_MEMMEM = YesPlease
                    NO_GECOS_IN_PWENT = YesPlease
                    HAVE_STRINGS_H = YesPlease

        """,

          },

    {
          "wrong code":
          """
                    #                                               -*- Autoconf -*-
            # Process this file with autoconf to produce a configure script.

            ## Definitions of private macros.

            # GIT_CONF_SUBST(VAL, VAR)
            # ------------------------
            # Cause the line "VAR=VAL" to be eventually appended to ${config_file}.
            AC_DEFUN([GIT_CONF_SUBST],
            [AC_REQUIRE([GIT_CONF_SUBST_INIT])
            config_appended_defs="$config_appended_defs${newline}dnl
            $1=m4_if([$#],[1],[${$1}],[$2])"])

            # GIT_CONF_SUBST_INIT
            # -------------------
            # Prepare shell variables and autoconf machine required by later calls
            # to GIT_CONF_SUBST.
            AC_DEFUN([GIT_CONF_SUBST_INIT],
            [config_appended_defs=; newline='
            '
            AC_CONFIG_COMMANDS([$config_file],
                            [echo "$config_appended_defs" >> "$config_file"],
                            [config_file=$config_file
                                    config_appended_defs="$config_appended_defs"])])

            # GIT_ARG_SET_PATH(PROGRAM)
            # -------------------------
            # Provide --with-PROGRAM=PATH option to set PATH to PROGRAM
            # Optional second argument allows setting NO_PROGRAM=YesPlease if
            # --without-PROGRAM version used.
            AC_DEFUN([GIT_ARG_SET_PATH],
            [AC_ARG_WITH([$1],
                    [AS_HELP_STRING([--with-$1=PATH],
                                    [provide PATH to $1])],
                    [GIT_CONF_APPEND_PATH([$1], [$2])],
                    [])])

            # GIT_CONF_APPEND_PATH(PROGRAM)
            # -----------------------------
            # Parse --with-PROGRAM=PATH option to set PROGRAM_PATH=PATH
            # Used by GIT_ARG_SET_PATH(PROGRAM)
            # Optional second argument allows setting NO_PROGRAM=YesPlease if
            # --without-PROGRAM is used.
            AC_DEFUN([GIT_CONF_APPEND_PATH],
            [m4_pushdef([GIT_UC_PROGRAM], m4_toupper([$1]))dnl
            if test "$withval" = "no"; then
                    if test -n "$2"; then
                            GIT_UC_PROGRAM[]_PATH=$withval
                            AC_MSG_NOTICE([Disabling use of GIT_UC_PROGRAM])
                            GIT_CONF_SUBST([NO_]GIT_UC_PROGRAM, [YesPlease])
                            GIT_CONF_SUBST(GIT_UC_PROGRAM[]_PATH, [])
                    else
                            AC_MSG_ERROR([You cannot use git without $1])
                    fi
            else
                    if test "$withval" = "yes"; then
                            AC_MSG_WARN([You should provide path for --with-$1=PATH])
                    else
                            GIT_UC_PROGRAM[]_PATH=$withval
                            AC_MSG_NOTICE([Setting GIT_UC_PROGRAM[]_PATH to $withval])
                            GIT_CONF_SUBST(GIT_UC_PROGRAM[]_PATH, [$withval])
                    fi
            fi
            m4_popdef([GIT_UC_PROGRAM])])

            # GIT_PARSE_WITH(PACKAGE)
            # -----------------------
            # For use in AC_ARG_WITH action-if-found, for packages default ON.
            # * Set NO_PACKAGE=YesPlease for --without-PACKAGE
            # * Set PACKAGEDIR=PATH for --with-PACKAGE=PATH
            # * Unset NO_PACKAGE for --with-PACKAGE without ARG
            AC_DEFUN([GIT_PARSE_WITH],
            [m4_pushdef([GIT_UC_PACKAGE], m4_toupper([$1]))dnl
            if test "$withval" = "no"; then
                    NO_[]GIT_UC_PACKAGE=YesPlease
            elif test "$withval" = "yes"; then
                    NO_[]GIT_UC_PACKAGE=
            else
                    NO_[]GIT_UC_PACKAGE=
                    GIT_UC_PACKAGE[]DIR=$withval
                    AC_MSG_NOTICE([Setting GIT_UC_PACKAGE[]DIR to $withval])
                    GIT_CONF_SUBST(GIT_UC_PACKAGE[DIR], [$withval])
            fi
            m4_popdef([GIT_UC_PACKAGE])])

            # GIT_PARSE_WITH_SET_MAKE_VAR(WITHNAME, VAR, HELP_TEXT)
            # -----------------------------------------------------
            # Set VAR to the value specified by --with-WITHNAME.
            # No verification of arguments is performed, but warnings are issued
            # if either 'yes' or 'no' is specified.
            # HELP_TEXT is presented when --help is called.
            # This is a direct way to allow setting variables in the Makefile.
            AC_DEFUN([GIT_PARSE_WITH_SET_MAKE_VAR],
            [AC_ARG_WITH([$1],
            [AS_HELP_STRING([--with-$1=VALUE], $3)],
            if test -n "$withval"; then
            if test "$withval" = "yes" || test "$withval" = "no"; then
            AC_MSG_WARN([You likely do not want either 'yes' or 'no' as]
                            [a value for $1 ($2).  Maybe you do...?])
            fi
            AC_MSG_NOTICE([Setting $2 to $withval])
            GIT_CONF_SUBST([$2], [$withval])
            fi)])# GIT_PARSE_WITH_SET_MAKE_VAR

            #
            # GIT_CHECK_FUNC(FUNCTION, IFTRUE, IFFALSE)
            # -----------------------------------------
            # Similar to AC_CHECK_FUNC, but on systems that do not generate
            # warnings for missing prototypes (e.g. FreeBSD when compiling without
            # -Wall), it does not work.  By looking for function definition in
            # libraries, this problem can be worked around.
            AC_DEFUN([GIT_CHECK_FUNC],[AC_CHECK_FUNC([$1],[
            AC_SEARCH_LIBS([$1],,
            [$2],[$3])
            ],[$3])])

            #
            # GIT_STASH_FLAGS(BASEPATH_VAR)
            # -----------------------------
            # Allow for easy stashing of LDFLAGS and CPPFLAGS before running
            # tests that may want to take user settings into account.
            AC_DEFUN([GIT_STASH_FLAGS],[
            if test -n "$1"; then
            old_CPPFLAGS="$CPPFLAGS"
            old_LDFLAGS="$LDFLAGS"
            CPPFLAGS="-I$1/include $CPPFLAGS"
            LDFLAGS="-L$1/$lib $LDFLAGS"
            fi
            ])

            dnl
            dnl GIT_UNSTASH_FLAGS(BASEPATH_VAR)
            dnl -----------------------------
            dnl Restore the stashed *FLAGS values.
            AC_DEFUN([GIT_UNSTASH_FLAGS],[
            if test -n "$1"; then
            CPPFLAGS="$old_CPPFLAGS"
            LDFLAGS="$old_LDFLAGS"
            fi
            ])

            ## Configure body starts here.

            AC_PREREQ(2.59)
            AC_INIT([git], [@GIT_VERSION@], [git@vger.kernel.org])

            AC_CONFIG_SRCDIR([git.c])

            config_file=config.mak.autogen
            config_in=config.mak.in

            GIT_CONF_SUBST([AUTOCONFIGURED], [YesPlease])

            # Directories holding "saner" versions of common or POSIX binaries.
            AC_ARG_WITH([sane-tool-path],
            [AS_HELP_STRING(
            [--with-sane-tool-path=DIR-1[[:DIR-2...:DIR-n]]],
            [Directories to prepend to PATH in build system and generated scripts])],
            [if test "$withval" = "no"; then
            withval=''
            else
            AC_MSG_NOTICE([Setting SANE_TOOL_PATH to '$withval'])
            fi
            GIT_CONF_SUBST([SANE_TOOL_PATH], [$withval])],
            [# If the "--with-sane-tool-path" option was not given, don't touch
            # SANE_TOOL_PATH here, but let defaults in Makefile take care of it.
            # This should minimize spurious differences in the behaviour of the
            # Git build system when configure is used w.r.t. when it is not.
            :])

            ## Site configuration related to programs (before tests)
            ## --with-PACKAGE[=ARG] and --without-PACKAGE
            #
            # Set lib to alternative name of lib directory (e.g. lib64)
            AC_ARG_WITH([lib],
            [AS_HELP_STRING([--with-lib=ARG],
                            [ARG specifies alternative name for lib directory])],
            [if test "$withval" = "no" || test "$withval" = "yes"; then
                    AC_MSG_WARN([You should provide name for --with-lib=ARG])
            else
                    lib=$withval
                    AC_MSG_NOTICE([Setting lib to '$lib'])
                    GIT_CONF_SUBST([lib])
            fi])

            if test -z "$lib"; then
            AC_MSG_NOTICE([Setting lib to 'lib' (the default)])
            lib=lib
            fi

            AC_ARG_ENABLE([pthreads],
            [AS_HELP_STRING([--enable-pthreads=FLAGS],
            [FLAGS is the value to pass to the compiler to enable POSIX Threads.]
            [The default if FLAGS is not specified is to try first -pthread]
            [and then -lpthread.]
            [--disable-pthreads will disable threading.])],
            [
            if test "x$enableval" = "xyes"; then
            AC_MSG_NOTICE([Will try -pthread then -lpthread to enable POSIX Threads])
            elif test "x$enableval" != "xno"; then
            PTHREAD_CFLAGS=$enableval
            AC_MSG_NOTICE([Setting '$PTHREAD_CFLAGS' as the FLAGS to enable POSIX Threads])
            else
            AC_MSG_NOTICE([POSIX Threads will be disabled.])
            NO_PTHREADS=YesPlease
            USER_NOPTHREAD=1
            fi],
            [
            AC_MSG_NOTICE([Will try -pthread then -lpthread to enable POSIX Threads.])
            ])

            # Define option to enable JavaScript minification
            AC_ARG_ENABLE([jsmin],
            [AS_HELP_STRING([--enable-jsmin=PATH],
            [PATH is the name of a JavaScript minifier or the absolute path to one.])],
            [
            JSMIN=$enableval;
            AC_MSG_NOTICE([Setting JSMIN to '$JSMIN' to enable JavaScript minifying])
            GIT_CONF_SUBST([JSMIN])
            ])

            # Define option to enable CSS minification
            AC_ARG_ENABLE([cssmin],
            [AS_HELP_STRING([--enable-cssmin=PATH],
            [PATH is the name of a CSS minifier or the absolute path to one.])],
            [
            CSSMIN=$enableval;
            AC_MSG_NOTICE([Setting CSSMIN to '$CSSMIN' to enable CSS minifying])
            GIT_CONF_SUBST([CSSMIN])
            ])

            ## Site configuration (override autodetection)
            ## --with-PACKAGE[=ARG] and --without-PACKAGE
            AC_MSG_NOTICE([CHECKS for site configuration])
            #
            # Define NO_SVN_TESTS if you want to skip time-consuming SVN interoperability
            # tests.  These tests take up a significant amount of the total test time
            # but are not needed unless you plan to talk to SVN repos.
            #
            # Define NO_OPENSSL environment variable if you do not have OpenSSL.
            #
            # Define OPENSSLDIR=/foo/bar if your openssl header and library files are in
            # /foo/bar/include and /foo/bar/lib directories.
            AC_ARG_WITH(openssl,
            AS_HELP_STRING([--with-openssl],[use OpenSSL library (default is YES)])
            AS_HELP_STRING([],              [ARG can be prefix for openssl library and headers]),
            GIT_PARSE_WITH([openssl]))

            # Define USE_LIBPCRE if you have and want to use libpcre. Various
            # commands such as log and grep offer runtime options to use
            # Perl-compatible regular expressions instead of standard or extended
            # POSIX regular expressions. Only libpcre version 2 is supported.
            #
            # Define LIBPCREDIR=/foo/bar if your PCRE header and library files are in
            # /foo/bar/include and /foo/bar/lib directories.
            #

            AC_ARG_WITH(libpcre1,
            AS_HELP_STRING([--with-libpcre1],[DEPRECATED]),
            AC_MSG_ERROR([support for --with-libpcre1 has been removed. Use --with-libpcre2!])
            )

            AC_ARG_WITH(libpcre,
            AS_HELP_STRING([--with-libpcre],[synonym for --with-libpcre2]),
            if test "$withval" = "no"; then
                    USE_LIBPCRE2=
            elif test "$withval" = "yes"; then
                    USE_LIBPCRE2=YesPlease
            else
                    USE_LIBPCRE2=YesPlease
                    LIBPCREDIR=$withval
                    AC_MSG_NOTICE([Setting LIBPCREDIR to $LIBPCREDIR])
                    dnl USE_LIBPCRE2 can still be modified below, so don't substitute
                    dnl it yet.
                    GIT_CONF_SUBST([LIBPCREDIR])
            fi)

            AC_ARG_WITH(libpcre2,
            AS_HELP_STRING([--with-libpcre2],[support Perl-compatible regexes via libpcre2 (default is NO)])
            AS_HELP_STRING([],           [ARG can be also prefix for libpcre library and headers]),
            if test -n "$USE_LIBPCRE2"; then
                    AC_MSG_ERROR([Only supply one of --with-libpcre or its synonym --with-libpcre2!])
            fi

            if test "$withval" = "no"; then
                    USE_LIBPCRE2=
            elif test "$withval" = "yes"; then
                    USE_LIBPCRE2=YesPlease
            else
                    USE_LIBPCRE2=YesPlease
                    LIBPCREDIR=$withval
                    AC_MSG_NOTICE([Setting LIBPCREDIR to $LIBPCREDIR])
                    dnl USE_LIBPCRE2 can still be modified below, so don't substitute
                    dnl it yet.
                    GIT_CONF_SUBST([LIBPCREDIR])
            fi)
            #
            # Define HAVE_ALLOCA_H if you have working alloca(3) defined in that header.
            AC_FUNC_ALLOCA
            case $ac_cv_working_alloca_h in
            yes)    HAVE_ALLOCA_H=YesPlease;;
            *)      HAVE_ALLOCA_H='';;
            esac
            GIT_CONF_SUBST([HAVE_ALLOCA_H])
            #
            # Define NO_CURL if you do not have curl installed.  git-http-pull and
            # git-http-push are not built, and you cannot use http:// and https://
            # transports.
            #
            # Define CURLDIR=/foo/bar if your curl header and library files are in
            # /foo/bar/include and /foo/bar/lib directories.
            AC_ARG_WITH(curl,
            AS_HELP_STRING([--with-curl],[support http(s):// transports (default is YES)])
            AS_HELP_STRING([],           [ARG can be also prefix for curl library and headers]),
            GIT_PARSE_WITH(curl))
            #
            # Define NO_EXPAT if you do not have expat installed.  git-http-push is
            # not built, and you cannot push using http:// and https:// transports.
            #
            # Define EXPATDIR=/foo/bar if your expat header and library files are in
            # /foo/bar/include and /foo/bar/lib directories.
            AC_ARG_WITH(expat,
            AS_HELP_STRING([--with-expat],
            [support git-push using http:// and https:// transports via WebDAV (default is YES)])
            AS_HELP_STRING([],            [ARG can be also prefix for expat library and headers]),
            GIT_PARSE_WITH(expat))
            #
            # Define NO_FINK if you are building on Darwin/Mac OS X, have Fink
            # installed in /sw, but don't want GIT to link against any libraries
            # installed there.  If defined you may specify your own (or Fink's)
            # include directories and library directories by defining CFLAGS
            # and LDFLAGS appropriately.
            #
            # Define NO_DARWIN_PORTS if you are building on Darwin/Mac OS X,
            # have DarwinPorts installed in /opt/local, but don't want GIT to
            # link against any libraries installed there.  If defined you may
            # specify your own (or DarwinPort's) include directories and
            # library directories by defining CFLAGS and LDFLAGS appropriately.
            #
            # Define NO_MMAP if you want to avoid mmap.
            #
            # Define NO_ICONV if your libc does not properly support iconv.
            AC_ARG_WITH(iconv,
            AS_HELP_STRING([--without-iconv],
            [if your architecture doesn't properly support iconv])
            AS_HELP_STRING([--with-iconv=PATH],
            [PATH is prefix for libiconv library and headers])
            AS_HELP_STRING([],
            [used only if you need linking with libiconv]),
            GIT_PARSE_WITH(iconv))

            ## --enable-FEATURE[=ARG] and --disable-FEATURE
            #
            # Define USE_NSEC below if you want git to care about sub-second file mtimes
            # and ctimes. Note that you need recent glibc (at least 2.2.4) for this, and
            # it will BREAK YOUR LOCAL DIFFS! show-diff and anything using it will likely
            # randomly break unless your underlying filesystem supports those sub-second
            # times (my ext3 doesn't).
            #
            # Define USE_STDEV below if you want git to care about the underlying device
            # change being considered an inode change from the update-index perspective.

            #
            # Allow user to set ETC_GITCONFIG variable
            GIT_PARSE_WITH_SET_MAKE_VAR(gitconfig, ETC_GITCONFIG,
                                    Use VALUE instead of /etc/gitconfig as the
                                    global git configuration file.
                                    If VALUE is not fully qualified it will be interpreted
                                    as a path relative to the computed prefix at runtime.)

            #
            # Allow user to set ETC_GITATTRIBUTES variable
            GIT_PARSE_WITH_SET_MAKE_VAR(gitattributes, ETC_GITATTRIBUTES,
                                    Use VALUE instead of /etc/gitattributes as the
                                    global git attributes file.
                                    If VALUE is not fully qualified it will be interpreted
                                    as a path relative to the computed prefix at runtime.)

            #
            # Allow user to set the default pager
            GIT_PARSE_WITH_SET_MAKE_VAR(pager, DEFAULT_PAGER,
                                    Use VALUE as the fall-back pager instead of 'less'.
                                    This is used by things like 'git log' when the user
                                    does not specify a pager to use through alternate
                                    methods. eg: /usr/bin/pager)
            #
            # Allow user to set the default editor
            GIT_PARSE_WITH_SET_MAKE_VAR(editor, DEFAULT_EDITOR,
                                    Use VALUE as the fall-back editor instead of 'vi'.
                                    This is used by things like 'git commit' when the user
                                    does not specify a preferred editor through other
                                    methods. eg: /usr/bin/editor)

            #
            # Define SHELL_PATH to provide path to shell.
            GIT_ARG_SET_PATH(shell)
            #
            # Define PERL_PATH to provide path to Perl.
            GIT_ARG_SET_PATH(perl)
            #
            # Define PYTHON_PATH to provide path to Python.
            GIT_ARG_SET_PATH(python, allow-without)
            #
            # Define ZLIB_PATH to provide path to zlib.
            GIT_ARG_SET_PATH(zlib)
            #
            # Declare the with-tcltk/without-tcltk options.
            AC_ARG_WITH(tcltk,
            AS_HELP_STRING([--with-tcltk],[use Tcl/Tk GUI (default is YES)])
            AS_HELP_STRING([],[ARG is the full path to the Tcl/Tk interpreter.])
            AS_HELP_STRING([],[Bare --with-tcltk will make the GUI part only if])
            AS_HELP_STRING([],[Tcl/Tk interpreter will be found in a system.]),
            GIT_PARSE_WITH(tcltk))
            #


            ## Checks for programs.
            AC_MSG_NOTICE([CHECKS for programs])
            #
            AC_PROG_CC([cc gcc])
            AC_C_INLINE
            case $ac_cv_c_inline in
            inline | yes | no) INLINE='';;
            *)                 INLINE=$ac_cv_c_inline ;;
            esac
            GIT_CONF_SUBST([INLINE])

            # which switch to pass runtime path to dynamic libraries to the linker
            AC_CACHE_CHECK([if linker supports -R], git_cv_ld_dashr, [
            SAVE_LDFLAGS="${LDFLAGS}"
            LDFLAGS="${SAVE_LDFLAGS} -R /"
            AC_LINK_IFELSE([AC_LANG_PROGRAM([], [])], [git_cv_ld_dashr=yes], [git_cv_ld_dashr=no])
            LDFLAGS="${SAVE_LDFLAGS}"
            ])
            if test "$git_cv_ld_dashr" = "yes"; then
            CC_LD_DYNPATH=-R
            else
            AC_CACHE_CHECK([if linker supports -Wl,-rpath,], git_cv_ld_wl_rpath, [
            SAVE_LDFLAGS="${LDFLAGS}"
            LDFLAGS="${SAVE_LDFLAGS} -Wl,-rpath,/"
            AC_LINK_IFELSE([AC_LANG_PROGRAM([], [])], [git_cv_ld_wl_rpath=yes], [git_cv_ld_wl_rpath=no])
            LDFLAGS="${SAVE_LDFLAGS}"
            ])
            if test "$git_cv_ld_wl_rpath" = "yes"; then
            CC_LD_DYNPATH=-Wl,-rpath,
            else
            AC_CACHE_CHECK([if linker supports -rpath], git_cv_ld_rpath, [
                    SAVE_LDFLAGS="${LDFLAGS}"
                    LDFLAGS="${SAVE_LDFLAGS} -rpath /"
                    AC_LINK_IFELSE([AC_LANG_PROGRAM([], [])], [git_cv_ld_rpath=yes], [git_cv_ld_rpath=no])
                    LDFLAGS="${SAVE_LDFLAGS}"
            ])
            if test "$git_cv_ld_rpath" = "yes"; then
                    CC_LD_DYNPATH=-rpath
            else
                    AC_CACHE_CHECK([if linker supports -Wl,+b,], git_cv_ld_wl_b, [
                    SAVE_LDFLAGS="${LDFLAGS}"
                    LDFLAGS="${SAVE_LDFLAGS} -Wl,+b,/"
                    AC_LINK_IFELSE([AC_LANG_PROGRAM([], [])], [git_cv_ld_wl_b=yes], [git_cv_ld_wl_b=no])
                    LDFLAGS="${SAVE_LDFLAGS}"
                    ])
                    if test "$git_cv_ld_wl_b" = "yes"; then
                    CC_LD_DYNPATH=-Wl,+b,
                    else
                    CC_LD_DYNPATH=
                    AC_MSG_WARN([linker does not support runtime path to dynamic libraries])
                    fi
            fi
            fi
            fi
            GIT_CONF_SUBST([CC_LD_DYNPATH])
            #AC_PROG_INSTALL                # needs install-sh or install.sh in sources
            AC_CHECK_TOOLS(AR, [gar ar], :)
            AC_CHECK_PROGS(TAR, [gtar tar])
            AC_CHECK_PROGS(DIFF, [gnudiff gdiff diff])
            # TCLTK_PATH will be set to some value if we want Tcl/Tk
            # or will be empty otherwise.
            if test -n "$NO_TCLTK"; then
            TCLTK_PATH=
            else
            if test "$with_tcltk" = ""; then
            # No Tcl/Tk switches given. Do not check for Tcl/Tk, use bare 'wish'.
            TCLTK_PATH=wish
            elif test "$with_tcltk" = "yes"; then
            # Tcl/Tk check requested.
            AC_CHECK_PROGS(TCLTK_PATH, [wish], )
            else
            AC_MSG_RESULT([Using Tcl/Tk interpreter $with_tcltk])
            TCLTK_PATH="$with_tcltk"
            fi
            fi
            GIT_CONF_SUBST([TCLTK_PATH])
            AC_CHECK_PROGS(ASCIIDOC, [asciidoc])
            if test -n "$ASCIIDOC"; then
                    AC_MSG_CHECKING([for asciidoc version])
                    asciidoc_version=`$ASCIIDOC --version 2>/dev/null`
                    case "${asciidoc_version}" in
                    asciidoc' '8*)
                            AC_MSG_RESULT([${asciidoc_version}])
                            ;;
                    *)
                            AC_MSG_RESULT([${asciidoc_version} (unknown)])
                            ;;
                    esac
            fi

            ## Checks for libraries.
            AC_MSG_NOTICE([CHECKS for libraries])
            #
            # Define NO_OPENSSL environment variable if you do not have OpenSSL.
            # Define NEEDS_SSL_WITH_CRYPTO if you need -lcrypto with -lssl (Darwin).

            GIT_STASH_FLAGS($OPENSSLDIR)

            AC_CHECK_LIB([crypto], [SHA1_Init],
            [NEEDS_SSL_WITH_CRYPTO=],
            [AC_CHECK_LIB([ssl], [SHA1_Init],
            [NEEDS_SSL_WITH_CRYPTO=YesPlease NO_OPENSSL=],
            [NEEDS_SSL_WITH_CRYPTO=          NO_OPENSSL=YesPlease])])

            GIT_UNSTASH_FLAGS($OPENSSLDIR)

            GIT_CONF_SUBST([NEEDS_SSL_WITH_CRYPTO])
            GIT_CONF_SUBST([NO_OPENSSL])

            #
            # Handle the USE_LIBPCRE options potentially set above.
            #

            if test -n "$USE_LIBPCRE2"; then

            GIT_STASH_FLAGS($LIBPCREDIR)

            AC_CHECK_LIB([pcre2-8], [pcre2_config_8],
            [USE_LIBPCRE2=YesPlease],
            [USE_LIBPCRE2=])

            GIT_UNSTASH_FLAGS($LIBPCREDIR)

            GIT_CONF_SUBST([USE_LIBPCRE2])

            fi

            #
            # Define NO_CURL if you do not have libcurl installed.  git-http-pull and
            # git-http-push are not built, and you cannot use http:// and https://
            # transports.

            if test -z "$NO_CURL"; then

            GIT_STASH_FLAGS($CURLDIR)

            AC_CHECK_LIB([curl], [curl_global_init],
            [NO_CURL=],
            [NO_CURL=YesPlease])

            GIT_UNSTASH_FLAGS($CURLDIR)

            fi

            GIT_CONF_SUBST([NO_CURL])

            if test -z "$NO_CURL"; then

            AC_CHECK_PROG([CURL_CONFIG], [curl-config],
            [curl-config],
            [no])

            if test $CURL_CONFIG != no; then
            GIT_CONF_SUBST([CURL_CONFIG])

            if test -z "$CURL_CONFIG_OPTS"; then
                    CURL_CONFIG_OPTS="--libs"
            fi

            CURL_LDFLAGS=$($CURL_CONFIG $CURL_CONFIG_OPTS)
            AC_MSG_NOTICE([Setting CURL_LDFLAGS to '$CURL_LDFLAGS'])
            GIT_CONF_SUBST([CURL_LDFLAGS], [$CURL_LDFLAGS])
            fi

            fi


            #
            # Define NO_EXPAT if you do not have expat installed.  git-http-push is
            # not built, and you cannot push using http:// and https:// transports.

            if test -z "$NO_EXPAT"; then

            GIT_STASH_FLAGS($EXPATDIR)

            AC_CHECK_LIB([expat], [XML_ParserCreate],
            [NO_EXPAT=],
            [NO_EXPAT=YesPlease])

            GIT_UNSTASH_FLAGS($EXPATDIR)

            fi

            GIT_CONF_SUBST([NO_EXPAT])

            #
            # Define NEEDS_LIBICONV if linking with libc is not enough (Darwin and
            # some Solaris installations).
            # Define NO_ICONV if neither libc nor libiconv support iconv.

            if test -z "$NO_ICONV"; then

            GIT_STASH_FLAGS($ICONVDIR)

            AC_DEFUN([ICONVTEST_SRC],
            [AC_LANG_PROGRAM([#include <iconv.h>],
            [iconv_open("", "");])])

            if test -n "$ICONVDIR"; then
            lib_order="-liconv -lc"
            else
            lib_order="-lc -liconv"
            fi

            NO_ICONV=YesPlease

            for l in $lib_order; do
            if test "$l" = "-liconv"; then
            NEEDS_LIBICONV=YesPlease
            else
            NEEDS_LIBICONV=
            fi

            old_LIBS="$LIBS"
            LIBS="$LIBS $l"
            AC_MSG_CHECKING([for iconv in $l])
            AC_LINK_IFELSE([ICONVTEST_SRC],
                    [AC_MSG_RESULT([yes])
                    NO_ICONV=
                    break],
                    [AC_MSG_RESULT([no])])
            LIBS="$old_LIBS"
            done

            #in case of break
            LIBS="$old_LIBS"

            GIT_UNSTASH_FLAGS($ICONVDIR)

            GIT_CONF_SUBST([NEEDS_LIBICONV])

            if test -n "$NO_ICONV"; then
            NEEDS_LIBICONV=
            fi

            fi

            GIT_CONF_SUBST([NO_ICONV])

            #
            # Define NO_DEFLATE_BOUND if deflateBound is missing from zlib.

            GIT_STASH_FLAGS($ZLIB_PATH)

            AC_DEFUN([ZLIBTEST_SRC], [
            AC_LANG_PROGRAM([#include <zlib.h>],
            [deflateBound(0, 0);])])
            AC_MSG_CHECKING([for deflateBound in -lz])
            old_LIBS="$LIBS"
            LIBS="$LIBS -lz"
            AC_LINK_IFELSE([ZLIBTEST_SRC],
                    [AC_MSG_RESULT([yes])],
                    [AC_MSG_RESULT([no])
                    NO_DEFLATE_BOUND=yes])
            LIBS="$old_LIBS"

            GIT_UNSTASH_FLAGS($ZLIB_PATH)

            GIT_CONF_SUBST([NO_DEFLATE_BOUND])

            #
            # Define NEEDS_SOCKET if linking with libc is not enough (SunOS,
            # Patrick Mauritz).
            AC_CHECK_LIB([c], [socket],
            [NEEDS_SOCKET=],
            [NEEDS_SOCKET=YesPlease])
            GIT_CONF_SUBST([NEEDS_SOCKET])
            test -n "$NEEDS_SOCKET" && LIBS="$LIBS -lsocket"

            #
            # The next few tests will define NEEDS_RESOLV if linking with
            # libresolv provides some of the functions we would normally get
            # from libc.
            NEEDS_RESOLV=
            #
            # Define NO_INET_NTOP if linking with -lresolv is not enough.
            # Solaris 2.7 in particular hos inet_ntop in -lresolv.
            NO_INET_NTOP=
            AC_CHECK_FUNC([inet_ntop],
            [],
            [AC_CHECK_LIB([resolv], [inet_ntop],
                    [NEEDS_RESOLV=YesPlease],
                    [NO_INET_NTOP=YesPlease])
            ])
            GIT_CONF_SUBST([NO_INET_NTOP])
            #
            # Define NO_INET_PTON if linking with -lresolv is not enough.
            # Solaris 2.7 in particular hos inet_pton in -lresolv.
            NO_INET_PTON=
            AC_CHECK_FUNC([inet_pton],
            [],
            [AC_CHECK_LIB([resolv], [inet_pton],
                    [NEEDS_RESOLV=YesPlease],
                    [NO_INET_PTON=YesPlease])
            ])
            GIT_CONF_SUBST([NO_INET_PTON])
            #
            # Define NO_HSTRERROR if linking with -lresolv is not enough.
            # Solaris 2.6 in particular has no hstrerror, even in -lresolv.
            NO_HSTRERROR=
            AC_CHECK_FUNC([hstrerror],
            [],
            [AC_CHECK_LIB([resolv], [hstrerror],
                    [NEEDS_RESOLV=YesPlease],
                    [NO_HSTRERROR=YesPlease])
            ])
            GIT_CONF_SUBST([NO_HSTRERROR])

            dnl This must go after all the possible places for its initialization,
            dnl in the AC_CHECK_FUNC invocations above.
            GIT_CONF_SUBST([NEEDS_RESOLV])
            #
            # If any of the above tests determined that -lresolv is needed at
            # build-time, also set it here for remaining configure-time checks.
            test -n "$NEEDS_RESOLV" && LIBS="$LIBS -lresolv"

            AC_CHECK_LIB([c], [basename],
            [NEEDS_LIBGEN=],
            [NEEDS_LIBGEN=YesPlease])
            GIT_CONF_SUBST([NEEDS_LIBGEN])
            test -n "$NEEDS_LIBGEN" && LIBS="$LIBS -lgen"

            AC_DEFUN([LIBINTL_SRC], [
            AC_LANG_PROGRAM([[
            #include <libintl.h>
            ]],[[
            char *msg = gettext("test");
            ]])])

            AC_MSG_CHECKING([if libc contains libintl])
            AC_LINK_IFELSE([LIBINTL_SRC],
                    [AC_MSG_RESULT([yes])
                    LIBC_CONTAINS_LIBINTL=YesPlease],
                    [AC_MSG_RESULT([no])
                    LIBC_CONTAINS_LIBINTL=])
            GIT_CONF_SUBST([LIBC_CONTAINS_LIBINTL])

            #
            # Define NO_GETTEXT if you don't want Git output to be translated.
            # A translated Git requires GNU libintl or another gettext implementation
            AC_CHECK_HEADER([libintl.h],
            [NO_GETTEXT=],
            [NO_GETTEXT=YesPlease])
            GIT_CONF_SUBST([NO_GETTEXT])

            if test -z "$NO_GETTEXT"; then
            test -n "$LIBC_CONTAINS_LIBINTL" || LIBS="$LIBS -lintl"
            fi

            ## Checks for header files.
            AC_MSG_NOTICE([CHECKS for header files])
            #
            # Define NO_SYS_SELECT_H if you don't have sys/select.h.
            AC_CHECK_HEADER([sys/select.h],
            [NO_SYS_SELECT_H=],
            [NO_SYS_SELECT_H=UnfortunatelyYes])
            GIT_CONF_SUBST([NO_SYS_SELECT_H])
            #
            # Define NO_POLL_H if you don't have poll.h
            AC_CHECK_HEADER([poll.h],
            [NO_POLL_H=],
            [NO_POLL_H=UnfortunatelyYes])
            GIT_CONF_SUBST([NO_POLL_H])
            #
            # Define NO_SYS_POLL_H if you don't have sys/poll.h
            AC_CHECK_HEADER([sys/poll.h],
            [NO_SYS_POLL_H=],
            [NO_SYS_POLL_H=UnfortunatelyYes])
            GIT_CONF_SUBST([NO_SYS_POLL_H])
            #
            # Define NO_INTTYPES_H if you don't have inttypes.h
            AC_CHECK_HEADER([inttypes.h],
            [NO_INTTYPES_H=],
            [NO_INTTYPES_H=UnfortunatelyYes])
            GIT_CONF_SUBST([NO_INTTYPES_H])
            #
            # Define OLD_ICONV if your library has an old iconv(), where the second
            # (input buffer pointer) parameter is declared with type (const char **).
            AC_DEFUN([OLDICONVTEST_SRC], [
            AC_LANG_PROGRAM([[
            #include <iconv.h>

            extern size_t iconv(iconv_t cd,
                            char **inbuf, size_t *inbytesleft,
                            char **outbuf, size_t *outbytesleft);
            ]], [])])

            GIT_STASH_FLAGS($ICONVDIR)

            AC_MSG_CHECKING([for old iconv()])
            AC_COMPILE_IFELSE([OLDICONVTEST_SRC],
                    [AC_MSG_RESULT([no])],
                    [AC_MSG_RESULT([yes])
                    AC_DEFINE(HAVE_OLD_ICONV, 1)
                    OLD_ICONV=UnfortunatelyYes])

            GIT_UNSTASH_FLAGS($ICONVDIR)

            GIT_CONF_SUBST([OLD_ICONV])

            #
            # Define ICONV_OMITS_BOM if you are on a system which
            # iconv omits bom for utf-{16,32}
            if test -z "$NO_ICONV"; then
            AC_CACHE_CHECK([whether iconv omits bom for utf-16 and utf-32],
            [ac_cv_iconv_omits_bom],
            [
            old_LIBS="$LIBS"
            if test -n "$NEEDS_LIBICONV"; then
                    LIBS="$LIBS -liconv"
            fi

            AC_RUN_IFELSE(
                    [AC_LANG_PROGRAM([AC_INCLUDES_DEFAULT
                    #include <iconv.h>
                    #ifdef HAVE_OLD_ICONV
                    typedef const char *iconv_ibp;
                    #else
                    typedef char *iconv_ibp;
                    #endif
                    ],
                    [[
                    int v;
                    iconv_t conv;
                    char in[] = "a"; iconv_ibp pin = in;
                    char out[20] = ""; char *pout = out;
                    size_t isz = sizeof in;
                    size_t osz = sizeof out;

                    conv = iconv_open("UTF-16", "UTF-8");
                    iconv(conv, &pin, &isz, &pout, &osz);
                    iconv_close(conv);
                    v = (unsigned char)(out[0]) + (unsigned char)(out[1]);
                    return v != 0xfe + 0xff;
                    ]])],
                    [ac_cv_iconv_omits_bom=no],
                    [ac_cv_iconv_omits_bom=yes])

            LIBS="$old_LIBS"
            ])
            if test "x$ac_cv_iconv_omits_bom" = xyes; then
                    ICONV_OMITS_BOM=Yes
            else
                    ICONV_OMITS_BOM=
            fi
            GIT_CONF_SUBST([ICONV_OMITS_BOM])
            fi

            ## Checks for typedefs, structures, and compiler characteristics.
            AC_MSG_NOTICE([CHECKS for typedefs, structures, and compiler characteristics])
            #
            TYPE_SOCKLEN_T
            case $ac_cv_type_socklen_t in
            yes)  SOCKLEN_T='';;
            *)    SOCKLEN_T=$git_cv_socklen_t_equiv;;
            esac
            GIT_CONF_SUBST([SOCKLEN_T])

            #
            # Define NO_STRUCT_ITIMERVAL if you don't have struct itimerval.
            AC_CHECK_TYPES([struct itimerval],
            [NO_STRUCT_ITIMERVAL=],
            [NO_STRUCT_ITIMERVAL=UnfortunatelyYes],
            [#include <sys/time.h>])
            GIT_CONF_SUBST([NO_STRUCT_ITIMERVAL])
            #
            # Define USE_ST_TIMESPEC=YesPlease when stat.st_mtimespec.tv_nsec exists.
            # Define NO_NSEC=YesPlease when neither stat.st_mtim.tv_nsec nor
            # stat.st_mtimespec.tv_nsec exists.
            AC_CHECK_MEMBER([struct stat.st_mtimespec.tv_nsec])
            AC_CHECK_MEMBER([struct stat.st_mtim.tv_nsec])
            if test x$ac_cv_member_struct_stat_st_mtimespec_tv_nsec = xyes; then
                    USE_ST_TIMESPEC=YesPlease
                    GIT_CONF_SUBST([USE_ST_TIMESPEC])
            elif test x$ac_cv_member_struct_stat_st_mtim_tv_nsec != xyes; then
                    NO_NSEC=YesPlease
                    GIT_CONF_SUBST([NO_NSEC])
            fi
            #
            # Define NO_D_TYPE_IN_DIRENT if your platform defines DT_UNKNOWN but lacks
            # d_type in struct dirent (latest Cygwin -- will be fixed soonish).
            AC_CHECK_MEMBER(struct dirent.d_type,
            [NO_D_TYPE_IN_DIRENT=],
            [NO_D_TYPE_IN_DIRENT=YesPlease],
            [#include <dirent.h>])
            GIT_CONF_SUBST([NO_D_TYPE_IN_DIRENT])
            #
            # Define NO_GECOS_IN_PWENT if you don't have pw_gecos in struct passwd
            # in the C library.
            AC_CHECK_MEMBER(struct passwd.pw_gecos,
            [NO_GECOS_IN_PWENT=],
            [NO_GECOS_IN_PWENT=YesPlease],
            [#include <pwd.h>])
            GIT_CONF_SUBST([NO_GECOS_IN_PWENT])
            #
            # Define NO_SOCKADDR_STORAGE if your platform does not have struct
            # sockaddr_storage.
            AC_CHECK_TYPE(struct sockaddr_storage,
            [NO_SOCKADDR_STORAGE=],
            [NO_SOCKADDR_STORAGE=YesPlease],[
            #include <sys/types.h>
            #include <sys/socket.h>
            ])
            GIT_CONF_SUBST([NO_SOCKADDR_STORAGE])
            #
            # Define NO_IPV6 if you lack IPv6 support and getaddrinfo().
            AC_CHECK_TYPE([struct addrinfo],[
            GIT_CHECK_FUNC([getaddrinfo],
            [NO_IPV6=],
            [NO_IPV6=YesPlease])
            ],[NO_IPV6=YesPlease],[
            #include <sys/types.h>
            #include <sys/socket.h>
            #include <netdb.h>
            ])
            GIT_CONF_SUBST([NO_IPV6])
            #
            # Define NO_REGEX if your C library lacks regex support with REG_STARTEND
            # feature.
            AC_CACHE_CHECK([whether the platform regex supports REG_STARTEND],
            [ac_cv_c_regex_with_reg_startend], [
            AC_EGREP_CPP(yippeeyeswehaveit,
                    AC_LANG_PROGRAM([AC_INCLUDES_DEFAULT
            #include <regex.h>
            ],
            [#ifdef REG_STARTEND
            yippeeyeswehaveit
            #endif
            ]),
                    [ac_cv_c_regex_with_reg_startend=yes],
                    [ac_cv_c_regex_with_reg_startend=no])
            ])
            if test $ac_cv_c_regex_with_reg_startend = yes; then
                    NO_REGEX=
            else
                    NO_REGEX=YesPlease
            fi
            GIT_CONF_SUBST([NO_REGEX])
            #
            # Define FREAD_READS_DIRECTORIES if your are on a system which succeeds
            # when attempting to read from an fopen'ed directory.
            AC_CACHE_CHECK([whether system succeeds to read fopen'ed directory],
            [ac_cv_fread_reads_directories],
            [
            AC_RUN_IFELSE(
                    [AC_LANG_PROGRAM([AC_INCLUDES_DEFAULT],
                            [[
                            FILE *f = fopen(".", "r");
                            return f != NULL;]])],
                    [ac_cv_fread_reads_directories=no],
                    [ac_cv_fread_reads_directories=yes])
            ])
            if test $ac_cv_fread_reads_directories = yes; then
                    FREAD_READS_DIRECTORIES=UnfortunatelyYes
            else
                    FREAD_READS_DIRECTORIES=
            fi
            GIT_CONF_SUBST([FREAD_READS_DIRECTORIES])
            #
            # Define SNPRINTF_RETURNS_BOGUS if your are on a system which snprintf()
            # or vsnprintf() return -1 instead of number of characters which would
            # have been written to the final string if enough space had been available.
            AC_CACHE_CHECK([whether snprintf() and/or vsnprintf() return bogus value],
            [ac_cv_snprintf_returns_bogus],
            [
            AC_RUN_IFELSE(
                    [AC_LANG_PROGRAM([AC_INCLUDES_DEFAULT
                            #include "stdarg.h"

                            int test_vsnprintf(char *str, size_t maxsize, const char *format, ...)
                            {
                            int ret;
                            va_list ap;
                            va_start(ap, format);
                            ret = vsnprintf(str, maxsize, format, ap);
                            va_end(ap);
                            return ret;
                            }],
                            [[char buf[6];
                            if (test_vsnprintf(buf, 3, "%s", "12345") != 5
                            || strcmp(buf, "12")) return 1;
                            if (snprintf(buf, 3, "%s", "12345") != 5
                            || strcmp(buf, "12")) return 1]])],
                    [ac_cv_snprintf_returns_bogus=no],
                    [ac_cv_snprintf_returns_bogus=yes])
            ])
            if test $ac_cv_snprintf_returns_bogus = yes; then
                    SNPRINTF_RETURNS_BOGUS=UnfortunatelyYes
            else
                    SNPRINTF_RETURNS_BOGUS=
            fi
            GIT_CONF_SUBST([SNPRINTF_RETURNS_BOGUS])
            #
            # Define NEEDS_MODE_TRANSLATION if your OS strays from the typical file type
            # bits in mode values.
            AC_CACHE_CHECK([whether the platform uses typical file type bits],
            [ac_cv_sane_mode_bits], [
            AC_EGREP_CPP(yippeeyeswehaveit,
                    AC_LANG_PROGRAM([AC_INCLUDES_DEFAULT],
            [#if S_IFMT == 0170000 && \
                    S_IFREG == 0100000 && S_IFDIR == 0040000 && S_IFLNK == 0120000 && \
                    S_IFBLK == 0060000 && S_IFCHR == 0020000 && \
                    S_IFIFO == 0010000 && S_IFSOCK == 0140000
            yippeeyeswehaveit
            #endif
            ]),
                    [ac_cv_sane_mode_bits=yes],
                    [ac_cv_sane_mode_bits=no])
            ])
            if test $ac_cv_sane_mode_bits = yes; then
                    NEEDS_MODE_TRANSLATION=
            else
                    NEEDS_MODE_TRANSLATION=UnfortunatelyYes
            fi
            GIT_CONF_SUBST([NEEDS_MODE_TRANSLATION])


            ## Checks for library functions.
            ## (in default C library and libraries checked by AC_CHECK_LIB)
            AC_MSG_NOTICE([CHECKS for library functions])
            #
            # Define NO_LIBGEN_H if you don't have libgen.h.
            AC_CHECK_HEADER([libgen.h],
            [NO_LIBGEN_H=],
            [NO_LIBGEN_H=YesPlease])
            GIT_CONF_SUBST([NO_LIBGEN_H])
            #
            # Define HAVE_PATHS_H if you have paths.h.
            AC_CHECK_HEADER([paths.h],
            [HAVE_PATHS_H=YesPlease],
            [HAVE_PATHS_H=])
            GIT_CONF_SUBST([HAVE_PATHS_H])
            #
            # Define HAVE_LIBCHARSET_H if have libcharset.h
            AC_CHECK_HEADER([libcharset.h],
            [HAVE_LIBCHARSET_H=YesPlease],
            [HAVE_LIBCHARSET_H=])
            GIT_CONF_SUBST([HAVE_LIBCHARSET_H])
            #
            # Define HAVE_STRINGS_H if you have strings.h
            AC_CHECK_HEADER([strings.h],
            [HAVE_STRINGS_H=YesPlease],
            [HAVE_STRINGS_H=])
            GIT_CONF_SUBST([HAVE_STRINGS_H])
            # Define CHARSET_LIB if libiconv does not export the locale_charset symbol
            # and libcharset does
            CHARSET_LIB=
            AC_CHECK_LIB([iconv], [locale_charset],
            [CHARSET_LIB=-liconv],
            [AC_CHECK_LIB([charset], [locale_charset],
                            [CHARSET_LIB=-lcharset])])
            GIT_CONF_SUBST([CHARSET_LIB])
            #
            # Define HAVE_CLOCK_GETTIME=YesPlease if clock_gettime is available.
            GIT_CHECK_FUNC(clock_gettime,
                    [HAVE_CLOCK_GETTIME=YesPlease],
                    [HAVE_CLOCK_GETTIME=])
            GIT_CONF_SUBST([HAVE_CLOCK_GETTIME])

            AC_DEFUN([CLOCK_MONOTONIC_SRC], [
            AC_LANG_PROGRAM([[
            #include <time.h>
            clockid_t id = CLOCK_MONOTONIC;
            ]])])

            #
            # Define HAVE_CLOCK_MONOTONIC=YesPlease if CLOCK_MONOTONIC is available.
            AC_MSG_CHECKING([for CLOCK_MONOTONIC])
            AC_COMPILE_IFELSE([CLOCK_MONOTONIC_SRC],
                    [AC_MSG_RESULT([yes])
                    HAVE_CLOCK_MONOTONIC=YesPlease],
                    [AC_MSG_RESULT([no])
                    HAVE_CLOCK_MONOTONIC=])
            GIT_CONF_SUBST([HAVE_CLOCK_MONOTONIC])

            #
            # Define HAVE_SYNC_FILE_RANGE=YesPlease if sync_file_range is available.
            GIT_CHECK_FUNC(sync_file_range,
                    [HAVE_SYNC_FILE_RANGE=YesPlease],
                    [HAVE_SYNC_FILE_RANGE=])
            GIT_CONF_SUBST([HAVE_SYNC_FILE_RANGE])

            #
            # Define NO_SETITIMER if you don't have setitimer.
            GIT_CHECK_FUNC(setitimer,
            [NO_SETITIMER=],
            [NO_SETITIMER=YesPlease])
            GIT_CONF_SUBST([NO_SETITIMER])
            #
            # Define NO_STRCASESTR if you don't have strcasestr.
            GIT_CHECK_FUNC(strcasestr,
            [NO_STRCASESTR=],
            [NO_STRCASESTR=YesPlease])
            GIT_CONF_SUBST([NO_STRCASESTR])
            #
            # Define NO_MEMMEM if you don't have memmem.
            GIT_CHECK_FUNC(memmem,
            [NO_MEMMEM=],
            [NO_MEMMEM=YesPlease])
            GIT_CONF_SUBST([NO_MEMMEM])
            #
            # Define NO_STRLCPY if you don't have strlcpy.
            GIT_CHECK_FUNC(strlcpy,
            [NO_STRLCPY=],
            [NO_STRLCPY=YesPlease])
            GIT_CONF_SUBST([NO_STRLCPY])
            #
            # Define NO_UINTMAX_T if your platform does not have uintmax_t
            AC_CHECK_TYPE(uintmax_t,
            [NO_UINTMAX_T=],
            [NO_UINTMAX_T=YesPlease],[
            #include <inttypes.h>
            ])
            GIT_CONF_SUBST([NO_UINTMAX_T])
            #
            # Define NO_STRTOUMAX if you don't have strtoumax in the C library.
            GIT_CHECK_FUNC(strtoumax,
            [NO_STRTOUMAX=],
            [NO_STRTOUMAX=YesPlease])
            GIT_CONF_SUBST([NO_STRTOUMAX])
            #
            # Define NO_SETENV if you don't have setenv in the C library.
            GIT_CHECK_FUNC(setenv,
            [NO_SETENV=],
            [NO_SETENV=YesPlease])
            GIT_CONF_SUBST([NO_SETENV])
            #
            # Define NO_UNSETENV if you don't have unsetenv in the C library.
            GIT_CHECK_FUNC(unsetenv,
            [NO_UNSETENV=],
            [NO_UNSETENV=YesPlease])
            GIT_CONF_SUBST([NO_UNSETENV])
            #
            # Define NO_MKDTEMP if you don't have mkdtemp in the C library.
            GIT_CHECK_FUNC(mkdtemp,
            [NO_MKDTEMP=],
            [NO_MKDTEMP=YesPlease])
            GIT_CONF_SUBST([NO_MKDTEMP])
            #
            # Define NO_INITGROUPS if you don't have initgroups in the C library.
            GIT_CHECK_FUNC(initgroups,
            [NO_INITGROUPS=],
            [NO_INITGROUPS=YesPlease])
            GIT_CONF_SUBST([NO_INITGROUPS])
            #
            # Define HAVE_GETDELIM if you have getdelim in the C library.
            GIT_CHECK_FUNC(getdelim,
            [HAVE_GETDELIM=YesPlease],
            [HAVE_GETDELIM=])
            GIT_CONF_SUBST([HAVE_GETDELIM])
            #
            #
            # Define NO_MMAP if you want to avoid mmap.
            #
            # Define NO_ICONV if your libc does not properly support iconv.

            AC_DEFUN([BSD_SYSCTL_SRC], [
            AC_LANG_PROGRAM([[
            #include <stddef.h>
            #include <sys/types.h>
            #include <sys/sysctl.h>
            ]],[[
            int val, mib[2];
            size_t len;
            mib[0] = CTL_HW;
            mib[1] = 1;
            len = sizeof(val);
            return sysctl(mib, 2, &val, &len, NULL, 0) ? 1 : 0;
            ]])])

            #
            # Define HAVE_BSD_SYSCTL=YesPlease if a BSD-compatible sysctl function is available.
            AC_MSG_CHECKING([for BSD sysctl])
            AC_COMPILE_IFELSE([BSD_SYSCTL_SRC],
                    [AC_MSG_RESULT([yes])
                    HAVE_BSD_SYSCTL=YesPlease],
                    [AC_MSG_RESULT([no])
                    HAVE_BSD_SYSCTL=])
            GIT_CONF_SUBST([HAVE_BSD_SYSCTL])

            ## Other checks.
            # Define NO_SYMLINK_HEAD if you never want .git/HEAD to be a symbolic link.
            # Enable it on Windows.  By default, symrefs are still used.
            #
            # Define NO_PTHREADS if we do not have pthreads.
            #
            # Define PTHREAD_LIBS to the linker flag used for Pthread support.
            AC_DEFUN([PTHREADTEST_SRC], [
            AC_LANG_PROGRAM([[
            #include <pthread.h>
            static void *noop(void *ignore) { return ignore; }
            ]], [[
                    pthread_mutex_t test_mutex;
                    pthread_key_t test_key;
                    pthread_t th;
                    int retcode = 0;
                    void *ret = (void *)0;
                    retcode |= pthread_key_create(&test_key, (void *)0);
                    retcode |= pthread_mutex_init(&test_mutex,(void *)0);
                    retcode |= pthread_mutex_lock(&test_mutex);
                    retcode |= pthread_mutex_unlock(&test_mutex);
                    retcode |= pthread_create(&th, ret, noop, ret);
                    retcode |= pthread_join(th, &ret);
                    return retcode;
            ]])])

            dnl AC_LANG_CONFTEST([AC_LANG_PROGRAM(
            dnl   [[#include <pthread.h>]],
            dnl   [[pthread_mutex_t test_mutex;]]
            dnl )])

            NO_PTHREADS=UnfortunatelyYes
            PTHREAD_LIBS=

            if test -n "$USER_NOPTHREAD"; then
            AC_MSG_NOTICE([Skipping POSIX Threads at user request.])
            # handle these separately since PTHREAD_CFLAGS could be '-lpthreads
            # -D_REENTRANT' or some such.
            elif test -z "$PTHREAD_CFLAGS"; then
            threads_found=no
            # Attempt to compile and link some code using pthreads to determine
            # required linker flags. The order is somewhat important here: We
            # first try it without any extra flags, to catch systems where
            # pthreads are part of the C library, then go on testing various other
            # flags. We do so to avoid false positives. For example, on Mac OS X
            # pthreads are part of the C library; moreover, the compiler allows us
            # to add "-mt" to the CFLAGS (although it will do nothing except
            # trigger a warning about an unused flag). Hence if we checked for
            # "-mt" before "" we would end up picking it. But unfortunately this
            # would then trigger compiler warnings on every single file we compile.
            for opt in "" -mt -pthread -lpthread; do
            old_CFLAGS="$CFLAGS"
            old_LIBS="$LIBS"
            case "$opt" in
                    -l*)  LIBS="$opt $LIBS" ;;
                    *)    CFLAGS="$opt $CFLAGS" ;;
            esac

            AC_MSG_CHECKING([for POSIX Threads with '$opt'])
            AC_LINK_IFELSE([PTHREADTEST_SRC],
                    [AC_MSG_RESULT([yes])
                            NO_PTHREADS=
                            PTHREAD_LIBS="$opt"
                            PTHREAD_CFLAGS="$opt"
                            threads_found=yes
                            break
                    ],
                    [AC_MSG_RESULT([no])])
            CFLAGS="$old_CFLAGS"
            LIBS="$old_LIBS"
            done
            if test $threads_found != yes; then
            AC_CHECK_LIB([pthread], [pthread_create],
                    [PTHREAD_LIBS="-lpthread"],
                    [NO_PTHREADS=UnfortunatelyYes])
            fi
            else
            old_CFLAGS="$CFLAGS"
            CFLAGS="$PTHREAD_CFLAGS $CFLAGS"
            AC_MSG_CHECKING([for POSIX Threads with '$PTHREAD_CFLAGS'])
            AC_LINK_IFELSE([PTHREADTEST_SRC],
                    [AC_MSG_RESULT([yes])
                            NO_PTHREADS=
                            PTHREAD_LIBS="$PTHREAD_CFLAGS"
                    ],
                    [AC_MSG_RESULT([no])])

            CFLAGS="$old_CFLAGS"
            fi

            CFLAGS="$old_CFLAGS"

            GIT_CONF_SUBST([PTHREAD_CFLAGS])
            GIT_CONF_SUBST([PTHREAD_LIBS])
            GIT_CONF_SUBST([NO_PTHREADS])

            ## Output files
            AC_CONFIG_FILES(["${config_file}":"${config_in}"])
            AC_OUTPUT

          """,
    "error":"On OS/390, dynamic library linking might be handled differently than on other platforms like Linux or Windows.
             The patch ensures that the correct linker flag (-L) is used on OS/390 systems for finding dynamic libraries during the build process.",
    "error Category":"Functionality Patch",

    "Corrected Code":
    """
                    #                                               -*- Autoconf -*-
            # Process this file with autoconf to produce a configure script.

            ## Definitions of private macros.

            # GIT_CONF_SUBST(VAL, VAR)
            # ------------------------
            # Cause the line "VAR=VAL" to be eventually appended to ${config_file}.
            AC_DEFUN([GIT_CONF_SUBST],
            [AC_REQUIRE([GIT_CONF_SUBST_INIT])
            config_appended_defs="$config_appended_defs${newline}dnl
            $1=m4_if([$#],[1],[${$1}],[$2])"])

            # GIT_CONF_SUBST_INIT
            # -------------------
            # Prepare shell variables and autoconf machine required by later calls
            # to GIT_CONF_SUBST.
            AC_DEFUN([GIT_CONF_SUBST_INIT],
            [config_appended_defs=; newline='
            '
            AC_CONFIG_COMMANDS([$config_file],
                            [echo "$config_appended_defs" >> "$config_file"],
                            [config_file=$config_file
                                    config_appended_defs="$config_appended_defs"])])

            # GIT_ARG_SET_PATH(PROGRAM)
            # -------------------------
            # Provide --with-PROGRAM=PATH option to set PATH to PROGRAM
            # Optional second argument allows setting NO_PROGRAM=YesPlease if
            # --without-PROGRAM version used.
            AC_DEFUN([GIT_ARG_SET_PATH],
            [AC_ARG_WITH([$1],
                    [AS_HELP_STRING([--with-$1=PATH],
                                    [provide PATH to $1])],
                    [GIT_CONF_APPEND_PATH([$1], [$2])],
                    [])])

            # GIT_CONF_APPEND_PATH(PROGRAM)
            # -----------------------------
            # Parse --with-PROGRAM=PATH option to set PROGRAM_PATH=PATH
            # Used by GIT_ARG_SET_PATH(PROGRAM)
            # Optional second argument allows setting NO_PROGRAM=YesPlease if
            # --without-PROGRAM is used.
            AC_DEFUN([GIT_CONF_APPEND_PATH],
            [m4_pushdef([GIT_UC_PROGRAM], m4_toupper([$1]))dnl
            if test "$withval" = "no"; then
                    if test -n "$2"; then
                            GIT_UC_PROGRAM[]_PATH=$withval
                            AC_MSG_NOTICE([Disabling use of GIT_UC_PROGRAM])
                            GIT_CONF_SUBST([NO_]GIT_UC_PROGRAM, [YesPlease])
                            GIT_CONF_SUBST(GIT_UC_PROGRAM[]_PATH, [])
                    else
                            AC_MSG_ERROR([You cannot use git without $1])
                    fi
            else
                    if test "$withval" = "yes"; then
                            AC_MSG_WARN([You should provide path for --with-$1=PATH])
                    else
                            GIT_UC_PROGRAM[]_PATH=$withval
                            AC_MSG_NOTICE([Setting GIT_UC_PROGRAM[]_PATH to $withval])
                            GIT_CONF_SUBST(GIT_UC_PROGRAM[]_PATH, [$withval])
                    fi
            fi
            m4_popdef([GIT_UC_PROGRAM])])

            # GIT_PARSE_WITH(PACKAGE)
            # -----------------------
            # For use in AC_ARG_WITH action-if-found, for packages default ON.
            # * Set NO_PACKAGE=YesPlease for --without-PACKAGE
            # * Set PACKAGEDIR=PATH for --with-PACKAGE=PATH
            # * Unset NO_PACKAGE for --with-PACKAGE without ARG
            AC_DEFUN([GIT_PARSE_WITH],
            [m4_pushdef([GIT_UC_PACKAGE], m4_toupper([$1]))dnl
            if test "$withval" = "no"; then
                    NO_[]GIT_UC_PACKAGE=YesPlease
            elif test "$withval" = "yes"; then
                    NO_[]GIT_UC_PACKAGE=
            else
                    NO_[]GIT_UC_PACKAGE=
                    GIT_UC_PACKAGE[]DIR=$withval
                    AC_MSG_NOTICE([Setting GIT_UC_PACKAGE[]DIR to $withval])
                    GIT_CONF_SUBST(GIT_UC_PACKAGE[DIR], [$withval])
            fi
            m4_popdef([GIT_UC_PACKAGE])])

            # GIT_PARSE_WITH_SET_MAKE_VAR(WITHNAME, VAR, HELP_TEXT)
            # -----------------------------------------------------
            # Set VAR to the value specified by --with-WITHNAME.
            # No verification of arguments is performed, but warnings are issued
            # if either 'yes' or 'no' is specified.
            # HELP_TEXT is presented when --help is called.
            # This is a direct way to allow setting variables in the Makefile.
            AC_DEFUN([GIT_PARSE_WITH_SET_MAKE_VAR],
            [AC_ARG_WITH([$1],
            [AS_HELP_STRING([--with-$1=VALUE], $3)],
            if test -n "$withval"; then
            if test "$withval" = "yes" || test "$withval" = "no"; then
            AC_MSG_WARN([You likely do not want either 'yes' or 'no' as]
                            [a value for $1 ($2).  Maybe you do...?])
            fi
            AC_MSG_NOTICE([Setting $2 to $withval])
            GIT_CONF_SUBST([$2], [$withval])
            fi)])# GIT_PARSE_WITH_SET_MAKE_VAR

            #
            # GIT_CHECK_FUNC(FUNCTION, IFTRUE, IFFALSE)
            # -----------------------------------------
            # Similar to AC_CHECK_FUNC, but on systems that do not generate
            # warnings for missing prototypes (e.g. FreeBSD when compiling without
            # -Wall), it does not work.  By looking for function definition in
            # libraries, this problem can be worked around.
            AC_DEFUN([GIT_CHECK_FUNC],[AC_CHECK_FUNC([$1],[
            AC_SEARCH_LIBS([$1],,
            [$2],[$3])
            ],[$3])])

            #
            # GIT_STASH_FLAGS(BASEPATH_VAR)
            # -----------------------------
            # Allow for easy stashing of LDFLAGS and CPPFLAGS before running
            # tests that may want to take user settings into account.
            AC_DEFUN([GIT_STASH_FLAGS],[
            if test -n "$1"; then
            old_CPPFLAGS="$CPPFLAGS"
            old_LDFLAGS="$LDFLAGS"
            CPPFLAGS="-I$1/include $CPPFLAGS"
            LDFLAGS="-L$1/$lib $LDFLAGS"
            fi
            ])

            dnl
            dnl GIT_UNSTASH_FLAGS(BASEPATH_VAR)
            dnl -----------------------------
            dnl Restore the stashed *FLAGS values.
            AC_DEFUN([GIT_UNSTASH_FLAGS],[
            if test -n "$1"; then
            CPPFLAGS="$old_CPPFLAGS"
            LDFLAGS="$old_LDFLAGS"
            fi
            ])

            ## Configure body starts here.

            AC_PREREQ(2.59)
            AC_INIT([git], [@GIT_VERSION@], [git@vger.kernel.org])

            AC_CONFIG_SRCDIR([git.c])

            config_file=config.mak.autogen
            config_in=config.mak.in

            GIT_CONF_SUBST([AUTOCONFIGURED], [YesPlease])

            # Directories holding "saner" versions of common or POSIX binaries.
            AC_ARG_WITH([sane-tool-path],
            [AS_HELP_STRING(
            [--with-sane-tool-path=DIR-1[[:DIR-2...:DIR-n]]],
            [Directories to prepend to PATH in build system and generated scripts])],
            [if test "$withval" = "no"; then
            withval=''
            else
            AC_MSG_NOTICE([Setting SANE_TOOL_PATH to '$withval'])
            fi
            GIT_CONF_SUBST([SANE_TOOL_PATH], [$withval])],
            [# If the "--with-sane-tool-path" option was not given, don't touch
            # SANE_TOOL_PATH here, but let defaults in Makefile take care of it.
            # This should minimize spurious differences in the behaviour of the
            # Git build system when configure is used w.r.t. when it is not.
            :])

            ## Site configuration related to programs (before tests)
            ## --with-PACKAGE[=ARG] and --without-PACKAGE
            #
            # Set lib to alternative name of lib directory (e.g. lib64)
            AC_ARG_WITH([lib],
            [AS_HELP_STRING([--with-lib=ARG],
                            [ARG specifies alternative name for lib directory])],
            [if test "$withval" = "no" || test "$withval" = "yes"; then
                    AC_MSG_WARN([You should provide name for --with-lib=ARG])
            else
                    lib=$withval
                    AC_MSG_NOTICE([Setting lib to '$lib'])
                    GIT_CONF_SUBST([lib])
            fi])

            if test -z "$lib"; then
            AC_MSG_NOTICE([Setting lib to 'lib' (the default)])
            lib=lib
            fi

            AC_ARG_ENABLE([pthreads],
            [AS_HELP_STRING([--enable-pthreads=FLAGS],
            [FLAGS is the value to pass to the compiler to enable POSIX Threads.]
            [The default if FLAGS is not specified is to try first -pthread]
            [and then -lpthread.]
            [--disable-pthreads will disable threading.])],
            [
            if test "x$enableval" = "xyes"; then
            AC_MSG_NOTICE([Will try -pthread then -lpthread to enable POSIX Threads])
            elif test "x$enableval" != "xno"; then
            PTHREAD_CFLAGS=$enableval
            AC_MSG_NOTICE([Setting '$PTHREAD_CFLAGS' as the FLAGS to enable POSIX Threads])
            else
            AC_MSG_NOTICE([POSIX Threads will be disabled.])
            NO_PTHREADS=YesPlease
            USER_NOPTHREAD=1
            fi],
            [
            AC_MSG_NOTICE([Will try -pthread then -lpthread to enable POSIX Threads.])
            ])

            # Define option to enable JavaScript minification
            AC_ARG_ENABLE([jsmin],
            [AS_HELP_STRING([--enable-jsmin=PATH],
            [PATH is the name of a JavaScript minifier or the absolute path to one.])],
            [
            JSMIN=$enableval;
            AC_MSG_NOTICE([Setting JSMIN to '$JSMIN' to enable JavaScript minifying])
            GIT_CONF_SUBST([JSMIN])
            ])

            # Define option to enable CSS minification
            AC_ARG_ENABLE([cssmin],
            [AS_HELP_STRING([--enable-cssmin=PATH],
            [PATH is the name of a CSS minifier or the absolute path to one.])],
            [
            CSSMIN=$enableval;
            AC_MSG_NOTICE([Setting CSSMIN to '$CSSMIN' to enable CSS minifying])
            GIT_CONF_SUBST([CSSMIN])
            ])

            ## Site configuration (override autodetection)
            ## --with-PACKAGE[=ARG] and --without-PACKAGE
            AC_MSG_NOTICE([CHECKS for site configuration])
            #
            # Define NO_SVN_TESTS if you want to skip time-consuming SVN interoperability
            # tests.  These tests take up a significant amount of the total test time
            # but are not needed unless you plan to talk to SVN repos.
            #
            # Define NO_OPENSSL environment variable if you do not have OpenSSL.
            #
            # Define OPENSSLDIR=/foo/bar if your openssl header and library files are in
            # /foo/bar/include and /foo/bar/lib directories.
            AC_ARG_WITH(openssl,
            AS_HELP_STRING([--with-openssl],[use OpenSSL library (default is YES)])
            AS_HELP_STRING([],              [ARG can be prefix for openssl library and headers]),
            GIT_PARSE_WITH([openssl]))

            # Define USE_LIBPCRE if you have and want to use libpcre. Various
            # commands such as log and grep offer runtime options to use
            # Perl-compatible regular expressions instead of standard or extended
            # POSIX regular expressions. Only libpcre version 2 is supported.
            #
            # Define LIBPCREDIR=/foo/bar if your PCRE header and library files are in
            # /foo/bar/include and /foo/bar/lib directories.
            #

            AC_ARG_WITH(libpcre1,
            AS_HELP_STRING([--with-libpcre1],[DEPRECATED]),
            AC_MSG_ERROR([support for --with-libpcre1 has been removed. Use --with-libpcre2!])
            )

            AC_ARG_WITH(libpcre,
            AS_HELP_STRING([--with-libpcre],[synonym for --with-libpcre2]),
            if test "$withval" = "no"; then
                    USE_LIBPCRE2=
            elif test "$withval" = "yes"; then
                    USE_LIBPCRE2=YesPlease
            else
                    USE_LIBPCRE2=YesPlease
                    LIBPCREDIR=$withval
                    AC_MSG_NOTICE([Setting LIBPCREDIR to $LIBPCREDIR])
                    dnl USE_LIBPCRE2 can still be modified below, so don't substitute
                    dnl it yet.
                    GIT_CONF_SUBST([LIBPCREDIR])
            fi)

            AC_ARG_WITH(libpcre2,
            AS_HELP_STRING([--with-libpcre2],[support Perl-compatible regexes via libpcre2 (default is NO)])
            AS_HELP_STRING([],           [ARG can be also prefix for libpcre library and headers]),
            if test -n "$USE_LIBPCRE2"; then
                    AC_MSG_ERROR([Only supply one of --with-libpcre or its synonym --with-libpcre2!])
            fi

            if test "$withval" = "no"; then
                    USE_LIBPCRE2=
            elif test "$withval" = "yes"; then
                    USE_LIBPCRE2=YesPlease
            else
                    USE_LIBPCRE2=YesPlease
                    LIBPCREDIR=$withval
                    AC_MSG_NOTICE([Setting LIBPCREDIR to $LIBPCREDIR])
                    dnl USE_LIBPCRE2 can still be modified below, so don't substitute
                    dnl it yet.
                    GIT_CONF_SUBST([LIBPCREDIR])
            fi)
            #
            # Define HAVE_ALLOCA_H if you have working alloca(3) defined in that header.
            AC_FUNC_ALLOCA
            case $ac_cv_working_alloca_h in
            yes)    HAVE_ALLOCA_H=YesPlease;;
            *)      HAVE_ALLOCA_H='';;
            esac
            GIT_CONF_SUBST([HAVE_ALLOCA_H])
            #
            # Define NO_CURL if you do not have curl installed.  git-http-pull and
            # git-http-push are not built, and you cannot use http:// and https://
            # transports.
            #
            # Define CURLDIR=/foo/bar if your curl header and library files are in
            # /foo/bar/include and /foo/bar/lib directories.
            AC_ARG_WITH(curl,
            AS_HELP_STRING([--with-curl],[support http(s):// transports (default is YES)])
            AS_HELP_STRING([],           [ARG can be also prefix for curl library and headers]),
            GIT_PARSE_WITH(curl))
            #
            # Define NO_EXPAT if you do not have expat installed.  git-http-push is
            # not built, and you cannot push using http:// and https:// transports.
            #
            # Define EXPATDIR=/foo/bar if your expat header and library files are in
            # /foo/bar/include and /foo/bar/lib directories.
            AC_ARG_WITH(expat,
            AS_HELP_STRING([--with-expat],
            [support git-push using http:// and https:// transports via WebDAV (default is YES)])
            AS_HELP_STRING([],            [ARG can be also prefix for expat library and headers]),
            GIT_PARSE_WITH(expat))
            #
            # Define NO_FINK if you are building on Darwin/Mac OS X, have Fink
            # installed in /sw, but don't want GIT to link against any libraries
            # installed there.  If defined you may specify your own (or Fink's)
            # include directories and library directories by defining CFLAGS
            # and LDFLAGS appropriately.
            #
            # Define NO_DARWIN_PORTS if you are building on Darwin/Mac OS X,
            # have DarwinPorts installed in /opt/local, but don't want GIT to
            # link against any libraries installed there.  If defined you may
            # specify your own (or DarwinPort's) include directories and
            # library directories by defining CFLAGS and LDFLAGS appropriately.
            #
            # Define NO_MMAP if you want to avoid mmap.
            #
            # Define NO_ICONV if your libc does not properly support iconv.
            AC_ARG_WITH(iconv,
            AS_HELP_STRING([--without-iconv],
            [if your architecture doesn't properly support iconv])
            AS_HELP_STRING([--with-iconv=PATH],
            [PATH is prefix for libiconv library and headers])
            AS_HELP_STRING([],
            [used only if you need linking with libiconv]),
            GIT_PARSE_WITH(iconv))

            ## --enable-FEATURE[=ARG] and --disable-FEATURE
            #
            # Define USE_NSEC below if you want git to care about sub-second file mtimes
            # and ctimes. Note that you need recent glibc (at least 2.2.4) for this, and
            # it will BREAK YOUR LOCAL DIFFS! show-diff and anything using it will likely
            # randomly break unless your underlying filesystem supports those sub-second
            # times (my ext3 doesn't).
            #
            # Define USE_STDEV below if you want git to care about the underlying device
            # change being considered an inode change from the update-index perspective.

            #
            # Allow user to set ETC_GITCONFIG variable
            GIT_PARSE_WITH_SET_MAKE_VAR(gitconfig, ETC_GITCONFIG,
                                    Use VALUE instead of /etc/gitconfig as the
                                    global git configuration file.
                                    If VALUE is not fully qualified it will be interpreted
                                    as a path relative to the computed prefix at runtime.)

            #
            # Allow user to set ETC_GITATTRIBUTES variable
            GIT_PARSE_WITH_SET_MAKE_VAR(gitattributes, ETC_GITATTRIBUTES,
                                    Use VALUE instead of /etc/gitattributes as the
                                    global git attributes file.
                                    If VALUE is not fully qualified it will be interpreted
                                    as a path relative to the computed prefix at runtime.)

            #
            # Allow user to set the default pager
            GIT_PARSE_WITH_SET_MAKE_VAR(pager, DEFAULT_PAGER,
                                    Use VALUE as the fall-back pager instead of 'less'.
                                    This is used by things like 'git log' when the user
                                    does not specify a pager to use through alternate
                                    methods. eg: /usr/bin/pager)
            #
            # Allow user to set the default editor
            GIT_PARSE_WITH_SET_MAKE_VAR(editor, DEFAULT_EDITOR,
                                    Use VALUE as the fall-back editor instead of 'vi'.
                                    This is used by things like 'git commit' when the user
                                    does not specify a preferred editor through other
                                    methods. eg: /usr/bin/editor)

            #
            # Define SHELL_PATH to provide path to shell.
            GIT_ARG_SET_PATH(shell)
            #
            # Define PERL_PATH to provide path to Perl.
            GIT_ARG_SET_PATH(perl)
            #
            # Define PYTHON_PATH to provide path to Python.
            GIT_ARG_SET_PATH(python, allow-without)
            #
            # Define ZLIB_PATH to provide path to zlib.
            GIT_ARG_SET_PATH(zlib)
            #
            # Declare the with-tcltk/without-tcltk options.
            AC_ARG_WITH(tcltk,
            AS_HELP_STRING([--with-tcltk],[use Tcl/Tk GUI (default is YES)])
            AS_HELP_STRING([],[ARG is the full path to the Tcl/Tk interpreter.])
            AS_HELP_STRING([],[Bare --with-tcltk will make the GUI part only if])
            AS_HELP_STRING([],[Tcl/Tk interpreter will be found in a system.]),
            GIT_PARSE_WITH(tcltk))
            #


            ## Checks for programs.
            AC_MSG_NOTICE([CHECKS for programs])
            #
            AC_PROG_CC([cc gcc])
            AC_C_INLINE
            case $ac_cv_c_inline in
            inline | yes | no) INLINE='';;
            *)                 INLINE=$ac_cv_c_inline ;;
            esac
            GIT_CONF_SUBST([INLINE])

            # which switch to pass runtime path to dynamic libraries to the linker
            AC_CACHE_CHECK([if linker supports -R], git_cv_ld_dashr, [
            SAVE_LDFLAGS="${LDFLAGS}"
            LDFLAGS="${SAVE_LDFLAGS} -R /"
            AC_LINK_IFELSE([AC_LANG_PROGRAM([], [])], [git_cv_ld_dashr=yes], [git_cv_ld_dashr=no])
            LDFLAGS="${SAVE_LDFLAGS}"
            ])
            if test "$git_cv_ld_dashr" = "yes"; then
            CC_LD_DYNPATH=-R
            else
            AC_CACHE_CHECK([if linker supports -Wl,-rpath,], git_cv_ld_wl_rpath, [
            SAVE_LDFLAGS="${LDFLAGS}"
            LDFLAGS="${SAVE_LDFLAGS} -Wl,-rpath,/"
            AC_LINK_IFELSE([AC_LANG_PROGRAM([], [])], [git_cv_ld_wl_rpath=yes], [git_cv_ld_wl_rpath=no])
            LDFLAGS="${SAVE_LDFLAGS}"
            ])
            if test "$git_cv_ld_wl_rpath" = "yes"; then
            CC_LD_DYNPATH=-Wl,-rpath,
            else
            AC_CACHE_CHECK([if linker supports -rpath], git_cv_ld_rpath, [
                    SAVE_LDFLAGS="${LDFLAGS}"
                    LDFLAGS="${SAVE_LDFLAGS} -rpath /"
                    AC_LINK_IFELSE([AC_LANG_PROGRAM([], [])], [git_cv_ld_rpath=yes], [git_cv_ld_rpath=no])
                    LDFLAGS="${SAVE_LDFLAGS}"
            ])
            if test "$git_cv_ld_rpath" = "yes"; then
                    CC_LD_DYNPATH=-rpath
            else
                    AC_CACHE_CHECK([if linker supports -Wl,+b,], git_cv_ld_wl_b, [
                    SAVE_LDFLAGS="${LDFLAGS}"
                    LDFLAGS="${SAVE_LDFLAGS} -Wl,+b,/"
                    AC_LINK_IFELSE([AC_LANG_PROGRAM([], [])], [git_cv_ld_wl_b=yes], [git_cv_ld_wl_b=no])
                    LDFLAGS="${SAVE_LDFLAGS}"
                    ])
                    if test "$git_cv_ld_wl_b" = "yes"; then
                    CC_LD_DYNPATH=-Wl,+b,
                    else
                    CC_LD_DYNPATH=
                    if test "$(uname -s)" = "OS/390"; then
                            CC_LD_DYNPATH=-L
                    fi
                    AC_MSG_WARN([linker does not support runtime path to dynamic libraries])
                    fi
            fi
            fi
            fi
            GIT_CONF_SUBST([CC_LD_DYNPATH])
            #AC_PROG_INSTALL                # needs install-sh or install.sh in sources
            AC_CHECK_TOOLS(AR, [gar ar], :)
            AC_CHECK_PROGS(TAR, [gtar tar])
            AC_CHECK_PROGS(DIFF, [gnudiff gdiff diff])
            # TCLTK_PATH will be set to some value if we want Tcl/Tk
            # or will be empty otherwise.
            if test -n "$NO_TCLTK"; then
            TCLTK_PATH=
            else
            if test "$with_tcltk" = ""; then
            # No Tcl/Tk switches given. Do not check for Tcl/Tk, use bare 'wish'.
            TCLTK_PATH=wish
            elif test "$with_tcltk" = "yes"; then
            # Tcl/Tk check requested.
            AC_CHECK_PROGS(TCLTK_PATH, [wish], )
            else
            AC_MSG_RESULT([Using Tcl/Tk interpreter $with_tcltk])
            TCLTK_PATH="$with_tcltk"
            fi
            fi
            GIT_CONF_SUBST([TCLTK_PATH])
            AC_CHECK_PROGS(ASCIIDOC, [asciidoc])
            if test -n "$ASCIIDOC"; then
                    AC_MSG_CHECKING([for asciidoc version])
                    asciidoc_version=`$ASCIIDOC --version 2>/dev/null`
                    case "${asciidoc_version}" in
                    asciidoc' '8*)
                            AC_MSG_RESULT([${asciidoc_version}])
                            ;;
                    *)
                            AC_MSG_RESULT([${asciidoc_version} (unknown)])
                            ;;
                    esac
            fi

            ## Checks for libraries.
            AC_MSG_NOTICE([CHECKS for libraries])
            #
            # Define NO_OPENSSL environment variable if you do not have OpenSSL.
            # Define NEEDS_SSL_WITH_CRYPTO if you need -lcrypto with -lssl (Darwin).

            GIT_STASH_FLAGS($OPENSSLDIR)

            AC_CHECK_LIB([crypto], [SHA1_Init],
            [NEEDS_SSL_WITH_CRYPTO=],
            [AC_CHECK_LIB([ssl], [SHA1_Init],
            [NEEDS_SSL_WITH_CRYPTO=YesPlease NO_OPENSSL=],
            [NEEDS_SSL_WITH_CRYPTO=          NO_OPENSSL=YesPlease])])

            GIT_UNSTASH_FLAGS($OPENSSLDIR)

            GIT_CONF_SUBST([NEEDS_SSL_WITH_CRYPTO])
            GIT_CONF_SUBST([NO_OPENSSL])

            #
            # Handle the USE_LIBPCRE options potentially set above.
            #

            if test -n "$USE_LIBPCRE2"; then

            GIT_STASH_FLAGS($LIBPCREDIR)

            AC_CHECK_LIB([pcre2-8], [pcre2_config_8],
            [USE_LIBPCRE2=YesPlease],
            [USE_LIBPCRE2=])

            GIT_UNSTASH_FLAGS($LIBPCREDIR)

            GIT_CONF_SUBST([USE_LIBPCRE2])

            fi

            #
            # Define NO_CURL if you do not have libcurl installed.  git-http-pull and
            # git-http-push are not built, and you cannot use http:// and https://
            # transports.

            if test -z "$NO_CURL"; then

            GIT_STASH_FLAGS($CURLDIR)

            AC_CHECK_LIB([curl], [curl_global_init],
            [NO_CURL=],
            [NO_CURL=YesPlease])

            GIT_UNSTASH_FLAGS($CURLDIR)

            fi

            GIT_CONF_SUBST([NO_CURL])

            if test -z "$NO_CURL"; then

            AC_CHECK_PROG([CURL_CONFIG], [curl-config],
            [curl-config],
            [no])

            if test $CURL_CONFIG != no; then
            GIT_CONF_SUBST([CURL_CONFIG])

            if test -z "$CURL_CONFIG_OPTS"; then
                    CURL_CONFIG_OPTS="--libs"
            fi

            CURL_LDFLAGS=$($CURL_CONFIG $CURL_CONFIG_OPTS)
            AC_MSG_NOTICE([Setting CURL_LDFLAGS to '$CURL_LDFLAGS'])
            GIT_CONF_SUBST([CURL_LDFLAGS], [$CURL_LDFLAGS])
            fi

            fi


            #
            # Define NO_EXPAT if you do not have expat installed.  git-http-push is
            # not built, and you cannot push using http:// and https:// transports.

            if test -z "$NO_EXPAT"; then

            GIT_STASH_FLAGS($EXPATDIR)

            AC_CHECK_LIB([expat], [XML_ParserCreate],
            [NO_EXPAT=],
            [NO_EXPAT=YesPlease])

            GIT_UNSTASH_FLAGS($EXPATDIR)

            fi

            GIT_CONF_SUBST([NO_EXPAT])

            #
            # Define NEEDS_LIBICONV if linking with libc is not enough (Darwin and
            # some Solaris installations).
            # Define NO_ICONV if neither libc nor libiconv support iconv.

            if test -z "$NO_ICONV"; then

            GIT_STASH_FLAGS($ICONVDIR)

            AC_DEFUN([ICONVTEST_SRC],
            [AC_LANG_PROGRAM([#include <iconv.h>],
            [iconv_open("", "");])])

            if test -n "$ICONVDIR"; then
            lib_order="-liconv -lc"
            else
            lib_order="-lc -liconv"
            fi

            NO_ICONV=YesPlease

            for l in $lib_order; do
            if test "$l" = "-liconv"; then
            NEEDS_LIBICONV=YesPlease
            else
            NEEDS_LIBICONV=
            fi

            old_LIBS="$LIBS"
            LIBS="$LIBS $l"
            AC_MSG_CHECKING([for iconv in $l])
            AC_LINK_IFELSE([ICONVTEST_SRC],
                    [AC_MSG_RESULT([yes])
                    NO_ICONV=
                    break],
                    [AC_MSG_RESULT([no])])
            LIBS="$old_LIBS"
            done

            #in case of break
            LIBS="$old_LIBS"

            GIT_UNSTASH_FLAGS($ICONVDIR)

            GIT_CONF_SUBST([NEEDS_LIBICONV])

            if test -n "$NO_ICONV"; then
            NEEDS_LIBICONV=
            fi

            fi

            GIT_CONF_SUBST([NO_ICONV])

            #
            # Define NO_DEFLATE_BOUND if deflateBound is missing from zlib.

            GIT_STASH_FLAGS($ZLIB_PATH)

            AC_DEFUN([ZLIBTEST_SRC], [
            AC_LANG_PROGRAM([#include <zlib.h>],
            [deflateBound(0, 0);])])
            AC_MSG_CHECKING([for deflateBound in -lz])
            old_LIBS="$LIBS"
            LIBS="$LIBS -lz"
            AC_LINK_IFELSE([ZLIBTEST_SRC],
                    [AC_MSG_RESULT([yes])],
                    [AC_MSG_RESULT([no])
                    NO_DEFLATE_BOUND=yes])
            LIBS="$old_LIBS"

            GIT_UNSTASH_FLAGS($ZLIB_PATH)

            GIT_CONF_SUBST([NO_DEFLATE_BOUND])

            #
            # Define NEEDS_SOCKET if linking with libc is not enough (SunOS,
            # Patrick Mauritz).
            AC_CHECK_LIB([c], [socket],
            [NEEDS_SOCKET=],
            [NEEDS_SOCKET=YesPlease])
            GIT_CONF_SUBST([NEEDS_SOCKET])
            test -n "$NEEDS_SOCKET" && LIBS="$LIBS -lsocket"

            #
            # The next few tests will define NEEDS_RESOLV if linking with
            # libresolv provides some of the functions we would normally get
            # from libc.
            NEEDS_RESOLV=
            #
            # Define NO_INET_NTOP if linking with -lresolv is not enough.
            # Solaris 2.7 in particular hos inet_ntop in -lresolv.
            NO_INET_NTOP=
            AC_CHECK_FUNC([inet_ntop],
            [],
            [AC_CHECK_LIB([resolv], [inet_ntop],
                    [NEEDS_RESOLV=YesPlease],
                    [NO_INET_NTOP=YesPlease])
            ])
            GIT_CONF_SUBST([NO_INET_NTOP])
            #
            # Define NO_INET_PTON if linking with -lresolv is not enough.
            # Solaris 2.7 in particular hos inet_pton in -lresolv.
            NO_INET_PTON=
            AC_CHECK_FUNC([inet_pton],
            [],
            [AC_CHECK_LIB([resolv], [inet_pton],
                    [NEEDS_RESOLV=YesPlease],
                    [NO_INET_PTON=YesPlease])
            ])
            GIT_CONF_SUBST([NO_INET_PTON])
            #
            # Define NO_HSTRERROR if linking with -lresolv is not enough.
            # Solaris 2.6 in particular has no hstrerror, even in -lresolv.
            NO_HSTRERROR=
            AC_CHECK_FUNC([hstrerror],
            [],
            [AC_CHECK_LIB([resolv], [hstrerror],
                    [NEEDS_RESOLV=YesPlease],
                    [NO_HSTRERROR=YesPlease])
            ])
            GIT_CONF_SUBST([NO_HSTRERROR])

            dnl This must go after all the possible places for its initialization,
            dnl in the AC_CHECK_FUNC invocations above.
            GIT_CONF_SUBST([NEEDS_RESOLV])
            #
            # If any of the above tests determined that -lresolv is needed at
            # build-time, also set it here for remaining configure-time checks.
            test -n "$NEEDS_RESOLV" && LIBS="$LIBS -lresolv"

            AC_CHECK_LIB([c], [basename],
            [NEEDS_LIBGEN=],
            [NEEDS_LIBGEN=YesPlease])
            GIT_CONF_SUBST([NEEDS_LIBGEN])
            test -n "$NEEDS_LIBGEN" && LIBS="$LIBS -lgen"

            AC_DEFUN([LIBINTL_SRC], [
            AC_LANG_PROGRAM([[
            #include <libintl.h>
            ]],[[
            char *msg = gettext("test");
            ]])])

            AC_MSG_CHECKING([if libc contains libintl])
            AC_LINK_IFELSE([LIBINTL_SRC],
                    [AC_MSG_RESULT([yes])
                    LIBC_CONTAINS_LIBINTL=YesPlease],
                    [AC_MSG_RESULT([no])
                    LIBC_CONTAINS_LIBINTL=])
            GIT_CONF_SUBST([LIBC_CONTAINS_LIBINTL])

            #
            # Define NO_GETTEXT if you don't want Git output to be translated.
            # A translated Git requires GNU libintl or another gettext implementation
            AC_CHECK_HEADER([libintl.h],
            [NO_GETTEXT=],
            [NO_GETTEXT=YesPlease])
            GIT_CONF_SUBST([NO_GETTEXT])

            if test -z "$NO_GETTEXT"; then
            test -n "$LIBC_CONTAINS_LIBINTL" || LIBS="$LIBS -lintl"
            fi

            ## Checks for header files.
            AC_MSG_NOTICE([CHECKS for header files])
            #
            # Define NO_SYS_SELECT_H if you don't have sys/select.h.
            AC_CHECK_HEADER([sys/select.h],
            [NO_SYS_SELECT_H=],
            [NO_SYS_SELECT_H=UnfortunatelyYes])
            GIT_CONF_SUBST([NO_SYS_SELECT_H])
            #
            # Define NO_POLL_H if you don't have poll.h
            AC_CHECK_HEADER([poll.h],
            [NO_POLL_H=],
            [NO_POLL_H=UnfortunatelyYes])
            GIT_CONF_SUBST([NO_POLL_H])
            #
            # Define NO_SYS_POLL_H if you don't have sys/poll.h
            AC_CHECK_HEADER([sys/poll.h],
            [NO_SYS_POLL_H=],
            [NO_SYS_POLL_H=UnfortunatelyYes])
            GIT_CONF_SUBST([NO_SYS_POLL_H])
            #
            # Define NO_INTTYPES_H if you don't have inttypes.h
            AC_CHECK_HEADER([inttypes.h],
            [NO_INTTYPES_H=],
            [NO_INTTYPES_H=UnfortunatelyYes])
            GIT_CONF_SUBST([NO_INTTYPES_H])
            #
            # Define OLD_ICONV if your library has an old iconv(), where the second
            # (input buffer pointer) parameter is declared with type (const char **).
            AC_DEFUN([OLDICONVTEST_SRC], [
            AC_LANG_PROGRAM([[
            #include <iconv.h>

            extern size_t iconv(iconv_t cd,
                            char **inbuf, size_t *inbytesleft,
                            char **outbuf, size_t *outbytesleft);
            ]], [])])

            GIT_STASH_FLAGS($ICONVDIR)

            AC_MSG_CHECKING([for old iconv()])
            AC_COMPILE_IFELSE([OLDICONVTEST_SRC],
                    [AC_MSG_RESULT([no])],
                    [AC_MSG_RESULT([yes])
                    AC_DEFINE(HAVE_OLD_ICONV, 1)
                    OLD_ICONV=UnfortunatelyYes])

            GIT_UNSTASH_FLAGS($ICONVDIR)

            GIT_CONF_SUBST([OLD_ICONV])

            #
            # Define ICONV_OMITS_BOM if you are on a system which
            # iconv omits bom for utf-{16,32}
            if test -z "$NO_ICONV"; then
            AC_CACHE_CHECK([whether iconv omits bom for utf-16 and utf-32],
            [ac_cv_iconv_omits_bom],
            [
            old_LIBS="$LIBS"
            if test -n "$NEEDS_LIBICONV"; then
                    LIBS="$LIBS -liconv"
            fi

            AC_RUN_IFELSE(
                    [AC_LANG_PROGRAM([AC_INCLUDES_DEFAULT
                    #include <iconv.h>
                    #ifdef HAVE_OLD_ICONV
                    typedef const char *iconv_ibp;
                    #else
                    typedef char *iconv_ibp;
                    #endif
                    ],
                    [[
                    int v;
                    iconv_t conv;
                    char in[] = "a"; iconv_ibp pin = in;
                    char out[20] = ""; char *pout = out;
                    size_t isz = sizeof in;
                    size_t osz = sizeof out;

                    conv = iconv_open("UTF-16", "UTF-8");
                    iconv(conv, &pin, &isz, &pout, &osz);
                    iconv_close(conv);
                    v = (unsigned char)(out[0]) + (unsigned char)(out[1]);
                    return v != 0xfe + 0xff;
                    ]])],
                    [ac_cv_iconv_omits_bom=no],
                    [ac_cv_iconv_omits_bom=yes])

            LIBS="$old_LIBS"
            ])
            if test "x$ac_cv_iconv_omits_bom" = xyes; then
                    ICONV_OMITS_BOM=Yes
            else
                    ICONV_OMITS_BOM=
            fi
            GIT_CONF_SUBST([ICONV_OMITS_BOM])
            fi

            ## Checks for typedefs, structures, and compiler characteristics.
            AC_MSG_NOTICE([CHECKS for typedefs, structures, and compiler characteristics])
            #
            TYPE_SOCKLEN_T
            case $ac_cv_type_socklen_t in
            yes)  SOCKLEN_T='';;
            *)    SOCKLEN_T=$git_cv_socklen_t_equiv;;
            esac
            GIT_CONF_SUBST([SOCKLEN_T])

            #
            # Define NO_STRUCT_ITIMERVAL if you don't have struct itimerval.
            AC_CHECK_TYPES([struct itimerval],
            [NO_STRUCT_ITIMERVAL=],
            [NO_STRUCT_ITIMERVAL=UnfortunatelyYes],
            [#include <sys/time.h>])
            GIT_CONF_SUBST([NO_STRUCT_ITIMERVAL])
            #
            # Define USE_ST_TIMESPEC=YesPlease when stat.st_mtimespec.tv_nsec exists.
            # Define NO_NSEC=YesPlease when neither stat.st_mtim.tv_nsec nor
            # stat.st_mtimespec.tv_nsec exists.
            AC_CHECK_MEMBER([struct stat.st_mtimespec.tv_nsec])
            AC_CHECK_MEMBER([struct stat.st_mtim.tv_nsec])
            if test x$ac_cv_member_struct_stat_st_mtimespec_tv_nsec = xyes; then
                    USE_ST_TIMESPEC=YesPlease
                    GIT_CONF_SUBST([USE_ST_TIMESPEC])
            elif test x$ac_cv_member_struct_stat_st_mtim_tv_nsec != xyes; then
                    NO_NSEC=YesPlease
                    GIT_CONF_SUBST([NO_NSEC])
            fi
            #
            # Define NO_D_TYPE_IN_DIRENT if your platform defines DT_UNKNOWN but lacks
            # d_type in struct dirent (latest Cygwin -- will be fixed soonish).
            AC_CHECK_MEMBER(struct dirent.d_type,
            [NO_D_TYPE_IN_DIRENT=],
            [NO_D_TYPE_IN_DIRENT=YesPlease],
            [#include <dirent.h>])
            GIT_CONF_SUBST([NO_D_TYPE_IN_DIRENT])
            #
            # Define NO_GECOS_IN_PWENT if you don't have pw_gecos in struct passwd
            # in the C library.
            AC_CHECK_MEMBER(struct passwd.pw_gecos,
            [NO_GECOS_IN_PWENT=],
            [NO_GECOS_IN_PWENT=YesPlease],
            [#include <pwd.h>])
            GIT_CONF_SUBST([NO_GECOS_IN_PWENT])
            #
            # Define NO_SOCKADDR_STORAGE if your platform does not have struct
            # sockaddr_storage.
            AC_CHECK_TYPE(struct sockaddr_storage,
            [NO_SOCKADDR_STORAGE=],
            [NO_SOCKADDR_STORAGE=YesPlease],[
            #include <sys/types.h>
            #include <sys/socket.h>
            ])
            GIT_CONF_SUBST([NO_SOCKADDR_STORAGE])
            #
            # Define NO_IPV6 if you lack IPv6 support and getaddrinfo().
            AC_CHECK_TYPE([struct addrinfo],[
            GIT_CHECK_FUNC([getaddrinfo],
            [NO_IPV6=],
            [NO_IPV6=YesPlease])
            ],[NO_IPV6=YesPlease],[
            #include <sys/types.h>
            #include <sys/socket.h>
            #include <netdb.h>
            ])
            GIT_CONF_SUBST([NO_IPV6])
            #
            # Define NO_REGEX if your C library lacks regex support with REG_STARTEND
            # feature.
            AC_CACHE_CHECK([whether the platform regex supports REG_STARTEND],
            [ac_cv_c_regex_with_reg_startend], [
            AC_EGREP_CPP(yippeeyeswehaveit,
                    AC_LANG_PROGRAM([AC_INCLUDES_DEFAULT
            #include <regex.h>
            ],
            [#ifdef REG_STARTEND
            yippeeyeswehaveit
            #endif
            ]),
                    [ac_cv_c_regex_with_reg_startend=yes],
                    [ac_cv_c_regex_with_reg_startend=no])
            ])
            if test $ac_cv_c_regex_with_reg_startend = yes; then
                    NO_REGEX=
            else
                    NO_REGEX=YesPlease
            fi
            GIT_CONF_SUBST([NO_REGEX])
            #
            # Define FREAD_READS_DIRECTORIES if your are on a system which succeeds
            # when attempting to read from an fopen'ed directory.
            AC_CACHE_CHECK([whether system succeeds to read fopen'ed directory],
            [ac_cv_fread_reads_directories],
            [
            AC_RUN_IFELSE(
                    [AC_LANG_PROGRAM([AC_INCLUDES_DEFAULT],
                            [[
                            FILE *f = fopen(".", "r");
                            return f != NULL;]])],
                    [ac_cv_fread_reads_directories=no],
                    [ac_cv_fread_reads_directories=yes])
            ])
            if test $ac_cv_fread_reads_directories = yes; then
                    FREAD_READS_DIRECTORIES=UnfortunatelyYes
            else
                    FREAD_READS_DIRECTORIES=
            fi
            GIT_CONF_SUBST([FREAD_READS_DIRECTORIES])
            #
            # Define SNPRINTF_RETURNS_BOGUS if your are on a system which snprintf()
            # or vsnprintf() return -1 instead of number of characters which would
            # have been written to the final string if enough space had been available.
            AC_CACHE_CHECK([whether snprintf() and/or vsnprintf() return bogus value],
            [ac_cv_snprintf_returns_bogus],
            [
            AC_RUN_IFELSE(
                    [AC_LANG_PROGRAM([AC_INCLUDES_DEFAULT
                            #include "stdarg.h"

                            int test_vsnprintf(char *str, size_t maxsize, const char *format, ...)
                            {
                            int ret;
                            va_list ap;
                            va_start(ap, format);
                            ret = vsnprintf(str, maxsize, format, ap);
                            va_end(ap);
                            return ret;
                            }],
                            [[char buf[6];
                            if (test_vsnprintf(buf, 3, "%s", "12345") != 5
                            || strcmp(buf, "12")) return 1;
                            if (snprintf(buf, 3, "%s", "12345") != 5
                            || strcmp(buf, "12")) return 1]])],
                    [ac_cv_snprintf_returns_bogus=no],
                    [ac_cv_snprintf_returns_bogus=yes])
            ])
            if test $ac_cv_snprintf_returns_bogus = yes; then
                    SNPRINTF_RETURNS_BOGUS=UnfortunatelyYes
            else
                    SNPRINTF_RETURNS_BOGUS=
            fi
            GIT_CONF_SUBST([SNPRINTF_RETURNS_BOGUS])
            #
            # Define NEEDS_MODE_TRANSLATION if your OS strays from the typical file type
            # bits in mode values.
            AC_CACHE_CHECK([whether the platform uses typical file type bits],
            [ac_cv_sane_mode_bits], [
            AC_EGREP_CPP(yippeeyeswehaveit,
                    AC_LANG_PROGRAM([AC_INCLUDES_DEFAULT],
            [#if S_IFMT == 0170000 && \
                    S_IFREG == 0100000 && S_IFDIR == 0040000 && S_IFLNK == 0120000 && \
                    S_IFBLK == 0060000 && S_IFCHR == 0020000 && \
                    S_IFIFO == 0010000 && S_IFSOCK == 0140000
            yippeeyeswehaveit
            #endif
            ]),
                    [ac_cv_sane_mode_bits=yes],
                    [ac_cv_sane_mode_bits=no])
            ])
            if test $ac_cv_sane_mode_bits = yes; then
                    NEEDS_MODE_TRANSLATION=
            else
                    NEEDS_MODE_TRANSLATION=UnfortunatelyYes
            fi
            GIT_CONF_SUBST([NEEDS_MODE_TRANSLATION])


            ## Checks for library functions.
            ## (in default C library and libraries checked by AC_CHECK_LIB)
            AC_MSG_NOTICE([CHECKS for library functions])
            #
            # Define NO_LIBGEN_H if you don't have libgen.h.
            AC_CHECK_HEADER([libgen.h],
            [NO_LIBGEN_H=],
            [NO_LIBGEN_H=YesPlease])
            GIT_CONF_SUBST([NO_LIBGEN_H])
            #
            # Define HAVE_PATHS_H if you have paths.h.
            AC_CHECK_HEADER([paths.h],
            [HAVE_PATHS_H=YesPlease],
            [HAVE_PATHS_H=])
            GIT_CONF_SUBST([HAVE_PATHS_H])
            #
            # Define HAVE_LIBCHARSET_H if have libcharset.h
            AC_CHECK_HEADER([libcharset.h],
            [HAVE_LIBCHARSET_H=YesPlease],
            [HAVE_LIBCHARSET_H=])
            GIT_CONF_SUBST([HAVE_LIBCHARSET_H])
            #
            # Define HAVE_STRINGS_H if you have strings.h
            AC_CHECK_HEADER([strings.h],
            [HAVE_STRINGS_H=YesPlease],
            [HAVE_STRINGS_H=])
            GIT_CONF_SUBST([HAVE_STRINGS_H])
            # Define CHARSET_LIB if libiconv does not export the locale_charset symbol
            # and libcharset does
            CHARSET_LIB=
            AC_CHECK_LIB([iconv], [locale_charset],
            [CHARSET_LIB=-liconv],
            [AC_CHECK_LIB([charset], [locale_charset],
                            [CHARSET_LIB=-lcharset])])
            GIT_CONF_SUBST([CHARSET_LIB])
            #
            # Define HAVE_CLOCK_GETTIME=YesPlease if clock_gettime is available.
            GIT_CHECK_FUNC(clock_gettime,
                    [HAVE_CLOCK_GETTIME=YesPlease],
                    [HAVE_CLOCK_GETTIME=])
            GIT_CONF_SUBST([HAVE_CLOCK_GETTIME])

            AC_DEFUN([CLOCK_MONOTONIC_SRC], [
            AC_LANG_PROGRAM([[
            #include <time.h>
            clockid_t id = CLOCK_MONOTONIC;
            ]])])

            #
            # Define HAVE_CLOCK_MONOTONIC=YesPlease if CLOCK_MONOTONIC is available.
            AC_MSG_CHECKING([for CLOCK_MONOTONIC])
            AC_COMPILE_IFELSE([CLOCK_MONOTONIC_SRC],
                    [AC_MSG_RESULT([yes])
                    HAVE_CLOCK_MONOTONIC=YesPlease],
                    [AC_MSG_RESULT([no])
                    HAVE_CLOCK_MONOTONIC=])
            GIT_CONF_SUBST([HAVE_CLOCK_MONOTONIC])

            #
            # Define HAVE_SYNC_FILE_RANGE=YesPlease if sync_file_range is available.
            GIT_CHECK_FUNC(sync_file_range,
                    [HAVE_SYNC_FILE_RANGE=YesPlease],
                    [HAVE_SYNC_FILE_RANGE=])
            GIT_CONF_SUBST([HAVE_SYNC_FILE_RANGE])

            #
            # Define NO_SETITIMER if you don't have setitimer.
            GIT_CHECK_FUNC(setitimer,
            [NO_SETITIMER=],
            [NO_SETITIMER=YesPlease])
            GIT_CONF_SUBST([NO_SETITIMER])
            #
            # Define NO_STRCASESTR if you don't have strcasestr.
            GIT_CHECK_FUNC(strcasestr,
            [NO_STRCASESTR=],
            [NO_STRCASESTR=YesPlease])
            GIT_CONF_SUBST([NO_STRCASESTR])
            #
            # Define NO_MEMMEM if you don't have memmem.
            GIT_CHECK_FUNC(memmem,
            [NO_MEMMEM=],
            [NO_MEMMEM=YesPlease])
            GIT_CONF_SUBST([NO_MEMMEM])
            #
            # Define NO_STRLCPY if you don't have strlcpy.
            GIT_CHECK_FUNC(strlcpy,
            [NO_STRLCPY=],
            [NO_STRLCPY=YesPlease])
            GIT_CONF_SUBST([NO_STRLCPY])
            #
            # Define NO_UINTMAX_T if your platform does not have uintmax_t
            AC_CHECK_TYPE(uintmax_t,
            [NO_UINTMAX_T=],
            [NO_UINTMAX_T=YesPlease],[
            #include <inttypes.h>
            ])
            GIT_CONF_SUBST([NO_UINTMAX_T])
            #
            # Define NO_STRTOUMAX if you don't have strtoumax in the C library.
            GIT_CHECK_FUNC(strtoumax,
            [NO_STRTOUMAX=],
            [NO_STRTOUMAX=YesPlease])
            GIT_CONF_SUBST([NO_STRTOUMAX])
            #
            # Define NO_SETENV if you don't have setenv in the C library.
            GIT_CHECK_FUNC(setenv,
            [NO_SETENV=],
            [NO_SETENV=YesPlease])
            GIT_CONF_SUBST([NO_SETENV])
            #
            # Define NO_UNSETENV if you don't have unsetenv in the C library.
            GIT_CHECK_FUNC(unsetenv,
            [NO_UNSETENV=],
            [NO_UNSETENV=YesPlease])
            GIT_CONF_SUBST([NO_UNSETENV])
            #
            # Define NO_MKDTEMP if you don't have mkdtemp in the C library.
            GIT_CHECK_FUNC(mkdtemp,
            [NO_MKDTEMP=],
            [NO_MKDTEMP=YesPlease])
            GIT_CONF_SUBST([NO_MKDTEMP])
            #
            # Define NO_INITGROUPS if you don't have initgroups in the C library.
            GIT_CHECK_FUNC(initgroups,
            [NO_INITGROUPS=],
            [NO_INITGROUPS=YesPlease])
            GIT_CONF_SUBST([NO_INITGROUPS])
            #
            # Define HAVE_GETDELIM if you have getdelim in the C library.
            GIT_CHECK_FUNC(getdelim,
            [HAVE_GETDELIM=YesPlease],
            [HAVE_GETDELIM=])
            GIT_CONF_SUBST([HAVE_GETDELIM])
            #
            #
            # Define NO_MMAP if you want to avoid mmap.
            #
            # Define NO_ICONV if your libc does not properly support iconv.

            AC_DEFUN([BSD_SYSCTL_SRC], [
            AC_LANG_PROGRAM([[
            #include <stddef.h>
            #include <sys/types.h>
            #include <sys/sysctl.h>
            ]],[[
            int val, mib[2];
            size_t len;
            mib[0] = CTL_HW;
            mib[1] = 1;
            len = sizeof(val);
            return sysctl(mib, 2, &val, &len, NULL, 0) ? 1 : 0;
            ]])])

            #
            # Define HAVE_BSD_SYSCTL=YesPlease if a BSD-compatible sysctl function is available.
            AC_MSG_CHECKING([for BSD sysctl])
            AC_COMPILE_IFELSE([BSD_SYSCTL_SRC],
                    [AC_MSG_RESULT([yes])
                    HAVE_BSD_SYSCTL=YesPlease],
                    [AC_MSG_RESULT([no])
                    HAVE_BSD_SYSCTL=])
            GIT_CONF_SUBST([HAVE_BSD_SYSCTL])

            ## Other checks.
            # Define NO_SYMLINK_HEAD if you never want .git/HEAD to be a symbolic link.
            # Enable it on Windows.  By default, symrefs are still used.
            #
            # Define NO_PTHREADS if we do not have pthreads.
            #
            # Define PTHREAD_LIBS to the linker flag used for Pthread support.
            AC_DEFUN([PTHREADTEST_SRC], [
            AC_LANG_PROGRAM([[
            #include <pthread.h>
            static void *noop(void *ignore) { return ignore; }
            ]], [[
                    pthread_mutex_t test_mutex;
                    pthread_key_t test_key;
                    pthread_t th;
                    int retcode = 0;
                    void *ret = (void *)0;
                    retcode |= pthread_key_create(&test_key, (void *)0);
                    retcode |= pthread_mutex_init(&test_mutex,(void *)0);
                    retcode |= pthread_mutex_lock(&test_mutex);
                    retcode |= pthread_mutex_unlock(&test_mutex);
                    retcode |= pthread_create(&th, ret, noop, ret);
                    retcode |= pthread_join(th, &ret);
                    return retcode;
            ]])])

            dnl AC_LANG_CONFTEST([AC_LANG_PROGRAM(
            dnl   [[#include <pthread.h>]],
            dnl   [[pthread_mutex_t test_mutex;]]
            dnl )])

            NO_PTHREADS=UnfortunatelyYes
            PTHREAD_LIBS=

            if test -n "$USER_NOPTHREAD"; then
            AC_MSG_NOTICE([Skipping POSIX Threads at user request.])
            # handle these separately since PTHREAD_CFLAGS could be '-lpthreads
            # -D_REENTRANT' or some such.
            elif test -z "$PTHREAD_CFLAGS"; then
            threads_found=no
            # Attempt to compile and link some code using pthreads to determine
            # required linker flags. The order is somewhat important here: We
            # first try it without any extra flags, to catch systems where
            # pthreads are part of the C library, then go on testing various other
            # flags. We do so to avoid false positives. For example, on Mac OS X
            # pthreads are part of the C library; moreover, the compiler allows us
            # to add "-mt" to the CFLAGS (although it will do nothing except
            # trigger a warning about an unused flag). Hence if we checked for
            # "-mt" before "" we would end up picking it. But unfortunately this
            # would then trigger compiler warnings on every single file we compile.
            for opt in "" -mt -pthread -lpthread; do
            old_CFLAGS="$CFLAGS"
            old_LIBS="$LIBS"
            case "$opt" in
                    -l*)  LIBS="$opt $LIBS" ;;
                    *)    CFLAGS="$opt $CFLAGS" ;;
            esac

            AC_MSG_CHECKING([for POSIX Threads with '$opt'])
            AC_LINK_IFELSE([PTHREADTEST_SRC],
                    [AC_MSG_RESULT([yes])
                            NO_PTHREADS=
                            PTHREAD_LIBS="$opt"
                            PTHREAD_CFLAGS="$opt"
                            threads_found=yes
                            break
                    ],
                    [AC_MSG_RESULT([no])])
            CFLAGS="$old_CFLAGS"
            LIBS="$old_LIBS"
            done
            if test $threads_found != yes; then
            AC_CHECK_LIB([pthread], [pthread_create],
                    [PTHREAD_LIBS="-lpthread"],
                    [NO_PTHREADS=UnfortunatelyYes])
            fi
            else
            old_CFLAGS="$CFLAGS"
            CFLAGS="$PTHREAD_CFLAGS $CFLAGS"
            AC_MSG_CHECKING([for POSIX Threads with '$PTHREAD_CFLAGS'])
            AC_LINK_IFELSE([PTHREADTEST_SRC],
                    [AC_MSG_RESULT([yes])
                            NO_PTHREADS=
                            PTHREAD_LIBS="$PTHREAD_CFLAGS"
                    ],
                    [AC_MSG_RESULT([no])])

            CFLAGS="$old_CFLAGS"
            fi

            CFLAGS="$old_CFLAGS"

            GIT_CONF_SUBST([PTHREAD_CFLAGS])
            GIT_CONF_SUBST([PTHREAD_LIBS])
            GIT_CONF_SUBST([NO_PTHREADS])

            ## Output files
            AC_CONFIG_FILES(["${config_file}":"${config_in}"])
            AC_OUTPUT

    """,
    "patche":
    """
                    diff --git a/configure.ac b/configure.ac
            index 38ff866..c9cf5ac 100644
            --- a/configure.ac
            +++ b/configure.ac
            @@ -463,6 +463,9 @@ else
                    CC_LD_DYNPATH=-Wl,+b,
                    else
                    CC_LD_DYNPATH=
            +             if test "$(uname -s)" = "OS/390"; then
            +                CC_LD_DYNPATH=-L
            +             fi
                    AC_MSG_WARN([linker does not support runtime path to dynamic libraries])
                    fi
            fi

    """,

      },

    {
      "wrongcode":
      """

            #define USE_THE_REPOSITORY_VARIABLE
            #define DISABLE_SIGN_COMPARE_WARNINGS

            #include "git-compat-util.h"
            #include "advice.h"
            #include "config.h"
            #include "convert.h"
            #include "copy.h"
            #include "gettext.h"
            #include "hex.h"
            #include "object-store-ll.h"
            #include "attr.h"
            #include "run-command.h"
            #include "quote.h"
            #include "read-cache-ll.h"
            #include "sigchain.h"
            #include "pkt-line.h"
            #include "sub-process.h"
            #include "trace.h"
            #include "utf8.h"
            #include "merge-ll.h"

            /*
            * convert.c - convert a file when checking it out and checking it in.
            *
            * This should use the pathname to decide on whether it wants to do some
            * more interesting conversions (automatic gzip/unzip, general format
            * conversions etc etc), but by default it just does automatic CRLF<->LF
            * translation when the "text" attribute or "auto_crlf" option is set.
            */

            /* Stat bits: When BIN is set, the txt bits are unset */
            #define CONVERT_STAT_BITS_TXT_LF    0x1
            #define CONVERT_STAT_BITS_TXT_CRLF  0x2
            #define CONVERT_STAT_BITS_BIN       0x4

            struct text_stat {
                    /* NUL, CR, LF and CRLF counts */
                    unsigned nul, lonecr, lonelf, crlf;

                    /* These are just approximations! */
                    unsigned printable, nonprintable;
            };

            static void gather_stats(const char *buf, unsigned long size, struct text_stat *stats)
            {
                    unsigned long i;

                    memset(stats, 0, sizeof(*stats));

                    for (i = 0; i < size; i++) {
                            unsigned char c = buf[i];
                            if (c == '\r') {
                                    if (i+1 < size && buf[i+1] == '\n') {
                                            stats->crlf++;
                                            i++;
                                    } else
                                            stats->lonecr++;
                                    continue;
                            }
                            if (c == '\n') {
                                    stats->lonelf++;
                                    continue;
                            }
                            if (c == 127)
                                    /* DEL */
                                    stats->nonprintable++;
                            else if (c < 32) {
                                    switch (c) {
                                            /* BS, HT, ESC and FF */
                                    case '\b': case '\t': case '\033': case '\014':
                                            stats->printable++;
                                            break;
                                    case 0:
                                            stats->nul++;
                                            /* fall through */
                                    default:
                                            stats->nonprintable++;
                                    }
                            }
                            else
                                    stats->printable++;
                    }

                    /* If file ends with EOF then don't count this EOF as non-printable. */
                    if (size >= 1 && buf[size-1] == '\032')
                            stats->nonprintable--;
            }

            /*
            * The same heuristics as diff.c::mmfile_is_binary()
            * We treat files with bare CR as binary
            */
            static int convert_is_binary(const struct text_stat *stats)
            {
                    if (stats->lonecr)
                            return 1;
                    if (stats->nul)
                            return 1;
                    if ((stats->printable >> 7) < stats->nonprintable)
                            return 1;
                    return 0;
            }

            static unsigned int gather_convert_stats(const char *data, unsigned long size)
            {
                    struct text_stat stats;
                    int ret = 0;
                    if (!data || !size)
                            return 0;
                    gather_stats(data, size, &stats);
                    if (convert_is_binary(&stats))
                            ret |= CONVERT_STAT_BITS_BIN;
                    if (stats.crlf)
                            ret |= CONVERT_STAT_BITS_TXT_CRLF;
                    if (stats.lonelf)
                            ret |=  CONVERT_STAT_BITS_TXT_LF;

                    return ret;
            }

            static const char *gather_convert_stats_ascii(const char *data, unsigned long size)
            {
                    unsigned int convert_stats = gather_convert_stats(data, size);

                    if (convert_stats & CONVERT_STAT_BITS_BIN)
                            return "-text";
                    switch (convert_stats) {
                    case CONVERT_STAT_BITS_TXT_LF:
                            return "lf";
                    case CONVERT_STAT_BITS_TXT_CRLF:
                            return "crlf";
                    case CONVERT_STAT_BITS_TXT_LF | CONVERT_STAT_BITS_TXT_CRLF:
                            return "mixed";
                    default:
                            return "none";
                    }
            }

            const char *get_cached_convert_stats_ascii(struct index_state *istate,
                                                    const char *path)
            {
                    const char *ret;
                    unsigned long sz;
                    void *data = read_blob_data_from_index(istate, path, &sz);
                    ret = gather_convert_stats_ascii(data, sz);
                    free(data);
                    return ret;
            }

            const char *get_wt_convert_stats_ascii(const char *path)
            {
                    const char *ret = "";
                    struct strbuf sb = STRBUF_INIT;
                    if (strbuf_read_file(&sb, path, 0) >= 0)
                            ret = gather_convert_stats_ascii(sb.buf, sb.len);
                    strbuf_release(&sb);
                    return ret;
            }

            static int text_eol_is_crlf(void)
            {
                    if (auto_crlf == AUTO_CRLF_TRUE)
                            return 1;
                    else if (auto_crlf == AUTO_CRLF_INPUT)
                            return 0;
                    if (core_eol == EOL_CRLF)
                            return 1;
                    if (core_eol == EOL_UNSET && EOL_NATIVE == EOL_CRLF)
                            return 1;
                    return 0;
            }

            static enum eol output_eol(enum convert_crlf_action crlf_action)
            {
                    switch (crlf_action) {
                    case CRLF_BINARY:
                            return EOL_UNSET;
                    case CRLF_TEXT_CRLF:
                            return EOL_CRLF;
                    case CRLF_TEXT_INPUT:
                            return EOL_LF;
                    case CRLF_UNDEFINED:
                    case CRLF_AUTO_CRLF:
                            return EOL_CRLF;
                    case CRLF_AUTO_INPUT:
                            return EOL_LF;
                    case CRLF_TEXT:
                    case CRLF_AUTO:
                            /* fall through */
                            return text_eol_is_crlf() ? EOL_CRLF : EOL_LF;
                    }
                    warning(_("illegal crlf_action %d"), (int)crlf_action);
                    return core_eol;
            }

            static void check_global_conv_flags_eol(const char *path,
                                    struct text_stat *old_stats, struct text_stat *new_stats,
                                    int conv_flags)
            {
                    if (old_stats->crlf && !new_stats->crlf ) {
                            /*
                            * CRLFs would not be restored by checkout
                            */
                            if (conv_flags & CONV_EOL_RNDTRP_DIE)
                                    die(_("CRLF would be replaced by LF in %s"), path);
                            else if (conv_flags & CONV_EOL_RNDTRP_WARN)
                                    warning(_("in the working copy of '%s', CRLF will be"
                                            " replaced by LF the next time Git touches"
                                            " it"), path);
                    } else if (old_stats->lonelf && !new_stats->lonelf ) {
                            /*
                            * CRLFs would be added by checkout
                            */
                            if (conv_flags & CONV_EOL_RNDTRP_DIE)
                                    die(_("LF would be replaced by CRLF in %s"), path);
                            else if (conv_flags & CONV_EOL_RNDTRP_WARN)
                                    warning(_("in the working copy of '%s', LF will be"
                                            " replaced by CRLF the next time Git touches"
                                            " it"), path);
                    }
            }

            static int has_crlf_in_index(struct index_state *istate, const char *path)
            {
                    unsigned long sz;
                    void *data;
                    const char *crp;
                    int has_crlf = 0;

                    data = read_blob_data_from_index(istate, path, &sz);
                    if (!data)
                            return 0;

                    crp = memchr(data, '\r', sz);
                    if (crp) {
                            unsigned int ret_stats;
                            ret_stats = gather_convert_stats(data, sz);
                            if (!(ret_stats & CONVERT_STAT_BITS_BIN) &&
                            (ret_stats & CONVERT_STAT_BITS_TXT_CRLF))
                                    has_crlf = 1;
                    }
                    free(data);
                    return has_crlf;
            }

            static int will_convert_lf_to_crlf(struct text_stat *stats,
                                            enum convert_crlf_action crlf_action)
            {
                    if (output_eol(crlf_action) != EOL_CRLF)
                            return 0;
                    /* No "naked" LF? Nothing to convert, regardless. */
                    if (!stats->lonelf)
                            return 0;

                    if (crlf_action == CRLF_AUTO || crlf_action == CRLF_AUTO_INPUT || crlf_action == CRLF_AUTO_CRLF) {
                            /* If we have any CR or CRLF line endings, we do not touch it */
                            /* This is the new safer autocrlf-handling */
                            if (stats->lonecr || stats->crlf)
                                    return 0;

                            if (convert_is_binary(stats))
                                    return 0;
                    }
                    return 1;

            }

            static int validate_encoding(const char *path, const char *enc,
                            const char *data, size_t len, int die_on_error)
            {
                    const char *stripped;

                    /* We only check for UTF here as UTF?? can be an alias for UTF-?? */
                    if (skip_iprefix(enc, "UTF", &stripped)) {
                            skip_prefix(stripped, "-", &stripped);

                            /*
                            * Check for detectable errors in UTF encodings
                            */
                            if (has_prohibited_utf_bom(enc, data, len)) {
                                    const char *error_msg = _(
                                            "BOM is prohibited in '%s' if encoded as %s");
                                    /*
                                    * This advice is shown for UTF-??BE and UTF-??LE encodings.
                                    * We cut off the last two characters of the encoding name
                                    * to generate the encoding name suitable for BOMs.
                                    */
                                    const char *advise_msg = _(
                                            "The file '%s' contains a byte order "
                                            "mark (BOM). Please use UTF-%.*s as "
                                            "working-tree-encoding.");
                                    int stripped_len = strlen(stripped) - strlen("BE");
                                    advise(advise_msg, path, stripped_len, stripped);
                                    if (die_on_error)
                                            die(error_msg, path, enc);
                                    else {
                                            return error(error_msg, path, enc);
                                    }

                            } else if (is_missing_required_utf_bom(enc, data, len)) {
                                    const char *error_msg = _(
                                            "BOM is required in '%s' if encoded as %s");
                                    const char *advise_msg = _(
                                            "The file '%s' is missing a byte order "
                                            "mark (BOM). Please use UTF-%sBE or UTF-%sLE "
                                            "(depending on the byte order) as "
                                            "working-tree-encoding.");
                                    advise(advise_msg, path, stripped, stripped);
                                    if (die_on_error)
                                            die(error_msg, path, enc);
                                    else {
                                            return error(error_msg, path, enc);
                                    }
                            }

                    }
                    return 0;
            }

            static void trace_encoding(const char *context, const char *path,
                                    const char *encoding, const char *buf, size_t len)
            {
                    static struct trace_key coe = TRACE_KEY_INIT(WORKING_TREE_ENCODING);
                    struct strbuf trace = STRBUF_INIT;
                    int i;

                    if (!trace_want(&coe))
                            return;

                    strbuf_addf(&trace, "%s (%s, considered %s):\n", context, path, encoding);
                    for (i = 0; i < len && buf; ++i) {
                            strbuf_addf(
                                    &trace, "| \033[2m%2i:\033[0m %2x \033[2m%c\033[0m%c",
                                    i,
                                    (unsigned char) buf[i],
                                    (buf[i] > 32 && buf[i] < 127 ? buf[i] : ' '),
                                    ((i+1) % 8 && (i+1) < len ? ' ' : '\n')
                            );
                    }
                    strbuf_addchars(&trace, '\n', 1);

                    trace_strbuf(&coe, &trace);
                    strbuf_release(&trace);
            }

            static int check_roundtrip(const char *enc_name)
            {
                    /*
                    * check_roundtrip_encoding contains a string of comma and/or
                    * space separated encodings (eg. "UTF-16, ASCII, CP1125").
                    * Search for the given encoding in that string.
                    */
                    const char *encoding = check_roundtrip_encoding ?
                            check_roundtrip_encoding : "SHIFT-JIS";
                    const char *found = strcasestr(encoding, enc_name);
                    const char *next;
                    int len;
                    if (!found)
                            return 0;
                    next = found + strlen(enc_name);
                    len = strlen(encoding);
                    return (found && (
                                    /*
                                    * Check that the found encoding is at the beginning of
                                    * encoding or that it is prefixed with a space or
                                    * comma.
                                    */
                                    found == encoding || (
                                            (isspace(found[-1]) || found[-1] == ',')
                                    )
                            ) && (
                                    /*
                                    * Check that the found encoding is at the end of
                                    * encoding or that it is suffixed with a space
                                    * or comma.
                                    */
                                    next == encoding + len || (
                                            next < encoding + len &&
                                            (isspace(next[0]) || next[0] == ',')
                                    )
                            ));
            }

            static const char *default_encoding = "UTF-8";

            static int encode_to_git(const char *path, const char *src, size_t src_len,
                                    struct strbuf *buf, const char *enc, int conv_flags)
            {
                    char *dst;
                    size_t dst_len;
                    int die_on_error = conv_flags & CONV_WRITE_OBJECT;

                    /*
                    * No encoding is specified or there is nothing to encode.
                    * Tell the caller that the content was not modified.
                    */
                    if (!enc || (src && !src_len))
                            return 0;

                    /*
                    * Looks like we got called from "would_convert_to_git()".
                    * This means Git wants to know if it would encode (= modify!)
                    * the content. Let's answer with "yes", since an encoding was
                    * specified.
                    */
                    if (!buf && !src)
                            return 1;

                    if (validate_encoding(path, enc, src, src_len, die_on_error))
                            return 0;

                    trace_encoding("source", path, enc, src, src_len);
                    dst = reencode_string_len(src, src_len, default_encoding, enc,
                                            &dst_len);
                    if (!dst) {
                            /*
                            * We could add the blob "as-is" to Git. However, on checkout
                            * we would try to re-encode to the original encoding. This
                            * would fail and we would leave the user with a messed-up
                            * working tree. Let's try to avoid this by screaming loud.
                            */
                            const char* msg = _("failed to encode '%s' from %s to %s");
                            if (die_on_error)
                                    die(msg, path, enc, default_encoding);
                            else {
                                    error(msg, path, enc, default_encoding);
                                    return 0;
                            }
                    }
                    trace_encoding("destination", path, default_encoding, dst, dst_len);

                    /*
                    * UTF supports lossless conversion round tripping [1] and conversions
                    * between UTF and other encodings are mostly round trip safe as
                    * Unicode aims to be a superset of all other character encodings.
                    * However, certain encodings (e.g. SHIFT-JIS) are known to have round
                    * trip issues [2]. Check the round trip conversion for all encodings
                    * listed in core.checkRoundtripEncoding.
                    *
                    * The round trip check is only performed if content is written to Git.
                    * This ensures that no information is lost during conversion to/from
                    * the internal UTF-8 representation.
                    *
                    * Please note, the code below is not tested because I was not able to
                    * generate a faulty round trip without an iconv error. Iconv errors
                    * are already caught above.
                    *
                    * [1] http://unicode.org/faq/utf_bom.html#gen2
                    * [2] https://support.microsoft.com/en-us/help/170559/prb-conversion-problem-between-shift-jis-and-unicode
                    */
                    if (die_on_error && check_roundtrip(enc)) {
                            char *re_src;
                            size_t re_src_len;

                            re_src = reencode_string_len(dst, dst_len,
                                                    enc, default_encoding,
                                                    &re_src_len);

                            trace_printf("Checking roundtrip encoding for %s...\n", enc);
                            trace_encoding("reencoded source", path, enc,
                                    re_src, re_src_len);

                            if (!re_src || src_len != re_src_len ||
                            memcmp(src, re_src, src_len)) {
                                    const char* msg = _("encoding '%s' from %s to %s and "
                                                    "back is not the same");
                                    die(msg, path, enc, default_encoding);
                            }

                            free(re_src);
                    }

                    strbuf_attach(buf, dst, dst_len, dst_len + 1);
                    return 1;
            }

            static int encode_to_worktree(const char *path, const char *src, size_t src_len,
                                    struct strbuf *buf, const char *enc)
            {
                    char *dst;
                    size_t dst_len;

                    /*
                    * No encoding is specified or there is nothing to encode.
                    * Tell the caller that the content was not modified.
                    */
                    if (!enc || (src && !src_len))
                            return 0;

                    dst = reencode_string_len(src, src_len, enc, default_encoding,
                                            &dst_len);
                    if (!dst) {
                            error(_("failed to encode '%s' from %s to %s"),
                            path, default_encoding, enc);
                            return 0;
                    }

                    strbuf_attach(buf, dst, dst_len, dst_len + 1);
                    return 1;
            }

            static int crlf_to_git(struct index_state *istate,
                            const char *path, const char *src, size_t len,
                            struct strbuf *buf,
                            enum convert_crlf_action crlf_action, int conv_flags)
            {
                    struct text_stat stats;
                    char *dst;
                    int convert_crlf_into_lf;

                    if (crlf_action == CRLF_BINARY ||
                    (src && !len))
                            return 0;

                    /*
                    * If we are doing a dry-run and have no source buffer, there is
                    * nothing to analyze; we must assume we would convert.
                    */
                    if (!buf && !src)
                            return 1;

                    gather_stats(src, len, &stats);
                    /* Optimization: No CRLF? Nothing to convert, regardless. */
                    convert_crlf_into_lf = !!stats.crlf;

                    if (crlf_action == CRLF_AUTO || crlf_action == CRLF_AUTO_INPUT || crlf_action == CRLF_AUTO_CRLF) {
                            if (convert_is_binary(&stats))
                                    return 0;
                            /*
                            * If the file in the index has any CR in it, do not
                            * convert.  This is the new safer autocrlf handling,
                            * unless we want to renormalize in a merge or
                            * cherry-pick.
                            */
                            if ((!(conv_flags & CONV_EOL_RENORMALIZE)) &&
                            has_crlf_in_index(istate, path))
                                    convert_crlf_into_lf = 0;
                    }
                    if (((conv_flags & CONV_EOL_RNDTRP_WARN) ||
                    ((conv_flags & CONV_EOL_RNDTRP_DIE) && len))) {
                            struct text_stat new_stats;
                            memcpy(&new_stats, &stats, sizeof(new_stats));
                            /* simulate "git add" */
                            if (convert_crlf_into_lf) {
                                    new_stats.lonelf += new_stats.crlf;
                                    new_stats.crlf = 0;
                            }
                            /* simulate "git checkout" */
                            if (will_convert_lf_to_crlf(&new_stats, crlf_action)) {
                                    new_stats.crlf += new_stats.lonelf;
                                    new_stats.lonelf = 0;
                            }
                            check_global_conv_flags_eol(path, &stats, &new_stats, conv_flags);
                    }
                    if (!convert_crlf_into_lf)
                            return 0;

                    /*
                    * At this point all of our source analysis is done, and we are sure we
                    * would convert. If we are in dry-run mode, we can give an answer.
                    */
                    if (!buf)
                            return 1;

                    /* only grow if not in place */
                    if (strbuf_avail(buf) + buf->len < len)
                            strbuf_grow(buf, len - buf->len);
                    dst = buf->buf;
                    if (crlf_action == CRLF_AUTO || crlf_action == CRLF_AUTO_INPUT || crlf_action == CRLF_AUTO_CRLF) {
                            /*
                            * If we guessed, we already know we rejected a file with
                            * lone CR, and we can strip a CR without looking at what
                            * follow it.
                            */
                            do {
                                    unsigned char c = *src++;
                                    if (c != '\r')
                                            *dst++ = c;
                            } while (--len);
                    } else {
                            do {
                                    unsigned char c = *src++;
                                    if (! (c == '\r' && (1 < len && *src == '\n')))
                                            *dst++ = c;
                            } while (--len);
                    }
                    strbuf_setlen(buf, dst - buf->buf);
                    return 1;
            }

            static int crlf_to_worktree(const char *src, size_t len, struct strbuf *buf,
                                    enum convert_crlf_action crlf_action)
            {
                    char *to_free = NULL;
                    struct text_stat stats;

                    if (!len || output_eol(crlf_action) != EOL_CRLF)
                            return 0;

                    gather_stats(src, len, &stats);
                    if (!will_convert_lf_to_crlf(&stats, crlf_action))
                            return 0;

                    /* are we "faking" in place editing ? */
                    if (src == buf->buf)
                            to_free = strbuf_detach(buf, NULL);

                    strbuf_grow(buf, len + stats.lonelf);
                    for (;;) {
                            const char *nl = memchr(src, '\n', len);
                            if (!nl)
                                    break;
                            if (nl > src && nl[-1] == '\r') {
                                    strbuf_add(buf, src, nl + 1 - src);
                            } else {
                                    strbuf_add(buf, src, nl - src);
                                    strbuf_addstr(buf, "\r\n");
                            }
                            len -= nl + 1 - src;
                            src  = nl + 1;
                    }
                    strbuf_add(buf, src, len);

                    free(to_free);
                    return 1;
            }

            struct filter_params {
                    const char *src;
                    size_t size;
                    int fd;
                    const char *cmd;
                    const char *path;
            };

            static int filter_buffer_or_fd(int in UNUSED, int out, void *data)
            {
                    /*
                    * Spawn cmd and feed the buffer contents through its stdin.
                    */
                    struct child_process child_process = CHILD_PROCESS_INIT;
                    struct filter_params *params = (struct filter_params *)data;
                    const char *format = params->cmd;
                    int write_err, status;

                    /* apply % substitution to cmd */
                    struct strbuf cmd = STRBUF_INIT;

                    /* expand all %f with the quoted path; quote to preserve space, etc. */
                    while (strbuf_expand_step(&cmd, &format)) {
                            if (skip_prefix(format, "%", &format))
                                    strbuf_addch(&cmd, '%');
                            else if (skip_prefix(format, "f", &format))
                                    sq_quote_buf(&cmd, params->path);
                            else
                                    strbuf_addch(&cmd, '%');
                    }

                    strvec_push(&child_process.args, cmd.buf);
                    child_process.use_shell = 1;
                    child_process.in = -1;
                    child_process.out = out;

                    if (start_command(&child_process)) {
                            strbuf_release(&cmd);
                            return error(_("cannot fork to run external filter '%s'"),
                                    params->cmd);
                    }

                    sigchain_push(SIGPIPE, SIG_IGN);

                    if (params->src) {
                            write_err = (write_in_full(child_process.in,
                                                    params->src, params->size) < 0);
                            if (errno == EPIPE)
                                    write_err = 0;
                    } else {
                            write_err = copy_fd(params->fd, child_process.in);
                            if (write_err == COPY_WRITE_ERROR && errno == EPIPE)
                                    write_err = 0;
                    }

                    if (close(child_process.in))
                            write_err = 1;
                    if (write_err)
                            error(_("cannot feed the input to external filter '%s'"),
                            params->cmd);

                    sigchain_pop(SIGPIPE);

                    status = finish_command(&child_process);
                    if (status)
                            error(_("external filter '%s' failed %d"), params->cmd, status);

                    strbuf_release(&cmd);
                    return (write_err || status);
            }

            static int apply_single_file_filter(const char *path, const char *src, size_t len, int fd,
                                            struct strbuf *dst, const char *cmd)
            {
                    /*
                    * Create a pipeline to have the command filter the buffer's
                    * contents.
                    *
                    * (child --> cmd) --> us
                    */
                    int err = 0;
                    struct strbuf nbuf = STRBUF_INIT;
                    struct async async;
                    struct filter_params params;

                    memset(&async, 0, sizeof(async));
                    async.proc = filter_buffer_or_fd;
                    async.data = &params;
                    async.out = -1;
                    params.src = src;
                    params.size = len;
                    params.fd = fd;
                    params.cmd = cmd;
                    params.path = path;

                    fflush(NULL);
                    if (start_async(&async))
                            return 0;       /* error was already reported */

                    if (strbuf_read(&nbuf, async.out, 0) < 0) {
                            err = error(_("read from external filter '%s' failed"), cmd);
                    }
                    if (close(async.out)) {
                            err = error(_("read from external filter '%s' failed"), cmd);
                    }
                    if (finish_async(&async)) {
                            err = error(_("external filter '%s' failed"), cmd);
                    }

                    if (!err) {
                            strbuf_swap(dst, &nbuf);
                    }
                    strbuf_release(&nbuf);
                    return !err;
            }

            #define CAP_CLEAN    (1u<<0)
            #define CAP_SMUDGE   (1u<<1)
            #define CAP_DELAY    (1u<<2)

            struct cmd2process {
                    struct subprocess_entry subprocess; /* must be the first member! */
                    unsigned int supported_capabilities;
            };

            static int subprocess_map_initialized;
            static struct hashmap subprocess_map;

            static int start_multi_file_filter_fn(struct subprocess_entry *subprocess)
            {
                    static int versions[] = {2, 0};
                    static struct subprocess_capability capabilities[] = {
                            { "clean",  CAP_CLEAN  },
                            { "smudge", CAP_SMUDGE },
                            { "delay",  CAP_DELAY  },
                            { NULL, 0 }
                    };
                    struct cmd2process *entry = (struct cmd2process *)subprocess;
                    return subprocess_handshake(subprocess, "git-filter", versions, NULL,
                                            capabilities,
                                            &entry->supported_capabilities);
            }

            static void handle_filter_error(const struct strbuf *filter_status,
                                            struct cmd2process *entry,
                                            const unsigned int wanted_capability)
            {
                    if (!strcmp(filter_status->buf, "error"))
                            ; /* The filter signaled a problem with the file. */
                    else if (!strcmp(filter_status->buf, "abort") && wanted_capability) {
                            /*
                            * The filter signaled a permanent problem. Don't try to filter
                            * files with the same command for the lifetime of the current
                            * Git process.
                            */
                            entry->supported_capabilities &= ~wanted_capability;
                    } else {
                            /*
                            * Something went wrong with the protocol filter.
                            * Force shutdown and restart if another blob requires filtering.
                            */
                            error(_("external filter '%s' failed"), entry->subprocess.cmd);
                            subprocess_stop(&subprocess_map, &entry->subprocess);
                            free(entry);
                    }
            }

            static int apply_multi_file_filter(const char *path, const char *src, size_t len,
                                            int fd, struct strbuf *dst, const char *cmd,
                                            const unsigned int wanted_capability,
                                            const struct checkout_metadata *meta,
                                            struct delayed_checkout *dco)
            {
                    int err;
                    int can_delay = 0;
                    struct cmd2process *entry;
                    struct child_process *process;
                    struct strbuf nbuf = STRBUF_INIT;
                    struct strbuf filter_status = STRBUF_INIT;
                    const char *filter_type;

                    if (!subprocess_map_initialized) {
                            subprocess_map_initialized = 1;
                            hashmap_init(&subprocess_map, cmd2process_cmp, NULL, 0);
                            entry = NULL;
                    } else {
                            entry = (struct cmd2process *)subprocess_find_entry(&subprocess_map, cmd);
                    }

                    fflush(NULL);

                    if (!entry) {
                            entry = xmalloc(sizeof(*entry));
                            entry->supported_capabilities = 0;

                            if (subprocess_start(&subprocess_map, &entry->subprocess, cmd, start_multi_file_filter_fn)) {
                                    free(entry);
                                    return 0;
                            }
                    }
                    process = &entry->subprocess.process;

                    if (!(entry->supported_capabilities & wanted_capability))
                            return 0;

                    if (wanted_capability & CAP_CLEAN)
                            filter_type = "clean";
                    else if (wanted_capability & CAP_SMUDGE)
                            filter_type = "smudge";
                    else
                            die(_("unexpected filter type"));

                    sigchain_push(SIGPIPE, SIG_IGN);

                    assert(strlen(filter_type) < LARGE_PACKET_DATA_MAX - strlen("command=\n"));
                    err = packet_write_fmt_gently(process->in, "command=%s\n", filter_type);
                    if (err)
                            goto done;

                    err = strlen(path) > LARGE_PACKET_DATA_MAX - strlen("pathname=\n");
                    if (err) {
                            error(_("path name too long for external filter"));
                            goto done;
                    }

                    err = packet_write_fmt_gently(process->in, "pathname=%s\n", path);
                    if (err)
                            goto done;

                    if (meta && meta->refname) {
                            err = packet_write_fmt_gently(process->in, "ref=%s\n", meta->refname);
                            if (err)
                                    goto done;
                    }

                    if (meta && !is_null_oid(&meta->treeish)) {
                            err = packet_write_fmt_gently(process->in, "treeish=%s\n", oid_to_hex(&meta->treeish));
                            if (err)
                                    goto done;
                    }

                    if (meta && !is_null_oid(&meta->blob)) {
                            err = packet_write_fmt_gently(process->in, "blob=%s\n", oid_to_hex(&meta->blob));
                            if (err)
                                    goto done;
                    }

                    if ((entry->supported_capabilities & CAP_DELAY) &&
                    dco && dco->state == CE_CAN_DELAY) {
                            can_delay = 1;
                            err = packet_write_fmt_gently(process->in, "can-delay=1\n");
                            if (err)
                                    goto done;
                    }

                    err = packet_flush_gently(process->in);
                    if (err)
                            goto done;

                    if (fd >= 0)
                            err = write_packetized_from_fd_no_flush(fd, process->in);
                    else
                            err = write_packetized_from_buf_no_flush(src, len, process->in);
                    if (err)
                            goto done;

                    err = packet_flush_gently(process->in);
                    if (err)
                            goto done;

                    err = subprocess_read_status(process->out, &filter_status);
                    if (err)
                            goto done;

                    if (can_delay && !strcmp(filter_status.buf, "delayed")) {
                            string_list_insert(&dco->filters, cmd);
                            string_list_insert(&dco->paths, path);
                    } else {
                            /* The filter got the blob and wants to send us a response. */
                            err = strcmp(filter_status.buf, "success");
                            if (err)
                                    goto done;

                            err = read_packetized_to_strbuf(process->out, &nbuf,
                                                            PACKET_READ_GENTLE_ON_EOF) < 0;
                            if (err)
                                    goto done;

                            err = subprocess_read_status(process->out, &filter_status);
                            if (err)
                                    goto done;

                            err = strcmp(filter_status.buf, "success");
                    }

            done:
                    sigchain_pop(SIGPIPE);

                    if (err)
                            handle_filter_error(&filter_status, entry, wanted_capability);
                    else
                            strbuf_swap(dst, &nbuf);
                    strbuf_release(&nbuf);
                    strbuf_release(&filter_status);
                    return !err;
            }


            int async_query_available_blobs(const char *cmd, struct string_list *available_paths)
            {
                    int err;
                    char *line;
                    struct cmd2process *entry;
                    struct child_process *process;
                    struct strbuf filter_status = STRBUF_INIT;

                    assert(subprocess_map_initialized);
                    entry = (struct cmd2process *)subprocess_find_entry(&subprocess_map, cmd);
                    if (!entry) {
                            error(_("external filter '%s' is not available anymore although "
                                    "not all paths have been filtered"), cmd);
                            return 0;
                    }
                    process = &entry->subprocess.process;
                    sigchain_push(SIGPIPE, SIG_IGN);

                    err = packet_write_fmt_gently(
                            process->in, "command=list_available_blobs\n");
                    if (err)
                            goto done;

                    err = packet_flush_gently(process->in);
                    if (err)
                            goto done;

                    while ((line = packet_read_line(process->out, NULL))) {
                            const char *path;
                            if (skip_prefix(line, "pathname=", &path))
                                    string_list_insert(available_paths, path);
                            else
                                    ; /* ignore unknown keys */
                    }

                    err = subprocess_read_status(process->out, &filter_status);
                    if (err)
                            goto done;

                    err = strcmp(filter_status.buf, "success");

            done:
                    sigchain_pop(SIGPIPE);

                    if (err)
                            handle_filter_error(&filter_status, entry, 0);
                    strbuf_release(&filter_status);
                    return !err;
            }

            static struct convert_driver {
                    const char *name;
                    struct convert_driver *next;
                    char *smudge;
                    char *clean;
                    char *process;
                    int required;
            } *user_convert, **user_convert_tail;

            static int apply_filter(const char *path, const char *src, size_t len,
                                    int fd, struct strbuf *dst, struct convert_driver *drv,
                                    const unsigned int wanted_capability,
                                    const struct checkout_metadata *meta,
                                    struct delayed_checkout *dco)
            {
                    const char *cmd = NULL;

                    if (!drv)
                            return 0;

                    if (!dst)
                            return 1;

                    if ((wanted_capability & CAP_CLEAN) && !drv->process && drv->clean)
                            cmd = drv->clean;
                    else if ((wanted_capability & CAP_SMUDGE) && !drv->process && drv->smudge)
                            cmd = drv->smudge;

                    if (cmd && *cmd)
                            return apply_single_file_filter(path, src, len, fd, dst, cmd);
                    else if (drv->process && *drv->process)
                            return apply_multi_file_filter(path, src, len, fd, dst,
                                    drv->process, wanted_capability, meta, dco);

                    return 0;
            }

            static int read_convert_config(const char *var, const char *value,
                                    const struct config_context *ctx UNUSED,
                                    void *cb UNUSED)
            {
                    const char *key, *name;
                    size_t namelen;
                    struct convert_driver *drv;

                    /*
                    * External conversion drivers are configured using
                    * "filter.<name>.variable".
                    */
                    if (parse_config_key(var, "filter", &name, &namelen, &key) < 0 || !name)
                            return 0;
                    for (drv = user_convert; drv; drv = drv->next)
                            if (!xstrncmpz(drv->name, name, namelen))
                                    break;
                    if (!drv) {
                            CALLOC_ARRAY(drv, 1);
                            drv->name = xmemdupz(name, namelen);
                            *user_convert_tail = drv;
                            user_convert_tail = &(drv->next);
                    }

                    /*
                    * filter.<name>.smudge and filter.<name>.clean specifies
                    * the command line:
                    *
                    *      command-line
                    *
                    * The command-line will not be interpolated in any way.
                    */

                    if (!strcmp("smudge", key)) {
                            FREE_AND_NULL(drv->smudge);
                            return git_config_string(&drv->smudge, var, value);
                    }

                    if (!strcmp("clean", key)) {
                            FREE_AND_NULL(drv->clean);
                            return git_config_string(&drv->clean, var, value);
                    }

                    if (!strcmp("process", key)) {
                            FREE_AND_NULL(drv->process);
                            return git_config_string(&drv->process, var, value);
                    }

                    if (!strcmp("required", key)) {
                            drv->required = git_config_bool(var, value);
                            return 0;
                    }

                    return 0;
            }

            static int count_ident(const char *cp, unsigned long size)
            {
                    /*
                    * "$Id: 0000000000000000000000000000000000000000 $" <=> "$Id$"
                    */
                    int cnt = 0;
                    char ch;

                    while (size) {
                            ch = *cp++;
                            size--;
                            if (ch != '$')
                                    continue;
                            if (size < 3)
                                    break;
                            if (memcmp("Id", cp, 2))
                                    continue;
                            ch = cp[2];
                            cp += 3;
                            size -= 3;
                            if (ch == '$')
                                    cnt++; /* $Id$ */
                            if (ch != ':')
                                    continue;

                            /*
                            * "$Id: ... "; scan up to the closing dollar sign and discard.
                            */
                            while (size) {
                                    ch = *cp++;
                                    size--;
                                    if (ch == '$') {
                                            cnt++;
                                            break;
                                    }
                                    if (ch == '\n')
                                            break;
                            }
                    }
                    return cnt;
            }

            static int ident_to_git(const char *src, size_t len,
                                    struct strbuf *buf, int ident)
            {
                    char *dst, *dollar;

                    if (!ident || (src && !count_ident(src, len)))
                            return 0;

                    if (!buf)
                            return 1;

                    /* only grow if not in place */
                    if (strbuf_avail(buf) + buf->len < len)
                            strbuf_grow(buf, len - buf->len);
                    dst = buf->buf;
                    for (;;) {
                            dollar = memchr(src, '$', len);
                            if (!dollar)
                                    break;
                            memmove(dst, src, dollar + 1 - src);
                            dst += dollar + 1 - src;
                            len -= dollar + 1 - src;
                            src  = dollar + 1;

                            if (len > 3 && !memcmp(src, "Id:", 3)) {
                                    dollar = memchr(src + 3, '$', len - 3);
                                    if (!dollar)
                                            break;
                                    if (memchr(src + 3, '\n', dollar - src - 3)) {
                                            /* Line break before the next dollar. */
                                            continue;
                                    }

                                    memcpy(dst, "Id$", 3);
                                    dst += 3;
                                    len -= dollar + 1 - src;
                                    src  = dollar + 1;
                            }
                    }
                    memmove(dst, src, len);
                    strbuf_setlen(buf, dst + len - buf->buf);
                    return 1;
            }

            static int ident_to_worktree(const char *src, size_t len,
                                    struct strbuf *buf, int ident)
            {
                    struct object_id oid;
                    char *to_free = NULL, *dollar, *spc;
                    int cnt;

                    if (!ident)
                            return 0;

                    cnt = count_ident(src, len);
                    if (!cnt)
                            return 0;

                    /* are we "faking" in place editing ? */
                    if (src == buf->buf)
                            to_free = strbuf_detach(buf, NULL);
                    hash_object_file(the_hash_algo, src, len, OBJ_BLOB, &oid);

                    strbuf_grow(buf, len + cnt * (the_hash_algo->hexsz + 3));
                    for (;;) {
                            /* step 1: run to the next '$' */
                            dollar = memchr(src, '$', len);
                            if (!dollar)
                                    break;
                            strbuf_add(buf, src, dollar + 1 - src);
                            len -= dollar + 1 - src;
                            src  = dollar + 1;

                            /* step 2: does it looks like a bit like Id:xxx$ or Id$ ? */
                            if (len < 3 || memcmp("Id", src, 2))
                                    continue;

                            /* step 3: skip over Id$ or Id:xxxxx$ */
                            if (src[2] == '$') {
                                    src += 3;
                                    len -= 3;
                            } else if (src[2] == ':') {
                                    /*
                                    * It's possible that an expanded Id has crept its way into the
                                    * repository, we cope with that by stripping the expansion out.
                                    * This is probably not a good idea, since it will cause changes
                                    * on checkout, which won't go away by stash, but let's keep it
                                    * for git-style ids.
                                    */
                                    dollar = memchr(src + 3, '$', len - 3);
                                    if (!dollar) {
                                            /* incomplete keyword, no more '$', so just quit the loop */
                                            break;
                                    }

                                    if (memchr(src + 3, '\n', dollar - src - 3)) {
                                            /* Line break before the next dollar. */
                                            continue;
                                    }

                                    spc = memchr(src + 4, ' ', dollar - src - 4);
                                    if (spc && spc < dollar-1) {
                                            /* There are spaces in unexpected places.
                                            * This is probably an id from some other
                                            * versioning system. Keep it for now.
                                            */
                                            continue;
                                    }

                                    len -= dollar + 1 - src;
                                    src  = dollar + 1;
                            } else {
                                    /* it wasn't a "Id$" or "Id:xxxx$" */
                                    continue;
                            }

                            /* step 4: substitute */
                            strbuf_addstr(buf, "Id: ");
                            strbuf_addstr(buf, oid_to_hex(&oid));
                            strbuf_addstr(buf, " $");
                    }
                    strbuf_add(buf, src, len);

                    free(to_free);
                    return 1;
            }

            static const char *git_path_check_encoding(struct attr_check_item *check)
            {
                    const char *value = check->value;

                    if (ATTR_UNSET(value) || !strlen(value))
                            return NULL;

                    if (ATTR_TRUE(value) || ATTR_FALSE(value)) {
                            die(_("true/false are no valid working-tree-encodings"));
                    }

                    /* Don't encode to the default encoding */
                    if (same_encoding(value, default_encoding))
                            return NULL;

                    return value;
            }

            static enum convert_crlf_action git_path_check_crlf(struct attr_check_item *check)
            {
                    const char *value = check->value;

                    if (ATTR_TRUE(value))
                            return CRLF_TEXT;
                    else if (ATTR_FALSE(value))
                            return CRLF_BINARY;
                    else if (ATTR_UNSET(value))
                            ;
                    else if (!strcmp(value, "input"))
                            return CRLF_TEXT_INPUT;
                    else if (!strcmp(value, "auto"))
                            return CRLF_AUTO;
                    return CRLF_UNDEFINED;
            }

            static enum eol git_path_check_eol(struct attr_check_item *check)
            {
                    const char *value = check->value;

                    if (ATTR_UNSET(value))
                            ;
                    else if (!strcmp(value, "lf"))
                            return EOL_LF;
                    else if (!strcmp(value, "crlf"))
                            return EOL_CRLF;
                    return EOL_UNSET;
            }

            static struct convert_driver *git_path_check_convert(struct attr_check_item *check)
            {
                    const char *value = check->value;
                    struct convert_driver *drv;

                    if (ATTR_TRUE(value) || ATTR_FALSE(value) || ATTR_UNSET(value))
                            return NULL;
                    for (drv = user_convert; drv; drv = drv->next)
                            if (!strcmp(value, drv->name))
                                    return drv;
                    return NULL;
            }

            static int git_path_check_ident(struct attr_check_item *check)
            {
                    const char *value = check->value;

                    return !!ATTR_TRUE(value);
            }

            static struct attr_check *check;

            void convert_attrs(struct index_state *istate,
                            struct conv_attrs *ca, const char *path)
            {
                    struct attr_check_item *ccheck = NULL;

                    if (!check) {
                            check = attr_check_initl("crlf", "ident", "filter",
                                                    "eol", "text", "working-tree-encoding",
                                                    NULL);
                            user_convert_tail = &user_convert;
                            git_config(read_convert_config, NULL);
                    }

                    git_check_attr(istate, path, check);
                    ccheck = check->items;
                    ca->crlf_action = git_path_check_crlf(ccheck + 4);
                    if (ca->crlf_action == CRLF_UNDEFINED)
                            ca->crlf_action = git_path_check_crlf(ccheck + 0);
                    ca->ident = git_path_check_ident(ccheck + 1);
                    ca->drv = git_path_check_convert(ccheck + 2);
                    if (ca->crlf_action != CRLF_BINARY) {
                            enum eol eol_attr = git_path_check_eol(ccheck + 3);
                            if (ca->crlf_action == CRLF_AUTO && eol_attr == EOL_LF)
                                    ca->crlf_action = CRLF_AUTO_INPUT;
                            else if (ca->crlf_action == CRLF_AUTO && eol_attr == EOL_CRLF)
                                    ca->crlf_action = CRLF_AUTO_CRLF;
                            else if (eol_attr == EOL_LF)
                                    ca->crlf_action = CRLF_TEXT_INPUT;
                            else if (eol_attr == EOL_CRLF)
                                    ca->crlf_action = CRLF_TEXT_CRLF;
                    }
                    ca->working_tree_encoding = git_path_check_encoding(ccheck + 5);

                    /* Save attr and make a decision for action */
                    ca->attr_action = ca->crlf_action;
                    if (ca->crlf_action == CRLF_TEXT)
                            ca->crlf_action = text_eol_is_crlf() ? CRLF_TEXT_CRLF : CRLF_TEXT_INPUT;
                    if (ca->crlf_action == CRLF_UNDEFINED && auto_crlf == AUTO_CRLF_FALSE)
                            ca->crlf_action = CRLF_BINARY;
                    if (ca->crlf_action == CRLF_UNDEFINED && auto_crlf == AUTO_CRLF_TRUE)
                            ca->crlf_action = CRLF_AUTO_CRLF;
                    if (ca->crlf_action == CRLF_UNDEFINED && auto_crlf == AUTO_CRLF_INPUT)
                            ca->crlf_action = CRLF_AUTO_INPUT;
            }

            void reset_parsed_attributes(void)
            {
                    struct convert_driver *drv, *next;

                    attr_check_free(check);
                    check = NULL;
                    reset_merge_attributes();

                    for (drv = user_convert; drv; drv = next) {
                            next = drv->next;
                            free((void *)drv->name);
                            free((void *)drv->smudge);
                            free((void *)drv->clean);
                            free((void *)drv->process);
                            free(drv);
                    }
                    user_convert = NULL;
                    user_convert_tail = NULL;
            }

            int would_convert_to_git_filter_fd(struct index_state *istate, const char *path)
            {
                    struct conv_attrs ca;

                    convert_attrs(istate, &ca, path);
                    if (!ca.drv)
                            return 0;

                    /*
                    * Apply a filter to an fd only if the filter is required to succeed.
                    * We must die if the filter fails, because the original data before
                    * filtering is not available.
                    */
                    if (!ca.drv->required)
                            return 0;

                    return apply_filter(path, NULL, 0, -1, NULL, ca.drv, CAP_CLEAN, NULL, NULL);
            }

            const char *get_convert_attr_ascii(struct index_state *istate, const char *path)
            {
                    struct conv_attrs ca;

                    convert_attrs(istate, &ca, path);
                    switch (ca.attr_action) {
                    case CRLF_UNDEFINED:
                            return "";
                    case CRLF_BINARY:
                            return "-text";
                    case CRLF_TEXT:
                            return "text";
                    case CRLF_TEXT_INPUT:
                            return "text eol=lf";
                    case CRLF_TEXT_CRLF:
                            return "text eol=crlf";
                    case CRLF_AUTO:
                            return "text=auto";
                    case CRLF_AUTO_CRLF:
                            return "text=auto eol=crlf";
                    case CRLF_AUTO_INPUT:
                            return "text=auto eol=lf";
                    }
                    return "";
            }

            int convert_to_git(struct index_state *istate,
                            const char *path, const char *src, size_t len,
                            struct strbuf *dst, int conv_flags)
            {
                    int ret = 0;
                    struct conv_attrs ca;

                    convert_attrs(istate, &ca, path);

                    ret |= apply_filter(path, src, len, -1, dst, ca.drv, CAP_CLEAN, NULL, NULL);
                    if (!ret && ca.drv && ca.drv->required)
                            die(_("%s: clean filter '%s' failed"), path, ca.drv->name);

                    if (ret && dst) {
                            src = dst->buf;
                            len = dst->len;
                    }

                    ret |= encode_to_git(path, src, len, dst, ca.working_tree_encoding, conv_flags);
                    if (ret && dst) {
                            src = dst->buf;
                            len = dst->len;
                    }

                    if (!(conv_flags & CONV_EOL_KEEP_CRLF)) {
                            ret |= crlf_to_git(istate, path, src, len, dst, ca.crlf_action, conv_flags);
                            if (ret && dst) {
                                    src = dst->buf;
                                    len = dst->len;
                            }
                    }
                    return ret | ident_to_git(src, len, dst, ca.ident);
            }

            void convert_to_git_filter_fd(struct index_state *istate,
                                    const char *path, int fd, struct strbuf *dst,
                                    int conv_flags)
            {
                    struct conv_attrs ca;
                    convert_attrs(istate, &ca, path);

                    assert(ca.drv);

                    if (!apply_filter(path, NULL, 0, fd, dst, ca.drv, CAP_CLEAN, NULL, NULL))
                            die(_("%s: clean filter '%s' failed"), path, ca.drv->name);

                    encode_to_git(path, dst->buf, dst->len, dst, ca.working_tree_encoding, conv_flags);
                    crlf_to_git(istate, path, dst->buf, dst->len, dst, ca.crlf_action, conv_flags);
                    ident_to_git(dst->buf, dst->len, dst, ca.ident);
            }

            static int convert_to_working_tree_ca_internal(const struct conv_attrs *ca,
                                                    const char *path, const char *src,
                                                    size_t len, struct strbuf *dst,
                                                    int normalizing,
                                                    const struct checkout_metadata *meta,
                                                    struct delayed_checkout *dco)
            {
                    int ret = 0, ret_filter = 0;

                    ret |= ident_to_worktree(src, len, dst, ca->ident);
                    if (ret) {
                            src = dst->buf;
                            len = dst->len;
                    }
                    /*
                    * CRLF conversion can be skipped if normalizing, unless there
                    * is a smudge or process filter (even if the process filter doesn't
                    * support smudge).  The filters might expect CRLFs.
                    */
                    if ((ca->drv && (ca->drv->smudge || ca->drv->process)) || !normalizing) {
                            ret |= crlf_to_worktree(src, len, dst, ca->crlf_action);
                            if (ret) {
                                    src = dst->buf;
                                    len = dst->len;
                            }
                    }

                    ret |= encode_to_worktree(path, src, len, dst, ca->working_tree_encoding);
                    if (ret) {
                            src = dst->buf;
                            len = dst->len;
                    }

                    ret_filter = apply_filter(
                            path, src, len, -1, dst, ca->drv, CAP_SMUDGE, meta, dco);
                    if (!ret_filter && ca->drv && ca->drv->required)
                            die(_("%s: smudge filter %s failed"), path, ca->drv->name);

                    return ret | ret_filter;
            }

            int async_convert_to_working_tree_ca(const struct conv_attrs *ca,
                                            const char *path, const char *src,
                                            size_t len, struct strbuf *dst,
                                            const struct checkout_metadata *meta,
                                            void *dco)
            {
                    return convert_to_working_tree_ca_internal(ca, path, src, len, dst, 0,
                                                            meta, dco);
            }

            int convert_to_working_tree_ca(const struct conv_attrs *ca,
                                    const char *path, const char *src,
                                    size_t len, struct strbuf *dst,
                                    const struct checkout_metadata *meta)
            {
                    return convert_to_working_tree_ca_internal(ca, path, src, len, dst, 0,
                                                            meta, NULL);
            }

            int renormalize_buffer(struct index_state *istate, const char *path,
                            const char *src, size_t len, struct strbuf *dst)
            {
                    struct conv_attrs ca;
                    int ret;

                    convert_attrs(istate, &ca, path);
                    ret = convert_to_working_tree_ca_internal(&ca, path, src, len, dst, 1,
                                                            NULL, NULL);
                    if (ret) {
                            src = dst->buf;
                            len = dst->len;
                    }
                    return ret | convert_to_git(istate, path, src, len, dst, CONV_EOL_RENORMALIZE);
            }

            /*****************************************************************
            *
            * Streaming conversion support
            *
            *****************************************************************/

            typedef int (*filter_fn)(struct stream_filter *,
                                    const char *input, size_t *isize_p,
                                    char *output, size_t *osize_p);
            typedef void (*free_fn)(struct stream_filter *);

            struct stream_filter_vtbl {
                    filter_fn filter;
                    free_fn free;
            };

            struct stream_filter {
                    struct stream_filter_vtbl *vtbl;
            };

            static int null_filter_fn(struct stream_filter *filter UNUSED,
                                    const char *input, size_t *isize_p,
                                    char *output, size_t *osize_p)
            {
                    size_t count;

                    if (!input)
                            return 0; /* we do not keep any states */
                    count = *isize_p;
                    if (*osize_p < count)
                            count = *osize_p;
                    if (count) {
                            memmove(output, input, count);
                            *isize_p -= count;
                            *osize_p -= count;
                    }
                    return 0;
            }

            static void null_free_fn(struct stream_filter *filter UNUSED)
            {
                    ; /* nothing -- null instances are shared */
            }

            static struct stream_filter_vtbl null_vtbl = {
                    .filter = null_filter_fn,
                    .free = null_free_fn,
            };

            static struct stream_filter null_filter_singleton = {
                    .vtbl = &null_vtbl,
            };

            int is_null_stream_filter(struct stream_filter *filter)
            {
                    return filter == &null_filter_singleton;
            }


            /*
            * LF-to-CRLF filter
            */

            struct lf_to_crlf_filter {
                    struct stream_filter filter;
                    unsigned has_held:1;
                    char held;
            };

            static int lf_to_crlf_filter_fn(struct stream_filter *filter,
                                            const char *input, size_t *isize_p,
                                            char *output, size_t *osize_p)
            {
                    size_t count, o = 0;
                    struct lf_to_crlf_filter *lf_to_crlf = (struct lf_to_crlf_filter *)filter;

                    /*
                    * We may be holding onto the CR to see if it is followed by a
                    * LF, in which case we would need to go to the main loop.
                    * Otherwise, just emit it to the output stream.
                    */
                    if (lf_to_crlf->has_held && (lf_to_crlf->held != '\r' || !input)) {
                            output[o++] = lf_to_crlf->held;
                            lf_to_crlf->has_held = 0;
                    }

                    /* We are told to drain */
                    if (!input) {
                            *osize_p -= o;
                            return 0;
                    }

                    count = *isize_p;
                    if (count || lf_to_crlf->has_held) {
                            size_t i;
                            int was_cr = 0;

                            if (lf_to_crlf->has_held) {
                                    was_cr = 1;
                                    lf_to_crlf->has_held = 0;
                            }

                            for (i = 0; o < *osize_p && i < count; i++) {
                                    char ch = input[i];

                                    if (ch == '\n') {
                                            output[o++] = '\r';
                                    } else if (was_cr) {
                                            /*
                                            * Previous round saw CR and it is not followed
                                            * by a LF; emit the CR before processing the
                                            * current character.
                                            */
                                            output[o++] = '\r';
                                    }

                                    /*
                                    * We may have consumed the last output slot,
                                    * in which case we need to break out of this
                                    * loop; hold the current character before
                                    * returning.
                                    */
                                    if (*osize_p <= o) {
                                            lf_to_crlf->has_held = 1;
                                            lf_to_crlf->held = ch;
                                            continue; /* break but increment i */
                                    }

                                    if (ch == '\r') {
                                            was_cr = 1;
                                            continue;
                                    }

                                    was_cr = 0;
                                    output[o++] = ch;
                            }

                            *osize_p -= o;
                            *isize_p -= i;

                            if (!lf_to_crlf->has_held && was_cr) {
                                    lf_to_crlf->has_held = 1;
                                    lf_to_crlf->held = '\r';
                            }
                    }
                    return 0;
            }

            static void lf_to_crlf_free_fn(struct stream_filter *filter)
            {
                    free(filter);
            }

            static struct stream_filter_vtbl lf_to_crlf_vtbl = {
                    .filter = lf_to_crlf_filter_fn,
                    .free = lf_to_crlf_free_fn,
            };

            static struct stream_filter *lf_to_crlf_filter(void)
            {
                    struct lf_to_crlf_filter *lf_to_crlf = xcalloc(1, sizeof(*lf_to_crlf));

                    lf_to_crlf->filter.vtbl = &lf_to_crlf_vtbl;
                    return (struct stream_filter *)lf_to_crlf;
            }

            /*
            * Cascade filter
            */
            #define FILTER_BUFFER 1024
            struct cascade_filter {
                    struct stream_filter filter;
                    struct stream_filter *one;
                    struct stream_filter *two;
                    char buf[FILTER_BUFFER];
                    int end, ptr;
            };

            static int cascade_filter_fn(struct stream_filter *filter,
                                    const char *input, size_t *isize_p,
                                    char *output, size_t *osize_p)
            {
                    struct cascade_filter *cas = (struct cascade_filter *) filter;
                    size_t filled = 0;
                    size_t sz = *osize_p;
                    size_t to_feed, remaining;

                    /*
                    * input -- (one) --> buf -- (two) --> output
                    */
                    while (filled < sz) {
                            remaining = sz - filled;

                            /* do we already have something to feed two with? */
                            if (cas->ptr < cas->end) {
                                    to_feed = cas->end - cas->ptr;
                                    if (stream_filter(cas->two,
                                                    cas->buf + cas->ptr, &to_feed,
                                                    output + filled, &remaining))
                                            return -1;
                                    cas->ptr += (cas->end - cas->ptr) - to_feed;
                                    filled = sz - remaining;
                                    continue;
                            }

                            /* feed one from upstream and have it emit into our buffer */
                            to_feed = input ? *isize_p : 0;
                            if (input && !to_feed)
                                    break;
                            remaining = sizeof(cas->buf);
                            if (stream_filter(cas->one,
                                            input, &to_feed,
                                            cas->buf, &remaining))
                                    return -1;
                            cas->end = sizeof(cas->buf) - remaining;
                            cas->ptr = 0;
                            if (input) {
                                    size_t fed = *isize_p - to_feed;
                                    *isize_p -= fed;
                                    input += fed;
                            }

                            /* do we know that we drained one completely? */
                            if (input || cas->end)
                                    continue;

                            /* tell two to drain; we have nothing more to give it */
                            to_feed = 0;
                            remaining = sz - filled;
                            if (stream_filter(cas->two,
                                            NULL, &to_feed,
                                            output + filled, &remaining))
                                    return -1;
                            if (remaining == (sz - filled))
                                    break; /* completely drained two */
                            filled = sz - remaining;
                    }
                    *osize_p -= filled;
                    return 0;
            }

            static void cascade_free_fn(struct stream_filter *filter)
            {
                    struct cascade_filter *cas = (struct cascade_filter *)filter;
                    free_stream_filter(cas->one);
                    free_stream_filter(cas->two);
                    free(filter);
            }

            static struct stream_filter_vtbl cascade_vtbl = {
                    .filter = cascade_filter_fn,
                    .free = cascade_free_fn,
            };

            static struct stream_filter *cascade_filter(struct stream_filter *one,
                                                    struct stream_filter *two)
            {
                    struct cascade_filter *cascade;

                    if (!one || is_null_stream_filter(one))
                            return two;
                    if (!two || is_null_stream_filter(two))
                            return one;

                    cascade = xmalloc(sizeof(*cascade));
                    cascade->one = one;
                    cascade->two = two;
                    cascade->end = cascade->ptr = 0;
                    cascade->filter.vtbl = &cascade_vtbl;
                    return (struct stream_filter *)cascade;
            }

            /*
            * ident filter
            */
            #define IDENT_DRAINING (-1)
            #define IDENT_SKIPPING (-2)
            struct ident_filter {
                    struct stream_filter filter;
                    struct strbuf left;
                    int state;
                    char ident[GIT_MAX_HEXSZ + 5]; /* ": x40 $" */
            };

            static int is_foreign_ident(const char *str)
            {
                    int i;

                    if (!skip_prefix(str, "$Id: ", &str))
                            return 0;
                    for (i = 0; str[i]; i++) {
                            if (isspace(str[i]) && str[i+1] != '$')
                                    return 1;
                    }
                    return 0;
            }

            static void ident_drain(struct ident_filter *ident, char **output_p, size_t *osize_p)
            {
                    size_t to_drain = ident->left.len;

                    if (*osize_p < to_drain)
                            to_drain = *osize_p;
                    if (to_drain) {
                            memcpy(*output_p, ident->left.buf, to_drain);
                            strbuf_remove(&ident->left, 0, to_drain);
                            *output_p += to_drain;
                            *osize_p -= to_drain;
                    }
                    if (!ident->left.len)
                            ident->state = 0;
            }

            static int ident_filter_fn(struct stream_filter *filter,
                                    const char *input, size_t *isize_p,
                                    char *output, size_t *osize_p)
            {
                    struct ident_filter *ident = (struct ident_filter *)filter;
                    static const char head[] = "$Id";

                    if (!input) {
                            /* drain upon eof */
                            switch (ident->state) {
                            default:
                                    strbuf_add(&ident->left, head, ident->state);
                                    /* fallthrough */
                            case IDENT_SKIPPING:
                                    /* fallthrough */
                            case IDENT_DRAINING:
                                    ident_drain(ident, &output, osize_p);
                            }
                            return 0;
                    }

                    while (*isize_p || (ident->state == IDENT_DRAINING)) {
                            int ch;

                            if (ident->state == IDENT_DRAINING) {
                                    ident_drain(ident, &output, osize_p);
                                    if (!*osize_p)
                                            break;
                                    continue;
                            }

                            ch = *(input++);
                            (*isize_p)--;

                            if (ident->state == IDENT_SKIPPING) {
                                    /*
                                    * Skipping until '$' or LF, but keeping them
                                    * in case it is a foreign ident.
                                    */
                                    strbuf_addch(&ident->left, ch);
                                    if (ch != '\n' && ch != '$')
                                            continue;
                                    if (ch == '$' && !is_foreign_ident(ident->left.buf)) {
                                            strbuf_setlen(&ident->left, sizeof(head) - 1);
                                            strbuf_addstr(&ident->left, ident->ident);
                                    }
                                    ident->state = IDENT_DRAINING;
                                    continue;
                            }

                            if (ident->state < sizeof(head) &&
                            head[ident->state] == ch) {
                                    ident->state++;
                                    continue;
                            }

                            if (ident->state)
                                    strbuf_add(&ident->left, head, ident->state);
                            if (ident->state == sizeof(head) - 1) {
                                    if (ch != ':' && ch != '$') {
                                            strbuf_addch(&ident->left, ch);
                                            ident->state = 0;
                                            continue;
                                    }

                                    if (ch == ':') {
                                            strbuf_addch(&ident->left, ch);
                                            ident->state = IDENT_SKIPPING;
                                    } else {
                                            strbuf_addstr(&ident->left, ident->ident);
                                            ident->state = IDENT_DRAINING;
                                    }
                                    continue;
                            }

                            strbuf_addch(&ident->left, ch);
                            ident->state = IDENT_DRAINING;
                    }
                    return 0;
            }

            static void ident_free_fn(struct stream_filter *filter)
            {
                    struct ident_filter *ident = (struct ident_filter *)filter;
                    strbuf_release(&ident->left);
                    free(filter);
            }

            static struct stream_filter_vtbl ident_vtbl = {
                    .filter = ident_filter_fn,
                    .free = ident_free_fn,
            };

            static struct stream_filter *ident_filter(const struct object_id *oid)
            {
                    struct ident_filter *ident = xmalloc(sizeof(*ident));

                    xsnprintf(ident->ident, sizeof(ident->ident),
                            ": %s $", oid_to_hex(oid));
                    strbuf_init(&ident->left, 0);
                    ident->filter.vtbl = &ident_vtbl;
                    ident->state = 0;
                    return (struct stream_filter *)ident;
            }

            /*
            * Return an appropriately constructed filter for the given ca, or NULL if
            * the contents cannot be filtered without reading the whole thing
            * in-core.
            *
            * Note that you would be crazy to set CRLF, smudge/clean or ident to a
            * large binary blob you would want us not to slurp into the memory!
            */
            struct stream_filter *get_stream_filter_ca(const struct conv_attrs *ca,
                                                    const struct object_id *oid)
            {
                    struct stream_filter *filter = NULL;

                    if (classify_conv_attrs(ca) != CA_CLASS_STREAMABLE)
                            return NULL;

                    if (ca->ident)
                            filter = ident_filter(oid);

                    if (output_eol(ca->crlf_action) == EOL_CRLF)
                            filter = cascade_filter(filter, lf_to_crlf_filter());
                    else
                            filter = cascade_filter(filter, &null_filter_singleton);

                    return filter;
            }

            struct stream_filter *get_stream_filter(struct index_state *istate,
                                                    const char *path,
                                                    const struct object_id *oid)
            {
                    struct conv_attrs ca;
                    convert_attrs(istate, &ca, path);
                    return get_stream_filter_ca(&ca, oid);
            }

            void free_stream_filter(struct stream_filter *filter)
            {
                    filter->vtbl->free(filter);
            }

            int stream_filter(struct stream_filter *filter,
                            const char *input, size_t *isize_p,
                            char *output, size_t *osize_p)
            {
                    return filter->vtbl->filter(filter, input, isize_p, output, osize_p);
            }

            void init_checkout_metadata(struct checkout_metadata *meta, const char *refname,
                                    const struct object_id *treeish,
                                    const struct object_id *blob)
            {
                    memset(meta, 0, sizeof(*meta));
                    if (refname)
                            meta->refname = refname;
                    if (treeish)
                            oidcpy(&meta->treeish, treeish);
                    if (blob)
                            oidcpy(&meta->blob, blob);
            }

            void clone_checkout_metadata(struct checkout_metadata *dst,
                                    const struct checkout_metadata *src,
                                    const struct object_id *blob)
            {
                    memcpy(dst, src, sizeof(*dst));
                    if (blob)
                            oidcpy(&dst->blob, blob);
            }

            enum conv_attrs_classification classify_conv_attrs(const struct conv_attrs *ca)
            {
                    if (ca->drv) {
                            if (ca->drv->process)
                                    return CA_CLASS_INCORE_PROCESS;
                            if (ca->drv->smudge || ca->drv->clean)
                                    return CA_CLASS_INCORE_FILTER;
                    }

                    if (ca->working_tree_encoding)
                            return CA_CLASS_INCORE;

                    if (ca->crlf_action == CRLF_AUTO || ca->crlf_action == CRLF_AUTO_CRLF)
                            return CA_CLASS_INCORE;

                    return CA_CLASS_STREAMABLE;
            }

      """,
      "Error":"The patch ensures that files are handled correctly based on their encoding and line-ending attributes.
               Git operations on OS/390 will respect the platform's encoding and file handling rules, ensuring correct
               processing of files without corruption.",
      "Error Category":"Functionality Patch",

      "Corrected Code":[
      """
                    #define USE_THE_REPOSITORY_VARIABLE
            #define DISABLE_SIGN_COMPARE_WARNINGS

            #include "git-compat-util.h"
            #include "advice.h"
            #include "config.h"
            #include "convert.h"
            #include "copy.h"
            #include "environment.h"
            #include "gettext.h"
            #include "hex.h"
            #include "object-store-ll.h"
            #include "attr.h"
            #include "run-command.h"
            #include "quote.h"
            #include "read-cache-ll.h"
            #include "sigchain.h"
            #include "pkt-line.h"
            #include "sub-process.h"
            #include "trace.h"
            #include "utf8.h"
            #include "merge-ll.h"

            /*
            * convert.c - convert a file when checking it out and checking it in.
            *
            * This should use the pathname to decide on whether it wants to do some
            * more interesting conversions (automatic gzip/unzip, general format
            * conversions etc etc), but by default it just does automatic CRLF<->LF
            * translation when the "text" attribute or "auto_crlf" option is set.
            */

            /* Stat bits: When BIN is set, the txt bits are unset */
            #define CONVERT_STAT_BITS_TXT_LF    0x1
            #define CONVERT_STAT_BITS_TXT_CRLF  0x2
            #define CONVERT_STAT_BITS_BIN       0x4

            struct text_stat {
                    /* NUL, CR, LF and CRLF counts */
                    unsigned nul, lonecr, lonelf, crlf;

                    /* These are just approximations! */
                    unsigned printable, nonprintable;
            };

            static void gather_stats(const char *buf, unsigned long size, struct text_stat *stats)
            {
                    unsigned long i;

                    memset(stats, 0, sizeof(*stats));

                    for (i = 0; i < size; i++) {
                            unsigned char c = buf[i];
                            if (c == '\r') {
                                    if (i+1 < size && buf[i+1] == '\n') {
                                            stats->crlf++;
                                            i++;
                                    } else
                                            stats->lonecr++;
                                    continue;
                            }
                            if (c == '\n') {
                                    stats->lonelf++;
                                    continue;
                            }
                            if (c == 127)
                                    /* DEL */
                                    stats->nonprintable++;
                            else if (c < 32) {
                                    switch (c) {
                                            /* BS, HT, ESC and FF */
                                    case '\b': case '\t': case '\033': case '\014':
                                            stats->printable++;
                                            break;
                                    case 0:
                                            stats->nul++;
                                            /* fall through */
                                    default:
                                            stats->nonprintable++;
                                    }
                            }
                            else
                                    stats->printable++;
                    }

                    /* If file ends with EOF then don't count this EOF as non-printable. */
                    if (size >= 1 && buf[size-1] == '\032')
                            stats->nonprintable--;
            }

            /*
            * The same heuristics as diff.c::mmfile_is_binary()
            * We treat files with bare CR as binary
            */
            static int convert_is_binary(const struct text_stat *stats)
            {
                    if (stats->lonecr)
                            return 1;
                    if (stats->nul)
                            return 1;
                    if ((stats->printable >> 7) < stats->nonprintable)
                            return 1;
                    return 0;
            }

            static unsigned int gather_convert_stats(const char *data, unsigned long size)
            {
                    struct text_stat stats;
                    int ret = 0;
                    if (!data || !size)
                            return 0;
                    gather_stats(data, size, &stats);
                    if (convert_is_binary(&stats))
                            ret |= CONVERT_STAT_BITS_BIN;
                    if (stats.crlf)
                            ret |= CONVERT_STAT_BITS_TXT_CRLF;
                    if (stats.lonelf)
                            ret |=  CONVERT_STAT_BITS_TXT_LF;

                    return ret;
            }

            static const char *gather_convert_stats_ascii(const char *data, unsigned long size)
            {
                    unsigned int convert_stats = gather_convert_stats(data, size);

                    if (convert_stats & CONVERT_STAT_BITS_BIN)
                            return "-text";
                    switch (convert_stats) {
                    case CONVERT_STAT_BITS_TXT_LF:
                            return "lf";
                    case CONVERT_STAT_BITS_TXT_CRLF:
                            return "crlf";
                    case CONVERT_STAT_BITS_TXT_LF | CONVERT_STAT_BITS_TXT_CRLF:
                            return "mixed";
                    default:
                            return "none";
                    }
            }

            const char *get_cached_convert_stats_ascii(struct index_state *istate,
                                                    const char *path)
            {
                    const char *ret;
                    unsigned long sz;
                    void *data = read_blob_data_from_index(istate, path, &sz);
                    ret = gather_convert_stats_ascii(data, sz);
                    free(data);
                    return ret;
            }

            const char *get_wt_convert_stats_ascii(const char *path)
            {
                    const char *ret = "";
                    struct strbuf sb = STRBUF_INIT;
                    if (strbuf_read_file(&sb, path, 0) >= 0)
                            ret = gather_convert_stats_ascii(sb.buf, sb.len);
                    strbuf_release(&sb);
                    return ret;
            }

            static int text_eol_is_crlf(void)
            {
                    if (auto_crlf == AUTO_CRLF_TRUE)
                            return 1;
                    else if (auto_crlf == AUTO_CRLF_INPUT)
                            return 0;
                    if (core_eol == EOL_CRLF)
                            return 1;
                    if (core_eol == EOL_UNSET && EOL_NATIVE == EOL_CRLF)
                            return 1;
                    return 0;
            }

            static enum eol output_eol(enum convert_crlf_action crlf_action)
            {
                    switch (crlf_action) {
                    case CRLF_BINARY:
                            return EOL_UNSET;
                    case CRLF_TEXT_CRLF:
                            return EOL_CRLF;
                    case CRLF_TEXT_INPUT:
                            return EOL_LF;
                    case CRLF_UNDEFINED:
                    case CRLF_AUTO_CRLF:
                            return EOL_CRLF;
                    case CRLF_AUTO_INPUT:
                            return EOL_LF;
                    case CRLF_TEXT:
                    case CRLF_AUTO:
                            /* fall through */
                            return text_eol_is_crlf() ? EOL_CRLF : EOL_LF;
                    }
                    warning(_("illegal crlf_action %d"), (int)crlf_action);
                    return core_eol;
            }

            static void check_global_conv_flags_eol(const char *path,
                                    struct text_stat *old_stats, struct text_stat *new_stats,
                                    int conv_flags)
            {
                    if (old_stats->crlf && !new_stats->crlf ) {
                            /*
                            * CRLFs would not be restored by checkout
                            */
                            if (conv_flags & CONV_EOL_RNDTRP_DIE)
                                    die(_("CRLF would be replaced by LF in %s"), path);
                            else if (conv_flags & CONV_EOL_RNDTRP_WARN)
                                    warning(_("in the working copy of '%s', CRLF will be"
                                            " replaced by LF the next time Git touches"
                                            " it"), path);
                    } else if (old_stats->lonelf && !new_stats->lonelf ) {
                            /*
                            * CRLFs would be added by checkout
                            */
                            if (conv_flags & CONV_EOL_RNDTRP_DIE)
                                    die(_("LF would be replaced by CRLF in %s"), path);
                            else if (conv_flags & CONV_EOL_RNDTRP_WARN)
                                    warning(_("in the working copy of '%s', LF will be"
                                            " replaced by CRLF the next time Git touches"
                                            " it"), path);
                    }
            }

            static int has_crlf_in_index(struct index_state *istate, const char *path)
            {
                    unsigned long sz;
                    void *data;
                    const char *crp;
                    int has_crlf = 0;

                    data = read_blob_data_from_index(istate, path, &sz);
                    if (!data)
                            return 0;

                    crp = memchr(data, '\r', sz);
                    if (crp) {
                            unsigned int ret_stats;
                            ret_stats = gather_convert_stats(data, sz);
                            if (!(ret_stats & CONVERT_STAT_BITS_BIN) &&
                            (ret_stats & CONVERT_STAT_BITS_TXT_CRLF))
                                    has_crlf = 1;
                    }
                    free(data);
                    return has_crlf;
            }

            static int will_convert_lf_to_crlf(struct text_stat *stats,
                                            enum convert_crlf_action crlf_action)
            {
                    if (output_eol(crlf_action) != EOL_CRLF)
                            return 0;
                    /* No "naked" LF? Nothing to convert, regardless. */
                    if (!stats->lonelf)
                            return 0;

                    if (crlf_action == CRLF_AUTO || crlf_action == CRLF_AUTO_INPUT || crlf_action == CRLF_AUTO_CRLF) {
                            /* If we have any CR or CRLF line endings, we do not touch it */
                            /* This is the new safer autocrlf-handling */
                            if (stats->lonecr || stats->crlf)
                                    return 0;

                            if (convert_is_binary(stats))
                                    return 0;
                    }
                    return 1;

            }

            static int validate_encoding(const char *path, const char *enc,
                            const char *data, size_t len, int die_on_error)
            {
                    const char *stripped;

                    /* We only check for UTF here as UTF?? can be an alias for UTF-?? */
                    if (skip_iprefix(enc, "UTF", &stripped)) {
                            skip_prefix(stripped, "-", &stripped);

                            /*
                            * Check for detectable errors in UTF encodings
                            */
                            if (has_prohibited_utf_bom(enc, data, len)) {
                                    const char *error_msg = _(
                                            "BOM is prohibited in '%s' if encoded as %s");
                                    /*
                                    * This advice is shown for UTF-??BE and UTF-??LE encodings.
                                    * We cut off the last two characters of the encoding name
                                    * to generate the encoding name suitable for BOMs.
                                    */
                                    const char *advise_msg = _(
                                            "The file '%s' contains a byte order "
                                            "mark (BOM). Please use UTF-%.*s as "
                                            "working-tree-encoding.");
                                    int stripped_len = strlen(stripped) - strlen("BE");
                                    advise(advise_msg, path, stripped_len, stripped);
                                    if (die_on_error)
                                            die(error_msg, path, enc);
                                    else {
                                            return error(error_msg, path, enc);
                                    }

                            } else if (is_missing_required_utf_bom(enc, data, len)) {
                                    const char *error_msg = _(
                                            "BOM is required in '%s' if encoded as %s");
                                    const char *advise_msg = _(
                                            "The file '%s' is missing a byte order "
                                            "mark (BOM). Please use UTF-%sBE or UTF-%sLE "
                                            "(depending on the byte order) as "
                                            "working-tree-encoding.");
                                    advise(advise_msg, path, stripped, stripped);
                                    if (die_on_error)
                                            die(error_msg, path, enc);
                                    else {
                                            return error(error_msg, path, enc);
                                    }
                            }

                    }
                    return 0;
            }

            static void trace_encoding(const char *context, const char *path,
                                    const char *encoding, const char *buf, size_t len)
            {
                    static struct trace_key coe = TRACE_KEY_INIT(WORKING_TREE_ENCODING);
                    struct strbuf trace = STRBUF_INIT;
                    int i;

                    if (!trace_want(&coe))
                            return;

                    strbuf_addf(&trace, "%s (%s, considered %s):\n", context, path, encoding);
                    for (i = 0; i < len && buf; ++i) {
                            strbuf_addf(
                                    &trace, "| \033[2m%2i:\033[0m %2x \033[2m%c\033[0m%c",
                                    i,
                                    (unsigned char) buf[i],
                                    (buf[i] > 32 && buf[i] < 127 ? buf[i] : ' '),
                                    ((i+1) % 8 && (i+1) < len ? ' ' : '\n')
                            );
                    }
                    strbuf_addchars(&trace, '\n', 1);

                    trace_strbuf(&coe, &trace);
                    strbuf_release(&trace);
            }

            static int check_roundtrip(const char *enc_name)
            {
                    /*
                    * check_roundtrip_encoding contains a string of comma and/or
                    * space separated encodings (eg. "UTF-16, ASCII, CP1125").
                    * Search for the given encoding in that string.
                    */
                    const char *encoding = check_roundtrip_encoding ?
                            check_roundtrip_encoding : "SHIFT-JIS";
                    const char *found = strcasestr(encoding, enc_name);
                    const char *next;
                    int len;
                    if (!found)
                            return 0;
                    next = found + strlen(enc_name);
                    len = strlen(encoding);
                    return (found && (
                                    /*
                                    * Check that the found encoding is at the beginning of
                                    * encoding or that it is prefixed with a space or
                                    * comma.
                                    */
                                    found == encoding || (
                                            (isspace(found[-1]) || found[-1] == ',')
                                    )
                            ) && (
                                    /*
                                    * Check that the found encoding is at the end of
                                    * encoding or that it is suffixed with a space
                                    * or comma.
                                    */
                                    next == encoding + len || (
                                            next < encoding + len &&
                                            (isspace(next[0]) || next[0] == ',')
                                    )
                            ));
            }

            static const char *default_encoding = "UTF-8";

            static int encode_to_git(const char *path, const char *src, size_t src_len,
                                    struct strbuf *buf, const char *enc,
                                    enum convert_crlf_action attr_action, int conv_flags)
            {
                    char *dst;
                    size_t dst_len;
                    int die_on_error = conv_flags & CONV_WRITE_OBJECT;

                    if (attr_action == CRLF_BINARY) {
                            return 0;
                    }
                    /*
                    * No encoding is specified or there is nothing to encode.
                    * Tell the caller that the content was not modified.
                    */
                    if (!enc || (src && !src_len))
                            return 0;

                    /*
                    * Looks like we got called from "would_convert_to_git()".
                    * This means Git wants to know if it would encode (= modify!)
                    * the content. Let's answer with "yes", since an encoding was
                    * specified.
                    */
                    if (!buf && !src)
                            return 1;

                    if (validate_encoding(path, enc, src, src_len, die_on_error))
                            return 0;

                    trace_encoding("source", path, enc, src, src_len);
            #ifdef __MVS__
            // If UTF CCSID == 819 (ISO8859-1), do not convert ISO8859-1 tagged files
            if (utf8_ccsid == 819 && strcasecmp("ISO8859-1", enc) == 0)
                    return 0;
            #endif

                    dst = reencode_string_len(src, src_len, default_encoding, enc,
                                            &dst_len);
                    if (!dst) {
                            /*
                            * We could add the blob "as-is" to Git. However, on checkout
                            * we would try to re-encode to the original encoding. This
                            * would fail and we would leave the user with a messed-up
                            * working tree. Let's try to avoid this by screaming loud.
                            */
                    if (attr_action == CRLF_BINARY) {
                                    return 0;
                            }
                            const char* msg = _("failed to encode '%s' from %s to %s");
                            if (die_on_error)
                                    die(msg, path, enc, default_encoding);
                            else {
                                    error(msg, path, enc, default_encoding);
                                    return 0;
                            }
                    }
                    trace_encoding("destination", path, default_encoding, dst, dst_len);

                    /*
                    * UTF supports lossless conversion round tripping [1] and conversions
                    * between UTF and other encodings are mostly round trip safe as
                    * Unicode aims to be a superset of all other character encodings.
                    * However, certain encodings (e.g. SHIFT-JIS) are known to have round
                    * trip issues [2]. Check the round trip conversion for all encodings
                    * listed in core.checkRoundtripEncoding.
                    *
                    * The round trip check is only performed if content is written to Git.
                    * This ensures that no information is lost during conversion to/from
                    * the internal UTF-8 representation.
                    *
                    * Please note, the code below is not tested because I was not able to
                    * generate a faulty round trip without an iconv error. Iconv errors
                    * are already caught above.
                    *
                    * [1] http://unicode.org/faq/utf_bom.html#gen2
                    * [2] https://support.microsoft.com/en-us/help/170559/prb-conversion-problem-between-shift-jis-and-unicode
                    */
                    if (die_on_error && check_roundtrip(enc)) {
                            char *re_src;
                            size_t re_src_len;

                            re_src = reencode_string_len(dst, dst_len,
                                                    enc, default_encoding,
                                                    &re_src_len);

                            trace_printf("Checking roundtrip encoding for %s...\n", enc);
                            trace_encoding("reencoded source", path, enc,
                                    re_src, re_src_len);

                            if (!re_src || src_len != re_src_len ||
                            memcmp(src, re_src, src_len)) {
                                    const char* msg = _("encoding '%s' from %s to %s and "
                                                    "back is not the same");
                                    die(msg, path, enc, default_encoding);
                            }

                            free(re_src);
                    }

                    strbuf_attach(buf, dst, dst_len, dst_len + 1);
                    return 1;
            }

            static int encode_to_worktree(const char *path, const char *src, size_t src_len,
                                    struct strbuf *buf, enum convert_crlf_action attr_action,
                                    const char *enc)
            {
                    char *dst;
                    size_t dst_len;
            if (attr_action == CRLF_BINARY) {
            return 0;
            }

                    /*
                    * No encoding is specified or there is nothing to encode.
                    * Tell the caller that the content was not modified.
                    */
                    if (!enc || (src && !src_len))
                            return 0;

                    dst = reencode_string_len(src, src_len, enc, default_encoding,
                                            &dst_len);
                    if (!dst) {
                            error(_("failed to encode '%s' from %s to %s"),
                            path, default_encoding, enc);
                            return 0;
                    }

                    strbuf_attach(buf, dst, dst_len, dst_len + 1);
                    return 1;
            }

            static int crlf_to_git(struct index_state *istate,
                            const char *path, const char *src, size_t len,
                            struct strbuf *buf,
                            enum convert_crlf_action crlf_action, int conv_flags)
            {
                    struct text_stat stats;
                    char *dst;
                    int convert_crlf_into_lf;

                    if (crlf_action == CRLF_BINARY ||
                    (src && !len))
                            return 0;

                    /*
                    * If we are doing a dry-run and have no source buffer, there is
                    * nothing to analyze; we must assume we would convert.
                    */
                    if (!buf && !src)
                            return 1;

                    gather_stats(src, len, &stats);
                    /* Optimization: No CRLF? Nothing to convert, regardless. */
                    convert_crlf_into_lf = !!stats.crlf;

                    if (crlf_action == CRLF_AUTO || crlf_action == CRLF_AUTO_INPUT || crlf_action == CRLF_AUTO_CRLF) {
                            if (convert_is_binary(&stats))
                                    return 0;
                            /*
                            * If the file in the index has any CR in it, do not
                            * convert.  This is the new safer autocrlf handling,
                            * unless we want to renormalize in a merge or
                            * cherry-pick.
                            */
                            if ((!(conv_flags & CONV_EOL_RENORMALIZE)) &&
                            has_crlf_in_index(istate, path))
                                    convert_crlf_into_lf = 0;
                    }
                    if (((conv_flags & CONV_EOL_RNDTRP_WARN) ||
                    ((conv_flags & CONV_EOL_RNDTRP_DIE) && len))) {
                            struct text_stat new_stats;
                            memcpy(&new_stats, &stats, sizeof(new_stats));
                            /* simulate "git add" */
                            if (convert_crlf_into_lf) {
                                    new_stats.lonelf += new_stats.crlf;
                                    new_stats.crlf = 0;
                            }
                            /* simulate "git checkout" */
                            if (will_convert_lf_to_crlf(&new_stats, crlf_action)) {
                                    new_stats.crlf += new_stats.lonelf;
                                    new_stats.lonelf = 0;
                            }
                            check_global_conv_flags_eol(path, &stats, &new_stats, conv_flags);
                    }
                    if (!convert_crlf_into_lf)
                            return 0;

                    /*
                    * At this point all of our source analysis is done, and we are sure we
                    * would convert. If we are in dry-run mode, we can give an answer.
                    */
                    if (!buf)
                            return 1;

                    /* only grow if not in place */
                    if (strbuf_avail(buf) + buf->len < len)
                            strbuf_grow(buf, len - buf->len);
                    dst = buf->buf;
                    if (crlf_action == CRLF_AUTO || crlf_action == CRLF_AUTO_INPUT || crlf_action == CRLF_AUTO_CRLF) {
                            /*
                            * If we guessed, we already know we rejected a file with
                            * lone CR, and we can strip a CR without looking at what
                            * follow it.
                            */
                            do {
                                    unsigned char c = *src++;
                                    if (c != '\r')
                                            *dst++ = c;
                            } while (--len);
                    } else {
                            do {
                                    unsigned char c = *src++;
                                    if (! (c == '\r' && (1 < len && *src == '\n')))
                                            *dst++ = c;
                            } while (--len);
                    }
                    strbuf_setlen(buf, dst - buf->buf);
                    return 1;
            }

            static int crlf_to_worktree(const char *src, size_t len, struct strbuf *buf,
                                    enum convert_crlf_action crlf_action)
            {
                    char *to_free = NULL;
                    struct text_stat stats;

                    if (!len || output_eol(crlf_action) != EOL_CRLF)
                            return 0;

                    gather_stats(src, len, &stats);
                    if (!will_convert_lf_to_crlf(&stats, crlf_action))
                            return 0;

                    /* are we "faking" in place editing ? */
                    if (src == buf->buf)
                            to_free = strbuf_detach(buf, NULL);

                    strbuf_grow(buf, len + stats.lonelf);
                    for (;;) {
                            const char *nl = memchr(src, '\n', len);
                            if (!nl)
                                    break;
                            if (nl > src && nl[-1] == '\r') {
                                    strbuf_add(buf, src, nl + 1 - src);
                            } else {
                                    strbuf_add(buf, src, nl - src);
                                    strbuf_addstr(buf, "\r\n");
                            }
                            len -= nl + 1 - src;
                            src  = nl + 1;
                    }
                    strbuf_add(buf, src, len);

                    free(to_free);
                    return 1;
            }

            struct filter_params {
                    const char *src;
                    size_t size;
                    int fd;
                    const char *cmd;
                    const char *path;
            };

            static int filter_buffer_or_fd(int in UNUSED, int out, void *data)
            {
                    /*
                    * Spawn cmd and feed the buffer contents through its stdin.
                    */
                    struct child_process child_process = CHILD_PROCESS_INIT;
                    struct filter_params *params = (struct filter_params *)data;
                    const char *format = params->cmd;
                    int write_err, status;

                    /* apply % substitution to cmd */
                    struct strbuf cmd = STRBUF_INIT;

                    /* expand all %f with the quoted path; quote to preserve space, etc. */
                    while (strbuf_expand_step(&cmd, &format)) {
                            if (skip_prefix(format, "%", &format))
                                    strbuf_addch(&cmd, '%');
                            else if (skip_prefix(format, "f", &format))
                                    sq_quote_buf(&cmd, params->path);
                            else
                                    strbuf_addch(&cmd, '%');
                    }

                    strvec_push(&child_process.args, cmd.buf);
                    child_process.use_shell = 1;
                    child_process.in = -1;
                    child_process.out = out;

                    if (start_command(&child_process)) {
                            strbuf_release(&cmd);
                            return error(_("cannot fork to run external filter '%s'"),
                                    params->cmd);
                    }

                    sigchain_push(SIGPIPE, SIG_IGN);

                    if (params->src) {
                            write_err = (write_in_full(child_process.in,
                                                    params->src, params->size) < 0);
                            if (errno == EPIPE)
                                    write_err = 0;
                    } else {
                            write_err = copy_fd(params->fd, child_process.in);
                            if (write_err == COPY_WRITE_ERROR && errno == EPIPE)
                                    write_err = 0;
                    }

                    if (close(child_process.in))
                            write_err = 1;
                    if (write_err)
                            error(_("cannot feed the input to external filter '%s'"),
                            params->cmd);

                    sigchain_pop(SIGPIPE);

                    status = finish_command(&child_process);
                    if (status)
                            error(_("external filter '%s' failed %d"), params->cmd, status);

                    strbuf_release(&cmd);
                    return (write_err || status);
            }

            static int apply_single_file_filter(const char *path, const char *src, size_t len, int fd,
                                            struct strbuf *dst, const char *cmd)
            {
                    /*
                    * Create a pipeline to have the command filter the buffer's
                    * contents.
                    *
                    * (child --> cmd) --> us
                    */
                    int err = 0;
                    struct strbuf nbuf = STRBUF_INIT;
                    struct async async;
                    struct filter_params params;

                    memset(&async, 0, sizeof(async));
                    async.proc = filter_buffer_or_fd;
                    async.data = &params;
                    async.out = -1;
                    params.src = src;
                    params.size = len;
                    params.fd = fd;
                    params.cmd = cmd;
                    params.path = path;

                    fflush(NULL);
                    if (start_async(&async))
                            return 0;       /* error was already reported */

                    if (strbuf_read(&nbuf, async.out, 0) < 0) {
                            err = error(_("read from external filter '%s' failed"), cmd);
                    }
                    if (close(async.out)) {
                            err = error(_("read from external filter '%s' failed"), cmd);
                    }
                    if (finish_async(&async)) {
                            err = error(_("external filter '%s' failed"), cmd);
                    }

                    if (!err) {
                            strbuf_swap(dst, &nbuf);
                    }
                    strbuf_release(&nbuf);
                    return !err;
            }

            #define CAP_CLEAN    (1u<<0)
            #define CAP_SMUDGE   (1u<<1)
            #define CAP_DELAY    (1u<<2)

            struct cmd2process {
                    struct subprocess_entry subprocess; /* must be the first member! */
                    unsigned int supported_capabilities;
            };

            static int subprocess_map_initialized;
            static struct hashmap subprocess_map;

            static int start_multi_file_filter_fn(struct subprocess_entry *subprocess)
            {
                    static int versions[] = {2, 0};
                    static struct subprocess_capability capabilities[] = {
                            { "clean",  CAP_CLEAN  },
                            { "smudge", CAP_SMUDGE },
                            { "delay",  CAP_DELAY  },
                            { NULL, 0 }
                    };
                    struct cmd2process *entry = (struct cmd2process *)subprocess;
                    return subprocess_handshake(subprocess, "git-filter", versions, NULL,
                                            capabilities,
                                            &entry->supported_capabilities);
            }

            static void handle_filter_error(const struct strbuf *filter_status,
                                            struct cmd2process *entry,
                                            const unsigned int wanted_capability)
            {
                    if (!strcmp(filter_status->buf, "error"))
                            ; /* The filter signaled a problem with the file. */
                    else if (!strcmp(filter_status->buf, "abort") && wanted_capability) {
                            /*
                            * The filter signaled a permanent problem. Don't try to filter
                            * files with the same command for the lifetime of the current
                            * Git process.
                            */
                            entry->supported_capabilities &= ~wanted_capability;
                    } else {
                            /*
                            * Something went wrong with the protocol filter.
                            * Force shutdown and restart if another blob requires filtering.
                            */
                            error(_("external filter '%s' failed"), entry->subprocess.cmd);
                            subprocess_stop(&subprocess_map, &entry->subprocess);
                            free(entry);
                    }
            }

            static int apply_multi_file_filter(const char *path, const char *src, size_t len,
                                            int fd, struct strbuf *dst, const char *cmd,
                                            const unsigned int wanted_capability,
                                            const struct checkout_metadata *meta,
                                            struct delayed_checkout *dco)
            {
                    int err;
                    int can_delay = 0;
                    struct cmd2process *entry;
                    struct child_process *process;
                    struct strbuf nbuf = STRBUF_INIT;
                    struct strbuf filter_status = STRBUF_INIT;
                    const char *filter_type;

                    if (!subprocess_map_initialized) {
                            subprocess_map_initialized = 1;
                            hashmap_init(&subprocess_map, cmd2process_cmp, NULL, 0);
                            entry = NULL;
                    } else {
                            entry = (struct cmd2process *)subprocess_find_entry(&subprocess_map, cmd);
                    }

                    fflush(NULL);

                    if (!entry) {
                            entry = xmalloc(sizeof(*entry));
                            entry->supported_capabilities = 0;

                            if (subprocess_start(&subprocess_map, &entry->subprocess, cmd, start_multi_file_filter_fn)) {
                                    free(entry);
                                    return 0;
                            }
                    }
                    process = &entry->subprocess.process;

                    if (!(entry->supported_capabilities & wanted_capability))
                            return 0;

                    if (wanted_capability & CAP_CLEAN)
                            filter_type = "clean";
                    else if (wanted_capability & CAP_SMUDGE)
                            filter_type = "smudge";
                    else
                            die(_("unexpected filter type"));

                    sigchain_push(SIGPIPE, SIG_IGN);

                    assert(strlen(filter_type) < LARGE_PACKET_DATA_MAX - strlen("command=\n"));
                    err = packet_write_fmt_gently(process->in, "command=%s\n", filter_type);
                    if (err)
                            goto done;

                    err = strlen(path) > LARGE_PACKET_DATA_MAX - strlen("pathname=\n");
                    if (err) {
                            error(_("path name too long for external filter"));
                            goto done;
                    }

                    err = packet_write_fmt_gently(process->in, "pathname=%s\n", path);
                    if (err)
                            goto done;

                    if (meta && meta->refname) {
                            err = packet_write_fmt_gently(process->in, "ref=%s\n", meta->refname);
                            if (err)
                                    goto done;
                    }

                    if (meta && !is_null_oid(&meta->treeish)) {
                            err = packet_write_fmt_gently(process->in, "treeish=%s\n", oid_to_hex(&meta->treeish));
                            if (err)
                                    goto done;
                    }

                    if (meta && !is_null_oid(&meta->blob)) {
                            err = packet_write_fmt_gently(process->in, "blob=%s\n", oid_to_hex(&meta->blob));
                            if (err)
                                    goto done;
                    }

                    if ((entry->supported_capabilities & CAP_DELAY) &&
                    dco && dco->state == CE_CAN_DELAY) {
                            can_delay = 1;
                            err = packet_write_fmt_gently(process->in, "can-delay=1\n");
                            if (err)
                                    goto done;
                    }

                    err = packet_flush_gently(process->in);
                    if (err)
                            goto done;

                    if (fd >= 0)
                            err = write_packetized_from_fd_no_flush(fd, process->in);
                    else
                            err = write_packetized_from_buf_no_flush(src, len, process->in);
                    if (err)
                            goto done;

                    err = packet_flush_gently(process->in);
                    if (err)
                            goto done;

                    err = subprocess_read_status(process->out, &filter_status);
                    if (err)
                            goto done;

                    if (can_delay && !strcmp(filter_status.buf, "delayed")) {
                            string_list_insert(&dco->filters, cmd);
                            string_list_insert(&dco->paths, path);
                    } else {
                            /* The filter got the blob and wants to send us a response. */
                            err = strcmp(filter_status.buf, "success");
                            if (err)
                                    goto done;

                            err = read_packetized_to_strbuf(process->out, &nbuf,
                                                            PACKET_READ_GENTLE_ON_EOF) < 0;
                            if (err)
                                    goto done;

                            err = subprocess_read_status(process->out, &filter_status);
                            if (err)
                                    goto done;

                            err = strcmp(filter_status.buf, "success");
                    }

            done:
                    sigchain_pop(SIGPIPE);

                    if (err)
                            handle_filter_error(&filter_status, entry, wanted_capability);
                    else
                            strbuf_swap(dst, &nbuf);
                    strbuf_release(&nbuf);
                    strbuf_release(&filter_status);
                    return !err;
            }


            int async_query_available_blobs(const char *cmd, struct string_list *available_paths)
            {
                    int err;
                    char *line;
                    struct cmd2process *entry;
                    struct child_process *process;
                    struct strbuf filter_status = STRBUF_INIT;

                    assert(subprocess_map_initialized);
                    entry = (struct cmd2process *)subprocess_find_entry(&subprocess_map, cmd);
                    if (!entry) {
                            error(_("external filter '%s' is not available anymore although "
                                    "not all paths have been filtered"), cmd);
                            return 0;
                    }
                    process = &entry->subprocess.process;
                    sigchain_push(SIGPIPE, SIG_IGN);

                    err = packet_write_fmt_gently(
                            process->in, "command=list_available_blobs\n");
                    if (err)
                            goto done;

                    err = packet_flush_gently(process->in);
                    if (err)
                            goto done;

                    while ((line = packet_read_line(process->out, NULL))) {
                            const char *path;
                            if (skip_prefix(line, "pathname=", &path))
                                    string_list_insert(available_paths, path);
                            else
                                    ; /* ignore unknown keys */
                    }

                    err = subprocess_read_status(process->out, &filter_status);
                    if (err)
                            goto done;

                    err = strcmp(filter_status.buf, "success");

            done:
                    sigchain_pop(SIGPIPE);

                    if (err)
                            handle_filter_error(&filter_status, entry, 0);
                    strbuf_release(&filter_status);
                    return !err;
            }

            static struct convert_driver {
                    const char *name;
                    struct convert_driver *next;
                    char *smudge;
                    char *clean;
                    char *process;
                    int required;
            } *user_convert, **user_convert_tail;

            static int apply_filter(const char *path, const char *src, size_t len,
                                    int fd, struct strbuf *dst, struct convert_driver *drv,
                                    const unsigned int wanted_capability,
                                    const struct checkout_metadata *meta,
                                    struct delayed_checkout *dco)
            {
                    const char *cmd = NULL;

                    if (!drv)
                            return 0;

                    if (!dst)
                            return 1;

                    if ((wanted_capability & CAP_CLEAN) && !drv->process && drv->clean)
                            cmd = drv->clean;
                    else if ((wanted_capability & CAP_SMUDGE) && !drv->process && drv->smudge)
                            cmd = drv->smudge;

                    if (cmd && *cmd)
                            return apply_single_file_filter(path, src, len, fd, dst, cmd);
                    else if (drv->process && *drv->process)
                            return apply_multi_file_filter(path, src, len, fd, dst,
                                    drv->process, wanted_capability, meta, dco);

                    return 0;
            }

            static int read_convert_config(const char *var, const char *value,
                                    const struct config_context *ctx UNUSED,
                                    void *cb UNUSED)
            {
                    const char *key, *name;
                    size_t namelen;
                    struct convert_driver *drv;

                    /*
                    * External conversion drivers are configured using
                    * "filter.<name>.variable".
                    */
                    if (parse_config_key(var, "filter", &name, &namelen, &key) < 0 || !name)
                            return 0;
                    for (drv = user_convert; drv; drv = drv->next)
                            if (!xstrncmpz(drv->name, name, namelen))
                                    break;
                    if (!drv) {
                            CALLOC_ARRAY(drv, 1);
                            drv->name = xmemdupz(name, namelen);
                            *user_convert_tail = drv;
                            user_convert_tail = &(drv->next);
                    }

                    /*
                    * filter.<name>.smudge and filter.<name>.clean specifies
                    * the command line:
                    *
                    *      command-line
                    *
                    * The command-line will not be interpolated in any way.
                    */

                    if (!strcmp("smudge", key)) {
                            FREE_AND_NULL(drv->smudge);
                            return git_config_string(&drv->smudge, var, value);
                    }

                    if (!strcmp("clean", key)) {
                            FREE_AND_NULL(drv->clean);
                            return git_config_string(&drv->clean, var, value);
                    }

                    if (!strcmp("process", key)) {
                            FREE_AND_NULL(drv->process);
                            return git_config_string(&drv->process, var, value);
                    }

                    if (!strcmp("required", key)) {
                            drv->required = git_config_bool(var, value);
                            return 0;
                    }

                    return 0;
            }

            static int count_ident(const char *cp, unsigned long size)
            {
                    /*
                    * "$Id: 0000000000000000000000000000000000000000 $" <=> "$Id$"
                    */
                    int cnt = 0;
                    char ch;

                    while (size) {
                            ch = *cp++;
                            size--;
                            if (ch != '$')
                                    continue;
                            if (size < 3)
                                    break;
                            if (memcmp("Id", cp, 2))
                                    continue;
                            ch = cp[2];
                            cp += 3;
                            size -= 3;
                            if (ch == '$')
                                    cnt++; /* $Id$ */
                            if (ch != ':')
                                    continue;

                            /*
                            * "$Id: ... "; scan up to the closing dollar sign and discard.
                            */
                            while (size) {
                                    ch = *cp++;
                                    size--;
                                    if (ch == '$') {
                                            cnt++;
                                            break;
                                    }
                                    if (ch == '\n')
                                            break;
                            }
                    }
                    return cnt;
            }

            static int ident_to_git(const char *src, size_t len,
                                    struct strbuf *buf, int ident)
            {
                    char *dst, *dollar;

                    if (!ident || (src && !count_ident(src, len)))
                            return 0;

                    if (!buf)
                            return 1;

                    /* only grow if not in place */
                    if (strbuf_avail(buf) + buf->len < len)
                            strbuf_grow(buf, len - buf->len);
                    dst = buf->buf;
                    for (;;) {
                            dollar = memchr(src, '$', len);
                            if (!dollar)
                                    break;
                            memmove(dst, src, dollar + 1 - src);
                            dst += dollar + 1 - src;
                            len -= dollar + 1 - src;
                            src  = dollar + 1;

                            if (len > 3 && !memcmp(src, "Id:", 3)) {
                                    dollar = memchr(src + 3, '$', len - 3);
                                    if (!dollar)
                                            break;
                                    if (memchr(src + 3, '\n', dollar - src - 3)) {
                                            /* Line break before the next dollar. */
                                            continue;
                                    }

                                    memcpy(dst, "Id$", 3);
                                    dst += 3;
                                    len -= dollar + 1 - src;
                                    src  = dollar + 1;
                            }
                    }
                    memmove(dst, src, len);
                    strbuf_setlen(buf, dst + len - buf->buf);
                    return 1;
            }

            static int ident_to_worktree(const char *src, size_t len,
                                    struct strbuf *buf, int ident)
            {
                    struct object_id oid;
                    char *to_free = NULL, *dollar, *spc;
                    int cnt;

                    if (!ident)
                            return 0;

                    cnt = count_ident(src, len);
                    if (!cnt)
                            return 0;

                    /* are we "faking" in place editing ? */
                    if (src == buf->buf)
                            to_free = strbuf_detach(buf, NULL);
                    hash_object_file(the_hash_algo, src, len, OBJ_BLOB, &oid);

                    strbuf_grow(buf, len + cnt * (the_hash_algo->hexsz + 3));
                    for (;;) {
                            /* step 1: run to the next '$' */
                            dollar = memchr(src, '$', len);
                            if (!dollar)
                                    break;
                            strbuf_add(buf, src, dollar + 1 - src);
                            len -= dollar + 1 - src;
                            src  = dollar + 1;

                            /* step 2: does it looks like a bit like Id:xxx$ or Id$ ? */
                            if (len < 3 || memcmp("Id", src, 2))
                                    continue;

                            /* step 3: skip over Id$ or Id:xxxxx$ */
                            if (src[2] == '$') {
                                    src += 3;
                                    len -= 3;
                            } else if (src[2] == ':') {
                                    /*
                                    * It's possible that an expanded Id has crept its way into the
                                    * repository, we cope with that by stripping the expansion out.
                                    * This is probably not a good idea, since it will cause changes
                                    * on checkout, which won't go away by stash, but let's keep it
                                    * for git-style ids.
                                    */
                                    dollar = memchr(src + 3, '$', len - 3);
                                    if (!dollar) {
                                            /* incomplete keyword, no more '$', so just quit the loop */
                                            break;
                                    }

                                    if (memchr(src + 3, '\n', dollar - src - 3)) {
                                            /* Line break before the next dollar. */
                                            continue;
                                    }

                                    spc = memchr(src + 4, ' ', dollar - src - 4);
                                    if (spc && spc < dollar-1) {
                                            /* There are spaces in unexpected places.
                                            * This is probably an id from some other
                                            * versioning system. Keep it for now.
                                            */
                                            continue;
                                    }

                                    len -= dollar + 1 - src;
                                    src  = dollar + 1;
                            } else {
                                    /* it wasn't a "Id$" or "Id:xxxx$" */
                                    continue;
                            }

                            /* step 4: substitute */
                            strbuf_addstr(buf, "Id: ");
                            strbuf_addstr(buf, oid_to_hex(&oid));
                            strbuf_addstr(buf, " $");
                    }
                    strbuf_add(buf, src, len);

                    free(to_free);
                    return 1;
            }

            static const char *git_path_check_encoding(struct attr_check_item *check)
            {
                    const char *value = check->value;

                    if (ATTR_UNSET(value) || !strlen(value))
                            return NULL;

                    if (ATTR_TRUE(value) || ATTR_FALSE(value)) {
                            die(_("true/false are no valid working-tree-encodings"));
                    }

                    /* Don't encode to the default encoding */
                    if (same_encoding(value, default_encoding))
                            return NULL;

                    return value;
            }

            static enum convert_crlf_action git_path_check_crlf(struct attr_check_item *check)
            {
                    const char *value = check->value;

                    if (ATTR_TRUE(value))
                            return CRLF_TEXT;
                    else if (ATTR_FALSE(value))
                            return CRLF_BINARY;
                    else if (ATTR_UNSET(value))
                            ;
                    else if (!strcmp(value, "input"))
                            return CRLF_TEXT_INPUT;
                    else if (!strcmp(value, "auto"))
                            return CRLF_AUTO;
                    return CRLF_UNDEFINED;
            }

            static enum eol git_path_check_eol(struct attr_check_item *check)
            {
                    const char *value = check->value;

                    if (ATTR_UNSET(value))
                            ;
                    else if (!strcmp(value, "lf"))
                            return EOL_LF;
                    else if (!strcmp(value, "crlf"))
                            return EOL_CRLF;
                    return EOL_UNSET;
            }

            static struct convert_driver *git_path_check_convert(struct attr_check_item *check)
            {
                    const char *value = check->value;
                    struct convert_driver *drv;

                    if (ATTR_TRUE(value) || ATTR_FALSE(value) || ATTR_UNSET(value))
                            return NULL;
                    for (drv = user_convert; drv; drv = drv->next)
                            if (!strcmp(value, drv->name))
                                    return drv;
                    return NULL;
            }

            static int git_path_check_ident(struct attr_check_item *check)
            {
                    const char *value = check->value;

                    return !!ATTR_TRUE(value);
            }

            static struct attr_check *check;

            static const char* get_platform() {
            struct utsname uname_info;

            if (uname(&uname_info))
                    die(_("uname() failed with error '%s' (%d)\n"),
                            strerror(errno),
                            errno);

            if (!strcmp(uname_info.sysname, "OS/390"))
            return "zos";
            return uname_info.sysname;
            }

            void convert_attrs(struct index_state *istate,
                            struct conv_attrs *ca, const char *path)
            {
                    struct attr_check_item *ccheck = NULL;
                    struct strbuf platform_working_tree_encoding = STRBUF_INIT;

                    strbuf_addf(&platform_working_tree_encoding, "%s-working-tree-encoding", get_platform());

                    if (!check) {
                            check = attr_check_initl("crlf", "ident", "filter",
                                                    "eol", "text", "working-tree-encoding",
                                                    platform_working_tree_encoding.buf,
                                                    NULL);
                            user_convert_tail = &user_convert;
                            git_config(read_convert_config, NULL);
                    }
                            strbuf_release(&platform_working_tree_encoding);

                    git_check_attr(istate, path, check);
                    ccheck = check->items;
                    ca->crlf_action = git_path_check_crlf(ccheck + 4);
                    if (ca->crlf_action == CRLF_UNDEFINED)
                            ca->crlf_action = git_path_check_crlf(ccheck + 0);
                    ca->ident = git_path_check_ident(ccheck + 1);
                    ca->drv = git_path_check_convert(ccheck + 2);
                    if (ca->crlf_action != CRLF_BINARY) {
                            enum eol eol_attr = git_path_check_eol(ccheck + 3);
                            if (ca->crlf_action == CRLF_AUTO && eol_attr == EOL_LF)
                                    ca->crlf_action = CRLF_AUTO_INPUT;
                            else if (ca->crlf_action == CRLF_AUTO && eol_attr == EOL_CRLF)
                                    ca->crlf_action = CRLF_AUTO_CRLF;
                            else if (eol_attr == EOL_LF)
                                    ca->crlf_action = CRLF_TEXT_INPUT;
                            else if (eol_attr == EOL_CRLF)
                                    ca->crlf_action = CRLF_TEXT_CRLF;
                    }
                    ca->working_tree_encoding = git_path_check_encoding(ccheck + 5);
                    if (git_path_check_encoding(ccheck + 6))
                    ca->working_tree_encoding = git_path_check_encoding(ccheck + 6);

                    /* Save attr and make a decision for action */
                    ca->attr_action = ca->crlf_action;
                    if (ca->crlf_action == CRLF_TEXT)
                            ca->crlf_action = text_eol_is_crlf() ? CRLF_TEXT_CRLF : CRLF_TEXT_INPUT;
                    if (ca->crlf_action == CRLF_UNDEFINED && auto_crlf == AUTO_CRLF_FALSE)
                            ca->crlf_action = CRLF_BINARY;
                    if (ca->crlf_action == CRLF_UNDEFINED && auto_crlf == AUTO_CRLF_TRUE)
                            ca->crlf_action = CRLF_AUTO_CRLF;
                    if (ca->crlf_action == CRLF_UNDEFINED && auto_crlf == AUTO_CRLF_INPUT)
                            ca->crlf_action = CRLF_AUTO_INPUT;
            }

            void reset_parsed_attributes(void)
            {
                    struct convert_driver *drv, *next;

                    attr_check_free(check);
                    check = NULL;
                    reset_merge_attributes();

                    for (drv = user_convert; drv; drv = next) {
                            next = drv->next;
                            free((void *)drv->name);
                            free((void *)drv->smudge);
                            free((void *)drv->clean);
                            free((void *)drv->process);
                            free(drv);
                    }
                    user_convert = NULL;
                    user_convert_tail = NULL;
            }

            int would_convert_to_git_filter_fd(struct index_state *istate, const char *path)
            {
                    struct conv_attrs ca;

                    convert_attrs(istate, &ca, path);
                    if (!ca.drv)
                            return 0;

                    /*
                    * Apply a filter to an fd only if the filter is required to succeed.
                    * We must die if the filter fails, because the original data before
                    * filtering is not available.
                    */
                    if (!ca.drv->required)
                            return 0;

                    return apply_filter(path, NULL, 0, -1, NULL, ca.drv, CAP_CLEAN, NULL, NULL);
            }

            const char *get_convert_attr_ascii(struct index_state *istate, const char *path)
            {
                    struct conv_attrs ca;

                    convert_attrs(istate, &ca, path);
                    switch (ca.attr_action) {
                    case CRLF_UNDEFINED:
                            return "";
                    case CRLF_BINARY:
                            return "-text";
                    case CRLF_TEXT:
                            return "text";
                    case CRLF_TEXT_INPUT:
                            return "text eol=lf";
                    case CRLF_TEXT_CRLF:
                            return "text eol=crlf";
                    case CRLF_AUTO:
                            return "text=auto";
                    case CRLF_AUTO_CRLF:
                            return "text=auto eol=crlf";
                    case CRLF_AUTO_INPUT:
                            return "text=auto eol=lf";
                    }
                    return "";
            }

            int convert_to_git(struct index_state *istate,
                            const char *path, const char *src, size_t len,
                            struct strbuf *dst, int conv_flags)
            {
                    int ret = 0;
                    struct conv_attrs ca;

                    convert_attrs(istate, &ca, path);

                    ret |= apply_filter(path, src, len, -1, dst, ca.drv, CAP_CLEAN, NULL, NULL);
                    if (!ret && ca.drv && ca.drv->required)
                            die(_("%s: clean filter '%s' failed"), path, ca.drv->name);

                    if (ret && dst) {
                            src = dst->buf;
                            len = dst->len;
                    }

                    ret |= encode_to_git(path, src, len, dst, ca.working_tree_encoding, ca.attr_action, conv_flags);
                    if (ret && dst) {
                            src = dst->buf;
                            len = dst->len;
                    }

                    if (!(conv_flags & CONV_EOL_KEEP_CRLF)) {
                            ret |= crlf_to_git(istate, path, src, len, dst, ca.crlf_action, conv_flags);
                            if (ret && dst) {
                                    src = dst->buf;
                                    len = dst->len;
                            }
                    }
                    return ret | ident_to_git(src, len, dst, ca.ident);
            }

            void convert_to_git_filter_fd(struct index_state *istate,
                                    const char *path, int fd, struct strbuf *dst,
                                    int conv_flags)
            {
                    struct conv_attrs ca;
                    convert_attrs(istate, &ca, path);

                    assert(ca.drv);

                    if (!apply_filter(path, NULL, 0, fd, dst, ca.drv, CAP_CLEAN, NULL, NULL))
                            die(_("%s: clean filter '%s' failed"), path, ca.drv->name);

                    encode_to_git(path, dst->buf, dst->len, dst, ca.working_tree_encoding, ca.attr_action, conv_flags);
                    crlf_to_git(istate, path, dst->buf, dst->len, dst, ca.crlf_action, conv_flags);
                    ident_to_git(dst->buf, dst->len, dst, ca.ident);
            }

            static int convert_to_working_tree_ca_internal(const struct conv_attrs *ca,
                                                    const char *path, const char *src,
                                                    size_t len, struct strbuf *dst,
                                                    int normalizing,
                                                    const struct checkout_metadata *meta,
                                                    struct delayed_checkout *dco)
            {
                    int ret = 0, ret_filter = 0;

                    ret |= ident_to_worktree(src, len, dst, ca->ident);
                    if (ret) {
                            src = dst->buf;
                            len = dst->len;
                    }
                    /*
                    * CRLF conversion can be skipped if normalizing, unless there
                    * is a smudge or process filter (even if the process filter doesn't
                    * support smudge).  The filters might expect CRLFs.
                    */
                    if ((ca->drv && (ca->drv->smudge || ca->drv->process)) || !normalizing) {
                            ret |= crlf_to_worktree(src, len, dst, ca->crlf_action);
                            if (ret) {
                                    src = dst->buf;
                                    len = dst->len;
                            }
                    }

                    ret |= encode_to_worktree(path, src, len, dst, ca->attr_action, ca->working_tree_encoding);
                    if (ret) {
                            src = dst->buf;
                            len = dst->len;
                    }

                    ret_filter = apply_filter(
                            path, src, len, -1, dst, ca->drv, CAP_SMUDGE, meta, dco);
                    if (!ret_filter && ca->drv && ca->drv->required)
                            die(_("%s: smudge filter %s failed"), path, ca->drv->name);

                    return ret | ret_filter;
            }

            int async_convert_to_working_tree_ca(const struct conv_attrs *ca,
                                            const char *path, const char *src,
                                            size_t len, struct strbuf *dst,
                                            const struct checkout_metadata *meta,
                                            void *dco)
            {
                    return convert_to_working_tree_ca_internal(ca, path, src, len, dst, 0,
                                                            meta, dco);
            }

            int convert_to_working_tree_ca(const struct conv_attrs *ca,
                                    const char *path, const char *src,
                                    size_t len, struct strbuf *dst,
                                    const struct checkout_metadata *meta)
            {
                    return convert_to_working_tree_ca_internal(ca, path, src, len, dst, 0,
                                                            meta, NULL);
            }

            int renormalize_buffer(struct index_state *istate, const char *path,
                            const char *src, size_t len, struct strbuf *dst)
            {
                    struct conv_attrs ca;
                    int ret;

                    convert_attrs(istate, &ca, path);
                    ret = convert_to_working_tree_ca_internal(&ca, path, src, len, dst, 1,
                                                            NULL, NULL);
                    if (ret) {
                            src = dst->buf;
                            len = dst->len;
                    }
                    return ret | convert_to_git(istate, path, src, len, dst, CONV_EOL_RENORMALIZE);
            }

            /*****************************************************************
            *
            * Streaming conversion support
            *
            *****************************************************************/

            typedef int (*filter_fn)(struct stream_filter *,
                                    const char *input, size_t *isize_p,
                                    char *output, size_t *osize_p);
            typedef void (*free_fn)(struct stream_filter *);

            struct stream_filter_vtbl {
                    filter_fn filter;
                    free_fn free;
            };

            struct stream_filter {
                    struct stream_filter_vtbl *vtbl;
            };

            static int null_filter_fn(struct stream_filter *filter UNUSED,
                                    const char *input, size_t *isize_p,
                                    char *output, size_t *osize_p)
            {
                    size_t count;

                    if (!input)
                            return 0; /* we do not keep any states */
                    count = *isize_p;
                    if (*osize_p < count)
                            count = *osize_p;
                    if (count) {
                            memmove(output, input, count);
                            *isize_p -= count;
                            *osize_p -= count;
                    }
                    return 0;
            }

            static void null_free_fn(struct stream_filter *filter UNUSED)
            {
                    ; /* nothing -- null instances are shared */
            }

            static struct stream_filter_vtbl null_vtbl = {
                    .filter = null_filter_fn,
                    .free = null_free_fn,
            };

            static struct stream_filter null_filter_singleton = {
                    .vtbl = &null_vtbl,
            };

            int is_null_stream_filter(struct stream_filter *filter)
            {
                    return filter == &null_filter_singleton;
            }


            /*
            * LF-to-CRLF filter
            */

            struct lf_to_crlf_filter {
                    struct stream_filter filter;
                    unsigned has_held:1;
                    char held;
            };

            static int lf_to_crlf_filter_fn(struct stream_filter *filter,
                                            const char *input, size_t *isize_p,
                                            char *output, size_t *osize_p)
            {
                    size_t count, o = 0;
                    struct lf_to_crlf_filter *lf_to_crlf = (struct lf_to_crlf_filter *)filter;

                    /*
                    * We may be holding onto the CR to see if it is followed by a
                    * LF, in which case we would need to go to the main loop.
                    * Otherwise, just emit it to the output stream.
                    */
                    if (lf_to_crlf->has_held && (lf_to_crlf->held != '\r' || !input)) {
                            output[o++] = lf_to_crlf->held;
                            lf_to_crlf->has_held = 0;
                    }

                    /* We are told to drain */
                    if (!input) {
                            *osize_p -= o;
                            return 0;
                    }

                    count = *isize_p;
                    if (count || lf_to_crlf->has_held) {
                            size_t i;
                            int was_cr = 0;

                            if (lf_to_crlf->has_held) {
                                    was_cr = 1;
                                    lf_to_crlf->has_held = 0;
                            }

                            for (i = 0; o < *osize_p && i < count; i++) {
                                    char ch = input[i];

                                    if (ch == '\n') {
                                            output[o++] = '\r';
                                    } else if (was_cr) {
                                            /*
                                            * Previous round saw CR and it is not followed
                                            * by a LF; emit the CR before processing the
                                            * current character.
                                            */
                                            output[o++] = '\r';
                                    }

                                    /*
                                    * We may have consumed the last output slot,
                                    * in which case we need to break out of this
                                    * loop; hold the current character before
                                    * returning.
                                    */
                                    if (*osize_p <= o) {
                                            lf_to_crlf->has_held = 1;
                                            lf_to_crlf->held = ch;
                                            continue; /* break but increment i */
                                    }

                                    if (ch == '\r') {
                                            was_cr = 1;
                                            continue;
                                    }

                                    was_cr = 0;
                                    output[o++] = ch;
                            }

                            *osize_p -= o;
                            *isize_p -= i;

                            if (!lf_to_crlf->has_held && was_cr) {
                                    lf_to_crlf->has_held = 1;
                                    lf_to_crlf->held = '\r';
                            }
                    }
                    return 0;
            }

            static void lf_to_crlf_free_fn(struct stream_filter *filter)
            {
                    free(filter);
            }

            static struct stream_filter_vtbl lf_to_crlf_vtbl = {
                    .filter = lf_to_crlf_filter_fn,
                    .free = lf_to_crlf_free_fn,
            };

            static struct stream_filter *lf_to_crlf_filter(void)
            {
                    struct lf_to_crlf_filter *lf_to_crlf = xcalloc(1, sizeof(*lf_to_crlf));

                    lf_to_crlf->filter.vtbl = &lf_to_crlf_vtbl;
                    return (struct stream_filter *)lf_to_crlf;
            }

            /*
            * Cascade filter
            */
            #define FILTER_BUFFER 1024
            struct cascade_filter {
                    struct stream_filter filter;
                    struct stream_filter *one;
                    struct stream_filter *two;
                    char buf[FILTER_BUFFER];
                    int end, ptr;
            };

            static int cascade_filter_fn(struct stream_filter *filter,
                                    const char *input, size_t *isize_p,
                                    char *output, size_t *osize_p)
            {
                    struct cascade_filter *cas = (struct cascade_filter *) filter;
                    size_t filled = 0;
                    size_t sz = *osize_p;
                    size_t to_feed, remaining;

                    /*
                    * input -- (one) --> buf -- (two) --> output
                    */
                    while (filled < sz) {
                            remaining = sz - filled;

                            /* do we already have something to feed two with? */
                            if (cas->ptr < cas->end) {
                                    to_feed = cas->end - cas->ptr;
                                    if (stream_filter(cas->two,
                                                    cas->buf + cas->ptr, &to_feed,
                                                    output + filled, &remaining))
                                            return -1;
                                    cas->ptr += (cas->end - cas->ptr) - to_feed;
                                    filled = sz - remaining;
                                    continue;
                            }

                            /* feed one from upstream and have it emit into our buffer */
                            to_feed = input ? *isize_p : 0;
                            if (input && !to_feed)
                                    break;
                            remaining = sizeof(cas->buf);
                            if (stream_filter(cas->one,
                                            input, &to_feed,
                                            cas->buf, &remaining))
                                    return -1;
                            cas->end = sizeof(cas->buf) - remaining;
                            cas->ptr = 0;
                            if (input) {
                                    size_t fed = *isize_p - to_feed;
                                    *isize_p -= fed;
                                    input += fed;
                            }

                            /* do we know that we drained one completely? */
                            if (input || cas->end)
                                    continue;

                            /* tell two to drain; we have nothing more to give it */
                            to_feed = 0;
                            remaining = sz - filled;
                            if (stream_filter(cas->two,
                                            NULL, &to_feed,
                                            output + filled, &remaining))
                                    return -1;
                            if (remaining == (sz - filled))
                                    break; /* completely drained two */
                            filled = sz - remaining;
                    }
                    *osize_p -= filled;
                    return 0;
            }

            static void cascade_free_fn(struct stream_filter *filter)
            {
                    struct cascade_filter *cas = (struct cascade_filter *)filter;
                    free_stream_filter(cas->one);
                    free_stream_filter(cas->two);
                    free(filter);
            }

            static struct stream_filter_vtbl cascade_vtbl = {
                    .filter = cascade_filter_fn,
                    .free = cascade_free_fn,
            };

            static struct stream_filter *cascade_filter(struct stream_filter *one,
                                                    struct stream_filter *two)
            {
                    struct cascade_filter *cascade;

                    if (!one || is_null_stream_filter(one))
                            return two;
                    if (!two || is_null_stream_filter(two))
                            return one;

                    cascade = xmalloc(sizeof(*cascade));
                    cascade->one = one;
                    cascade->two = two;
                    cascade->end = cascade->ptr = 0;
                    cascade->filter.vtbl = &cascade_vtbl;
                    return (struct stream_filter *)cascade;
            }

            /*
            * ident filter
            */
            #define IDENT_DRAINING (-1)
            #define IDENT_SKIPPING (-2)
            struct ident_filter {
                    struct stream_filter filter;
                    struct strbuf left;
                    int state;
                    char ident[GIT_MAX_HEXSZ + 5]; /* ": x40 $" */
            };

            static int is_foreign_ident(const char *str)
            {
                    int i;

                    if (!skip_prefix(str, "$Id: ", &str))
                            return 0;
                    for (i = 0; str[i]; i++) {
                            if (isspace(str[i]) && str[i+1] != '$')
                                    return 1;
                    }
                    return 0;
            }

            static void ident_drain(struct ident_filter *ident, char **output_p, size_t *osize_p)
            {
                    size_t to_drain = ident->left.len;

                    if (*osize_p < to_drain)
                            to_drain = *osize_p;
                    if (to_drain) {
                            memcpy(*output_p, ident->left.buf, to_drain);
                            strbuf_remove(&ident->left, 0, to_drain);
                            *output_p += to_drain;
                            *osize_p -= to_drain;
                    }
                    if (!ident->left.len)
                            ident->state = 0;
            }

            static int ident_filter_fn(struct stream_filter *filter,
                                    const char *input, size_t *isize_p,
                                    char *output, size_t *osize_p)
            {
                    struct ident_filter *ident = (struct ident_filter *)filter;
                    static const char head[] = "$Id";

                    if (!input) {
                            /* drain upon eof */
                            switch (ident->state) {
                            default:
                                    strbuf_add(&ident->left, head, ident->state);
                                    /* fallthrough */
                            case IDENT_SKIPPING:
                                    /* fallthrough */
                            case IDENT_DRAINING:
                                    ident_drain(ident, &output, osize_p);
                            }
                            return 0;
                    }

                    while (*isize_p || (ident->state == IDENT_DRAINING)) {
                            int ch;

                            if (ident->state == IDENT_DRAINING) {
                                    ident_drain(ident, &output, osize_p);
                                    if (!*osize_p)
                                            break;
                                    continue;
                            }

                            ch = *(input++);
                            (*isize_p)--;

                            if (ident->state == IDENT_SKIPPING) {
                                    /*
                                    * Skipping until '$' or LF, but keeping them
                                    * in case it is a foreign ident.
                                    */
                                    strbuf_addch(&ident->left, ch);
                                    if (ch != '\n' && ch != '$')
                                            continue;
                                    if (ch == '$' && !is_foreign_ident(ident->left.buf)) {
                                            strbuf_setlen(&ident->left, sizeof(head) - 1);
                                            strbuf_addstr(&ident->left, ident->ident);
                                    }
                                    ident->state = IDENT_DRAINING;
                                    continue;
                            }

                            if (ident->state < sizeof(head) &&
                            head[ident->state] == ch) {
                                    ident->state++;
                                    continue;
                            }

                            if (ident->state)
                                    strbuf_add(&ident->left, head, ident->state);
                            if (ident->state == sizeof(head) - 1) {
                                    if (ch != ':' && ch != '$') {
                                            strbuf_addch(&ident->left, ch);
                                            ident->state = 0;
                                            continue;
                                    }

                                    if (ch == ':') {
                                            strbuf_addch(&ident->left, ch);
                                            ident->state = IDENT_SKIPPING;
                                    } else {
                                            strbuf_addstr(&ident->left, ident->ident);
                                            ident->state = IDENT_DRAINING;
                                    }
                                    continue;
                            }

                            strbuf_addch(&ident->left, ch);
                            ident->state = IDENT_DRAINING;
                    }
                    return 0;
            }

            static void ident_free_fn(struct stream_filter *filter)
            {
                    struct ident_filter *ident = (struct ident_filter *)filter;
                    strbuf_release(&ident->left);
                    free(filter);
            }

            static struct stream_filter_vtbl ident_vtbl = {
                    .filter = ident_filter_fn,
                    .free = ident_free_fn,
            };

            static struct stream_filter *ident_filter(const struct object_id *oid)
            {
                    struct ident_filter *ident = xmalloc(sizeof(*ident));

                    xsnprintf(ident->ident, sizeof(ident->ident),
                            ": %s $", oid_to_hex(oid));
                    strbuf_init(&ident->left, 0);
                    ident->filter.vtbl = &ident_vtbl;
                    ident->state = 0;
                    return (struct stream_filter *)ident;
            }

            /*
            * Return an appropriately constructed filter for the given ca, or NULL if
            * the contents cannot be filtered without reading the whole thing
            * in-core.
            *
            * Note that you would be crazy to set CRLF, smudge/clean or ident to a
            * large binary blob you would want us not to slurp into the memory!
            */
            struct stream_filter *get_stream_filter_ca(const struct conv_attrs *ca,
                                                    const struct object_id *oid)
            {
                    struct stream_filter *filter = NULL;

                    if (classify_conv_attrs(ca) != CA_CLASS_STREAMABLE)
                            return NULL;

                    if (ca->ident)
                            filter = ident_filter(oid);

                    if (output_eol(ca->crlf_action) == EOL_CRLF)
                            filter = cascade_filter(filter, lf_to_crlf_filter());
                    else
                            filter = cascade_filter(filter, &null_filter_singleton);

                    return filter;
            }

            struct stream_filter *get_stream_filter(struct index_state *istate,
                                                    const char *path,
                                                    const struct object_id *oid)
            {
                    struct conv_attrs ca;
                    convert_attrs(istate, &ca, path);
                    return get_stream_filter_ca(&ca, oid);
            }

            void free_stream_filter(struct stream_filter *filter)
            {
                    filter->vtbl->free(filter);
            }

            int stream_filter(struct stream_filter *filter,
                            const char *input, size_t *isize_p,
                            char *output, size_t *osize_p)
            {
                    return filter->vtbl->filter(filter, input, isize_p, output, osize_p);
            }

            void init_checkout_metadata(struct checkout_metadata *meta, const char *refname,
                                    const struct object_id *treeish,
                                    const struct object_id *blob)
            {
                    memset(meta, 0, sizeof(*meta));
                    if (refname)
                            meta->refname = refname;
                    if (treeish)
                            oidcpy(&meta->treeish, treeish);
                    if (blob)
                            oidcpy(&meta->blob, blob);
            }

            void clone_checkout_metadata(struct checkout_metadata *dst,
                                    const struct checkout_metadata *src,
                                    const struct object_id *blob)
            {
                    memcpy(dst, src, sizeof(*dst));
                    if (blob)
                            oidcpy(&dst->blob, blob);
            }

            enum conv_attrs_classification classify_conv_attrs(const struct conv_attrs *ca)
            {
                    if (ca->drv) {
                            if (ca->drv->process)
                                    return CA_CLASS_INCORE_PROCESS;
                            if (ca->drv->smudge || ca->drv->clean)
                                    return CA_CLASS_INCORE_FILTER;
                    }

                    if (ca->working_tree_encoding)
                            return CA_CLASS_INCORE;

                    if (ca->crlf_action == CRLF_AUTO || ca->crlf_action == CRLF_AUTO_CRLF)
                            return CA_CLASS_INCORE;

                    return CA_CLASS_STREAMABLE;
            }


      """,
      "Patche":
      """
                    diff --git a/convert.c b/convert.c
            index c4ddc4de81..010515a085 100644
            --- a/convert.c
            +++ b/convert.c
            @@ -5,6 +5,7 @@
            #include "config.h"
            #include "convert.h"
            #include "copy.h"
            +#include "environment.h"
            #include "gettext.h"
            #include "hex.h"
            #include "object-store-ll.h"
            @@ -384,12 +385,16 @@ static int check_roundtrip(const char *enc_name)
            static const char *default_encoding = "UTF-8";

            static int encode_to_git(const char *path, const char *src, size_t src_len,
            -            struct strbuf *buf, const char *enc, int conv_flags)
            +            struct strbuf *buf, const char *enc,
            +            enum convert_crlf_action attr_action, int conv_flags)
            {
                    char *dst;
                    size_t dst_len;
                    int die_on_error = conv_flags & CONV_WRITE_OBJECT;

            +   if (attr_action == CRLF_BINARY) {
            +       return 0;
            +   }
                    /*
                    * No encoding is specified or there is nothing to encode.
                    * Tell the caller that the content was not modified.
            @@ -410,6 +415,12 @@ static int encode_to_git(const char *path, const char *src, size_t src_len,
                            return 0;

                    trace_encoding("source", path, enc, src, src_len);
            +#ifdef __MVS__
            +  // If UTF CCSID == 819 (ISO8859-1), do not convert ISO8859-1 tagged files
            +  if (utf8_ccsid == 819 && strcasecmp("ISO8859-1", enc) == 0)
            +   return 0;
            +#endif
            +
                    dst = reencode_string_len(src, src_len, default_encoding, enc,
                                            &dst_len);
                    if (!dst) {
            @@ -419,6 +430,9 @@ static int encode_to_git(const char *path, const char *src, size_t src_len,
                            * would fail and we would leave the user with a messed-up
                            * working tree. Let's try to avoid this by screaming loud.
                            */
            +          if (attr_action == CRLF_BINARY) {
            +           return 0;
            +       }
                            const char* msg = _("failed to encode '%s' from %s to %s");
                            if (die_on_error)
                                    die(msg, path, enc, default_encoding);
            @@ -475,10 +489,14 @@ static int encode_to_git(const char *path, const char *src, size_t src_len,
            }

            static int encode_to_worktree(const char *path, const char *src, size_t src_len,
            -                 struct strbuf *buf, const char *enc)
            +                 struct strbuf *buf, enum convert_crlf_action attr_action,
            +                 const char *enc)
            {
                    char *dst;
                    size_t dst_len;
            +if (attr_action == CRLF_BINARY) {
            +    return 0;
            +}

                    /*
                    * No encoding is specified or there is nothing to encode.
            @@ -1309,18 +1327,36 @@ static int git_path_check_ident(struct attr_check_item *check)

            static struct attr_check *check;

            +static const char* get_platform() {
            +       struct utsname uname_info;
            +
            +       if (uname(&uname_info))
            +   die(_("uname() failed with error '%s' (%d)\n"),
            +       strerror(errno),
            +       errno);
            +
            +  if (!strcmp(uname_info.sysname, "OS/390"))
            +    return "zos";
            +  return uname_info.sysname;
            +}
            +
            void convert_attrs(struct index_state *istate,
                            struct conv_attrs *ca, const char *path)
            {
                    struct attr_check_item *ccheck = NULL;
            +   struct strbuf platform_working_tree_encoding = STRBUF_INIT;
            +
            +   strbuf_addf(&platform_working_tree_encoding, "%s-working-tree-encoding", get_platform());

                    if (!check) {
                            check = attr_check_initl("crlf", "ident", "filter",
                                                    "eol", "text", "working-tree-encoding",
            +                    platform_working_tree_encoding.buf,
                                                    NULL);
                            user_convert_tail = &user_convert;
                            git_config(read_convert_config, NULL);
                    }
            +       strbuf_release(&platform_working_tree_encoding);

                    git_check_attr(istate, path, check);
                    ccheck = check->items;
            @@ -1341,6 +1377,8 @@ void convert_attrs(struct index_state *istate,
                                    ca->crlf_action = CRLF_TEXT_CRLF;
                    }
                    ca->working_tree_encoding = git_path_check_encoding(ccheck + 5);
            +   if (git_path_check_encoding(ccheck + 6))
            +       ca->working_tree_encoding = git_path_check_encoding(ccheck + 6);

                    /* Save attr and make a decision for action */
                    ca->attr_action = ca->crlf_action;
            @@ -1434,7 +1472,7 @@ int convert_to_git(struct index_state *istate,
                            len = dst->len;
                    }

            -   ret |= encode_to_git(path, src, len, dst, ca.working_tree_encoding, conv_flags);
            +   ret |= encode_to_git(path, src, len, dst, ca.working_tree_encoding, ca.attr_action, conv_flags);
                    if (ret && dst) {
                            src = dst->buf;
                            len = dst->len;
            @@ -1462,7 +1500,7 @@ void convert_to_git_filter_fd(struct index_state *istate,
                    if (!apply_filter(path, NULL, 0, fd, dst, ca.drv, CAP_CLEAN, NULL, NULL))
                            die(_("%s: clean filter '%s' failed"), path, ca.drv->name);

            -   encode_to_git(path, dst->buf, dst->len, dst, ca.working_tree_encoding, conv_flags);
            +   encode_to_git(path, dst->buf, dst->len, dst, ca.working_tree_encoding, ca.attr_action, conv_flags);
                    crlf_to_git(istate, path, dst->buf, dst->len, dst, ca.crlf_action, conv_flags);
                    ident_to_git(dst->buf, dst->len, dst, ca.ident);
            }
            @@ -1494,7 +1532,7 @@ static int convert_to_working_tree_ca_internal(const struct conv_attrs *ca,
                            }
                    }

            -   ret |= encode_to_worktree(path, src, len, dst, ca->working_tree_encoding);
            +   ret |= encode_to_worktree(path, src, len, dst, ca->attr_action, ca->working_tree_encoding);
                    if (ret) {
                            src = dst->buf;
                            len = dst->len;
      """,

        },

        {

           "Wrong code":

           """
                    #include "git-compat-util.h"
            #include "copy.h"
            #include "path.h"
            #include "gettext.h"
            #include "strbuf.h"
            #include "abspath.h"

            int copy_fd(int ifd, int ofd)
            {
                    while (1) {
                            char buffer[8192];
                            ssize_t len = xread(ifd, buffer, sizeof(buffer));
                            if (!len)
                                    break;
                            if (len < 0)
                                    return COPY_READ_ERROR;
                            if (write_in_full(ofd, buffer, len) < 0)
                                    return COPY_WRITE_ERROR;
                    }
                    return 0;
            }

            static int copy_times(const char *dst, const char *src)
            {
                    struct stat st;
                    struct utimbuf times;
                    if (stat(src, &st) < 0)
                            return -1;
                    times.actime = st.st_atime;
                    times.modtime = st.st_mtime;
                    if (utime(dst, &times) < 0)
                            return -1;
                    return 0;
            }

            int copy_file(const char *dst, const char *src, int mode)
            {
                    int fdi, fdo, status;

                    mode = (mode & 0111) ? 0777 : 0666;
                    if ((fdi = open(src, O_RDONLY)) < 0)
                            return fdi;
                    if ((fdo = open(dst, O_WRONLY | O_CREAT | O_EXCL, mode)) < 0) {
                            close(fdi);
                            return fdo;
                    }
                    status = copy_fd(fdi, fdo);
                    switch (status) {
                    case COPY_READ_ERROR:
                            error_errno("copy-fd: read returned");
                            break;
                    case COPY_WRITE_ERROR:
                            error_errno("copy-fd: write returned");
                            break;
                    }
                    close(fdi);
                    if (close(fdo) != 0)
                            return error_errno("%s: close error", dst);

                    if (!status && adjust_shared_perm(dst))
                            return -1;

                    return status;
            }

            int copy_file_with_time(const char *dst, const char *src, int mode)
            {
                    int status = copy_file(dst, src, mode);
                    if (!status)
                            return copy_times(dst, src);
                    return status;
            }

           """,
           "error":"The patch ensures that files copied between file descriptors on z/OS are correctly processed, accounting for encoding
                     differences and ensuring that no data corruption occurs during the copy process.",
           "Error Category":"Functionality Patch",

           "Corrected code":
           """
                    #include "git-compat-util.h"
            #include "copy.h"
            #include "path.h"
            #include "gettext.h"
            #include "strbuf.h"
            #include "abspath.h"

            int copy_fd(int ifd, int ofd)
            {
                    while (1) {
                            char buffer[8192];
                            ssize_t len = xread(ifd, buffer, sizeof(buffer));
                            if (!len)
                                    break;
                            if (len < 0)
                                    return COPY_READ_ERROR;
                            if (write_in_full(ofd, buffer, len) < 0)
                                    return COPY_WRITE_ERROR;
                    }
            #ifdef __MVS__
            __copyfdccsid(ifd, ofd);
            #endif
                    return 0;
            }

            static int copy_times(const char *dst, const char *src)
            {
                    struct stat st;
                    struct utimbuf times;
                    if (stat(src, &st) < 0)
                            return -1;
                    times.actime = st.st_atime;
                    times.modtime = st.st_mtime;
                    if (utime(dst, &times) < 0)
                            return -1;
                    return 0;
            }

            int copy_file(const char *dst, const char *src, int mode)
            {
                    int fdi, fdo, status;

                    mode = (mode & 0111) ? 0777 : 0666;
                    if ((fdi = open(src, O_RDONLY)) < 0)
                            return fdi;
                    if ((fdo = open(dst, O_WRONLY | O_CREAT | O_EXCL, mode)) < 0) {
                            close(fdi);
                            return fdo;
                    }
                    status = copy_fd(fdi, fdo);
                    switch (status) {
                    case COPY_READ_ERROR:
                            error_errno("copy-fd: read returned");
                            break;
                    case COPY_WRITE_ERROR:
                            error_errno("copy-fd: write returned");
                            break;
                    }
                    close(fdi);
                    if (close(fdo) != 0)
                            return error_errno("%s: close error", dst);

                    if (!status && adjust_shared_perm(dst))
                            return -1;

                    return status;
            }

            int copy_file_with_time(const char *dst, const char *src, int mode)
            {
                    int status = copy_file(dst, src, mode);
                    if (!status)
                            return copy_times(dst, src);
                    return status;
            }

           """,
           "patche":

           """
                    diff --git a/copy.c b/copy.c
            index 4de6a11..c5584d4 100644
            --- a/copy.c
            +++ b/copy.c
            @@ -12,6 +12,9 @@ int copy_fd(int ifd, int ofd)
                            if (write_in_full(ofd, buffer, len) < 0)
                                    return COPY_WRITE_ERROR;
                    }
            +#ifdef __MVS__
            +  __copyfdccsid(ifd, ofd);
            +#endif
                    return 0;
            }


           """,

            },

     {
            "Wrong Code":
            """
                            /*
            * Copyright (C) 2005 Junio C Hamano
            */

            #define USE_THE_REPOSITORY_VARIABLE
            #define DISABLE_SIGN_COMPARE_WARNINGS

            #include "git-compat-util.h"
            #include "abspath.h"
            #include "base85.h"
            #include "config.h"
            #include "convert.h"
            #include "environment.h"
            #include "gettext.h"
            #include "tempfile.h"
            #include "revision.h"
            #include "quote.h"
            #include "diff.h"
            #include "diffcore.h"
            #include "delta.h"
            #include "hex.h"
            #include "xdiff-interface.h"
            #include "color.h"
            #include "run-command.h"
            #include "utf8.h"
            #include "object-store-ll.h"
            #include "userdiff.h"
            #include "submodule.h"
            #include "hashmap.h"
            #include "mem-pool.h"
            #include "merge-ll.h"
            #include "string-list.h"
            #include "strvec.h"
            #include "tmp-objdir.h"
            #include "graph.h"
            #include "oid-array.h"
            #include "packfile.h"
            #include "pager.h"
            #include "parse-options.h"
            #include "help.h"
            #include "promisor-remote.h"
            #include "dir.h"
            #include "object-file.h"
            #include "object-name.h"
            #include "read-cache-ll.h"
            #include "setup.h"
            #include "strmap.h"
            #include "ws.h"

            #ifdef NO_FAST_WORKING_DIRECTORY
            #define FAST_WORKING_DIRECTORY 0
            #else
            #define FAST_WORKING_DIRECTORY 1
            #endif

            static int diff_detect_rename_default;
            static int diff_indent_heuristic = 1;
            static int diff_rename_limit_default = 1000;
            static int diff_suppress_blank_empty;
            static int diff_use_color_default = -1;
            static int diff_color_moved_default;
            static int diff_color_moved_ws_default;
            static int diff_context_default = 3;
            static int diff_interhunk_context_default;
            static char *diff_word_regex_cfg;
            static struct external_diff external_diff_cfg;
            static char *diff_order_file_cfg;
            int diff_auto_refresh_index = 1;
            static int diff_mnemonic_prefix;
            static int diff_no_prefix;
            static char *diff_src_prefix;
            static char *diff_dst_prefix;
            static int diff_relative;
            static int diff_stat_name_width;
            static int diff_stat_graph_width;
            static int diff_dirstat_permille_default = 30;
            static struct diff_options default_diff_options;
            static long diff_algorithm;
            static unsigned ws_error_highlight_default = WSEH_NEW;

            static char diff_colors[][COLOR_MAXLEN] = {
                    GIT_COLOR_RESET,
                    GIT_COLOR_NORMAL,       /* CONTEXT */
                    GIT_COLOR_BOLD,         /* METAINFO */
                    GIT_COLOR_CYAN,         /* FRAGINFO */
                    GIT_COLOR_RED,          /* OLD */
                    GIT_COLOR_GREEN,        /* NEW */
                    GIT_COLOR_YELLOW,       /* COMMIT */
                    GIT_COLOR_BG_RED,       /* WHITESPACE */
                    GIT_COLOR_NORMAL,       /* FUNCINFO */
                    GIT_COLOR_BOLD_MAGENTA, /* OLD_MOVED */
                    GIT_COLOR_BOLD_BLUE,    /* OLD_MOVED ALTERNATIVE */
                    GIT_COLOR_FAINT,        /* OLD_MOVED_DIM */
                    GIT_COLOR_FAINT_ITALIC, /* OLD_MOVED_ALTERNATIVE_DIM */
                    GIT_COLOR_BOLD_CYAN,    /* NEW_MOVED */
                    GIT_COLOR_BOLD_YELLOW,  /* NEW_MOVED ALTERNATIVE */
                    GIT_COLOR_FAINT,        /* NEW_MOVED_DIM */
                    GIT_COLOR_FAINT_ITALIC, /* NEW_MOVED_ALTERNATIVE_DIM */
                    GIT_COLOR_FAINT,        /* CONTEXT_DIM */
                    GIT_COLOR_FAINT_RED,    /* OLD_DIM */
                    GIT_COLOR_FAINT_GREEN,  /* NEW_DIM */
                    GIT_COLOR_BOLD,         /* CONTEXT_BOLD */
                    GIT_COLOR_BOLD_RED,     /* OLD_BOLD */
                    GIT_COLOR_BOLD_GREEN,   /* NEW_BOLD */
            };

            static const char *color_diff_slots[] = {
                    [DIFF_CONTEXT]                = "context",
                    [DIFF_METAINFO]               = "meta",
                    [DIFF_FRAGINFO]               = "frag",
                    [DIFF_FILE_OLD]               = "old",
                    [DIFF_FILE_NEW]               = "new",
                    [DIFF_COMMIT]                 = "commit",
                    [DIFF_WHITESPACE]             = "whitespace",
                    [DIFF_FUNCINFO]               = "func",
                    [DIFF_FILE_OLD_MOVED]         = "oldMoved",
                    [DIFF_FILE_OLD_MOVED_ALT]     = "oldMovedAlternative",
                    [DIFF_FILE_OLD_MOVED_DIM]     = "oldMovedDimmed",
                    [DIFF_FILE_OLD_MOVED_ALT_DIM] = "oldMovedAlternativeDimmed",
                    [DIFF_FILE_NEW_MOVED]         = "newMoved",
                    [DIFF_FILE_NEW_MOVED_ALT]     = "newMovedAlternative",
                    [DIFF_FILE_NEW_MOVED_DIM]     = "newMovedDimmed",
                    [DIFF_FILE_NEW_MOVED_ALT_DIM] = "newMovedAlternativeDimmed",
                    [DIFF_CONTEXT_DIM]            = "contextDimmed",
                    [DIFF_FILE_OLD_DIM]           = "oldDimmed",
                    [DIFF_FILE_NEW_DIM]           = "newDimmed",
                    [DIFF_CONTEXT_BOLD]           = "contextBold",
                    [DIFF_FILE_OLD_BOLD]          = "oldBold",
                    [DIFF_FILE_NEW_BOLD]          = "newBold",
            };

            define_list_config_array_extra(color_diff_slots, {"plain"});

            static int parse_diff_color_slot(const char *var)
            {
                    if (!strcasecmp(var, "plain"))
                            return DIFF_CONTEXT;
                    return LOOKUP_CONFIG(color_diff_slots, var);
            }

            static int parse_dirstat_params(struct diff_options *options, const char *params_string,
                                            struct strbuf *errmsg)
            {
                    char *params_copy = xstrdup(params_string);
                    struct string_list params = STRING_LIST_INIT_NODUP;
                    int ret = 0;
                    int i;

                    if (*params_copy)
                            string_list_split_in_place(&params, params_copy, ",", -1);
                    for (i = 0; i < params.nr; i++) {
                            const char *p = params.items[i].string;
                            if (!strcmp(p, "changes")) {
                                    options->flags.dirstat_by_line = 0;
                                    options->flags.dirstat_by_file = 0;
                            } else if (!strcmp(p, "lines")) {
                                    options->flags.dirstat_by_line = 1;
                                    options->flags.dirstat_by_file = 0;
                            } else if (!strcmp(p, "files")) {
                                    options->flags.dirstat_by_line = 0;
                                    options->flags.dirstat_by_file = 1;
                            } else if (!strcmp(p, "noncumulative")) {
                                    options->flags.dirstat_cumulative = 0;
                            } else if (!strcmp(p, "cumulative")) {
                                    options->flags.dirstat_cumulative = 1;
                            } else if (isdigit(*p)) {
                                    char *end;
                                    int permille = strtoul(p, &end, 10) * 10;
                                    if (*end == '.' && isdigit(*++end)) {
                                            /* only use first digit */
                                            permille += *end - '0';
                                            /* .. and ignore any further digits */
                                            while (isdigit(*++end))
                                                    ; /* nothing */
                                    }
                                    if (!*end)
                                            options->dirstat_permille = permille;
                                    else {
                                            strbuf_addf(errmsg, _("  Failed to parse dirstat cut-off percentage '%s'\n"),
                                                    p);
                                            ret++;
                                    }
                            } else {
                                    strbuf_addf(errmsg, _("  Unknown dirstat parameter '%s'\n"), p);
                                    ret++;
                            }

                    }
                    string_list_clear(&params, 0);
                    free(params_copy);
                    return ret;
            }

            static int parse_submodule_params(struct diff_options *options, const char *value)
            {
                    if (!strcmp(value, "log"))
                            options->submodule_format = DIFF_SUBMODULE_LOG;
                    else if (!strcmp(value, "short"))
                            options->submodule_format = DIFF_SUBMODULE_SHORT;
                    else if (!strcmp(value, "diff"))
                            options->submodule_format = DIFF_SUBMODULE_INLINE_DIFF;
                    /*
                    * Please update $__git_diff_submodule_formats in
                    * git-completion.bash when you add new formats.
                    */
                    else
                            return -1;
                    return 0;
            }

            int git_config_rename(const char *var, const char *value)
            {
                    if (!value)
                            return DIFF_DETECT_RENAME;
                    if (!strcasecmp(value, "copies") || !strcasecmp(value, "copy"))
                            return  DIFF_DETECT_COPY;
                    return git_config_bool(var,value) ? DIFF_DETECT_RENAME : 0;
            }

            long parse_algorithm_value(const char *value)
            {
                    if (!value)
                            return -1;
                    else if (!strcasecmp(value, "myers") || !strcasecmp(value, "default"))
                            return 0;
                    else if (!strcasecmp(value, "minimal"))
                            return XDF_NEED_MINIMAL;
                    else if (!strcasecmp(value, "patience"))
                            return XDF_PATIENCE_DIFF;
                    else if (!strcasecmp(value, "histogram"))
                            return XDF_HISTOGRAM_DIFF;
                    /*
                    * Please update $__git_diff_algorithms in git-completion.bash
                    * when you add new algorithms.
                    */
                    return -1;
            }

            static int parse_one_token(const char **arg, const char *token)
            {
                    const char *rest;
                    if (skip_prefix(*arg, token, &rest) && (!*rest || *rest == ',')) {
                            *arg = rest;
                            return 1;
                    }
                    return 0;
            }

            static int parse_ws_error_highlight(const char *arg)
            {
                    const char *orig_arg = arg;
                    unsigned val = 0;

                    while (*arg) {
                            if (parse_one_token(&arg, "none"))
                                    val = 0;
                            else if (parse_one_token(&arg, "default"))
                                    val = WSEH_NEW;
                            else if (parse_one_token(&arg, "all"))
                                    val = WSEH_NEW | WSEH_OLD | WSEH_CONTEXT;
                            else if (parse_one_token(&arg, "new"))
                                    val |= WSEH_NEW;
                            else if (parse_one_token(&arg, "old"))
                                    val |= WSEH_OLD;
                            else if (parse_one_token(&arg, "context"))
                                    val |= WSEH_CONTEXT;
                            else {
                                    return -1 - (int)(arg - orig_arg);
                            }
                            if (*arg)
                                    arg++;
                    }
                    return val;
            }

            /*
            * These are to give UI layer defaults.
            * The core-level commands such as git-diff-files should
            * never be affected by the setting of diff.renames
            * the user happens to have in the configuration file.
            */
            void init_diff_ui_defaults(void)
            {
                    diff_detect_rename_default = DIFF_DETECT_RENAME;
            }

            int git_diff_heuristic_config(const char *var, const char *value,
                                    void *cb UNUSED)
            {
                    if (!strcmp(var, "diff.indentheuristic"))
                            diff_indent_heuristic = git_config_bool(var, value);
                    return 0;
            }

            static int parse_color_moved(const char *arg)
            {
                    switch (git_parse_maybe_bool(arg)) {
                    case 0:
                            return COLOR_MOVED_NO;
                    case 1:
                            return COLOR_MOVED_DEFAULT;
                    default:
                            break;
                    }

                    if (!strcmp(arg, "no"))
                            return COLOR_MOVED_NO;
                    else if (!strcmp(arg, "plain"))
                            return COLOR_MOVED_PLAIN;
                    else if (!strcmp(arg, "blocks"))
                            return COLOR_MOVED_BLOCKS;
                    else if (!strcmp(arg, "zebra"))
                            return COLOR_MOVED_ZEBRA;
                    else if (!strcmp(arg, "default"))
                            return COLOR_MOVED_DEFAULT;
                    else if (!strcmp(arg, "dimmed-zebra"))
                            return COLOR_MOVED_ZEBRA_DIM;
                    else if (!strcmp(arg, "dimmed_zebra"))
                            return COLOR_MOVED_ZEBRA_DIM;
                    else
                            return error(_("color moved setting must be one of 'no', 'default', 'blocks', 'zebra', 'dimmed-zebra', 'plain'"));
            }

            static unsigned parse_color_moved_ws(const char *arg)
            {
                    int ret = 0;
                    struct string_list l = STRING_LIST_INIT_DUP;
                    struct string_list_item *i;

                    string_list_split(&l, arg, ',', -1);

                    for_each_string_list_item(i, &l) {
                            struct strbuf sb = STRBUF_INIT;
                            strbuf_addstr(&sb, i->string);
                            strbuf_trim(&sb);

                            if (!strcmp(sb.buf, "no"))
                                    ret = 0;
                            else if (!strcmp(sb.buf, "ignore-space-change"))
                                    ret |= XDF_IGNORE_WHITESPACE_CHANGE;
                            else if (!strcmp(sb.buf, "ignore-space-at-eol"))
                                    ret |= XDF_IGNORE_WHITESPACE_AT_EOL;
                            else if (!strcmp(sb.buf, "ignore-all-space"))
                                    ret |= XDF_IGNORE_WHITESPACE;
                            else if (!strcmp(sb.buf, "allow-indentation-change"))
                                    ret |= COLOR_MOVED_WS_ALLOW_INDENTATION_CHANGE;
                            else {
                                    ret |= COLOR_MOVED_WS_ERROR;
                                    error(_("unknown color-moved-ws mode '%s', possible values are 'ignore-space-change', 'ignore-space-at-eol', 'ignore-all-space', 'allow-indentation-change'"), sb.buf);
                            }

                            strbuf_release(&sb);
                    }

                    if ((ret & COLOR_MOVED_WS_ALLOW_INDENTATION_CHANGE) &&
                    (ret & XDF_WHITESPACE_FLAGS)) {
                            error(_("color-moved-ws: allow-indentation-change cannot be combined with other whitespace modes"));
                            ret |= COLOR_MOVED_WS_ERROR;
                    }

                    string_list_clear(&l, 0);

                    return ret;
            }

            int git_diff_ui_config(const char *var, const char *value,
                            const struct config_context *ctx, void *cb)
            {
                    if (!strcmp(var, "diff.color") || !strcmp(var, "color.diff")) {
                            diff_use_color_default = git_config_colorbool(var, value);
                            return 0;
                    }
                    if (!strcmp(var, "diff.colormoved")) {
                            int cm = parse_color_moved(value);
                            if (cm < 0)
                                    return -1;
                            diff_color_moved_default = cm;
                            return 0;
                    }
                    if (!strcmp(var, "diff.colormovedws")) {
                            unsigned cm;
                            if (!value)
                                    return config_error_nonbool(var);
                            cm = parse_color_moved_ws(value);
                            if (cm & COLOR_MOVED_WS_ERROR)
                                    return -1;
                            diff_color_moved_ws_default = cm;
                            return 0;
                    }
                    if (!strcmp(var, "diff.context")) {
                            diff_context_default = git_config_int(var, value, ctx->kvi);
                            if (diff_context_default < 0)
                                    return -1;
                            return 0;
                    }
                    if (!strcmp(var, "diff.interhunkcontext")) {
                            diff_interhunk_context_default = git_config_int(var, value,
                                                                            ctx->kvi);
                            if (diff_interhunk_context_default < 0)
                                    return -1;
                            return 0;
                    }
                    if (!strcmp(var, "diff.renames")) {
                            diff_detect_rename_default = git_config_rename(var, value);
                            return 0;
                    }
                    if (!strcmp(var, "diff.autorefreshindex")) {
                            diff_auto_refresh_index = git_config_bool(var, value);
                            return 0;
                    }
                    if (!strcmp(var, "diff.mnemonicprefix")) {
                            diff_mnemonic_prefix = git_config_bool(var, value);
                            return 0;
                    }
                    if (!strcmp(var, "diff.noprefix")) {
                            diff_no_prefix = git_config_bool(var, value);
                            return 0;
                    }
                    if (!strcmp(var, "diff.srcprefix")) {
                            FREE_AND_NULL(diff_src_prefix);
                            return git_config_string(&diff_src_prefix, var, value);
                    }
                    if (!strcmp(var, "diff.dstprefix")) {
                            FREE_AND_NULL(diff_dst_prefix);
                            return git_config_string(&diff_dst_prefix, var, value);
                    }
                    if (!strcmp(var, "diff.relative")) {
                            diff_relative = git_config_bool(var, value);
                            return 0;
                    }
                    if (!strcmp(var, "diff.statnamewidth")) {
                            diff_stat_name_width = git_config_int(var, value, ctx->kvi);
                            return 0;
                    }
                    if (!strcmp(var, "diff.statgraphwidth")) {
                            diff_stat_graph_width = git_config_int(var, value, ctx->kvi);
                            return 0;
                    }
                    if (!strcmp(var, "diff.external"))
                            return git_config_string(&external_diff_cfg.cmd, var, value);
                    if (!strcmp(var, "diff.trustexitcode")) {
                            external_diff_cfg.trust_exit_code = git_config_bool(var, value);
                            return 0;
                    }
                    if (!strcmp(var, "diff.wordregex"))
                            return git_config_string(&diff_word_regex_cfg, var, value);
                    if (!strcmp(var, "diff.orderfile")) {
                            FREE_AND_NULL(diff_order_file_cfg);
                            return git_config_pathname(&diff_order_file_cfg, var, value);
                    }

                    if (!strcmp(var, "diff.ignoresubmodules")) {
                            if (!value)
                                    return config_error_nonbool(var);
                            handle_ignore_submodules_arg(&default_diff_options, value);
                    }

                    if (!strcmp(var, "diff.submodule")) {
                            if (!value)
                                    return config_error_nonbool(var);
                            if (parse_submodule_params(&default_diff_options, value))
                                    warning(_("Unknown value for 'diff.submodule' config variable: '%s'"),
                                            value);
                            return 0;
                    }

                    if (!strcmp(var, "diff.algorithm")) {
                            if (!value)
                                    return config_error_nonbool(var);
                            diff_algorithm = parse_algorithm_value(value);
                            if (diff_algorithm < 0)
                                    return error(_("unknown value for config '%s': %s"),
                                            var, value);
                            return 0;
                    }

                    if (git_color_config(var, value, cb) < 0)
                            return -1;

                    return git_diff_basic_config(var, value, ctx, cb);
            }

            int git_diff_basic_config(const char *var, const char *value,
                                    const struct config_context *ctx, void *cb)
            {
                    const char *name;

                    if (!strcmp(var, "diff.renamelimit")) {
                            diff_rename_limit_default = git_config_int(var, value, ctx->kvi);
                            return 0;
                    }

                    if (userdiff_config(var, value) < 0)
                            return -1;

                    if (skip_prefix(var, "diff.color.", &name) ||
                    skip_prefix(var, "color.diff.", &name)) {
                            int slot = parse_diff_color_slot(name);
                            if (slot < 0)
                                    return 0;
                            if (!value)
                                    return config_error_nonbool(var);
                            return color_parse(value, diff_colors[slot]);
                    }

                    if (!strcmp(var, "diff.wserrorhighlight")) {
                            int val;
                            if (!value)
                                    return config_error_nonbool(var);
                            val = parse_ws_error_highlight(value);
                            if (val < 0)
                                    return error(_("unknown value for config '%s': %s"),
                                            var, value);
                            ws_error_highlight_default = val;
                            return 0;
                    }

                    /* like GNU diff's --suppress-blank-empty option  */
                    if (!strcmp(var, "diff.suppressblankempty") ||
                                    /* for backwards compatibility */
                                    !strcmp(var, "diff.suppress-blank-empty")) {
                            diff_suppress_blank_empty = git_config_bool(var, value);
                            return 0;
                    }

                    if (!strcmp(var, "diff.dirstat")) {
                            struct strbuf errmsg = STRBUF_INIT;
                            if (!value)
                                    return config_error_nonbool(var);
                            default_diff_options.dirstat_permille = diff_dirstat_permille_default;
                            if (parse_dirstat_params(&default_diff_options, value, &errmsg))
                                    warning(_("Found errors in 'diff.dirstat' config variable:\n%s"),
                                            errmsg.buf);
                            strbuf_release(&errmsg);
                            diff_dirstat_permille_default = default_diff_options.dirstat_permille;
                            return 0;
                    }

                    if (git_diff_heuristic_config(var, value, cb) < 0)
                            return -1;

                    return git_default_config(var, value, ctx, cb);
            }

            static char *quote_two(const char *one, const char *two)
            {
                    int need_one = quote_c_style(one, NULL, NULL, CQUOTE_NODQ);
                    int need_two = quote_c_style(two, NULL, NULL, CQUOTE_NODQ);
                    struct strbuf res = STRBUF_INIT;

                    if (need_one + need_two) {
                            strbuf_addch(&res, '"');
                            quote_c_style(one, &res, NULL, CQUOTE_NODQ);
                            quote_c_style(two, &res, NULL, CQUOTE_NODQ);
                            strbuf_addch(&res, '"');
                    } else {
                            strbuf_addstr(&res, one);
                            strbuf_addstr(&res, two);
                    }
                    return strbuf_detach(&res, NULL);
            }

            static const struct external_diff *external_diff(void)
            {
                    static struct external_diff external_diff_env, *external_diff_ptr;
                    static int done_preparing = 0;

                    if (done_preparing)
                            return external_diff_ptr;
                    external_diff_env.cmd = xstrdup_or_null(getenv("GIT_EXTERNAL_DIFF"));
                    if (git_env_bool("GIT_EXTERNAL_DIFF_TRUST_EXIT_CODE", 0))
                            external_diff_env.trust_exit_code = 1;
                    if (external_diff_env.cmd)
                            external_diff_ptr = &external_diff_env;
                    else if (external_diff_cfg.cmd)
                            external_diff_ptr = &external_diff_cfg;
                    done_preparing = 1;
                    return external_diff_ptr;
            }

            /*
            * Keep track of files used for diffing. Sometimes such an entry
            * refers to a temporary file, sometimes to an existing file, and
            * sometimes to "/dev/null".
            */
            static struct diff_tempfile {
                    /*
                    * filename external diff should read from, or NULL if this
                    * entry is currently not in use:
                    */
                    const char *name;

                    char hex[GIT_MAX_HEXSZ + 1];
                    char mode[10];

                    /*
                    * If this diff_tempfile instance refers to a temporary file,
                    * this tempfile object is used to manage its lifetime.
                    */
                    struct tempfile *tempfile;
            } diff_temp[2];

            struct emit_callback {
                    int color_diff;
                    unsigned ws_rule;
                    int blank_at_eof_in_preimage;
                    int blank_at_eof_in_postimage;
                    int lno_in_preimage;
                    int lno_in_postimage;
                    const char **label_path;
                    struct diff_words_data *diff_words;
                    struct diff_options *opt;
                    struct strbuf *header;
            };

            static int count_lines(const char *data, int size)
            {
                    int count, ch, completely_empty = 1, nl_just_seen = 0;
                    count = 0;
                    while (0 < size--) {
                            ch = *data++;
                            if (ch == '\n') {
                                    count++;
                                    nl_just_seen = 1;
                                    completely_empty = 0;
                            }
                            else {
                                    nl_just_seen = 0;
                                    completely_empty = 0;
                            }
                    }
                    if (completely_empty)
                            return 0;
                    if (!nl_just_seen)
                            count++; /* no trailing newline */
                    return count;
            }

            static int fill_mmfile(struct repository *r, mmfile_t *mf,
                            struct diff_filespec *one)
            {
                    if (!DIFF_FILE_VALID(one)) {
                            mf->ptr = (char *)""; /* does not matter */
                            mf->size = 0;
                            return 0;
                    }
                    else if (diff_populate_filespec(r, one, NULL))
                            return -1;

                    mf->ptr = one->data;
                    mf->size = one->size;
                    return 0;
            }

            /* like fill_mmfile, but only for size, so we can avoid retrieving blob */
            static unsigned long diff_filespec_size(struct repository *r,
                                                    struct diff_filespec *one)
            {
                    struct diff_populate_filespec_options dpf_options = {
                            .check_size_only = 1,
                    };

                    if (!DIFF_FILE_VALID(one))
                            return 0;
                    diff_populate_filespec(r, one, &dpf_options);
                    return one->size;
            }

            static int count_trailing_blank(mmfile_t *mf)
            {
                    char *ptr = mf->ptr;
                    long size = mf->size;
                    int cnt = 0;

                    if (!size)
                            return cnt;
                    ptr += size - 1; /* pointing at the very end */
                    if (*ptr != '\n')
                            ; /* incomplete line */
                    else
                            ptr--; /* skip the last LF */
                    while (mf->ptr < ptr) {
                            char *prev_eol;
                            for (prev_eol = ptr; mf->ptr <= prev_eol; prev_eol--)
                                    if (*prev_eol == '\n')
                                            break;
                            if (!ws_blank_line(prev_eol + 1, ptr - prev_eol))
                                    break;
                            cnt++;
                            ptr = prev_eol - 1;
                    }
                    return cnt;
            }

            static void check_blank_at_eof(mmfile_t *mf1, mmfile_t *mf2,
                                    struct emit_callback *ecbdata)
            {
                    int l1, l2, at;
                    l1 = count_trailing_blank(mf1);
                    l2 = count_trailing_blank(mf2);
                    if (l2 <= l1) {
                            ecbdata->blank_at_eof_in_preimage = 0;
                            ecbdata->blank_at_eof_in_postimage = 0;
                            return;
                    }
                    at = count_lines(mf1->ptr, mf1->size);
                    ecbdata->blank_at_eof_in_preimage = (at - l1) + 1;

                    at = count_lines(mf2->ptr, mf2->size);
                    ecbdata->blank_at_eof_in_postimage = (at - l2) + 1;
            }

            static void emit_line_0(struct diff_options *o,
                                    const char *set_sign, const char *set, unsigned reverse, const char *reset,
                                    int first, const char *line, int len)
            {
                    int has_trailing_newline, has_trailing_carriage_return;
                    int needs_reset = 0; /* at the end of the line */
                    FILE *file = o->file;

                    fputs(diff_line_prefix(o), file);

                    has_trailing_newline = (len > 0 && line[len-1] == '\n');
                    if (has_trailing_newline)
                            len--;

                    has_trailing_carriage_return = (len > 0 && line[len-1] == '\r');
                    if (has_trailing_carriage_return)
                            len--;

                    if (!len && !first)
                            goto end_of_line;

                    if (reverse && want_color(o->use_color)) {
                            fputs(GIT_COLOR_REVERSE, file);
                            needs_reset = 1;
                    }

                    if (set_sign) {
                            fputs(set_sign, file);
                            needs_reset = 1;
                    }

                    if (first)
                            fputc(first, file);

                    if (!len)
                            goto end_of_line;

                    if (set) {
                            if (set_sign && set != set_sign)
                                    fputs(reset, file);
                            fputs(set, file);
                            needs_reset = 1;
                    }
                    fwrite(line, len, 1, file);
                    needs_reset = 1; /* 'line' may contain color codes. */

            end_of_line:
                    if (needs_reset)
                            fputs(reset, file);
                    if (has_trailing_carriage_return)
                            fputc('\r', file);
                    if (has_trailing_newline)
                            fputc('\n', file);
            }

            static void emit_line(struct diff_options *o, const char *set, const char *reset,
                            const char *line, int len)
            {
                    emit_line_0(o, set, NULL, 0, reset, 0, line, len);
            }

            enum diff_symbol {
                    DIFF_SYMBOL_BINARY_DIFF_HEADER,
                    DIFF_SYMBOL_BINARY_DIFF_HEADER_DELTA,
                    DIFF_SYMBOL_BINARY_DIFF_HEADER_LITERAL,
                    DIFF_SYMBOL_BINARY_DIFF_BODY,
                    DIFF_SYMBOL_BINARY_DIFF_FOOTER,
                    DIFF_SYMBOL_STATS_SUMMARY_NO_FILES,
                    DIFF_SYMBOL_STATS_SUMMARY_ABBREV,
                    DIFF_SYMBOL_STATS_SUMMARY_INSERTS_DELETES,
                    DIFF_SYMBOL_STATS_LINE,
                    DIFF_SYMBOL_WORD_DIFF,
                    DIFF_SYMBOL_STAT_SEP,
                    DIFF_SYMBOL_SUMMARY,
                    DIFF_SYMBOL_SUBMODULE_ADD,
                    DIFF_SYMBOL_SUBMODULE_DEL,
                    DIFF_SYMBOL_SUBMODULE_UNTRACKED,
                    DIFF_SYMBOL_SUBMODULE_MODIFIED,
                    DIFF_SYMBOL_SUBMODULE_HEADER,
                    DIFF_SYMBOL_SUBMODULE_ERROR,
                    DIFF_SYMBOL_SUBMODULE_PIPETHROUGH,
                    DIFF_SYMBOL_REWRITE_DIFF,
                    DIFF_SYMBOL_BINARY_FILES,
                    DIFF_SYMBOL_HEADER,
                    DIFF_SYMBOL_FILEPAIR_PLUS,
                    DIFF_SYMBOL_FILEPAIR_MINUS,
                    DIFF_SYMBOL_WORDS_PORCELAIN,
                    DIFF_SYMBOL_WORDS,
                    DIFF_SYMBOL_CONTEXT,
                    DIFF_SYMBOL_CONTEXT_INCOMPLETE,
                    DIFF_SYMBOL_PLUS,
                    DIFF_SYMBOL_MINUS,
                    DIFF_SYMBOL_NO_LF_EOF,
                    DIFF_SYMBOL_CONTEXT_FRAGINFO,
                    DIFF_SYMBOL_CONTEXT_MARKER,
                    DIFF_SYMBOL_SEPARATOR
            };
            /*
            * Flags for content lines:
            * 0..12 are whitespace rules
            * 13-15 are WSEH_NEW | WSEH_OLD | WSEH_CONTEXT
            * 16 is marking if the line is blank at EOF
            */
            #define DIFF_SYMBOL_CONTENT_BLANK_LINE_EOF      (1<<16)
            #define DIFF_SYMBOL_MOVED_LINE                  (1<<17)
            #define DIFF_SYMBOL_MOVED_LINE_ALT              (1<<18)
            #define DIFF_SYMBOL_MOVED_LINE_UNINTERESTING    (1<<19)
            #define DIFF_SYMBOL_CONTENT_WS_MASK (WSEH_NEW | WSEH_OLD | WSEH_CONTEXT | WS_RULE_MASK)

            /*
            * This struct is used when we need to buffer the output of the diff output.
            *
            * NEEDSWORK: Instead of storing a copy of the line, add an offset pointer
            * into the pre/post image file. This pointer could be a union with the
            * line pointer. By storing an offset into the file instead of the literal line,
            * we can decrease the memory footprint for the buffered output. At first we
            * may want to only have indirection for the content lines, but we could also
            * enhance the state for emitting prefabricated lines, e.g. the similarity
            * score line or hunk/file headers would only need to store a number or path
            * and then the output can be constructed later on depending on state.
            */
            struct emitted_diff_symbol {
                    const char *line;
                    int len;
                    int flags;
                    int indent_off;   /* Offset to first non-whitespace character */
                    int indent_width; /* The visual width of the indentation */
                    unsigned id;
                    enum diff_symbol s;
            };
            #define EMITTED_DIFF_SYMBOL_INIT { 0 }

            struct emitted_diff_symbols {
                    struct emitted_diff_symbol *buf;
                    int nr, alloc;
            };
            #define EMITTED_DIFF_SYMBOLS_INIT { 0 }

            static void append_emitted_diff_symbol(struct diff_options *o,
                                            struct emitted_diff_symbol *e)
            {
                    struct emitted_diff_symbol *f;

                    ALLOC_GROW(o->emitted_symbols->buf,
                            o->emitted_symbols->nr + 1,
                            o->emitted_symbols->alloc);
                    f = &o->emitted_symbols->buf[o->emitted_symbols->nr++];

                    memcpy(f, e, sizeof(struct emitted_diff_symbol));
                    f->line = e->line ? xmemdupz(e->line, e->len) : NULL;
            }

            static void free_emitted_diff_symbols(struct emitted_diff_symbols *e)
            {
                    if (!e)
                            return;
                    free(e->buf);
                    free(e);
            }

            struct moved_entry {
                    const struct emitted_diff_symbol *es;
                    struct moved_entry *next_line;
                    struct moved_entry *next_match;
            };

            struct moved_block {
                    struct moved_entry *match;
                    int wsd; /* The whitespace delta of this block */
            };

            #define INDENT_BLANKLINE INT_MIN

            static void fill_es_indent_data(struct emitted_diff_symbol *es)
            {
                    unsigned int off = 0, i;
                    int width = 0, tab_width = es->flags & WS_TAB_WIDTH_MASK;
                    const char *s = es->line;
                    const int len = es->len;

                    /* skip any \v \f \r at start of indentation */
                    while (s[off] == '\f' || s[off] == '\v' ||
                    (s[off] == '\r' && off < len - 1))
                            off++;

                    /* calculate the visual width of indentation */
                    while(1) {
                            if (s[off] == ' ') {
                                    width++;
                                    off++;
                            } else if (s[off] == '\t') {
                                    width += tab_width - (width % tab_width);
                                    while (s[++off] == '\t')
                                            width += tab_width;
                            } else {
                                    break;
                            }
                    }

                    /* check if this line is blank */
                    for (i = off; i < len; i++)
                            if (!isspace(s[i]))
                            break;

                    if (i == len) {
                            es->indent_width = INDENT_BLANKLINE;
                            es->indent_off = len;
                    } else {
                            es->indent_off = off;
                            es->indent_width = width;
                    }
            }

            static int compute_ws_delta(const struct emitted_diff_symbol *a,
                                    const struct emitted_diff_symbol *b)
            {
                    int a_width = a->indent_width,
                    b_width = b->indent_width;

                    if (a_width == INDENT_BLANKLINE && b_width == INDENT_BLANKLINE)
                            return INDENT_BLANKLINE;

                    return a_width - b_width;
            }

            static int cmp_in_block_with_wsd(const struct moved_entry *cur,
                                            const struct emitted_diff_symbol *l,
                                            struct moved_block *pmb)
            {
                    int a_width = cur->es->indent_width, b_width = l->indent_width;
                    int delta;

                    /* The text of each line must match */
                    if (cur->es->id != l->id)
                            return 1;

                    /*
                    * If 'l' and 'cur' are both blank then we don't need to check the
                    * indent. We only need to check cur as we know the strings match.
                    * */
                    if (a_width == INDENT_BLANKLINE)
                            return 0;

                    /*
                    * The indent changes of the block are known and stored in pmb->wsd;
                    * however we need to check if the indent changes of the current line
                    * match those of the current block.
                    */
                    delta = b_width - a_width;

                    /*
                    * If the previous lines of this block were all blank then set its
                    * whitespace delta.
                    */
                    if (pmb->wsd == INDENT_BLANKLINE)
                            pmb->wsd = delta;

                    return delta != pmb->wsd;
            }

            struct interned_diff_symbol {
                    struct hashmap_entry ent;
                    struct emitted_diff_symbol *es;
            };

            static int interned_diff_symbol_cmp(const void *hashmap_cmp_fn_data,
                                            const struct hashmap_entry *eptr,
                                            const struct hashmap_entry *entry_or_key,
                                            const void *keydata UNUSED)
            {
                    const struct diff_options *diffopt = hashmap_cmp_fn_data;
                    const struct emitted_diff_symbol *a, *b;
                    unsigned flags = diffopt->color_moved_ws_handling
                                    & XDF_WHITESPACE_FLAGS;

                    a = container_of(eptr, const struct interned_diff_symbol, ent)->es;
                    b = container_of(entry_or_key, const struct interned_diff_symbol, ent)->es;

                    return !xdiff_compare_lines(a->line + a->indent_off,
                                            a->len - a->indent_off,
                                            b->line + b->indent_off,
                                            b->len - b->indent_off, flags);
            }

            static void prepare_entry(struct diff_options *o, struct emitted_diff_symbol *l,
                                    struct interned_diff_symbol *s)
            {
                    unsigned flags = o->color_moved_ws_handling & XDF_WHITESPACE_FLAGS;
                    unsigned int hash = xdiff_hash_string(l->line + l->indent_off,
                                                    l->len - l->indent_off, flags);

                    hashmap_entry_init(&s->ent, hash);
                    s->es = l;
            }

            struct moved_entry_list {
                    struct moved_entry *add, *del;
            };

            static struct moved_entry_list *add_lines_to_move_detection(struct diff_options *o,
                                                                    struct mem_pool *entry_mem_pool)
            {
                    struct moved_entry *prev_line = NULL;
                    struct mem_pool interned_pool;
                    struct hashmap interned_map;
                    struct moved_entry_list *entry_list = NULL;
                    size_t entry_list_alloc = 0;
                    unsigned id = 0;
                    int n;

                    hashmap_init(&interned_map, interned_diff_symbol_cmp, o, 8096);
                    mem_pool_init(&interned_pool, 1024 * 1024);

                    for (n = 0; n < o->emitted_symbols->nr; n++) {
                            struct interned_diff_symbol key;
                            struct emitted_diff_symbol *l = &o->emitted_symbols->buf[n];
                            struct interned_diff_symbol *s;
                            struct moved_entry *entry;

                            if (l->s != DIFF_SYMBOL_PLUS && l->s != DIFF_SYMBOL_MINUS) {
                                    prev_line = NULL;
                                    continue;
                            }

                            if (o->color_moved_ws_handling &
                            COLOR_MOVED_WS_ALLOW_INDENTATION_CHANGE)
                                    fill_es_indent_data(l);

                            prepare_entry(o, l, &key);
                            s = hashmap_get_entry(&interned_map, &key, ent, &key.ent);
                            if (s) {
                                    l->id = s->es->id;
                            } else {
                                    l->id = id;
                                    ALLOC_GROW_BY(entry_list, id, 1, entry_list_alloc);
                                    hashmap_add(&interned_map,
                                            memcpy(mem_pool_alloc(&interned_pool,
                                                                    sizeof(key)),
                                                    &key, sizeof(key)));
                            }
                            entry = mem_pool_alloc(entry_mem_pool, sizeof(*entry));
                            entry->es = l;
                            entry->next_line = NULL;
                            if (prev_line && prev_line->es->s == l->s)
                                    prev_line->next_line = entry;
                            prev_line = entry;
                            if (l->s == DIFF_SYMBOL_PLUS) {
                                    entry->next_match = entry_list[l->id].add;
                                    entry_list[l->id].add = entry;
                            } else {
                                    entry->next_match = entry_list[l->id].del;
                                    entry_list[l->id].del = entry;
                            }
                    }

                    hashmap_clear(&interned_map);
                    mem_pool_discard(&interned_pool, 0);

                    return entry_list;
            }

            static void pmb_advance_or_null(struct diff_options *o,
                                            struct emitted_diff_symbol *l,
                                            struct moved_block *pmb,
                                            int *pmb_nr)
            {
                    int i, j;

                    for (i = 0, j = 0; i < *pmb_nr; i++) {
                            int match;
                            struct moved_entry *prev = pmb[i].match;
                            struct moved_entry *cur = (prev && prev->next_line) ?
                                            prev->next_line : NULL;

                            if (o->color_moved_ws_handling &
                            COLOR_MOVED_WS_ALLOW_INDENTATION_CHANGE)
                                    match = cur &&
                                            !cmp_in_block_with_wsd(cur, l, &pmb[i]);
                            else
                                    match = cur && cur->es->id == l->id;

                            if (match) {
                                    pmb[j] = pmb[i];
                                    pmb[j++].match = cur;
                            }
                    }
                    *pmb_nr = j;
            }

            static void fill_potential_moved_blocks(struct diff_options *o,
                                                    struct moved_entry *match,
                                                    struct emitted_diff_symbol *l,
                                                    struct moved_block **pmb_p,
                                                    int *pmb_alloc_p, int *pmb_nr_p)

            {
                    struct moved_block *pmb = *pmb_p;
                    int pmb_alloc = *pmb_alloc_p, pmb_nr = *pmb_nr_p;

                    /*
                    * The current line is the start of a new block.
                    * Setup the set of potential blocks.
                    */
                    for (; match; match = match->next_match) {
                            ALLOC_GROW(pmb, pmb_nr + 1, pmb_alloc);
                            if (o->color_moved_ws_handling &
                            COLOR_MOVED_WS_ALLOW_INDENTATION_CHANGE)
                                    pmb[pmb_nr].wsd = compute_ws_delta(l, match->es);
                            else
                                    pmb[pmb_nr].wsd = 0;
                            pmb[pmb_nr++].match = match;
                    }

                    *pmb_p = pmb;
                    *pmb_alloc_p = pmb_alloc;
                    *pmb_nr_p = pmb_nr;
            }

            /*
            * If o->color_moved is COLOR_MOVED_PLAIN, this function does nothing.
            *
            * Otherwise, if the last block has fewer alphanumeric characters than
            * COLOR_MOVED_MIN_ALNUM_COUNT, unset DIFF_SYMBOL_MOVED_LINE on all lines in
            * that block.
            *
            * The last block consists of the (n - block_length)'th line up to but not
            * including the nth line.
            *
            * Returns 0 if the last block is empty or is unset by this function, non zero
            * otherwise.
            *
            * NEEDSWORK: This uses the same heuristic as blame_entry_score() in blame.c.
            * Think of a way to unify them.
            */
            #define DIFF_SYMBOL_MOVED_LINE_ZEBRA_MASK \
            (DIFF_SYMBOL_MOVED_LINE | DIFF_SYMBOL_MOVED_LINE_ALT)
            static int adjust_last_block(struct diff_options *o, int n, int block_length)
            {
                    int i, alnum_count = 0;
                    if (o->color_moved == COLOR_MOVED_PLAIN)
                            return block_length;
                    for (i = 1; i < block_length + 1; i++) {
                            const char *c = o->emitted_symbols->buf[n - i].line;
                            for (; *c; c++) {
                                    if (!isalnum(*c))
                                            continue;
                                    alnum_count++;
                                    if (alnum_count >= COLOR_MOVED_MIN_ALNUM_COUNT)
                                            return 1;
                            }
                    }
                    for (i = 1; i < block_length + 1; i++)
                            o->emitted_symbols->buf[n - i].flags &= ~DIFF_SYMBOL_MOVED_LINE_ZEBRA_MASK;
                    return 0;
            }

            /* Find blocks of moved code, delegate actual coloring decision to helper */
            static void mark_color_as_moved(struct diff_options *o,
                                            struct moved_entry_list *entry_list)
            {
                    struct moved_block *pmb = NULL; /* potentially moved blocks */
                    int pmb_nr = 0, pmb_alloc = 0;
                    int n, flipped_block = 0, block_length = 0;
                    enum diff_symbol moved_symbol = DIFF_SYMBOL_BINARY_DIFF_HEADER;


                    for (n = 0; n < o->emitted_symbols->nr; n++) {
                            struct moved_entry *match = NULL;
                            struct emitted_diff_symbol *l = &o->emitted_symbols->buf[n];

                            switch (l->s) {
                            case DIFF_SYMBOL_PLUS:
                                    match = entry_list[l->id].del;
                                    break;
                            case DIFF_SYMBOL_MINUS:
                                    match = entry_list[l->id].add;
                                    break;
                            default:
                                    flipped_block = 0;
                            }

                            if (pmb_nr && (!match || l->s != moved_symbol)) {
                                    if (!adjust_last_block(o, n, block_length) &&
                                    block_length > 1) {
                                            /*
                                            * Rewind in case there is another match
                                            * starting at the second line of the block
                                            */
                                            match = NULL;
                                            n -= block_length;
                                    }
                                    pmb_nr = 0;
                                    block_length = 0;
                                    flipped_block = 0;
                            }
                            if (!match) {
                                    moved_symbol = DIFF_SYMBOL_BINARY_DIFF_HEADER;
                                    continue;
                            }

                            if (o->color_moved == COLOR_MOVED_PLAIN) {
                                    l->flags |= DIFF_SYMBOL_MOVED_LINE;
                                    continue;
                            }

                            pmb_advance_or_null(o, l, pmb, &pmb_nr);

                            if (pmb_nr == 0) {
                                    int contiguous = adjust_last_block(o, n, block_length);

                                    if (!contiguous && block_length > 1)
                                            /*
                                            * Rewind in case there is another match
                                            * starting at the second line of the block
                                            */
                                            n -= block_length;
                                    else
                                            fill_potential_moved_blocks(o, match, l,
                                                                    &pmb, &pmb_alloc,
                                                                    &pmb_nr);

                                    if (contiguous && pmb_nr && moved_symbol == l->s)
                                            flipped_block = (flipped_block + 1) % 2;
                                    else
                                            flipped_block = 0;

                                    if (pmb_nr)
                                            moved_symbol = l->s;
                                    else
                                            moved_symbol = DIFF_SYMBOL_BINARY_DIFF_HEADER;

                                    block_length = 0;
                            }

                            if (pmb_nr) {
                                    block_length++;
                                    l->flags |= DIFF_SYMBOL_MOVED_LINE;
                                    if (flipped_block && o->color_moved != COLOR_MOVED_BLOCKS)
                                            l->flags |= DIFF_SYMBOL_MOVED_LINE_ALT;
                            }
                    }
                    adjust_last_block(o, n, block_length);

                    free(pmb);
            }

            static void dim_moved_lines(struct diff_options *o)
            {
                    int n;
                    for (n = 0; n < o->emitted_symbols->nr; n++) {
                            struct emitted_diff_symbol *prev = (n != 0) ?
                                            &o->emitted_symbols->buf[n - 1] : NULL;
                            struct emitted_diff_symbol *l = &o->emitted_symbols->buf[n];
                            struct emitted_diff_symbol *next =
                                            (n < o->emitted_symbols->nr - 1) ?
                                            &o->emitted_symbols->buf[n + 1] : NULL;

                            /* Not a plus or minus line? */
                            if (l->s != DIFF_SYMBOL_PLUS && l->s != DIFF_SYMBOL_MINUS)
                                    continue;

                            /* Not a moved line? */
                            if (!(l->flags & DIFF_SYMBOL_MOVED_LINE))
                                    continue;

                            /*
                            * If prev or next are not a plus or minus line,
                            * pretend they don't exist
                            */
                            if (prev && prev->s != DIFF_SYMBOL_PLUS &&
                                    prev->s != DIFF_SYMBOL_MINUS)
                                    prev = NULL;
                            if (next && next->s != DIFF_SYMBOL_PLUS &&
                                    next->s != DIFF_SYMBOL_MINUS)
                                    next = NULL;

                            /* Inside a block? */
                            if ((prev &&
                            (prev->flags & DIFF_SYMBOL_MOVED_LINE_ZEBRA_MASK) ==
                            (l->flags & DIFF_SYMBOL_MOVED_LINE_ZEBRA_MASK)) &&
                            (next &&
                            (next->flags & DIFF_SYMBOL_MOVED_LINE_ZEBRA_MASK) ==
                            (l->flags & DIFF_SYMBOL_MOVED_LINE_ZEBRA_MASK))) {
                                    l->flags |= DIFF_SYMBOL_MOVED_LINE_UNINTERESTING;
                                    continue;
                            }

                            /* Check if we are at an interesting bound: */
                            if (prev && (prev->flags & DIFF_SYMBOL_MOVED_LINE) &&
                            (prev->flags & DIFF_SYMBOL_MOVED_LINE_ALT) !=
                            (l->flags & DIFF_SYMBOL_MOVED_LINE_ALT))
                                    continue;
                            if (next && (next->flags & DIFF_SYMBOL_MOVED_LINE) &&
                            (next->flags & DIFF_SYMBOL_MOVED_LINE_ALT) !=
                            (l->flags & DIFF_SYMBOL_MOVED_LINE_ALT))
                                    continue;

                            /*
                            * The boundary to prev and next are not interesting,
                            * so this line is not interesting as a whole
                            */
                            l->flags |= DIFF_SYMBOL_MOVED_LINE_UNINTERESTING;
                    }
            }

            static void emit_line_ws_markup(struct diff_options *o,
                                            const char *set_sign, const char *set,
                                            const char *reset,
                                            int sign_index, const char *line, int len,
                                            unsigned ws_rule, int blank_at_eof)
            {
                    const char *ws = NULL;
                    int sign = o->output_indicators[sign_index];

                    if (o->ws_error_highlight & ws_rule) {
                            ws = diff_get_color_opt(o, DIFF_WHITESPACE);
                            if (!*ws)
                                    ws = NULL;
                    }

                    if (!ws && !set_sign)
                            emit_line_0(o, set, NULL, 0, reset, sign, line, len);
                    else if (!ws) {
                            emit_line_0(o, set_sign, set, !!set_sign, reset, sign, line, len);
                    } else if (blank_at_eof)
                            /* Blank line at EOF - paint '+' as well */
                            emit_line_0(o, ws, NULL, 0, reset, sign, line, len);
                    else {
                            /* Emit just the prefix, then the rest. */
                            emit_line_0(o, set_sign ? set_sign : set, NULL, !!set_sign, reset,
                                    sign, "", 0);
                            ws_check_emit(line, len, ws_rule,
                                    o->file, set, reset, ws);
                    }
            }

            static void emit_diff_symbol_from_struct(struct diff_options *o,
                                                    struct emitted_diff_symbol *eds)
            {
                    static const char *nneof = " No newline at end of file\n";
                    const char *context, *reset, *set, *set_sign, *meta, *fraginfo;

                    enum diff_symbol s = eds->s;
                    const char *line = eds->line;
                    int len = eds->len;
                    unsigned flags = eds->flags;

                    switch (s) {
                    case DIFF_SYMBOL_NO_LF_EOF:
                            context = diff_get_color_opt(o, DIFF_CONTEXT);
                            reset = diff_get_color_opt(o, DIFF_RESET);
                            putc('\n', o->file);
                            emit_line_0(o, context, NULL, 0, reset, '\\',
                                    nneof, strlen(nneof));
                            break;
                    case DIFF_SYMBOL_SUBMODULE_HEADER:
                    case DIFF_SYMBOL_SUBMODULE_ERROR:
                    case DIFF_SYMBOL_SUBMODULE_PIPETHROUGH:
                    case DIFF_SYMBOL_STATS_SUMMARY_INSERTS_DELETES:
                    case DIFF_SYMBOL_SUMMARY:
                    case DIFF_SYMBOL_STATS_LINE:
                    case DIFF_SYMBOL_BINARY_DIFF_BODY:
                    case DIFF_SYMBOL_CONTEXT_FRAGINFO:
                            emit_line(o, "", "", line, len);
                            break;
                    case DIFF_SYMBOL_CONTEXT_INCOMPLETE:
                    case DIFF_SYMBOL_CONTEXT_MARKER:
                            context = diff_get_color_opt(o, DIFF_CONTEXT);
                            reset = diff_get_color_opt(o, DIFF_RESET);
                            emit_line(o, context, reset, line, len);
                            break;
                    case DIFF_SYMBOL_SEPARATOR:
                            fprintf(o->file, "%s%c",
                                    diff_line_prefix(o),
                                    o->line_termination);
                            break;
                    case DIFF_SYMBOL_CONTEXT:
                            set = diff_get_color_opt(o, DIFF_CONTEXT);
                            reset = diff_get_color_opt(o, DIFF_RESET);
                            set_sign = NULL;
                            if (o->flags.dual_color_diffed_diffs) {
                                    char c = !len ? 0 : line[0];

                                    if (c == '+')
                                            set = diff_get_color_opt(o, DIFF_FILE_NEW);
                                    else if (c == '@')
                                            set = diff_get_color_opt(o, DIFF_FRAGINFO);
                                    else if (c == '-')
                                            set = diff_get_color_opt(o, DIFF_FILE_OLD);
                            }
                            emit_line_ws_markup(o, set_sign, set, reset,
                                            OUTPUT_INDICATOR_CONTEXT, line, len,
                                            flags & (DIFF_SYMBOL_CONTENT_WS_MASK), 0);
                            break;
                    case DIFF_SYMBOL_PLUS:
                            switch (flags & (DIFF_SYMBOL_MOVED_LINE |
                                            DIFF_SYMBOL_MOVED_LINE_ALT |
                                            DIFF_SYMBOL_MOVED_LINE_UNINTERESTING)) {
                            case DIFF_SYMBOL_MOVED_LINE |
                            DIFF_SYMBOL_MOVED_LINE_ALT |
                            DIFF_SYMBOL_MOVED_LINE_UNINTERESTING:
                                    set = diff_get_color_opt(o, DIFF_FILE_NEW_MOVED_ALT_DIM);
                                    break;
                            case DIFF_SYMBOL_MOVED_LINE |
                            DIFF_SYMBOL_MOVED_LINE_ALT:
                                    set = diff_get_color_opt(o, DIFF_FILE_NEW_MOVED_ALT);
                                    break;
                            case DIFF_SYMBOL_MOVED_LINE |
                            DIFF_SYMBOL_MOVED_LINE_UNINTERESTING:
                                    set = diff_get_color_opt(o, DIFF_FILE_NEW_MOVED_DIM);
                                    break;
                            case DIFF_SYMBOL_MOVED_LINE:
                                    set = diff_get_color_opt(o, DIFF_FILE_NEW_MOVED);
                                    break;
                            default:
                                    set = diff_get_color_opt(o, DIFF_FILE_NEW);
                            }
                            reset = diff_get_color_opt(o, DIFF_RESET);
                            if (!o->flags.dual_color_diffed_diffs)
                                    set_sign = NULL;
                            else {
                                    char c = !len ? 0 : line[0];

                                    set_sign = set;
                                    if (c == '-')
                                            set = diff_get_color_opt(o, DIFF_FILE_OLD_BOLD);
                                    else if (c == '@')
                                            set = diff_get_color_opt(o, DIFF_FRAGINFO);
                                    else if (c == '+')
                                            set = diff_get_color_opt(o, DIFF_FILE_NEW_BOLD);
                                    else
                                            set = diff_get_color_opt(o, DIFF_CONTEXT_BOLD);
                                    flags &= ~DIFF_SYMBOL_CONTENT_WS_MASK;
                            }
                            emit_line_ws_markup(o, set_sign, set, reset,
                                            OUTPUT_INDICATOR_NEW, line, len,
                                            flags & DIFF_SYMBOL_CONTENT_WS_MASK,
                                            flags & DIFF_SYMBOL_CONTENT_BLANK_LINE_EOF);
                            break;
                    case DIFF_SYMBOL_MINUS:
                            switch (flags & (DIFF_SYMBOL_MOVED_LINE |
                                            DIFF_SYMBOL_MOVED_LINE_ALT |
                                            DIFF_SYMBOL_MOVED_LINE_UNINTERESTING)) {
                            case DIFF_SYMBOL_MOVED_LINE |
                            DIFF_SYMBOL_MOVED_LINE_ALT |
                            DIFF_SYMBOL_MOVED_LINE_UNINTERESTING:
                                    set = diff_get_color_opt(o, DIFF_FILE_OLD_MOVED_ALT_DIM);
                                    break;
                            case DIFF_SYMBOL_MOVED_LINE |
                            DIFF_SYMBOL_MOVED_LINE_ALT:
                                    set = diff_get_color_opt(o, DIFF_FILE_OLD_MOVED_ALT);
                                    break;
                            case DIFF_SYMBOL_MOVED_LINE |
                            DIFF_SYMBOL_MOVED_LINE_UNINTERESTING:
                                    set = diff_get_color_opt(o, DIFF_FILE_OLD_MOVED_DIM);
                                    break;
                            case DIFF_SYMBOL_MOVED_LINE:
                                    set = diff_get_color_opt(o, DIFF_FILE_OLD_MOVED);
                                    break;
                            default:
                                    set = diff_get_color_opt(o, DIFF_FILE_OLD);
                            }
                            reset = diff_get_color_opt(o, DIFF_RESET);
                            if (!o->flags.dual_color_diffed_diffs)
                                    set_sign = NULL;
                            else {
                                    char c = !len ? 0 : line[0];

                                    set_sign = set;
                                    if (c == '+')
                                            set = diff_get_color_opt(o, DIFF_FILE_NEW_DIM);
                                    else if (c == '@')
                                            set = diff_get_color_opt(o, DIFF_FRAGINFO);
                                    else if (c == '-')
                                            set = diff_get_color_opt(o, DIFF_FILE_OLD_DIM);
                                    else
                                            set = diff_get_color_opt(o, DIFF_CONTEXT_DIM);
                            }
                            emit_line_ws_markup(o, set_sign, set, reset,
                                            OUTPUT_INDICATOR_OLD, line, len,
                                            flags & DIFF_SYMBOL_CONTENT_WS_MASK, 0);
                            break;
                    case DIFF_SYMBOL_WORDS_PORCELAIN:
                            context = diff_get_color_opt(o, DIFF_CONTEXT);
                            reset = diff_get_color_opt(o, DIFF_RESET);
                            emit_line(o, context, reset, line, len);
                            fputs("~\n", o->file);
                            break;
                    case DIFF_SYMBOL_WORDS:
                            context = diff_get_color_opt(o, DIFF_CONTEXT);
                            reset = diff_get_color_opt(o, DIFF_RESET);
                            /*
                            * Skip the prefix character, if any.  With
                            * diff_suppress_blank_empty, there may be
                            * none.
                            */
                            if (line[0] != '\n') {
                                    line++;
                                    len--;
                            }
                            emit_line(o, context, reset, line, len);
                            break;
                    case DIFF_SYMBOL_FILEPAIR_PLUS:
                            meta = diff_get_color_opt(o, DIFF_METAINFO);
                            reset = diff_get_color_opt(o, DIFF_RESET);
                            fprintf(o->file, "%s%s+++ %s%s%s\n", diff_line_prefix(o), meta,
                                    line, reset,
                                    strchr(line, ' ') ? "\t" : "");
                            break;
                    case DIFF_SYMBOL_FILEPAIR_MINUS:
                            meta = diff_get_color_opt(o, DIFF_METAINFO);
                            reset = diff_get_color_opt(o, DIFF_RESET);
                            fprintf(o->file, "%s%s--- %s%s%s\n", diff_line_prefix(o), meta,
                                    line, reset,
                                    strchr(line, ' ') ? "\t" : "");
                            break;
                    case DIFF_SYMBOL_BINARY_FILES:
                    case DIFF_SYMBOL_HEADER:
                            fprintf(o->file, "%s", line);
                            break;
                    case DIFF_SYMBOL_BINARY_DIFF_HEADER:
                            fprintf(o->file, "%sGIT binary patch\n", diff_line_prefix(o));
                            break;
                    case DIFF_SYMBOL_BINARY_DIFF_HEADER_DELTA:
                            fprintf(o->file, "%sdelta %s\n", diff_line_prefix(o), line);
                            break;
                    case DIFF_SYMBOL_BINARY_DIFF_HEADER_LITERAL:
                            fprintf(o->file, "%sliteral %s\n", diff_line_prefix(o), line);
                            break;
                    case DIFF_SYMBOL_BINARY_DIFF_FOOTER:
                            fputs(diff_line_prefix(o), o->file);
                            fputc('\n', o->file);
                            break;
                    case DIFF_SYMBOL_REWRITE_DIFF:
                            fraginfo = diff_get_color(o->use_color, DIFF_FRAGINFO);
                            reset = diff_get_color_opt(o, DIFF_RESET);
                            emit_line(o, fraginfo, reset, line, len);
                            break;
                    case DIFF_SYMBOL_SUBMODULE_ADD:
                            set = diff_get_color_opt(o, DIFF_FILE_NEW);
                            reset = diff_get_color_opt(o, DIFF_RESET);
                            emit_line(o, set, reset, line, len);
                            break;
                    case DIFF_SYMBOL_SUBMODULE_DEL:
                            set = diff_get_color_opt(o, DIFF_FILE_OLD);
                            reset = diff_get_color_opt(o, DIFF_RESET);
                            emit_line(o, set, reset, line, len);
                            break;
                    case DIFF_SYMBOL_SUBMODULE_UNTRACKED:
                            fprintf(o->file, "%sSubmodule %s contains untracked content\n",
                                    diff_line_prefix(o), line);
                            break;
                    case DIFF_SYMBOL_SUBMODULE_MODIFIED:
                            fprintf(o->file, "%sSubmodule %s contains modified content\n",
                                    diff_line_prefix(o), line);
                            break;
                    case DIFF_SYMBOL_STATS_SUMMARY_NO_FILES:
                            emit_line(o, "", "", " 0 files changed\n",
                                    strlen(" 0 files changed\n"));
                            break;
                    case DIFF_SYMBOL_STATS_SUMMARY_ABBREV:
                            emit_line(o, "", "", " ...\n", strlen(" ...\n"));
                            break;
                    case DIFF_SYMBOL_WORD_DIFF:
                            fprintf(o->file, "%.*s", len, line);
                            break;
                    case DIFF_SYMBOL_STAT_SEP:
                            fputs(o->stat_sep, o->file);
                            break;
                    default:
                            BUG("unknown diff symbol");
                    }
            }

            static void emit_diff_symbol(struct diff_options *o, enum diff_symbol s,
                                    const char *line, int len, unsigned flags)
            {
                    struct emitted_diff_symbol e = {
                            .line = line, .len = len, .flags = flags, .s = s
                    };

                    if (o->emitted_symbols)
                            append_emitted_diff_symbol(o, &e);
                    else
                            emit_diff_symbol_from_struct(o, &e);
            }

            void diff_emit_submodule_del(struct diff_options *o, const char *line)
            {
                    emit_diff_symbol(o, DIFF_SYMBOL_SUBMODULE_DEL, line, strlen(line), 0);
            }

            void diff_emit_submodule_add(struct diff_options *o, const char *line)
            {
                    emit_diff_symbol(o, DIFF_SYMBOL_SUBMODULE_ADD, line, strlen(line), 0);
            }

            void diff_emit_submodule_untracked(struct diff_options *o, const char *path)
            {
                    emit_diff_symbol(o, DIFF_SYMBOL_SUBMODULE_UNTRACKED,
                                    path, strlen(path), 0);
            }

            void diff_emit_submodule_modified(struct diff_options *o, const char *path)
            {
                    emit_diff_symbol(o, DIFF_SYMBOL_SUBMODULE_MODIFIED,
                                    path, strlen(path), 0);
            }

            void diff_emit_submodule_header(struct diff_options *o, const char *header)
            {
                    emit_diff_symbol(o, DIFF_SYMBOL_SUBMODULE_HEADER,
                                    header, strlen(header), 0);
            }

            void diff_emit_submodule_error(struct diff_options *o, const char *err)
            {
                    emit_diff_symbol(o, DIFF_SYMBOL_SUBMODULE_ERROR, err, strlen(err), 0);
            }

            void diff_emit_submodule_pipethrough(struct diff_options *o,
                                            const char *line, int len)
            {
                    emit_diff_symbol(o, DIFF_SYMBOL_SUBMODULE_PIPETHROUGH, line, len, 0);
            }

            static int new_blank_line_at_eof(struct emit_callback *ecbdata, const char *line, int len)
            {
                    if (!((ecbdata->ws_rule & WS_BLANK_AT_EOF) &&
                    ecbdata->blank_at_eof_in_preimage &&
                    ecbdata->blank_at_eof_in_postimage &&
                    ecbdata->blank_at_eof_in_preimage <= ecbdata->lno_in_preimage &&
                    ecbdata->blank_at_eof_in_postimage <= ecbdata->lno_in_postimage))
                            return 0;
                    return ws_blank_line(line, len);
            }

            static void emit_add_line(struct emit_callback *ecbdata,
                                    const char *line, int len)
            {
                    unsigned flags = WSEH_NEW | ecbdata->ws_rule;
                    if (new_blank_line_at_eof(ecbdata, line, len))
                            flags |= DIFF_SYMBOL_CONTENT_BLANK_LINE_EOF;

                    emit_diff_symbol(ecbdata->opt, DIFF_SYMBOL_PLUS, line, len, flags);
            }

            static void emit_del_line(struct emit_callback *ecbdata,
                                    const char *line, int len)
            {
                    unsigned flags = WSEH_OLD | ecbdata->ws_rule;
                    emit_diff_symbol(ecbdata->opt, DIFF_SYMBOL_MINUS, line, len, flags);
            }

            static void emit_context_line(struct emit_callback *ecbdata,
                                    const char *line, int len)
            {
                    unsigned flags = WSEH_CONTEXT | ecbdata->ws_rule;
                    emit_diff_symbol(ecbdata->opt, DIFF_SYMBOL_CONTEXT, line, len, flags);
            }

            static void emit_hunk_header(struct emit_callback *ecbdata,
                                    const char *line, int len)
            {
                    const char *context = diff_get_color(ecbdata->color_diff, DIFF_CONTEXT);
                    const char *frag = diff_get_color(ecbdata->color_diff, DIFF_FRAGINFO);
                    const char *func = diff_get_color(ecbdata->color_diff, DIFF_FUNCINFO);
                    const char *reset = diff_get_color(ecbdata->color_diff, DIFF_RESET);
                    const char *reverse = ecbdata->color_diff ? GIT_COLOR_REVERSE : "";
                    static const char atat[2] = { '@', '@' };
                    const char *cp, *ep;
                    struct strbuf msgbuf = STRBUF_INIT;
                    int org_len = len;
                    int i = 1;

                    /*
                    * As a hunk header must begin with "@@ -<old>, +<new> @@",
                    * it always is at least 10 bytes long.
                    */
                    if (len < 10 ||
                    memcmp(line, atat, 2) ||
                    !(ep = memmem(line + 2, len - 2, atat, 2))) {
                            emit_diff_symbol(ecbdata->opt,
                                            DIFF_SYMBOL_CONTEXT_MARKER, line, len, 0);
                            return;
                    }
                    ep += 2; /* skip over @@ */

                    /* The hunk header in fraginfo color */
                    if (ecbdata->opt->flags.dual_color_diffed_diffs)
                            strbuf_addstr(&msgbuf, reverse);
                    strbuf_addstr(&msgbuf, frag);
                    if (ecbdata->opt->flags.suppress_hunk_header_line_count)
                            strbuf_add(&msgbuf, atat, sizeof(atat));
                    else
                            strbuf_add(&msgbuf, line, ep - line);
                    strbuf_addstr(&msgbuf, reset);

                    /*
                    * trailing "\r\n"
                    */
                    for ( ; i < 3; i++)
                            if (line[len - i] == '\r' || line[len - i] == '\n')
                                    len--;

                    /* blank before the func header */
                    for (cp = ep; ep - line < len; ep++)
                            if (*ep != ' ' && *ep != '\t')
                                    break;
                    if (ep != cp) {
                            strbuf_addstr(&msgbuf, context);
                            strbuf_add(&msgbuf, cp, ep - cp);
                            strbuf_addstr(&msgbuf, reset);
                    }

                    if (ep < line + len) {
                            strbuf_addstr(&msgbuf, func);
                            strbuf_add(&msgbuf, ep, line + len - ep);
                            strbuf_addstr(&msgbuf, reset);
                    }

                    strbuf_add(&msgbuf, line + len, org_len - len);
                    strbuf_complete_line(&msgbuf);
                    emit_diff_symbol(ecbdata->opt,
                                    DIFF_SYMBOL_CONTEXT_FRAGINFO, msgbuf.buf, msgbuf.len, 0);
                    strbuf_release(&msgbuf);
            }

            static struct diff_tempfile *claim_diff_tempfile(void)
            {
                    int i;
                    for (i = 0; i < ARRAY_SIZE(diff_temp); i++)
                            if (!diff_temp[i].name)
                                    return diff_temp + i;
                    BUG("diff is failing to clean up its tempfiles");
            }

            static void remove_tempfile(void)
            {
                    int i;
                    for (i = 0; i < ARRAY_SIZE(diff_temp); i++) {
                            if (is_tempfile_active(diff_temp[i].tempfile))
                                    delete_tempfile(&diff_temp[i].tempfile);
                            diff_temp[i].name = NULL;
                    }
            }

            static void add_line_count(struct strbuf *out, int count)
            {
                    switch (count) {
                    case 0:
                            strbuf_addstr(out, "0,0");
                            break;
                    case 1:
                            strbuf_addstr(out, "1");
                            break;
                    default:
                            strbuf_addf(out, "1,%d", count);
                            break;
                    }
            }

            static void emit_rewrite_lines(struct emit_callback *ecb,
                                    int prefix, const char *data, int size)
            {
                    const char *endp = NULL;

                    while (0 < size) {
                            int len;

                            endp = memchr(data, '\n', size);
                            len = endp ? (endp - data + 1) : size;
                            if (prefix != '+') {
                                    ecb->lno_in_preimage++;
                                    emit_del_line(ecb, data, len);
                            } else {
                                    ecb->lno_in_postimage++;
                                    emit_add_line(ecb, data, len);
                            }
                            size -= len;
                            data += len;
                    }
                    if (!endp)
                            emit_diff_symbol(ecb->opt, DIFF_SYMBOL_NO_LF_EOF, NULL, 0, 0);
            }

            static void emit_rewrite_diff(const char *name_a,
                                    const char *name_b,
                                    struct diff_filespec *one,
                                    struct diff_filespec *two,
                                    struct userdiff_driver *textconv_one,
                                    struct userdiff_driver *textconv_two,
                                    struct diff_options *o)
            {
                    int lc_a, lc_b;
                    static struct strbuf a_name = STRBUF_INIT, b_name = STRBUF_INIT;
                    const char *a_prefix, *b_prefix;
                    char *data_one, *data_two;
                    size_t size_one, size_two;
                    struct emit_callback ecbdata;
                    struct strbuf out = STRBUF_INIT;

                    if (diff_mnemonic_prefix && o->flags.reverse_diff) {
                            a_prefix = o->b_prefix;
                            b_prefix = o->a_prefix;
                    } else {
                            a_prefix = o->a_prefix;
                            b_prefix = o->b_prefix;
                    }

                    name_a += (*name_a == '/');
                    name_b += (*name_b == '/');

                    strbuf_reset(&a_name);
                    strbuf_reset(&b_name);
                    quote_two_c_style(&a_name, a_prefix, name_a, 0);
                    quote_two_c_style(&b_name, b_prefix, name_b, 0);

                    size_one = fill_textconv(o->repo, textconv_one, one, &data_one);
                    size_two = fill_textconv(o->repo, textconv_two, two, &data_two);

                    memset(&ecbdata, 0, sizeof(ecbdata));
                    ecbdata.color_diff = want_color(o->use_color);
                    ecbdata.ws_rule = whitespace_rule(o->repo->index, name_b);
                    ecbdata.opt = o;
                    if (ecbdata.ws_rule & WS_BLANK_AT_EOF) {
                            mmfile_t mf1, mf2;
                            mf1.ptr = (char *)data_one;
                            mf2.ptr = (char *)data_two;
                            mf1.size = size_one;
                            mf2.size = size_two;
                            check_blank_at_eof(&mf1, &mf2, &ecbdata);
                    }
                    ecbdata.lno_in_preimage = 1;
                    ecbdata.lno_in_postimage = 1;

                    lc_a = count_lines(data_one, size_one);
                    lc_b = count_lines(data_two, size_two);

                    emit_diff_symbol(o, DIFF_SYMBOL_FILEPAIR_MINUS,
                                    a_name.buf, a_name.len, 0);
                    emit_diff_symbol(o, DIFF_SYMBOL_FILEPAIR_PLUS,
                                    b_name.buf, b_name.len, 0);

                    strbuf_addstr(&out, "@@ -");
                    if (!o->irreversible_delete)
                            add_line_count(&out, lc_a);
                    else
                            strbuf_addstr(&out, "?,?");
                    strbuf_addstr(&out, " +");
                    add_line_count(&out, lc_b);
                    strbuf_addstr(&out, " @@\n");
                    emit_diff_symbol(o, DIFF_SYMBOL_REWRITE_DIFF, out.buf, out.len, 0);
                    strbuf_release(&out);

                    if (lc_a && !o->irreversible_delete)
                            emit_rewrite_lines(&ecbdata, '-', data_one, size_one);
                    if (lc_b)
                            emit_rewrite_lines(&ecbdata, '+', data_two, size_two);
                    if (textconv_one)
                            free((char *)data_one);
                    if (textconv_two)
                            free((char *)data_two);
            }

            struct diff_words_buffer {
                    mmfile_t text;
                    unsigned long alloc;
                    struct diff_words_orig {
                            const char *begin, *end;
                    } *orig;
                    int orig_nr, orig_alloc;
            };

            static void diff_words_append(char *line, unsigned long len,
                            struct diff_words_buffer *buffer)
            {
                    ALLOC_GROW(buffer->text.ptr, buffer->text.size + len, buffer->alloc);
                    line++;
                    len--;
                    memcpy(buffer->text.ptr + buffer->text.size, line, len);
                    buffer->text.size += len;
                    buffer->text.ptr[buffer->text.size] = '\0';
            }

            struct diff_words_style_elem {
                    const char *prefix;
                    const char *suffix;
                    const char *color; /* NULL; filled in by the setup code if
                                    * color is enabled */
            };

            struct diff_words_style {
                    enum diff_words_type type;
                    struct diff_words_style_elem new_word, old_word, ctx;
                    const char *newline;
            };

            static struct diff_words_style diff_words_styles[] = {
                    { DIFF_WORDS_PORCELAIN, {"+", "\n"}, {"-", "\n"}, {" ", "\n"}, "~\n" },
                    { DIFF_WORDS_PLAIN, {"{+", "+}"}, {"[-", "-]"}, {"", ""}, "\n" },
                    { DIFF_WORDS_COLOR, {"", ""}, {"", ""}, {"", ""}, "\n" }
            };

            struct diff_words_data {
                    struct diff_words_buffer minus, plus;
                    const char *current_plus;
                    int last_minus;
                    struct diff_options *opt;
                    regex_t *word_regex;
                    enum diff_words_type type;
                    struct diff_words_style *style;
            };

            static int fn_out_diff_words_write_helper(struct diff_options *o,
                                                    struct diff_words_style_elem *st_el,
                                                    const char *newline,
                                                    size_t count, const char *buf)
            {
                    int print = 0;
                    struct strbuf sb = STRBUF_INIT;

                    while (count) {
                            char *p = memchr(buf, '\n', count);
                            if (print)
                                    strbuf_addstr(&sb, diff_line_prefix(o));

                            if (p != buf) {
                                    const char *reset = st_el->color && *st_el->color ?
                                                    GIT_COLOR_RESET : NULL;
                                    if (st_el->color && *st_el->color)
                                            strbuf_addstr(&sb, st_el->color);
                                    strbuf_addstr(&sb, st_el->prefix);
                                    strbuf_add(&sb, buf, p ? p - buf : count);
                                    strbuf_addstr(&sb, st_el->suffix);
                                    if (reset)
                                            strbuf_addstr(&sb, reset);
                            }
                            if (!p)
                                    goto out;

                            strbuf_addstr(&sb, newline);
                            count -= p + 1 - buf;
                            buf = p + 1;
                            print = 1;
                            if (count) {
                                    emit_diff_symbol(o, DIFF_SYMBOL_WORD_DIFF,
                                                    sb.buf, sb.len, 0);
                                    strbuf_reset(&sb);
                            }
                    }

            out:
                    if (sb.len)
                            emit_diff_symbol(o, DIFF_SYMBOL_WORD_DIFF,
                                            sb.buf, sb.len, 0);
                    strbuf_release(&sb);
                    return 0;
            }

            /*
            * '--color-words' algorithm can be described as:
            *
            *   1. collect the minus/plus lines of a diff hunk, divided into
            *      minus-lines and plus-lines;
            *
            *   2. break both minus-lines and plus-lines into words and
            *      place them into two mmfile_t with one word for each line;
            *
            *   3. use xdiff to run diff on the two mmfile_t to get the words level diff;
            *
            * And for the common parts of the both file, we output the plus side text.
            * diff_words->current_plus is used to trace the current position of the plus file
            * which printed. diff_words->last_minus is used to trace the last minus word
            * printed.
            *
            * For '--graph' to work with '--color-words', we need to output the graph prefix
            * on each line of color words output. Generally, there are two conditions on
            * which we should output the prefix.
            *
            *   1. diff_words->last_minus == 0 &&
            *      diff_words->current_plus == diff_words->plus.text.ptr
            *
            *      that is: the plus text must start as a new line, and if there is no minus
            *      word printed, a graph prefix must be printed.
            *
            *   2. diff_words->current_plus > diff_words->plus.text.ptr &&
            *      *(diff_words->current_plus - 1) == '\n'
            *
            *      that is: a graph prefix must be printed following a '\n'
            */
            static int color_words_output_graph_prefix(struct diff_words_data *diff_words)
            {
                    if ((diff_words->last_minus == 0 &&
                            diff_words->current_plus == diff_words->plus.text.ptr) ||
                            (diff_words->current_plus > diff_words->plus.text.ptr &&
                            *(diff_words->current_plus - 1) == '\n')) {
                            return 1;
                    } else {
                            return 0;
                    }
            }

            static void fn_out_diff_words_aux(void *priv,
                                            long minus_first, long minus_len,
                                            long plus_first, long plus_len,
                                            const char *func UNUSED, long funclen UNUSED)
            {
                    struct diff_words_data *diff_words = priv;
                    struct diff_words_style *style = diff_words->style;
                    const char *minus_begin, *minus_end, *plus_begin, *plus_end;
                    struct diff_options *opt = diff_words->opt;
                    const char *line_prefix;

                    assert(opt);
                    line_prefix = diff_line_prefix(opt);

                    /* POSIX requires that first be decremented by one if len == 0... */
                    if (minus_len) {
                            minus_begin = diff_words->minus.orig[minus_first].begin;
                            minus_end =
                                    diff_words->minus.orig[minus_first + minus_len - 1].end;
                    } else
                            minus_begin = minus_end =
                                    diff_words->minus.orig[minus_first].end;

                    if (plus_len) {
                            plus_begin = diff_words->plus.orig[plus_first].begin;
                            plus_end = diff_words->plus.orig[plus_first + plus_len - 1].end;
                    } else
                            plus_begin = plus_end = diff_words->plus.orig[plus_first].end;

                    if (color_words_output_graph_prefix(diff_words)) {
                            fputs(line_prefix, diff_words->opt->file);
                    }
                    if (diff_words->current_plus != plus_begin) {
                            fn_out_diff_words_write_helper(diff_words->opt,
                                            &style->ctx, style->newline,
                                            plus_begin - diff_words->current_plus,
                                            diff_words->current_plus);
                    }
                    if (minus_begin != minus_end) {
                            fn_out_diff_words_write_helper(diff_words->opt,
                                            &style->old_word, style->newline,
                                            minus_end - minus_begin, minus_begin);
                    }
                    if (plus_begin != plus_end) {
                            fn_out_diff_words_write_helper(diff_words->opt,
                                            &style->new_word, style->newline,
                                            plus_end - plus_begin, plus_begin);
                    }

                    diff_words->current_plus = plus_end;
                    diff_words->last_minus = minus_first;
            }

            /* This function starts looking at *begin, and returns 0 iff a word was found. */
            static int find_word_boundaries(mmfile_t *buffer, regex_t *word_regex,
                            int *begin, int *end)
            {
                    while (word_regex && *begin < buffer->size) {
                            regmatch_t match[1];
                            if (!regexec_buf(word_regex, buffer->ptr + *begin,
                                            buffer->size - *begin, 1, match, 0)) {
                                    char *p = memchr(buffer->ptr + *begin + match[0].rm_so,
                                                    '\n', match[0].rm_eo - match[0].rm_so);
                                    *end = p ? p - buffer->ptr : match[0].rm_eo + *begin;
                                    *begin += match[0].rm_so;
                                    if (*begin == *end)
                                            (*begin)++;
                                    else
                                            return *begin > *end;
                            } else {
                                    return -1;
                            }
                    }

                    /* find the next word */
                    while (*begin < buffer->size && isspace(buffer->ptr[*begin]))
                            (*begin)++;
                    if (*begin >= buffer->size)
                            return -1;

                    /* find the end of the word */
                    *end = *begin + 1;
                    while (*end < buffer->size && !isspace(buffer->ptr[*end]))
                            (*end)++;

                    return 0;
            }

            /*
            * This function splits the words in buffer->text, stores the list with
            * newline separator into out, and saves the offsets of the original words
            * in buffer->orig.
            */
            static void diff_words_fill(struct diff_words_buffer *buffer, mmfile_t *out,
                            regex_t *word_regex)
            {
                    int i, j;
                    long alloc = 0;

                    out->size = 0;
                    out->ptr = NULL;

                    /* fake an empty "0th" word */
                    ALLOC_GROW(buffer->orig, 1, buffer->orig_alloc);
                    buffer->orig[0].begin = buffer->orig[0].end = buffer->text.ptr;
                    buffer->orig_nr = 1;

                    for (i = 0; i < buffer->text.size; i++) {
                            if (find_word_boundaries(&buffer->text, word_regex, &i, &j))
                                    return;

                            /* store original boundaries */
                            ALLOC_GROW(buffer->orig, buffer->orig_nr + 1,
                                            buffer->orig_alloc);
                            buffer->orig[buffer->orig_nr].begin = buffer->text.ptr + i;
                            buffer->orig[buffer->orig_nr].end = buffer->text.ptr + j;
                            buffer->orig_nr++;

                            /* store one word */
                            ALLOC_GROW(out->ptr, out->size + j - i + 1, alloc);
                            memcpy(out->ptr + out->size, buffer->text.ptr + i, j - i);
                            out->ptr[out->size + j - i] = '\n';
                            out->size += j - i + 1;

                            i = j - 1;
                    }
            }

            /* this executes the word diff on the accumulated buffers */
            static void diff_words_show(struct diff_words_data *diff_words)
            {
                    xpparam_t xpp;
                    xdemitconf_t xecfg;
                    mmfile_t minus, plus;
                    struct diff_words_style *style = diff_words->style;

                    struct diff_options *opt = diff_words->opt;
                    const char *line_prefix;

                    assert(opt);
                    line_prefix = diff_line_prefix(opt);

                    /* special case: only removal */
                    if (!diff_words->plus.text.size) {
                            emit_diff_symbol(diff_words->opt, DIFF_SYMBOL_WORD_DIFF,
                                            line_prefix, strlen(line_prefix), 0);
                            fn_out_diff_words_write_helper(diff_words->opt,
                                    &style->old_word, style->newline,
                                    diff_words->minus.text.size,
                                    diff_words->minus.text.ptr);
                            diff_words->minus.text.size = 0;
                            return;
                    }

                    diff_words->current_plus = diff_words->plus.text.ptr;
                    diff_words->last_minus = 0;

                    memset(&xpp, 0, sizeof(xpp));
                    memset(&xecfg, 0, sizeof(xecfg));
                    diff_words_fill(&diff_words->minus, &minus, diff_words->word_regex);
                    diff_words_fill(&diff_words->plus, &plus, diff_words->word_regex);
                    xpp.flags = 0;
                    /* as only the hunk header will be parsed, we need a 0-context */
                    xecfg.ctxlen = 0;
                    if (xdi_diff_outf(&minus, &plus, fn_out_diff_words_aux, NULL,
                                    diff_words, &xpp, &xecfg))
                            die("unable to generate word diff");
                    free(minus.ptr);
                    free(plus.ptr);
                    if (diff_words->current_plus != diff_words->plus.text.ptr +
                                    diff_words->plus.text.size) {
                            if (color_words_output_graph_prefix(diff_words))
                                    emit_diff_symbol(diff_words->opt, DIFF_SYMBOL_WORD_DIFF,
                                                    line_prefix, strlen(line_prefix), 0);
                            fn_out_diff_words_write_helper(diff_words->opt,
                                    &style->ctx, style->newline,
                                    diff_words->plus.text.ptr + diff_words->plus.text.size
                                    - diff_words->current_plus, diff_words->current_plus);
                    }
                    diff_words->minus.text.size = diff_words->plus.text.size = 0;
            }

            /* In "color-words" mode, show word-diff of words accumulated in the buffer */
            static void diff_words_flush(struct emit_callback *ecbdata)
            {
                    struct diff_options *wo = ecbdata->diff_words->opt;

                    if (ecbdata->diff_words->minus.text.size ||
                    ecbdata->diff_words->plus.text.size)
                            diff_words_show(ecbdata->diff_words);

                    if (wo->emitted_symbols) {
                            struct diff_options *o = ecbdata->opt;
                            struct emitted_diff_symbols *wol = wo->emitted_symbols;
                            int i;

                            /*
                            * NEEDSWORK:
                            * Instead of appending each, concat all words to a line?
                            */
                            for (i = 0; i < wol->nr; i++)
                                    append_emitted_diff_symbol(o, &wol->buf[i]);

                            for (i = 0; i < wol->nr; i++)
                                    free((void *)wol->buf[i].line);

                            wol->nr = 0;
                    }
            }

            static void diff_filespec_load_driver(struct diff_filespec *one,
                                            struct index_state *istate)
            {
                    /* Use already-loaded driver */
                    if (one->driver)
                            return;

                    if (S_ISREG(one->mode))
                            one->driver = userdiff_find_by_path(istate, one->path);

                    /* Fallback to default settings */
                    if (!one->driver)
                            one->driver = userdiff_find_by_name("default");
            }

            static const char *userdiff_word_regex(struct diff_filespec *one,
                                            struct index_state *istate)
            {
                    diff_filespec_load_driver(one, istate);
                    return one->driver->word_regex;
            }

            static void init_diff_words_data(struct emit_callback *ecbdata,
                                            struct diff_options *orig_opts,
                                            struct diff_filespec *one,
                                            struct diff_filespec *two)
            {
                    int i;
                    struct diff_options *o = xmalloc(sizeof(struct diff_options));
                    memcpy(o, orig_opts, sizeof(struct diff_options));

                    CALLOC_ARRAY(ecbdata->diff_words, 1);
                    ecbdata->diff_words->type = o->word_diff;
                    ecbdata->diff_words->opt = o;

                    if (orig_opts->emitted_symbols)
                            CALLOC_ARRAY(o->emitted_symbols, 1);

                    if (!o->word_regex)
                            o->word_regex = userdiff_word_regex(one, o->repo->index);
                    if (!o->word_regex)
                            o->word_regex = userdiff_word_regex(two, o->repo->index);
                    if (!o->word_regex)
                            o->word_regex = diff_word_regex_cfg;
                    if (o->word_regex) {
                            ecbdata->diff_words->word_regex = (regex_t *)
                                    xmalloc(sizeof(regex_t));
                            if (regcomp(ecbdata->diff_words->word_regex,
                                    o->word_regex,
                                    REG_EXTENDED | REG_NEWLINE))
                                    die("invalid regular expression: %s",
                                    o->word_regex);
                    }
                    for (i = 0; i < ARRAY_SIZE(diff_words_styles); i++) {
                            if (o->word_diff == diff_words_styles[i].type) {
                                    ecbdata->diff_words->style =
                                            &diff_words_styles[i];
                                    break;
                            }
                    }
                    if (want_color(o->use_color)) {
                            struct diff_words_style *st = ecbdata->diff_words->style;
                            st->old_word.color = diff_get_color_opt(o, DIFF_FILE_OLD);
                            st->new_word.color = diff_get_color_opt(o, DIFF_FILE_NEW);
                            st->ctx.color = diff_get_color_opt(o, DIFF_CONTEXT);
                    }
            }

            static void free_diff_words_data(struct emit_callback *ecbdata)
            {
                    if (ecbdata->diff_words) {
                            diff_words_flush(ecbdata);
                            free_emitted_diff_symbols(ecbdata->diff_words->opt->emitted_symbols);
                            free (ecbdata->diff_words->opt);
                            free (ecbdata->diff_words->minus.text.ptr);
                            free (ecbdata->diff_words->minus.orig);
                            free (ecbdata->diff_words->plus.text.ptr);
                            free (ecbdata->diff_words->plus.orig);
                            if (ecbdata->diff_words->word_regex) {
                                    regfree(ecbdata->diff_words->word_regex);
                                    free(ecbdata->diff_words->word_regex);
                            }
                            FREE_AND_NULL(ecbdata->diff_words);
                    }
            }

            const char *diff_get_color(int diff_use_color, enum color_diff ix)
            {
                    if (want_color(diff_use_color))
                            return diff_colors[ix];
                    return "";
            }

            const char *diff_line_prefix(struct diff_options *opt)
            {
                    return opt->output_prefix ?
                            opt->output_prefix(opt, opt->output_prefix_data) :
                            "";
            }

            static unsigned long sane_truncate_line(char *line, unsigned long len)
            {
                    const char *cp;
                    unsigned long allot;
                    size_t l = len;

                    cp = line;
                    allot = l;
                    while (0 < l) {
                            (void) utf8_width(&cp, &l);
                            if (!cp)
                                    break; /* truncated in the middle? */
                    }
                    return allot - l;
            }

            static void find_lno(const char *line, struct emit_callback *ecbdata)
            {
                    const char *p;
                    ecbdata->lno_in_preimage = 0;
                    ecbdata->lno_in_postimage = 0;
                    p = strchr(line, '-');
                    if (!p)
                            return; /* cannot happen */
                    ecbdata->lno_in_preimage = strtol(p + 1, NULL, 10);
                    p = strchr(p, '+');
                    if (!p)
                            return; /* cannot happen */
                    ecbdata->lno_in_postimage = strtol(p + 1, NULL, 10);
            }

            static int fn_out_consume(void *priv, char *line, unsigned long len)
            {
                    struct emit_callback *ecbdata = priv;
                    struct diff_options *o = ecbdata->opt;

                    o->found_changes = 1;

                    if (ecbdata->header) {
                            emit_diff_symbol(o, DIFF_SYMBOL_HEADER,
                                            ecbdata->header->buf, ecbdata->header->len, 0);
                            strbuf_reset(ecbdata->header);
                            ecbdata->header = NULL;
                    }

                    if (ecbdata->label_path[0]) {
                            emit_diff_symbol(o, DIFF_SYMBOL_FILEPAIR_MINUS,
                                            ecbdata->label_path[0],
                                            strlen(ecbdata->label_path[0]), 0);
                            emit_diff_symbol(o, DIFF_SYMBOL_FILEPAIR_PLUS,
                                            ecbdata->label_path[1],
                                            strlen(ecbdata->label_path[1]), 0);
                            ecbdata->label_path[0] = ecbdata->label_path[1] = NULL;
                    }

                    if (diff_suppress_blank_empty
                    && len == 2 && line[0] == ' ' && line[1] == '\n') {
                            line[0] = '\n';
                            len = 1;
                    }

                    if (line[0] == '@') {
                            if (ecbdata->diff_words)
                                    diff_words_flush(ecbdata);
                            len = sane_truncate_line(line, len);
                            find_lno(line, ecbdata);
                            emit_hunk_header(ecbdata, line, len);
                            return 0;
                    }

                    if (ecbdata->diff_words) {
                            enum diff_symbol s =
                                    ecbdata->diff_words->type == DIFF_WORDS_PORCELAIN ?
                                    DIFF_SYMBOL_WORDS_PORCELAIN : DIFF_SYMBOL_WORDS;
                            if (line[0] == '-') {
                                    diff_words_append(line, len,
                                                    &ecbdata->diff_words->minus);
                                    return 0;
                            } else if (line[0] == '+') {
                                    diff_words_append(line, len,
                                                    &ecbdata->diff_words->plus);
                                    return 0;
                            } else if (starts_with(line, "\\ ")) {
                                    /*
                                    * Eat the "no newline at eof" marker as if we
                                    * saw a "+" or "-" line with nothing on it,
                                    * and return without diff_words_flush() to
                                    * defer processing. If this is the end of
                                    * preimage, more "+" lines may come after it.
                                    */
                                    return 0;
                            }
                            diff_words_flush(ecbdata);
                            emit_diff_symbol(o, s, line, len, 0);
                            return 0;
                    }

                    switch (line[0]) {
                    case '+':
                            ecbdata->lno_in_postimage++;
                            emit_add_line(ecbdata, line + 1, len - 1);
                            break;
                    case '-':
                            ecbdata->lno_in_preimage++;
                            emit_del_line(ecbdata, line + 1, len - 1);
                            break;
                    case ' ':
                            ecbdata->lno_in_postimage++;
                            ecbdata->lno_in_preimage++;
                            emit_context_line(ecbdata, line + 1, len - 1);
                            break;
                    default:
                            /* incomplete line at the end */
                            ecbdata->lno_in_preimage++;
                            emit_diff_symbol(o, DIFF_SYMBOL_CONTEXT_INCOMPLETE,
                                            line, len, 0);
                            break;
                    }
                    return 0;
            }

            static void pprint_rename(struct strbuf *name, const char *a, const char *b)
            {
                    const char *old_name = a;
                    const char *new_name = b;
                    int pfx_length, sfx_length;
                    int pfx_adjust_for_slash;
                    int len_a = strlen(a);
                    int len_b = strlen(b);
                    int a_midlen, b_midlen;
                    int qlen_a = quote_c_style(a, NULL, NULL, 0);
                    int qlen_b = quote_c_style(b, NULL, NULL, 0);

                    if (qlen_a || qlen_b) {
                            quote_c_style(a, name, NULL, 0);
                            strbuf_addstr(name, " => ");
                            quote_c_style(b, name, NULL, 0);
                            return;
                    }

                    /* Find common prefix */
                    pfx_length = 0;
                    while (*old_name && *new_name && *old_name == *new_name) {
                            if (*old_name == '/')
                                    pfx_length = old_name - a + 1;
                            old_name++;
                            new_name++;
                    }

                    /* Find common suffix */
                    old_name = a + len_a;
                    new_name = b + len_b;
                    sfx_length = 0;
                    /*
                    * If there is a common prefix, it must end in a slash.  In
                    * that case we let this loop run 1 into the prefix to see the
                    * same slash.
                    *
                    * If there is no common prefix, we cannot do this as it would
                    * underrun the input strings.
                    */
                    pfx_adjust_for_slash = (pfx_length ? 1 : 0);
                    while (a + pfx_length - pfx_adjust_for_slash <= old_name &&
                    b + pfx_length - pfx_adjust_for_slash <= new_name &&
                    *old_name == *new_name) {
                            if (*old_name == '/')
                                    sfx_length = len_a - (old_name - a);
                            old_name--;
                            new_name--;
                    }

                    /*
                    * pfx{mid-a => mid-b}sfx
                    * {pfx-a => pfx-b}sfx
                    * pfx{sfx-a => sfx-b}
                    * name-a => name-b
                    */
                    a_midlen = len_a - pfx_length - sfx_length;
                    b_midlen = len_b - pfx_length - sfx_length;
                    if (a_midlen < 0)
                            a_midlen = 0;
                    if (b_midlen < 0)
                            b_midlen = 0;

                    strbuf_grow(name, pfx_length + a_midlen + b_midlen + sfx_length + 7);
                    if (pfx_length + sfx_length) {
                            strbuf_add(name, a, pfx_length);
                            strbuf_addch(name, '{');
                    }
                    strbuf_add(name, a + pfx_length, a_midlen);
                    strbuf_addstr(name, " => ");
                    strbuf_add(name, b + pfx_length, b_midlen);
                    if (pfx_length + sfx_length) {
                            strbuf_addch(name, '}');
                            strbuf_add(name, a + len_a - sfx_length, sfx_length);
                    }
            }

            static struct diffstat_file *diffstat_add(struct diffstat_t *diffstat,
                                                    const char *name_a,
                                                    const char *name_b)
            {
                    struct diffstat_file *x;
                    CALLOC_ARRAY(x, 1);
                    ALLOC_GROW(diffstat->files, diffstat->nr + 1, diffstat->alloc);
                    diffstat->files[diffstat->nr++] = x;
                    if (name_b) {
                            x->from_name = xstrdup(name_a);
                            x->name = xstrdup(name_b);
                            x->is_renamed = 1;
                    }
                    else {
                            x->from_name = NULL;
                            x->name = xstrdup(name_a);
                    }
                    return x;
            }

            static int diffstat_consume(void *priv, char *line, unsigned long len)
            {
                    struct diffstat_t *diffstat = priv;
                    struct diffstat_file *x = diffstat->files[diffstat->nr - 1];

                    if (!len)
                            BUG("xdiff fed us an empty line");

                    if (line[0] == '+')
                            x->added++;
                    else if (line[0] == '-')
                            x->deleted++;
                    return 0;
            }

            const char mime_boundary_leader[] = "------------";

            static int scale_linear(int it, int width, int max_change)
            {
                    if (!it)
                            return 0;
                    /*
                    * make sure that at least one '-' or '+' is printed if
                    * there is any change to this path. The easiest way is to
                    * scale linearly as if the allotted width is one column shorter
                    * than it is, and then add 1 to the result.
                    */
                    return 1 + (it * (width - 1) / max_change);
            }

            static void show_graph(struct strbuf *out, char ch, int cnt,
                            const char *set, const char *reset)
            {
                    if (cnt <= 0)
                            return;
                    strbuf_addstr(out, set);
                    strbuf_addchars(out, ch, cnt);
                    strbuf_addstr(out, reset);
            }

            static void fill_print_name(struct diffstat_file *file)
            {
                    struct strbuf pname = STRBUF_INIT;

                    if (file->print_name)
                            return;

                    if (file->is_renamed)
                            pprint_rename(&pname, file->from_name, file->name);
                    else
                            quote_c_style(file->name, &pname, NULL, 0);

                    if (file->comments)
                            strbuf_addf(&pname, " (%s)", file->comments);

                    file->print_name = strbuf_detach(&pname, NULL);
            }

            static void print_stat_summary_inserts_deletes(struct diff_options *options,
                            int files, int insertions, int deletions)
            {
                    struct strbuf sb = STRBUF_INIT;

                    if (!files) {
                            assert(insertions == 0 && deletions == 0);
                            emit_diff_symbol(options, DIFF_SYMBOL_STATS_SUMMARY_NO_FILES,
                                            NULL, 0, 0);
                            return;
                    }

                    strbuf_addf(&sb,
                            (files == 1) ? " %d file changed" : " %d files changed",
                            files);

                    /*
                    * For binary diff, the caller may want to print "x files
                    * changed" with insertions == 0 && deletions == 0.
                    *
                    * Not omitting "0 insertions(+), 0 deletions(-)" in this case
                    * is probably less confusing (i.e skip over "2 files changed
                    * but nothing about added/removed lines? Is this a bug in Git?").
                    */
                    if (insertions || deletions == 0) {
                            strbuf_addf(&sb,
                                    (insertions == 1) ? ", %d insertion(+)" : ", %d insertions(+)",
                                    insertions);
                    }

                    if (deletions || insertions == 0) {
                            strbuf_addf(&sb,
                                    (deletions == 1) ? ", %d deletion(-)" : ", %d deletions(-)",
                                    deletions);
                    }
                    strbuf_addch(&sb, '\n');
                    emit_diff_symbol(options, DIFF_SYMBOL_STATS_SUMMARY_INSERTS_DELETES,
                                    sb.buf, sb.len, 0);
                    strbuf_release(&sb);
            }

            void print_stat_summary(FILE *fp, int files,
                                    int insertions, int deletions)
            {
                    struct diff_options o;
                    memset(&o, 0, sizeof(o));
                    o.file = fp;

                    print_stat_summary_inserts_deletes(&o, files, insertions, deletions);
            }

            static void show_stats(struct diffstat_t *data, struct diff_options *options)
            {
                    int i, len, add, del, adds = 0, dels = 0;
                    uintmax_t max_change = 0, max_len = 0;
                    int total_files = data->nr, count;
                    int width, name_width, graph_width, number_width = 0, bin_width = 0;
                    const char *reset, *add_c, *del_c;
                    int extra_shown = 0;
                    const char *line_prefix = diff_line_prefix(options);
                    struct strbuf out = STRBUF_INIT;

                    if (data->nr == 0)
                            return;

                    count = options->stat_count ? options->stat_count : data->nr;

                    reset = diff_get_color_opt(options, DIFF_RESET);
                    add_c = diff_get_color_opt(options, DIFF_FILE_NEW);
                    del_c = diff_get_color_opt(options, DIFF_FILE_OLD);

                    /*
                    * Find the longest filename and max number of changes
                    */
                    for (i = 0; (i < count) && (i < data->nr); i++) {
                            struct diffstat_file *file = data->files[i];
                            uintmax_t change = file->added + file->deleted;

                            if (!file->is_interesting && (change == 0)) {
                                    count++; /* not shown == room for one more */
                                    continue;
                            }
                            fill_print_name(file);
                            len = utf8_strwidth(file->print_name);
                            if (max_len < len)
                                    max_len = len;

                            if (file->is_unmerged) {
                                    /* "Unmerged" is 8 characters */
                                    bin_width = bin_width < 8 ? 8 : bin_width;
                                    continue;
                            }
                            if (file->is_binary) {
                                    /* "Bin XXX -> YYY bytes" */
                                    int w = 14 + decimal_width(file->added)
                                            + decimal_width(file->deleted);
                                    bin_width = bin_width < w ? w : bin_width;
                                    /* Display change counts aligned with "Bin" */
                                    number_width = 3;
                                    continue;
                            }

                            if (max_change < change)
                                    max_change = change;
                    }
                    count = i; /* where we can stop scanning in data->files[] */

                    /*
                    * We have width = stat_width or term_columns() columns total.
                    * We want a maximum of min(max_len, stat_name_width) for the name part.
                    * We want a maximum of min(max_change, stat_graph_width) for the +- part.
                    * We also need 1 for " " and 4 + decimal_width(max_change)
                    * for " | NNNN " and one the empty column at the end, altogether
                    * 6 + decimal_width(max_change).
                    *
                    * If there's not enough space, we will use the smaller of
                    * stat_name_width (if set) and 5/8*width for the filename,
                    * and the rest for constant elements + graph part, but no more
                    * than stat_graph_width for the graph part.
                    * (5/8 gives 50 for filename and 30 for the constant parts + graph
                    * for the standard terminal size).
                    *
                    * In other words: stat_width limits the maximum width, and
                    * stat_name_width fixes the maximum width of the filename,
                    * and is also used to divide available columns if there
                    * aren't enough.
                    *
                    * Binary files are displayed with "Bin XXX -> YYY bytes"
                    * instead of the change count and graph. This part is treated
                    * similarly to the graph part, except that it is not
                    * "scaled". If total width is too small to accommodate the
                    * guaranteed minimum width of the filename part and the
                    * separators and this message, this message will "overflow"
                    * making the line longer than the maximum width.
                    */

                    /*
                    * NEEDSWORK: line_prefix is often used for "log --graph" output
                    * and contains ANSI-colored string.  utf8_strnwidth() should be
                    * used to correctly count the display width instead of strlen().
                    */
                    if (options->stat_width == -1)
                            width = term_columns() - strlen(line_prefix);
                    else
                            width = options->stat_width ? options->stat_width : 80;
                    number_width = decimal_width(max_change) > number_width ?
                            decimal_width(max_change) : number_width;

                    if (options->stat_name_width == -1)
                            options->stat_name_width = diff_stat_name_width;
                    if (options->stat_graph_width == -1)
                            options->stat_graph_width = diff_stat_graph_width;

                    /*
                    * Guarantee 3/8*16 == 6 for the graph part
                    * and 5/8*16 == 10 for the filename part
                    */
                    if (width < 16 + 6 + number_width)
                            width = 16 + 6 + number_width;

                    /*
                    * First assign sizes that are wanted, ignoring available width.
                    * strlen("Bin XXX -> YYY bytes") == bin_width, and the part
                    * starting from "XXX" should fit in graph_width.
                    */
                    graph_width = max_change + 4 > bin_width ? max_change : bin_width - 4;
                    if (options->stat_graph_width &&
                    options->stat_graph_width < graph_width)
                            graph_width = options->stat_graph_width;

                    name_width = (options->stat_name_width > 0 &&
                            options->stat_name_width < max_len) ?
                            options->stat_name_width : max_len;

                    /*
                    * Adjust adjustable widths not to exceed maximum width
                    */
                    if (name_width + number_width + 6 + graph_width > width) {
                            if (graph_width > width * 3/8 - number_width - 6) {
                                    graph_width = width * 3/8 - number_width - 6;
                                    if (graph_width < 6)
                                            graph_width = 6;
                            }

                            if (options->stat_graph_width &&
                            graph_width > options->stat_graph_width)
                                    graph_width = options->stat_graph_width;
                            if (name_width > width - number_width - 6 - graph_width)
                                    name_width = width - number_width - 6 - graph_width;
                            else
                                    graph_width = width - number_width - 6 - name_width;
                    }

                    /*
                    * From here name_width is the width of the name area,
                    * and graph_width is the width of the graph area.
                    * max_change is used to scale graph properly.
                    */
                    for (i = 0; i < count; i++) {
                            const char *prefix = "";
                            struct diffstat_file *file = data->files[i];
                            char *name = file->print_name;
                            uintmax_t added = file->added;
                            uintmax_t deleted = file->deleted;
                            int name_len, padding;

                            if (!file->is_interesting && (added + deleted == 0))
                                    continue;

                            /*
                            * "scale" the filename
                            */
                            len = name_width;
                            name_len = utf8_strwidth(name);
                            if (name_width < name_len) {
                                    char *slash;
                                    prefix = "...";
                                    len -= 3;
                                    /*
                                    * NEEDSWORK: (name_len - len) counts the display
                                    * width, which would be shorter than the byte
                                    * length of the corresponding substring.
                                    * Advancing "name" by that number of bytes does
                                    * *NOT* skip over that many columns, so it is
                                    * very likely that chomping the pathname at the
                                    * slash we will find starting from "name" will
                                    * leave the resulting string still too long.
                                    */
                                    name += name_len - len;
                                    slash = strchr(name, '/');
                                    if (slash)
                                            name = slash;
                            }
                            padding = len - utf8_strwidth(name);
                            if (padding < 0)
                                    padding = 0;

                            if (file->is_binary) {
                                    strbuf_addf(&out, " %s%s%*s | %*s",
                                            prefix, name, padding, "",
                                            number_width, "Bin");
                                    if (!added && !deleted) {
                                            strbuf_addch(&out, '\n');
                                            emit_diff_symbol(options, DIFF_SYMBOL_STATS_LINE,
                                                            out.buf, out.len, 0);
                                            strbuf_reset(&out);
                                            continue;
                                    }
                                    strbuf_addf(&out, " %s%"PRIuMAX"%s",
                                            del_c, deleted, reset);
                                    strbuf_addstr(&out, " -> ");
                                    strbuf_addf(&out, "%s%"PRIuMAX"%s",
                                            add_c, added, reset);
                                    strbuf_addstr(&out, " bytes\n");
                                    emit_diff_symbol(options, DIFF_SYMBOL_STATS_LINE,
                                                    out.buf, out.len, 0);
                                    strbuf_reset(&out);
                                    continue;
                            }
                            else if (file->is_unmerged) {
                                    strbuf_addf(&out, " %s%s%*s | %*s",
                                            prefix, name, padding, "",
                                            number_width, "Unmerged\n");
                                    emit_diff_symbol(options, DIFF_SYMBOL_STATS_LINE,
                                                    out.buf, out.len, 0);
                                    strbuf_reset(&out);
                                    continue;
                            }

                            /*
                            * scale the add/delete
                            */
                            add = added;
                            del = deleted;

                            if (graph_width <= max_change) {
                                    int total = scale_linear(add + del, graph_width, max_change);
                                    if (total < 2 && add && del)
                                            /* width >= 2 due to the sanity check */
                                            total = 2;
                                    if (add < del) {
                                            add = scale_linear(add, graph_width, max_change);
                                            del = total - add;
                                    } else {
                                            del = scale_linear(del, graph_width, max_change);
                                            add = total - del;
                                    }
                            }
                            strbuf_addf(&out, " %s%s%*s | %*"PRIuMAX"%s",
                                    prefix, name, padding, "",
                                    number_width, added + deleted,
                                    added + deleted ? " " : "");
                            show_graph(&out, '+', add, add_c, reset);
                            show_graph(&out, '-', del, del_c, reset);
                            strbuf_addch(&out, '\n');
                            emit_diff_symbol(options, DIFF_SYMBOL_STATS_LINE,
                                            out.buf, out.len, 0);
                            strbuf_reset(&out);
                    }

                    for (i = 0; i < data->nr; i++) {
                            struct diffstat_file *file = data->files[i];
                            uintmax_t added = file->added;
                            uintmax_t deleted = file->deleted;

                            if (file->is_unmerged ||
                            (!file->is_interesting && (added + deleted == 0))) {
                                    total_files--;
                                    continue;
                            }

                            if (!file->is_binary) {
                                    adds += added;
                                    dels += deleted;
                            }
                            if (i < count)
                                    continue;
                            if (!extra_shown)
                                    emit_diff_symbol(options,
                                                    DIFF_SYMBOL_STATS_SUMMARY_ABBREV,
                                                    NULL, 0, 0);
                            extra_shown = 1;
                    }

                    print_stat_summary_inserts_deletes(options, total_files, adds, dels);
                    strbuf_release(&out);
            }

            static void show_shortstats(struct diffstat_t *data, struct diff_options *options)
            {
                    int i, adds = 0, dels = 0, total_files = data->nr;

                    if (data->nr == 0)
                            return;

                    for (i = 0; i < data->nr; i++) {
                            int added = data->files[i]->added;
                            int deleted = data->files[i]->deleted;

                            if (data->files[i]->is_unmerged ||
                            (!data->files[i]->is_interesting && (added + deleted == 0))) {
                                    total_files--;
                            } else if (!data->files[i]->is_binary) { /* don't count bytes */
                                    adds += added;
                                    dels += deleted;
                            }
                    }
                    print_stat_summary_inserts_deletes(options, total_files, adds, dels);
            }

            static void show_numstat(struct diffstat_t *data, struct diff_options *options)
            {
                    int i;

                    if (data->nr == 0)
                            return;

                    for (i = 0; i < data->nr; i++) {
                            struct diffstat_file *file = data->files[i];

                            fprintf(options->file, "%s", diff_line_prefix(options));

                            if (file->is_binary)
                                    fprintf(options->file, "-\t-\t");
                            else
                                    fprintf(options->file,
                                            "%"PRIuMAX"\t%"PRIuMAX"\t",
                                            file->added, file->deleted);
                            if (options->line_termination) {
                                    fill_print_name(file);
                                    if (!file->is_renamed)
                                            write_name_quoted(file->name, options->file,
                                                            options->line_termination);
                                    else {
                                            fputs(file->print_name, options->file);
                                            putc(options->line_termination, options->file);
                                    }
                            } else {
                                    if (file->is_renamed) {
                                            putc('\0', options->file);
                                            write_name_quoted(file->from_name, options->file, '\0');
                                    }
                                    write_name_quoted(file->name, options->file, '\0');
                            }
                    }
            }

            struct dirstat_file {
                    const char *name;
                    unsigned long changed;
            };

            struct dirstat_dir {
                    struct dirstat_file *files;
                    int alloc, nr, permille, cumulative;
            };

            static long gather_dirstat(struct diff_options *opt, struct dirstat_dir *dir,
                            unsigned long changed, const char *base, int baselen)
            {
                    unsigned long sum_changes = 0;
                    unsigned int sources = 0;
                    const char *line_prefix = diff_line_prefix(opt);

                    while (dir->nr) {
                            struct dirstat_file *f = dir->files;
                            int namelen = strlen(f->name);
                            unsigned long changes;
                            char *slash;

                            if (namelen < baselen)
                                    break;
                            if (memcmp(f->name, base, baselen))
                                    break;
                            slash = strchr(f->name + baselen, '/');
                            if (slash) {
                                    int newbaselen = slash + 1 - f->name;
                                    changes = gather_dirstat(opt, dir, changed, f->name, newbaselen);
                                    sources++;
                            } else {
                                    changes = f->changed;
                                    dir->files++;
                                    dir->nr--;
                                    sources += 2;
                            }
                            sum_changes += changes;
                    }

                    /*
                    * We don't report dirstat's for
                    *  - the top level
                    *  - or cases where everything came from a single directory
                    *    under this directory (sources == 1).
                    */
                    if (baselen && sources != 1) {
                            if (sum_changes) {
                                    int permille = sum_changes * 1000 / changed;
                                    if (permille >= dir->permille) {
                                            fprintf(opt->file, "%s%4d.%01d%% %.*s\n", line_prefix,
                                                    permille / 10, permille % 10, baselen, base);
                                            if (!dir->cumulative)
                                                    return 0;
                                    }
                            }
                    }
                    return sum_changes;
            }

            static int dirstat_compare(const void *_a, const void *_b)
            {
                    const struct dirstat_file *a = _a;
                    const struct dirstat_file *b = _b;
                    return strcmp(a->name, b->name);
            }

            static void conclude_dirstat(struct diff_options *options,
                                    struct dirstat_dir *dir,
                                    unsigned long changed)
            {
                    struct dirstat_file *to_free = dir->files;

                    if (!changed) {
                            /* This can happen even with many files, if everything was renames */
                            ;
                    } else {
                            /* Show all directories with more than x% of the changes */
                            QSORT(dir->files, dir->nr, dirstat_compare);
                            gather_dirstat(options, dir, changed, "", 0);
                    }

                    free(to_free);
            }

            static void show_dirstat(struct diff_options *options)
            {
                    int i;
                    unsigned long changed;
                    struct dirstat_dir dir;
                    struct diff_queue_struct *q = &diff_queued_diff;

                    dir.files = NULL;
                    dir.alloc = 0;
                    dir.nr = 0;
                    dir.permille = options->dirstat_permille;
                    dir.cumulative = options->flags.dirstat_cumulative;

                    changed = 0;
                    for (i = 0; i < q->nr; i++) {
                            struct diff_filepair *p = q->queue[i];
                            const char *name;
                            unsigned long copied, added, damage;
                            struct diff_populate_filespec_options dpf_options = {
                                    .check_size_only = 1,
                            };

                            name = p->two->path ? p->two->path : p->one->path;

                            if (p->one->oid_valid && p->two->oid_valid &&
                            oideq(&p->one->oid, &p->two->oid)) {
                                    /*
                                    * The SHA1 has not changed, so pre-/post-content is
                                    * identical. We can therefore skip looking at the
                                    * file contents altogether.
                                    */
                                    damage = 0;
                                    goto found_damage;
                            }

                            if (options->flags.dirstat_by_file) {
                                    /*
                                    * In --dirstat-by-file mode, we don't really need to
                                    * look at the actual file contents at all.
                                    * The fact that the SHA1 changed is enough for us to
                                    * add this file to the list of results
                                    * (with each file contributing equal damage).
                                    */
                                    damage = 1;
                                    goto found_damage;
                            }

                            if (DIFF_FILE_VALID(p->one) && DIFF_FILE_VALID(p->two)) {
                                    diff_populate_filespec(options->repo, p->one, NULL);
                                    diff_populate_filespec(options->repo, p->two, NULL);
                                    diffcore_count_changes(options->repo,
                                                    p->one, p->two, NULL, NULL,
                                                    &copied, &added);
                                    diff_free_filespec_data(p->one);
                                    diff_free_filespec_data(p->two);
                            } else if (DIFF_FILE_VALID(p->one)) {
                                    diff_populate_filespec(options->repo, p->one, &dpf_options);
                                    copied = added = 0;
                                    diff_free_filespec_data(p->one);
                            } else if (DIFF_FILE_VALID(p->two)) {
                                    diff_populate_filespec(options->repo, p->two, &dpf_options);
                                    copied = 0;
                                    added = p->two->size;
                                    diff_free_filespec_data(p->two);
                            } else
                                    continue;

                            /*
                            * Original minus copied is the removed material,
                            * added is the new material.  They are both damages
                            * made to the preimage.
                            * If the resulting damage is zero, we know that
                            * diffcore_count_changes() considers the two entries to
                            * be identical, but since the oid changed, we
                            * know that there must have been _some_ kind of change,
                            * so we force all entries to have damage > 0.
                            */
                            damage = (p->one->size - copied) + added;
                            if (!damage)
                                    damage = 1;

            found_damage:
                            ALLOC_GROW(dir.files, dir.nr + 1, dir.alloc);
                            dir.files[dir.nr].name = name;
                            dir.files[dir.nr].changed = damage;
                            changed += damage;
                            dir.nr++;
                    }

                    conclude_dirstat(options, &dir, changed);
            }

            static void show_dirstat_by_line(struct diffstat_t *data, struct diff_options *options)
            {
                    int i;
                    unsigned long changed;
                    struct dirstat_dir dir;

                    if (data->nr == 0)
                            return;

                    dir.files = NULL;
                    dir.alloc = 0;
                    dir.nr = 0;
                    dir.permille = options->dirstat_permille;
                    dir.cumulative = options->flags.dirstat_cumulative;

                    changed = 0;
                    for (i = 0; i < data->nr; i++) {
                            struct diffstat_file *file = data->files[i];
                            unsigned long damage = file->added + file->deleted;
                            if (file->is_binary)
                                    /*
                                    * binary files counts bytes, not lines. Must find some
                                    * way to normalize binary bytes vs. textual lines.
                                    * The following heuristic assumes that there are 64
                                    * bytes per "line".
                                    * This is stupid and ugly, but very cheap...
                                    */
                                    damage = DIV_ROUND_UP(damage, 64);
                            ALLOC_GROW(dir.files, dir.nr + 1, dir.alloc);
                            dir.files[dir.nr].name = file->name;
                            dir.files[dir.nr].changed = damage;
                            changed += damage;
                            dir.nr++;
                    }

                    conclude_dirstat(options, &dir, changed);
            }

            static void free_diffstat_file(struct diffstat_file *f)
            {
                    free(f->print_name);
                    free(f->name);
                    free(f->from_name);
                    free(f);
            }

            void free_diffstat_info(struct diffstat_t *diffstat)
            {
                    int i;
                    for (i = 0; i < diffstat->nr; i++)
                            free_diffstat_file(diffstat->files[i]);
                    free(diffstat->files);
            }

            struct checkdiff_t {
                    const char *filename;
                    int lineno;
                    int conflict_marker_size;
                    struct diff_options *o;
                    unsigned ws_rule;
                    unsigned status;
            };

            static int is_conflict_marker(const char *line, int marker_size, unsigned long len)
            {
                    char firstchar;
                    int cnt;

                    if (len < marker_size + 1)
                            return 0;
                    firstchar = line[0];
                    switch (firstchar) {
                    case '=': case '>': case '<': case '|':
                            break;
                    default:
                            return 0;
                    }
                    for (cnt = 1; cnt < marker_size; cnt++)
                            if (line[cnt] != firstchar)
                                    return 0;
                    /* line[1] through line[marker_size-1] are same as firstchar */
                    if (len < marker_size + 1 || !isspace(line[marker_size]))
                            return 0;
                    return 1;
            }

            static void checkdiff_consume_hunk(void *priv,
                                            long ob UNUSED, long on UNUSED,
                                            long nb, long nn UNUSED,
                                            const char *func UNUSED, long funclen UNUSED)

            {
                    struct checkdiff_t *data = priv;
                    data->lineno = nb - 1;
            }

            static int checkdiff_consume(void *priv, char *line, unsigned long len)
            {
                    struct checkdiff_t *data = priv;
                    int marker_size = data->conflict_marker_size;
                    const char *ws = diff_get_color(data->o->use_color, DIFF_WHITESPACE);
                    const char *reset = diff_get_color(data->o->use_color, DIFF_RESET);
                    const char *set = diff_get_color(data->o->use_color, DIFF_FILE_NEW);
                    char *err;
                    const char *line_prefix;

                    assert(data->o);
                    line_prefix = diff_line_prefix(data->o);

                    if (line[0] == '+') {
                            unsigned bad;
                            data->lineno++;
                            if (is_conflict_marker(line + 1, marker_size, len - 1)) {
                                    data->status |= 1;
                                    fprintf(data->o->file,
                                            "%s%s:%d: leftover conflict marker\n",
                                            line_prefix, data->filename, data->lineno);
                            }
                            bad = ws_check(line + 1, len - 1, data->ws_rule);
                            if (!bad)
                                    return 0;
                            data->status |= bad;
                            err = whitespace_error_string(bad);
                            fprintf(data->o->file, "%s%s:%d: %s.\n",
                                    line_prefix, data->filename, data->lineno, err);
                            free(err);
                            emit_line(data->o, set, reset, line, 1);
                            ws_check_emit(line + 1, len - 1, data->ws_rule,
                                    data->o->file, set, reset, ws);
                    } else if (line[0] == ' ') {
                            data->lineno++;
                    }
                    return 0;
            }

            static unsigned char *deflate_it(char *data,
                                            unsigned long size,
                                            unsigned long *result_size)
            {
                    int bound;
                    unsigned char *deflated;
                    git_zstream stream;

                    git_deflate_init(&stream, zlib_compression_level);
                    bound = git_deflate_bound(&stream, size);
                    deflated = xmalloc(bound);
                    stream.next_out = deflated;
                    stream.avail_out = bound;

                    stream.next_in = (unsigned char *)data;
                    stream.avail_in = size;
                    while (git_deflate(&stream, Z_FINISH) == Z_OK)
                            ; /* nothing */
                    git_deflate_end(&stream);
                    *result_size = stream.total_out;
                    return deflated;
            }

            static void emit_binary_diff_body(struct diff_options *o,
                                            mmfile_t *one, mmfile_t *two)
            {
                    void *cp;
                    void *delta;
                    void *deflated;
                    void *data;
                    unsigned long orig_size;
                    unsigned long delta_size;
                    unsigned long deflate_size;
                    unsigned long data_size;

                    /* We could do deflated delta, or we could do just deflated two,
                    * whichever is smaller.
                    */
                    delta = NULL;
                    deflated = deflate_it(two->ptr, two->size, &deflate_size);
                    if (one->size && two->size) {
                            delta = diff_delta(one->ptr, one->size,
                                            two->ptr, two->size,
                                            &delta_size, deflate_size);
                            if (delta) {
                                    void *to_free = delta;
                                    orig_size = delta_size;
                                    delta = deflate_it(delta, delta_size, &delta_size);
                                    free(to_free);
                            }
                    }

                    if (delta && delta_size < deflate_size) {
                            char *s = xstrfmt("%"PRIuMAX , (uintmax_t)orig_size);
                            emit_diff_symbol(o, DIFF_SYMBOL_BINARY_DIFF_HEADER_DELTA,
                                            s, strlen(s), 0);
                            free(s);
                            free(deflated);
                            data = delta;
                            data_size = delta_size;
                    } else {
                            char *s = xstrfmt("%lu", two->size);
                            emit_diff_symbol(o, DIFF_SYMBOL_BINARY_DIFF_HEADER_LITERAL,
                                            s, strlen(s), 0);
                            free(s);
                            free(delta);
                            data = deflated;
                            data_size = deflate_size;
                    }

                    /* emit data encoded in base85 */
                    cp = data;
                    while (data_size) {
                            int len;
                            int bytes = (52 < data_size) ? 52 : data_size;
                            char line[71];
                            data_size -= bytes;
                            if (bytes <= 26)
                                    line[0] = bytes + 'A' - 1;
                            else
                                    line[0] = bytes - 26 + 'a' - 1;
                            encode_85(line + 1, cp, bytes);
                            cp = (char *) cp + bytes;

                            len = strlen(line);
                            line[len++] = '\n';
                            line[len] = '\0';

                            emit_diff_symbol(o, DIFF_SYMBOL_BINARY_DIFF_BODY,
                                            line, len, 0);
                    }
                    emit_diff_symbol(o, DIFF_SYMBOL_BINARY_DIFF_FOOTER, NULL, 0, 0);
                    free(data);
            }

            static void emit_binary_diff(struct diff_options *o,
                                    mmfile_t *one, mmfile_t *two)
            {
                    emit_diff_symbol(o, DIFF_SYMBOL_BINARY_DIFF_HEADER, NULL, 0, 0);
                    emit_binary_diff_body(o, one, two);
                    emit_binary_diff_body(o, two, one);
            }

            int diff_filespec_is_binary(struct repository *r,
                                    struct diff_filespec *one)
            {
                    struct diff_populate_filespec_options dpf_options = {
                            .check_binary = 1,
                    };

                    if (one->is_binary == -1) {
                            diff_filespec_load_driver(one, r->index);
                            if (one->driver->binary != -1)
                                    one->is_binary = one->driver->binary;
                            else {
                                    if (!one->data && DIFF_FILE_VALID(one))
                                            diff_populate_filespec(r, one, &dpf_options);
                                    if (one->is_binary == -1 && one->data)
                                            one->is_binary = buffer_is_binary(one->data,
                                                            one->size);
                                    if (one->is_binary == -1)
                                            one->is_binary = 0;
                            }
                    }
                    return one->is_binary;
            }

            static const struct userdiff_funcname *
            diff_funcname_pattern(struct diff_options *o, struct diff_filespec *one)
            {
                    diff_filespec_load_driver(one, o->repo->index);
                    return one->driver->funcname.pattern ? &one->driver->funcname : NULL;
            }

            void diff_set_mnemonic_prefix(struct diff_options *options, const char *a, const char *b)
            {
                    if (!options->a_prefix)
                            options->a_prefix = a;
                    if (!options->b_prefix)
                            options->b_prefix = b;
            }

            void diff_set_noprefix(struct diff_options *options)
            {
                    options->a_prefix = options->b_prefix = "";
            }

            void diff_set_default_prefix(struct diff_options *options)
            {
                    options->a_prefix = diff_src_prefix ? diff_src_prefix : "a/";
                    options->b_prefix = diff_dst_prefix ? diff_dst_prefix : "b/";
            }

            struct userdiff_driver *get_textconv(struct repository *r,
                                            struct diff_filespec *one)
            {
                    if (!DIFF_FILE_VALID(one))
                            return NULL;

                    diff_filespec_load_driver(one, r->index);
                    return userdiff_get_textconv(r, one->driver);
            }

            static struct string_list *additional_headers(struct diff_options *o,
                                                    const char *path)
            {
                    if (!o->additional_path_headers)
                            return NULL;
                    return strmap_get(o->additional_path_headers, path);
            }

            static void add_formatted_header(struct strbuf *msg,
                                            const char *header,
                                            const char *line_prefix,
                                            const char *meta,
                                            const char *reset)
            {
                    const char *next, *newline;

                    for (next = header; *next; next = newline) {
                            newline = strchrnul(next, '\n');
                            strbuf_addf(msg, "%s%s%.*s%s\n", line_prefix, meta,
                                    (int)(newline - next), next, reset);
                            if (*newline)
                                    newline++;
                    }
            }

            static void add_formatted_headers(struct strbuf *msg,
                                            struct string_list *more_headers,
                                            const char *line_prefix,
                                            const char *meta,
                                            const char *reset)
            {
                    int i;

                    for (i = 0; i < more_headers->nr; i++)
                            add_formatted_header(msg, more_headers->items[i].string,
                                            line_prefix, meta, reset);
            }

            static int diff_filepair_is_phoney(struct diff_filespec *one,
                                            struct diff_filespec *two)
            {
                    /*
                    * This function specifically looks for pairs injected by
                    * create_filepairs_for_header_only_notifications().  Such
                    * pairs are "phoney" in that they do not represent any
                    * content or even mode difference, but were inserted because
                    * diff_queued_diff previously had no pair associated with
                    * that path but we needed some pair to avoid losing the
                    * "remerge CONFLICT" header associated with the path.
                    */
                    return !DIFF_FILE_VALID(one) && !DIFF_FILE_VALID(two);
            }

            static int set_diff_algorithm(struct diff_options *opts,
                                    const char *alg)
            {
                    long value = parse_algorithm_value(alg);

                    if (value < 0)
                            return -1;

                    /* clear out previous settings */
                    DIFF_XDL_CLR(opts, NEED_MINIMAL);
                    opts->xdl_opts &= ~XDF_DIFF_ALGORITHM_MASK;
                    opts->xdl_opts |= value;

                    return 0;
            }

            static void builtin_diff(const char *name_a,
                                    const char *name_b,
                                    struct diff_filespec *one,
                                    struct diff_filespec *two,
                                    const char *xfrm_msg,
                                    int must_show_header,
                                    struct diff_options *o,
                                    int complete_rewrite)
            {
                    mmfile_t mf1, mf2;
                    const char *lbl[2];
                    char *a_one, *b_two;
                    const char *meta = diff_get_color_opt(o, DIFF_METAINFO);
                    const char *reset = diff_get_color_opt(o, DIFF_RESET);
                    const char *a_prefix, *b_prefix;
                    struct userdiff_driver *textconv_one = NULL;
                    struct userdiff_driver *textconv_two = NULL;
                    struct strbuf header = STRBUF_INIT;
                    const char *line_prefix = diff_line_prefix(o);

                    diff_set_mnemonic_prefix(o, "a/", "b/");
                    if (o->flags.reverse_diff) {
                            a_prefix = o->b_prefix;
                            b_prefix = o->a_prefix;
                    } else {
                            a_prefix = o->a_prefix;
                            b_prefix = o->b_prefix;
                    }

                    if (o->submodule_format == DIFF_SUBMODULE_LOG &&
                    (!one->mode || S_ISGITLINK(one->mode)) &&
                    (!two->mode || S_ISGITLINK(two->mode)) &&
                    (!diff_filepair_is_phoney(one, two))) {
                            show_submodule_diff_summary(o, one->path ? one->path : two->path,
                                            &one->oid, &two->oid,
                                            two->dirty_submodule);
                            o->found_changes = 1;
                            return;
                    } else if (o->submodule_format == DIFF_SUBMODULE_INLINE_DIFF &&
                            (!one->mode || S_ISGITLINK(one->mode)) &&
                            (!two->mode || S_ISGITLINK(two->mode)) &&
                            (!diff_filepair_is_phoney(one, two))) {
                            show_submodule_inline_diff(o, one->path ? one->path : two->path,
                                            &one->oid, &two->oid,
                                            two->dirty_submodule);
                            o->found_changes = 1;
                            return;
                    }

                    if (o->flags.allow_textconv) {
                            textconv_one = get_textconv(o->repo, one);
                            textconv_two = get_textconv(o->repo, two);
                    }

                    /* Never use a non-valid filename anywhere if at all possible */
                    name_a = DIFF_FILE_VALID(one) ? name_a : name_b;
                    name_b = DIFF_FILE_VALID(two) ? name_b : name_a;

                    a_one = quote_two(a_prefix, name_a + (*name_a == '/'));
                    b_two = quote_two(b_prefix, name_b + (*name_b == '/'));
                    lbl[0] = DIFF_FILE_VALID(one) ? a_one : "/dev/null";
                    lbl[1] = DIFF_FILE_VALID(two) ? b_two : "/dev/null";
                    if (diff_filepair_is_phoney(one, two)) {
                            /*
                            * We should only reach this point for pairs generated from
                            * create_filepairs_for_header_only_notifications().  For
                            * these, we want to avoid the "/dev/null" special casing
                            * above, because we do not want such pairs shown as either
                            * "new file" or "deleted file" below.
                            */
                            lbl[0] = a_one;
                            lbl[1] = b_two;
                    }
                    strbuf_addf(&header, "%s%sdiff --git %s %s%s\n", line_prefix, meta, a_one, b_two, reset);
                    if (lbl[0][0] == '/') {
                            /* /dev/null */
                            strbuf_addf(&header, "%s%snew file mode %06o%s\n", line_prefix, meta, two->mode, reset);
                            if (xfrm_msg)
                                    strbuf_addstr(&header, xfrm_msg);
                            o->found_changes = 1;
                            must_show_header = 1;
                    }
                    else if (lbl[1][0] == '/') {
                            strbuf_addf(&header, "%s%sdeleted file mode %06o%s\n", line_prefix, meta, one->mode, reset);
                            if (xfrm_msg)
                                    strbuf_addstr(&header, xfrm_msg);
                            o->found_changes = 1;
                            must_show_header = 1;
                    }
                    else {
                            if (one->mode != two->mode) {
                                    strbuf_addf(&header, "%s%sold mode %06o%s\n", line_prefix, meta, one->mode, reset);
                                    strbuf_addf(&header, "%s%snew mode %06o%s\n", line_prefix, meta, two->mode, reset);
                                    o->found_changes = 1;
                                    must_show_header = 1;
                            }
                            if (xfrm_msg)
                                    strbuf_addstr(&header, xfrm_msg);

                            /*
                            * we do not run diff between different kind
                            * of objects.
                            */
                            if ((one->mode ^ two->mode) & S_IFMT)
                                    goto free_ab_and_return;
                            if (complete_rewrite &&
                            (textconv_one || !diff_filespec_is_binary(o->repo, one)) &&
                            (textconv_two || !diff_filespec_is_binary(o->repo, two))) {
                                    emit_diff_symbol(o, DIFF_SYMBOL_HEADER,
                                                    header.buf, header.len, 0);
                                    strbuf_reset(&header);
                                    emit_rewrite_diff(name_a, name_b, one, two,
                                                    textconv_one, textconv_two, o);
                                    o->found_changes = 1;
                                    goto free_ab_and_return;
                            }
                    }

                    if (o->irreversible_delete && lbl[1][0] == '/') {
                            emit_diff_symbol(o, DIFF_SYMBOL_HEADER, header.buf,
                                            header.len, 0);
                            strbuf_reset(&header);
                            goto free_ab_and_return;
                    } else if (!o->flags.text &&
                            ( (!textconv_one && diff_filespec_is_binary(o->repo, one)) ||
                            (!textconv_two && diff_filespec_is_binary(o->repo, two)) )) {
                            struct strbuf sb = STRBUF_INIT;
                            if (!one->data && !two->data &&
                            S_ISREG(one->mode) && S_ISREG(two->mode) &&
                            !o->flags.binary) {
                                    if (oideq(&one->oid, &two->oid)) {
                                            if (must_show_header)
                                                    emit_diff_symbol(o, DIFF_SYMBOL_HEADER,
                                                                    header.buf, header.len,
                                                                    0);
                                            goto free_ab_and_return;
                                    }
                                    emit_diff_symbol(o, DIFF_SYMBOL_HEADER,
                                                    header.buf, header.len, 0);
                                    strbuf_addf(&sb, "%sBinary files %s and %s differ\n",
                                            diff_line_prefix(o), lbl[0], lbl[1]);
                                    emit_diff_symbol(o, DIFF_SYMBOL_BINARY_FILES,
                                                    sb.buf, sb.len, 0);
                                    strbuf_release(&sb);
                                    o->found_changes = 1;
                                    goto free_ab_and_return;
                            }
                            if (fill_mmfile(o->repo, &mf1, one) < 0 ||
                            fill_mmfile(o->repo, &mf2, two) < 0)
                                    die("unable to read files to diff");
                            /* Quite common confusing case */
                            if (mf1.size == mf2.size &&
                            !memcmp(mf1.ptr, mf2.ptr, mf1.size)) {
                                    if (must_show_header)
                                            emit_diff_symbol(o, DIFF_SYMBOL_HEADER,
                                                            header.buf, header.len, 0);
                                    goto free_ab_and_return;
                            }
                            emit_diff_symbol(o, DIFF_SYMBOL_HEADER, header.buf, header.len, 0);
                            strbuf_reset(&header);
                            if (o->flags.binary)
                                    emit_binary_diff(o, &mf1, &mf2);
                            else {
                                    strbuf_addf(&sb, "%sBinary files %s and %s differ\n",
                                            diff_line_prefix(o), lbl[0], lbl[1]);
                                    emit_diff_symbol(o, DIFF_SYMBOL_BINARY_FILES,
                                                    sb.buf, sb.len, 0);
                                    strbuf_release(&sb);
                            }
                            o->found_changes = 1;
                    } else {
                            /* Crazy xdl interfaces.. */
                            const char *diffopts;
                            const char *v;
                            xpparam_t xpp;
                            xdemitconf_t xecfg;
                            struct emit_callback ecbdata;
                            const struct userdiff_funcname *pe;

                            if (must_show_header) {
                                    emit_diff_symbol(o, DIFF_SYMBOL_HEADER,
                                                    header.buf, header.len, 0);
                                    strbuf_reset(&header);
                            }

                            mf1.size = fill_textconv(o->repo, textconv_one, one, &mf1.ptr);
                            mf2.size = fill_textconv(o->repo, textconv_two, two, &mf2.ptr);

                            pe = diff_funcname_pattern(o, one);
                            if (!pe)
                                    pe = diff_funcname_pattern(o, two);

                            memset(&xpp, 0, sizeof(xpp));
                            memset(&xecfg, 0, sizeof(xecfg));
                            memset(&ecbdata, 0, sizeof(ecbdata));
                            if (o->flags.suppress_diff_headers)
                                    lbl[0] = NULL;
                            ecbdata.label_path = lbl;
                            ecbdata.color_diff = want_color(o->use_color);
                            ecbdata.ws_rule = whitespace_rule(o->repo->index, name_b);
                            if (ecbdata.ws_rule & WS_BLANK_AT_EOF)
                                    check_blank_at_eof(&mf1, &mf2, &ecbdata);
                            ecbdata.opt = o;
                            if (header.len && !o->flags.suppress_diff_headers)
                                    ecbdata.header = &header;
                            xpp.flags = o->xdl_opts;
                            xpp.ignore_regex = o->ignore_regex;
                            xpp.ignore_regex_nr = o->ignore_regex_nr;
                            xpp.anchors = o->anchors;
                            xpp.anchors_nr = o->anchors_nr;
                            xecfg.ctxlen = o->context;
                            xecfg.interhunkctxlen = o->interhunkcontext;
                            xecfg.flags = XDL_EMIT_FUNCNAMES;
                            if (o->flags.funccontext)
                                    xecfg.flags |= XDL_EMIT_FUNCCONTEXT;
                            if (pe)
                                    xdiff_set_find_func(&xecfg, pe->pattern, pe->cflags);

                            diffopts = getenv("GIT_DIFF_OPTS");
                            if (!diffopts)
                                    ;
                            else if (skip_prefix(diffopts, "--unified=", &v))
                                    xecfg.ctxlen = strtoul(v, NULL, 10);
                            else if (skip_prefix(diffopts, "-u", &v))
                                    xecfg.ctxlen = strtoul(v, NULL, 10);

                            if (o->word_diff)
                                    init_diff_words_data(&ecbdata, o, one, two);
                            if (xdi_diff_outf(&mf1, &mf2, NULL, fn_out_consume,
                                            &ecbdata, &xpp, &xecfg))
                                    die("unable to generate diff for %s", one->path);
                            if (o->word_diff)
                                    free_diff_words_data(&ecbdata);
                            if (textconv_one)
                                    free(mf1.ptr);
                            if (textconv_two)
                                    free(mf2.ptr);
                            xdiff_clear_find_func(&xecfg);
                    }

            free_ab_and_return:
                    strbuf_release(&header);
                    diff_free_filespec_data(one);
                    diff_free_filespec_data(two);
                    free(a_one);
                    free(b_two);
                    return;
            }

            static const char *get_compact_summary(const struct diff_filepair *p, int is_renamed)
            {
                    if (!is_renamed) {
                            if (p->status == DIFF_STATUS_ADDED) {
                                    if (S_ISLNK(p->two->mode))
                                            return "new +l";
                                    else if ((p->two->mode & 0777) == 0755)
                                            return "new +x";
                                    else
                                            return "new";
                            } else if (p->status == DIFF_STATUS_DELETED)
                                    return "gone";
                    }
                    if (S_ISLNK(p->one->mode) && !S_ISLNK(p->two->mode))
                            return "mode -l";
                    else if (!S_ISLNK(p->one->mode) && S_ISLNK(p->two->mode))
                            return "mode +l";
                    else if ((p->one->mode & 0777) == 0644 &&
                            (p->two->mode & 0777) == 0755)
                            return "mode +x";
                    else if ((p->one->mode & 0777) == 0755 &&
                            (p->two->mode & 0777) == 0644)
                            return "mode -x";
                    return NULL;
            }

            static void builtin_diffstat(const char *name_a, const char *name_b,
                                    struct diff_filespec *one,
                                    struct diff_filespec *two,
                                    struct diffstat_t *diffstat,
                                    struct diff_options *o,
                                    struct diff_filepair *p)
            {
                    mmfile_t mf1, mf2;
                    struct diffstat_file *data;
                    int may_differ;
                    int complete_rewrite = 0;

                    if (!DIFF_PAIR_UNMERGED(p)) {
                            if (p->status == DIFF_STATUS_MODIFIED && p->score)
                                    complete_rewrite = 1;
                    }

                    data = diffstat_add(diffstat, name_a, name_b);
                    data->is_interesting = p->status != DIFF_STATUS_UNKNOWN;
                    if (o->flags.stat_with_summary)
                            data->comments = get_compact_summary(p, data->is_renamed);

                    if (!one || !two) {
                            data->is_unmerged = 1;
                            return;
                    }

                    /* saves some reads if true, not a guarantee of diff outcome */
                    may_differ = !(one->oid_valid && two->oid_valid &&
                                    oideq(&one->oid, &two->oid));

                    if (diff_filespec_is_binary(o->repo, one) ||
                    diff_filespec_is_binary(o->repo, two)) {
                            data->is_binary = 1;
                            if (!may_differ) {
                                    data->added = 0;
                                    data->deleted = 0;
                            } else {
                                    data->added = diff_filespec_size(o->repo, two);
                                    data->deleted = diff_filespec_size(o->repo, one);
                            }
                    }

                    else if (complete_rewrite) {
                            diff_populate_filespec(o->repo, one, NULL);
                            diff_populate_filespec(o->repo, two, NULL);
                            data->deleted = count_lines(one->data, one->size);
                            data->added = count_lines(two->data, two->size);
                    }

                    else if (may_differ) {
                            /* Crazy xdl interfaces.. */
                            xpparam_t xpp;
                            xdemitconf_t xecfg;

                            if (fill_mmfile(o->repo, &mf1, one) < 0 ||
                            fill_mmfile(o->repo, &mf2, two) < 0)
                                    die("unable to read files to diff");

                            memset(&xpp, 0, sizeof(xpp));
                            memset(&xecfg, 0, sizeof(xecfg));
                            xpp.flags = o->xdl_opts;
                            xpp.ignore_regex = o->ignore_regex;
                            xpp.ignore_regex_nr = o->ignore_regex_nr;
                            xpp.anchors = o->anchors;
                            xpp.anchors_nr = o->anchors_nr;
                            xecfg.ctxlen = o->context;
                            xecfg.interhunkctxlen = o->interhunkcontext;
                            xecfg.flags = XDL_EMIT_NO_HUNK_HDR;
                            if (xdi_diff_outf(&mf1, &mf2, NULL,
                                            diffstat_consume, diffstat, &xpp, &xecfg))
                                    die("unable to generate diffstat for %s", one->path);

                            if (DIFF_FILE_VALID(one) && DIFF_FILE_VALID(two)) {
                                    struct diffstat_file *file =
                                            diffstat->files[diffstat->nr - 1];
                                    /*
                                    * Omit diffstats of modified files where nothing changed.
                                    * Even if may_differ, this might be the case due to
                                    * ignoring whitespace changes, etc.
                                    *
                                    * But note that we special-case additions, deletions,
                                    * renames, and mode changes as adding an empty file,
                                    * for example is still of interest.
                                    */
                                    if ((p->status == DIFF_STATUS_MODIFIED)
                                            && !file->added
                                            && !file->deleted
                                            && one->mode == two->mode) {
                                            free_diffstat_file(file);
                                            diffstat->nr--;
                                    }
                            }
                    }

                    diff_free_filespec_data(one);
                    diff_free_filespec_data(two);
            }

            static void builtin_checkdiff(const char *name_a, const char *name_b,
                                    const char *attr_path,
                                    struct diff_filespec *one,
                                    struct diff_filespec *two,
                                    struct diff_options *o)
            {
                    mmfile_t mf1, mf2;
                    struct checkdiff_t data;

                    if (!two)
                            return;

                    memset(&data, 0, sizeof(data));
                    data.filename = name_b ? name_b : name_a;
                    data.lineno = 0;
                    data.o = o;
                    data.ws_rule = whitespace_rule(o->repo->index, attr_path);
                    data.conflict_marker_size = ll_merge_marker_size(o->repo->index, attr_path);

                    if (fill_mmfile(o->repo, &mf1, one) < 0 ||
                    fill_mmfile(o->repo, &mf2, two) < 0)
                            die("unable to read files to diff");

                    /*
                    * All the other codepaths check both sides, but not checking
                    * the "old" side here is deliberate.  We are checking the newly
                    * introduced changes, and as long as the "new" side is text, we
                    * can and should check what it introduces.
                    */
                    if (diff_filespec_is_binary(o->repo, two))
                            goto free_and_return;
                    else {
                            /* Crazy xdl interfaces.. */
                            xpparam_t xpp;
                            xdemitconf_t xecfg;

                            memset(&xpp, 0, sizeof(xpp));
                            memset(&xecfg, 0, sizeof(xecfg));
                            xecfg.ctxlen = 1; /* at least one context line */
                            xpp.flags = 0;
                            if (xdi_diff_outf(&mf1, &mf2, checkdiff_consume_hunk,
                                            checkdiff_consume, &data,
                                            &xpp, &xecfg))
                                    die("unable to generate checkdiff for %s", one->path);

                            if (data.ws_rule & WS_BLANK_AT_EOF) {
                                    struct emit_callback ecbdata;
                                    int blank_at_eof;

                                    ecbdata.ws_rule = data.ws_rule;
                                    check_blank_at_eof(&mf1, &mf2, &ecbdata);
                                    blank_at_eof = ecbdata.blank_at_eof_in_postimage;

                                    if (blank_at_eof) {
                                            static char *err;
                                            if (!err)
                                                    err = whitespace_error_string(WS_BLANK_AT_EOF);
                                            fprintf(o->file, "%s:%d: %s.\n",
                                                    data.filename, blank_at_eof, err);
                                            data.status = 1; /* report errors */
                                    }
                            }
                    }
            free_and_return:
                    diff_free_filespec_data(one);
                    diff_free_filespec_data(two);
                    if (data.status)
                            o->flags.check_failed = 1;
            }

            struct diff_filespec *alloc_filespec(const char *path)
            {
                    struct diff_filespec *spec;

                    FLEXPTR_ALLOC_STR(spec, path, path);
                    spec->count = 1;
                    spec->is_binary = -1;
                    return spec;
            }

            void free_filespec(struct diff_filespec *spec)
            {
                    if (!--spec->count) {
                            diff_free_filespec_data(spec);
                            free(spec);
                    }
            }

            void fill_filespec(struct diff_filespec *spec, const struct object_id *oid,
                            int oid_valid, unsigned short mode)
            {
                    if (mode) {
                            spec->mode = canon_mode(mode);
                            oidcpy(&spec->oid, oid);
                            spec->oid_valid = oid_valid;
                    }
            }

            /*
            * Given a name and sha1 pair, if the index tells us the file in
            * the work tree has that object contents, return true, so that
            * prepare_temp_file() does not have to inflate and extract.
            */
            static int reuse_worktree_file(struct index_state *istate,
                                    const char *name,
                                    const struct object_id *oid,
                                    int want_file)
            {
                    const struct cache_entry *ce;
                    struct stat st;
                    int pos, len;

                    /*
                    * We do not read the cache ourselves here, because the
                    * benchmark with my previous version that always reads cache
                    * shows that it makes things worse for diff-tree comparing
                    * two linux-2.6 kernel trees in an already checked out work
                    * tree.  This is because most diff-tree comparisons deal with
                    * only a small number of files, while reading the cache is
                    * expensive for a large project, and its cost outweighs the
                    * savings we get by not inflating the object to a temporary
                    * file.  Practically, this code only helps when we are used
                    * by diff-cache --cached, which does read the cache before
                    * calling us.
                    */
                    if (!istate->cache)
                            return 0;

                    /* We want to avoid the working directory if our caller
                    * doesn't need the data in a normal file, this system
                    * is rather slow with its stat/open/mmap/close syscalls,
                    * and the object is contained in a pack file.  The pack
                    * is probably already open and will be faster to obtain
                    * the data through than the working directory.  Loose
                    * objects however would tend to be slower as they need
                    * to be individually opened and inflated.
                    */
                    if (!FAST_WORKING_DIRECTORY && !want_file &&
                    has_object_pack(istate->repo, oid))
                            return 0;

                    /*
                    * Similarly, if we'd have to convert the file contents anyway, that
                    * makes the optimization not worthwhile.
                    */
                    if (!want_file && would_convert_to_git(istate, name))
                            return 0;

                    /*
                    * If this path does not match our sparse-checkout definition,
                    * then the file will not be in the working directory.
                    */
                    if (!path_in_sparse_checkout(name, istate))
                            return 0;

                    len = strlen(name);
                    pos = index_name_pos(istate, name, len);
                    if (pos < 0)
                            return 0;
                    ce = istate->cache[pos];

                    /*
                    * This is not the sha1 we are looking for, or
                    * unreusable because it is not a regular file.
                    */
                    if (!oideq(oid, &ce->oid) || !S_ISREG(ce->ce_mode))
                            return 0;

                    /*
                    * If ce is marked as "assume unchanged", there is no
                    * guarantee that work tree matches what we are looking for.
                    */
                    if ((ce->ce_flags & CE_VALID) || ce_skip_worktree(ce))
                            return 0;

                    /*
                    * If ce matches the file in the work tree, we can reuse it.
                    */
                    if (ce_uptodate(ce) ||
                    (!lstat(name, &st) && !ie_match_stat(istate, ce, &st, 0)))
                            return 1;

                    return 0;
            }

            static int diff_populate_gitlink(struct diff_filespec *s, int size_only)
            {
                    struct strbuf buf = STRBUF_INIT;
                    const char *dirty = "";

                    /* Are we looking at the work tree? */
                    if (s->dirty_submodule)
                            dirty = "-dirty";

                    strbuf_addf(&buf, "Subproject commit %s%s\n",
                            oid_to_hex(&s->oid), dirty);
                    s->size = buf.len;
                    if (size_only) {
                            s->data = NULL;
                            strbuf_release(&buf);
                    } else {
                            s->data = strbuf_detach(&buf, NULL);
                            s->should_free = 1;
                    }
                    return 0;
            }

            /*
            * While doing rename detection and pickaxe operation, we may need to
            * grab the data for the blob (or file) for our own in-core comparison.
            * diff_filespec has data and size fields for this purpose.
            */
            int diff_populate_filespec(struct repository *r,
                                    struct diff_filespec *s,
                                    const struct diff_populate_filespec_options *options)
            {
                    int size_only = options ? options->check_size_only : 0;
                    int check_binary = options ? options->check_binary : 0;
                    int err = 0;
                    int conv_flags = global_conv_flags_eol;
                    /*
                    * demote FAIL to WARN to allow inspecting the situation
                    * instead of refusing.
                    */
                    if (conv_flags & CONV_EOL_RNDTRP_DIE)
                            conv_flags = CONV_EOL_RNDTRP_WARN;

                    if (!DIFF_FILE_VALID(s))
                            die("internal error: asking to populate invalid file.");
                    if (S_ISDIR(s->mode))
                            return -1;

                    if (s->data)
                            return 0;

                    if (size_only && 0 < s->size)
                            return 0;

                    if (S_ISGITLINK(s->mode))
                            return diff_populate_gitlink(s, size_only);

                    if (!s->oid_valid ||
                    reuse_worktree_file(r->index, s->path, &s->oid, 0)) {
                            struct strbuf buf = STRBUF_INIT;
                            struct stat st;
                            int fd;

                            if (lstat(s->path, &st) < 0) {
                            err_empty:
                                    err = -1;
                            empty:
                                    s->data = (char *)"";
                                    s->size = 0;
                                    return err;
                            }
                            s->size = xsize_t(st.st_size);
                            if (!s->size)
                                    goto empty;
                            if (S_ISLNK(st.st_mode)) {
                                    struct strbuf sb = STRBUF_INIT;

                                    if (strbuf_readlink(&sb, s->path, s->size))
                                            goto err_empty;
                                    s->size = sb.len;
                                    s->data = strbuf_detach(&sb, NULL);
                                    s->should_free = 1;
                                    return 0;
                            }

                            /*
                            * Even if the caller would be happy with getting
                            * only the size, we cannot return early at this
                            * point if the path requires us to run the content
                            * conversion.
                            */
                            if (size_only && !would_convert_to_git(r->index, s->path))
                                    return 0;

                            /*
                            * Note: this check uses xsize_t(st.st_size) that may
                            * not be the true size of the blob after it goes
                            * through convert_to_git().  This may not strictly be
                            * correct, but the whole point of big_file_threshold
                            * and is_binary check being that we want to avoid
                            * opening the file and inspecting the contents, this
                            * is probably fine.
                            */
                            if (check_binary &&
                            s->size > big_file_threshold && s->is_binary == -1) {
                                    s->is_binary = 1;
                                    return 0;
                            }
                            fd = open(s->path, O_RDONLY);
                            if (fd < 0)
                                    goto err_empty;
                            s->data = xmmap(NULL, s->size, PROT_READ, MAP_PRIVATE, fd, 0);
                            close(fd);
                            s->should_munmap = 1;

                            /*
                            * Convert from working tree format to canonical git format
                            */
                            if (convert_to_git(r->index, s->path, s->data, s->size, &buf, conv_flags)) {
                                    size_t size = 0;
                                    munmap(s->data, s->size);
                                    s->should_munmap = 0;
                                    s->data = strbuf_detach(&buf, &size);
                                    s->size = size;
                                    s->should_free = 1;
                            }
                    }
                    else {
                            struct object_info info = {
                                    .sizep = &s->size
                            };

                            if (!(size_only || check_binary))
                                    /*
                                    * Set contentp, since there is no chance that merely
                                    * the size is sufficient.
                                    */
                                    info.contentp = &s->data;

                            if (options && options->missing_object_cb) {
                                    if (!oid_object_info_extended(r, &s->oid, &info,
                                                            OBJECT_INFO_LOOKUP_REPLACE |
                                                            OBJECT_INFO_SKIP_FETCH_OBJECT))
                                            goto object_read;
                                    options->missing_object_cb(options->missing_object_data);
                            }
                            if (oid_object_info_extended(r, &s->oid, &info,
                                                    OBJECT_INFO_LOOKUP_REPLACE))
                                    die("unable to read %s", oid_to_hex(&s->oid));

            object_read:
                            if (size_only || check_binary) {
                                    if (size_only)
                                            return 0;
                                    if (s->size > big_file_threshold && s->is_binary == -1) {
                                            s->is_binary = 1;
                                            return 0;
                                    }
                            }
                            if (!info.contentp) {
                                    info.contentp = &s->data;
                                    if (oid_object_info_extended(r, &s->oid, &info,
                                                            OBJECT_INFO_LOOKUP_REPLACE))
                                            die("unable to read %s", oid_to_hex(&s->oid));
                            }
                            s->should_free = 1;
                    }
                    return 0;
            }

            void diff_free_filespec_blob(struct diff_filespec *s)
            {
                    if (s->should_free)
                            free(s->data);
                    else if (s->should_munmap)
                            munmap(s->data, s->size);

                    if (s->should_free || s->should_munmap) {
                            s->should_free = s->should_munmap = 0;
                            s->data = NULL;
                    }
            }

            void diff_free_filespec_data(struct diff_filespec *s)
            {
                    if (!s)
                            return;

                    diff_free_filespec_blob(s);
                    FREE_AND_NULL(s->cnt_data);
            }

            static void prep_temp_blob(struct index_state *istate,
                                    const char *path, struct diff_tempfile *temp,
                                    void *blob,
                                    unsigned long size,
                                    const struct object_id *oid,
                                    int mode)
            {
                    struct strbuf buf = STRBUF_INIT;
                    char *path_dup = xstrdup(path);
                    const char *base = basename(path_dup);
                    struct checkout_metadata meta;

                    init_checkout_metadata(&meta, NULL, NULL, oid);

                    temp->tempfile = mks_tempfile_dt("git-blob-XXXXXX", base);
                    if (!temp->tempfile)
                            die_errno("unable to create temp-file");
                    if (convert_to_working_tree(istate, path,
                                    (const char *)blob, (size_t)size, &buf, &meta)) {
                            blob = buf.buf;
                            size = buf.len;
                    }
                    if (write_in_full(temp->tempfile->fd, blob, size) < 0 ||
                    close_tempfile_gently(temp->tempfile))
                            die_errno("unable to write temp-file");
                    temp->name = get_tempfile_path(temp->tempfile);
                    oid_to_hex_r(temp->hex, oid);
                    xsnprintf(temp->mode, sizeof(temp->mode), "%06o", mode);
                    strbuf_release(&buf);
                    free(path_dup);
            }

            static struct diff_tempfile *prepare_temp_file(struct repository *r,
                                                    struct diff_filespec *one)
            {
                    struct diff_tempfile *temp = claim_diff_tempfile();

                    if (!DIFF_FILE_VALID(one)) {
                    not_a_valid_file:
                            /* A '-' entry produces this for file-2, and
                            * a '+' entry produces this for file-1.
                            */
                            temp->name = "/dev/null";
                            xsnprintf(temp->hex, sizeof(temp->hex), ".");
                            xsnprintf(temp->mode, sizeof(temp->mode), ".");
                            return temp;
                    }

                    if (!S_ISGITLINK(one->mode) &&
                    (!one->oid_valid ||
                    reuse_worktree_file(r->index, one->path, &one->oid, 1))) {
                            struct stat st;
                            if (lstat(one->path, &st) < 0) {
                                    if (errno == ENOENT)
                                            goto not_a_valid_file;
                                    die_errno("stat(%s)", one->path);
                            }
                            if (S_ISLNK(st.st_mode)) {
                                    struct strbuf sb = STRBUF_INIT;
                                    if (strbuf_readlink(&sb, one->path, st.st_size) < 0)
                                            die_errno("readlink(%s)", one->path);
                                    prep_temp_blob(r->index, one->path, temp, sb.buf, sb.len,
                                            (one->oid_valid ?
                                                    &one->oid : null_oid()),
                                            (one->oid_valid ?
                                                    one->mode : S_IFLNK));
                                    strbuf_release(&sb);
                            }
                            else {
                                    /* we can borrow from the file in the work tree */
                                    temp->name = one->path;
                                    if (!one->oid_valid)
                                            oid_to_hex_r(temp->hex, null_oid());
                                    else
                                            oid_to_hex_r(temp->hex, &one->oid);
                                    /* Even though we may sometimes borrow the
                                    * contents from the work tree, we always want
                                    * one->mode.  mode is trustworthy even when
                                    * !(one->oid_valid), as long as
                                    * DIFF_FILE_VALID(one).
                                    */
                                    xsnprintf(temp->mode, sizeof(temp->mode), "%06o", one->mode);
                            }
                            return temp;
                    }
                    else {
                            if (diff_populate_filespec(r, one, NULL))
                                    die("cannot read data blob for %s", one->path);
                            prep_temp_blob(r->index, one->path, temp,
                                    one->data, one->size,
                                    &one->oid, one->mode);
                    }
                    return temp;
            }

            static void add_external_diff_name(struct repository *r,
                                            struct strvec *argv,
                                            struct diff_filespec *df)
            {
                    struct diff_tempfile *temp = prepare_temp_file(r, df);
                    strvec_push(argv, temp->name);
                    strvec_push(argv, temp->hex);
                    strvec_push(argv, temp->mode);
            }

            /* An external diff command takes:
            *
            * diff-cmd name infile1 infile1-sha1 infile1-mode \
            *               infile2 infile2-sha1 infile2-mode [ rename-to ]
            *
            */
            static void run_external_diff(const struct external_diff *pgm,
                                    const char *name,
                                    const char *other,
                                    struct diff_filespec *one,
                                    struct diff_filespec *two,
                                    const char *xfrm_msg,
                                    struct diff_options *o)
            {
                    struct child_process cmd = CHILD_PROCESS_INIT;
                    struct diff_queue_struct *q = &diff_queued_diff;
                    int quiet = !(o->output_format & DIFF_FORMAT_PATCH);
                    int rc;

                    /*
                    * Trivial equality is handled by diff_unmodified_pair() before
                    * we get here.  If we don't need to show the diff and the
                    * external diff program lacks the ability to tell us whether
                    * it's empty then we consider it non-empty without even asking.
                    */
                    if (!pgm->trust_exit_code && quiet) {
                            o->found_changes = 1;
                            return;
                    }

                    strvec_push(&cmd.args, pgm->cmd);
                    strvec_push(&cmd.args, name);

                    if (one && two) {
                            add_external_diff_name(o->repo, &cmd.args, one);
                            add_external_diff_name(o->repo, &cmd.args, two);
                            if (other) {
                                    strvec_push(&cmd.args, other);
                                    if (xfrm_msg)
                                            strvec_push(&cmd.args, xfrm_msg);
                            }
                    }

                    strvec_pushf(&cmd.env, "GIT_DIFF_PATH_COUNTER=%d",
                            ++o->diff_path_counter);
                    strvec_pushf(&cmd.env, "GIT_DIFF_PATH_TOTAL=%d", q->nr);

                    diff_free_filespec_data(one);
                    diff_free_filespec_data(two);
                    cmd.use_shell = 1;
                    cmd.no_stdout = quiet;
                    rc = run_command(&cmd);
                    if (!pgm->trust_exit_code && rc == 0)
                            o->found_changes = 1;
                    else if (pgm->trust_exit_code && rc == 0)
                            ; /* nothing */
                    else if (pgm->trust_exit_code && rc == 1)
                            o->found_changes = 1;
                    else
                            die(_("external diff died, stopping at %s"), name);

                    remove_tempfile();
            }

            static int similarity_index(struct diff_filepair *p)
            {
                    return p->score * 100 / MAX_SCORE;
            }

            static const char *diff_abbrev_oid(const struct object_id *oid, int abbrev)
            {
                    if (startup_info->have_repository)
                            return repo_find_unique_abbrev(the_repository, oid, abbrev);
                    else {
                            char *hex = oid_to_hex(oid);
                            if (abbrev < 0)
                                    abbrev = FALLBACK_DEFAULT_ABBREV;
                            if (abbrev > the_hash_algo->hexsz)
                                    BUG("oid abbreviation out of range: %d", abbrev);
                            if (abbrev)
                                    hex[abbrev] = '\0';
                            return hex;
                    }
            }

            static void fill_metainfo(struct strbuf *msg,
                                    const char *name,
                                    const char *other,
                                    struct diff_filespec *one,
                                    struct diff_filespec *two,
                                    struct diff_options *o,
                                    struct diff_filepair *p,
                                    int *must_show_header,
                                    int use_color)
            {
                    const char *set = diff_get_color(use_color, DIFF_METAINFO);
                    const char *reset = diff_get_color(use_color, DIFF_RESET);
                    const char *line_prefix = diff_line_prefix(o);
                    struct string_list *more_headers = NULL;

                    *must_show_header = 1;
                    strbuf_init(msg, PATH_MAX * 2 + 300);
                    switch (p->status) {
                    case DIFF_STATUS_COPIED:
                            strbuf_addf(msg, "%s%ssimilarity index %d%%",
                                    line_prefix, set, similarity_index(p));
                            strbuf_addf(msg, "%s\n%s%scopy from ",
                                    reset,  line_prefix, set);
                            quote_c_style(name, msg, NULL, 0);
                            strbuf_addf(msg, "%s\n%s%scopy to ", reset, line_prefix, set);
                            quote_c_style(other, msg, NULL, 0);
                            strbuf_addf(msg, "%s\n", reset);
                            break;
                    case DIFF_STATUS_RENAMED:
                            strbuf_addf(msg, "%s%ssimilarity index %d%%",
                                    line_prefix, set, similarity_index(p));
                            strbuf_addf(msg, "%s\n%s%srename from ",
                                    reset, line_prefix, set);
                            quote_c_style(name, msg, NULL, 0);
                            strbuf_addf(msg, "%s\n%s%srename to ",
                                    reset, line_prefix, set);
                            quote_c_style(other, msg, NULL, 0);
                            strbuf_addf(msg, "%s\n", reset);
                            break;
                    case DIFF_STATUS_MODIFIED:
                            if (p->score) {
                                    strbuf_addf(msg, "%s%sdissimilarity index %d%%%s\n",
                                            line_prefix,
                                            set, similarity_index(p), reset);
                                    break;
                            }
                            /* fallthru */
                    default:
                            *must_show_header = 0;
                    }
                    if ((more_headers = additional_headers(o, name))) {
                            add_formatted_headers(msg, more_headers,
                                            line_prefix, set, reset);
                            *must_show_header = 1;
                    }
                    if (one && two && !oideq(&one->oid, &two->oid)) {
                            const unsigned hexsz = the_hash_algo->hexsz;
                            int abbrev = o->abbrev ? o->abbrev : DEFAULT_ABBREV;

                            if (o->flags.full_index)
                                    abbrev = hexsz;

                            if (o->flags.binary) {
                                    mmfile_t mf;
                                    if ((!fill_mmfile(o->repo, &mf, one) &&
                                    diff_filespec_is_binary(o->repo, one)) ||
                                    (!fill_mmfile(o->repo, &mf, two) &&
                                    diff_filespec_is_binary(o->repo, two)))
                                            abbrev = hexsz;
                            }
                            strbuf_addf(msg, "%s%sindex %s..%s", line_prefix, set,
                                    diff_abbrev_oid(&one->oid, abbrev),
                                    diff_abbrev_oid(&two->oid, abbrev));
                            if (one->mode == two->mode)
                                    strbuf_addf(msg, " %06o", one->mode);
                            strbuf_addf(msg, "%s\n", reset);
                    }
            }

            static void run_diff_cmd(const struct external_diff *pgm,
                                    const char *name,
                                    const char *other,
                                    const char *attr_path,
                                    struct diff_filespec *one,
                                    struct diff_filespec *two,
                                    struct strbuf *msg,
                                    struct diff_options *o,
                                    struct diff_filepair *p)
            {
                    const char *xfrm_msg = NULL;
                    int complete_rewrite = (p->status == DIFF_STATUS_MODIFIED) && p->score;
                    int must_show_header = 0;
                    struct userdiff_driver *drv = NULL;

                    if (o->flags.allow_external || !o->ignore_driver_algorithm)
                            drv = userdiff_find_by_path(o->repo->index, attr_path);

                    if (o->flags.allow_external && drv && drv->external.cmd)
                            pgm = &drv->external;

                    if (msg) {
                            /*
                            * don't use colors when the header is intended for an
                            * external diff driver
                            */
                            fill_metainfo(msg, name, other, one, two, o, p,
                                    &must_show_header,
                                    want_color(o->use_color) && !pgm);
                            xfrm_msg = msg->len ? msg->buf : NULL;
                    }

                    if (pgm) {
                            run_external_diff(pgm, name, other, one, two, xfrm_msg, o);
                            return;
                    }
                    if (one && two) {
                            if (!o->ignore_driver_algorithm && drv && drv->algorithm)
                                    set_diff_algorithm(o, drv->algorithm);

                            builtin_diff(name, other ? other : name,
                                    one, two, xfrm_msg, must_show_header,
                                    o, complete_rewrite);
                            if (p->status == DIFF_STATUS_COPIED ||
                            p->status == DIFF_STATUS_RENAMED)
                                    o->found_changes = 1;
                    } else {
                            fprintf(o->file, "* Unmerged path %s\n", name);
                            o->found_changes = 1;
                    }
            }

            static void diff_fill_oid_info(struct diff_filespec *one, struct index_state *istate)
            {
                    if (DIFF_FILE_VALID(one)) {
                            if (!one->oid_valid) {
                                    struct stat st;
                                    if (one->is_stdin) {
                                            oidclr(&one->oid, the_repository->hash_algo);
                                            return;
                                    }
                                    if (lstat(one->path, &st) < 0)
                                            die_errno("stat '%s'", one->path);
                                    if (index_path(istate, &one->oid, one->path, &st, 0))
                                            die("cannot hash %s", one->path);
                            }
                    }
                    else
                            oidclr(&one->oid, the_repository->hash_algo);
            }

            static void strip_prefix(int prefix_length, const char **namep, const char **otherp)
            {
                    /* Strip the prefix but do not molest /dev/null and absolute paths */
                    if (*namep && !is_absolute_path(*namep)) {
                            *namep += prefix_length;
                            if (**namep == '/')
                                    ++*namep;
                    }
                    if (*otherp && !is_absolute_path(*otherp)) {
                            *otherp += prefix_length;
                            if (**otherp == '/')
                                    ++*otherp;
                    }
            }

            static void run_diff(struct diff_filepair *p, struct diff_options *o)
            {
                    const struct external_diff *pgm = external_diff();
                    struct strbuf msg;
                    struct diff_filespec *one = p->one;
                    struct diff_filespec *two = p->two;
                    const char *name;
                    const char *other;
                    const char *attr_path;

                    name  = one->path;
                    other = (strcmp(name, two->path) ? two->path : NULL);
                    attr_path = name;
                    if (o->prefix_length)
                            strip_prefix(o->prefix_length, &name, &other);

                    if (!o->flags.allow_external)
                            pgm = NULL;

                    if (DIFF_PAIR_UNMERGED(p)) {
                            run_diff_cmd(pgm, name, NULL, attr_path,
                                    NULL, NULL, NULL, o, p);
                            return;
                    }

                    diff_fill_oid_info(one, o->repo->index);
                    diff_fill_oid_info(two, o->repo->index);

                    if (!pgm &&
                    DIFF_FILE_VALID(one) && DIFF_FILE_VALID(two) &&
                    (S_IFMT & one->mode) != (S_IFMT & two->mode)) {
                            /*
                            * a filepair that changes between file and symlink
                            * needs to be split into deletion and creation.
                            */
                            struct diff_filespec *null = alloc_filespec(two->path);
                            run_diff_cmd(NULL, name, other, attr_path,
                                    one, null, &msg,
                                    o, p);
                            free(null);
                            strbuf_release(&msg);

                            null = alloc_filespec(one->path);
                            run_diff_cmd(NULL, name, other, attr_path,
                                    null, two, &msg, o, p);
                            free(null);
                    }
                    else
                            run_diff_cmd(pgm, name, other, attr_path,
                                    one, two, &msg, o, p);

                    strbuf_release(&msg);
            }

            static void run_diffstat(struct diff_filepair *p, struct diff_options *o,
                                    struct diffstat_t *diffstat)
            {
                    const char *name;
                    const char *other;

                    if (!o->ignore_driver_algorithm) {
                            struct userdiff_driver *drv = userdiff_find_by_path(o->repo->index,
                                                                            p->one->path);

                            if (drv && drv->algorithm)
                                    set_diff_algorithm(o, drv->algorithm);
                    }

                    if (DIFF_PAIR_UNMERGED(p)) {
                            /* unmerged */
                            builtin_diffstat(p->one->path, NULL, NULL, NULL,
                                            diffstat, o, p);
                            return;
                    }

                    name = p->one->path;
                    other = (strcmp(name, p->two->path) ? p->two->path : NULL);

                    if (o->prefix_length)
                            strip_prefix(o->prefix_length, &name, &other);

                    diff_fill_oid_info(p->one, o->repo->index);
                    diff_fill_oid_info(p->two, o->repo->index);

                    builtin_diffstat(name, other, p->one, p->two,
                                    diffstat, o, p);
            }

            static void run_checkdiff(struct diff_filepair *p, struct diff_options *o)
            {
                    const char *name;
                    const char *other;
                    const char *attr_path;

                    if (DIFF_PAIR_UNMERGED(p)) {
                            /* unmerged */
                            return;
                    }

                    name = p->one->path;
                    other = (strcmp(name, p->two->path) ? p->two->path : NULL);
                    attr_path = other ? other : name;

                    if (o->prefix_length)
                            strip_prefix(o->prefix_length, &name, &other);

                    diff_fill_oid_info(p->one, o->repo->index);
                    diff_fill_oid_info(p->two, o->repo->index);

                    builtin_checkdiff(name, other, attr_path, p->one, p->two, o);
            }

            void repo_diff_setup(struct repository *r, struct diff_options *options)
            {
                    memcpy(options, &default_diff_options, sizeof(*options));

                    options->file = stdout;
                    options->repo = r;

                    options->output_indicators[OUTPUT_INDICATOR_NEW] = '+';
                    options->output_indicators[OUTPUT_INDICATOR_OLD] = '-';
                    options->output_indicators[OUTPUT_INDICATOR_CONTEXT] = ' ';
                    options->abbrev = DEFAULT_ABBREV;
                    options->line_termination = '\n';
                    options->break_opt = -1;
                    options->rename_limit = -1;
                    options->dirstat_permille = diff_dirstat_permille_default;
                    options->context = diff_context_default;
                    options->interhunkcontext = diff_interhunk_context_default;
                    options->ws_error_highlight = ws_error_highlight_default;
                    options->flags.rename_empty = 1;
                    options->flags.relative_name = diff_relative;
                    options->objfind = NULL;

                    /* pathchange left =NULL by default */
                    options->change = diff_change;
                    options->add_remove = diff_addremove;
                    options->use_color = diff_use_color_default;
                    options->detect_rename = diff_detect_rename_default;
                    options->xdl_opts |= diff_algorithm;
                    if (diff_indent_heuristic)
                            DIFF_XDL_SET(options, INDENT_HEURISTIC);

                    options->orderfile = xstrdup_or_null(diff_order_file_cfg);

                    if (!options->flags.ignore_submodule_set)
                            options->flags.ignore_untracked_in_submodules = 1;

                    if (diff_no_prefix) {
                            diff_set_noprefix(options);
                    } else if (!diff_mnemonic_prefix) {
                            diff_set_default_prefix(options);
                    }

                    options->color_moved = diff_color_moved_default;
                    options->color_moved_ws_handling = diff_color_moved_ws_default;
            }

            static const char diff_status_letters[] = {
                    DIFF_STATUS_ADDED,
                    DIFF_STATUS_COPIED,
                    DIFF_STATUS_DELETED,
                    DIFF_STATUS_MODIFIED,
                    DIFF_STATUS_RENAMED,
                    DIFF_STATUS_TYPE_CHANGED,
                    DIFF_STATUS_UNKNOWN,
                    DIFF_STATUS_UNMERGED,
                    DIFF_STATUS_FILTER_AON,
                    DIFF_STATUS_FILTER_BROKEN,
                    '\0',
            };

            static unsigned int filter_bit['Z' + 1];

            static void prepare_filter_bits(void)
            {
                    int i;

                    if (!filter_bit[DIFF_STATUS_ADDED]) {
                            for (i = 0; diff_status_letters[i]; i++)
                                    filter_bit[(int) diff_status_letters[i]] = (1 << i);
                    }
            }

            static unsigned filter_bit_tst(char status, const struct diff_options *opt)
            {
                    return opt->filter & filter_bit[(int) status];
            }

            unsigned diff_filter_bit(char status)
            {
                    prepare_filter_bits();
                    return filter_bit[(int) status];
            }

            int diff_check_follow_pathspec(struct pathspec *ps, int die_on_error)
            {
                    unsigned forbidden_magic;

                    if (ps->nr != 1) {
                            if (die_on_error)
                                    die(_("--follow requires exactly one pathspec"));
                            return 0;
                    }

                    forbidden_magic = ps->items[0].magic & ~(PATHSPEC_FROMTOP |
                                                            PATHSPEC_LITERAL);
                    if (forbidden_magic) {
                            if (die_on_error) {
                                    struct strbuf sb = STRBUF_INIT;
                                    pathspec_magic_names(forbidden_magic, &sb);
                                    die(_("pathspec magic not supported by --follow: %s"),
                                    sb.buf);
                            }
                            return 0;
                    }

                    return 1;
            }

            void diff_setup_done(struct diff_options *options)
            {
                    unsigned check_mask = DIFF_FORMAT_NAME |
                                    DIFF_FORMAT_NAME_STATUS |
                                    DIFF_FORMAT_CHECKDIFF |
                                    DIFF_FORMAT_NO_OUTPUT;
                    /*
                    * This must be signed because we're comparing against a potentially
                    * negative value.
                    */
                    const int hexsz = the_hash_algo->hexsz;

                    if (options->set_default)
                            options->set_default(options);

                    if (HAS_MULTI_BITS(options->output_format & check_mask))
                            die(_("options '%s', '%s', '%s', and '%s' cannot be used together"),
                                    "--name-only", "--name-status", "--check", "-s");

                    if (HAS_MULTI_BITS(options->pickaxe_opts & DIFF_PICKAXE_KINDS_MASK))
                            die(_("options '%s', '%s', and '%s' cannot be used together"),
                                    "-G", "-S", "--find-object");

                    if (HAS_MULTI_BITS(options->pickaxe_opts & DIFF_PICKAXE_KINDS_G_REGEX_MASK))
                            die(_("options '%s' and '%s' cannot be used together, use '%s' with '%s'"),
                                    "-G", "--pickaxe-regex", "--pickaxe-regex", "-S");

                    if (HAS_MULTI_BITS(options->pickaxe_opts & DIFF_PICKAXE_KINDS_ALL_OBJFIND_MASK))
                            die(_("options '%s' and '%s' cannot be used together, use '%s' with '%s' and '%s'"),
                                    "--pickaxe-all", "--find-object", "--pickaxe-all", "-G", "-S");

                    /*
                    * Most of the time we can say "there are changes"
                    * only by checking if there are changed paths, but
                    * --ignore-whitespace* options force us to look
                    * inside contents.
                    */

                    if ((options->xdl_opts & XDF_WHITESPACE_FLAGS) ||
                    options->ignore_regex_nr)
                            options->flags.diff_from_contents = 1;
                    else
                            options->flags.diff_from_contents = 0;

                    if (options->flags.find_copies_harder)
                            options->detect_rename = DIFF_DETECT_COPY;

                    if (!options->flags.relative_name)
                            options->prefix = NULL;
                    if (options->prefix)
                            options->prefix_length = strlen(options->prefix);
                    else
                            options->prefix_length = 0;

                    /*
                    * --name-only, --name-status, --checkdiff, and -s
                    * turn other output format off.
                    */
                    if (options->output_format & (DIFF_FORMAT_NAME |
                                            DIFF_FORMAT_NAME_STATUS |
                                            DIFF_FORMAT_CHECKDIFF |
                                            DIFF_FORMAT_NO_OUTPUT))
                            options->output_format &= ~(DIFF_FORMAT_RAW |
                                                    DIFF_FORMAT_NUMSTAT |
                                                    DIFF_FORMAT_DIFFSTAT |
                                                    DIFF_FORMAT_SHORTSTAT |
                                                    DIFF_FORMAT_DIRSTAT |
                                                    DIFF_FORMAT_SUMMARY |
                                                    DIFF_FORMAT_PATCH);

                    /*
                    * These cases always need recursive; we do not drop caller-supplied
                    * recursive bits for other formats here.
                    */
                    if (options->output_format & (DIFF_FORMAT_PATCH |
                                            DIFF_FORMAT_NUMSTAT |
                                            DIFF_FORMAT_DIFFSTAT |
                                            DIFF_FORMAT_SHORTSTAT |
                                            DIFF_FORMAT_DIRSTAT |
                                            DIFF_FORMAT_SUMMARY |
                                            DIFF_FORMAT_CHECKDIFF))
                            options->flags.recursive = 1;
                    /*
                    * Also pickaxe would not work very well if you do not say recursive
                    */
                    if (options->pickaxe_opts & DIFF_PICKAXE_KINDS_MASK)
                            options->flags.recursive = 1;
                    /*
                    * When patches are generated, submodules diffed against the work tree
                    * must be checked for dirtiness too so it can be shown in the output
                    */
                    if (options->output_format & DIFF_FORMAT_PATCH)
                            options->flags.dirty_submodules = 1;

                    if (options->detect_rename && options->rename_limit < 0)
                            options->rename_limit = diff_rename_limit_default;
                    if (hexsz < options->abbrev)
                            options->abbrev = hexsz; /* full */

                    /*
                    * It does not make sense to show the first hit we happened
                    * to have found.  It does not make sense not to return with
                    * exit code in such a case either.
                    */
                    if (options->flags.quick) {
                            options->output_format = DIFF_FORMAT_NO_OUTPUT;
                            options->flags.exit_with_status = 1;
                    }

                    /*
                    * External diffs could declare non-identical contents equal
                    * (think diff --ignore-space-change).
                    */
                    if (options->flags.allow_external && options->flags.exit_with_status)
                            options->flags.diff_from_contents = 1;

                    options->diff_path_counter = 0;

                    if (options->flags.follow_renames)
                            diff_check_follow_pathspec(&options->pathspec, 1);

                    if (!options->use_color ||
                    (options->flags.allow_external && external_diff()))
                            options->color_moved = 0;

                    if (options->filter_not) {
                            if (!options->filter)
                                    options->filter = ~filter_bit[DIFF_STATUS_FILTER_AON];
                            options->filter &= ~options->filter_not;
                    }
            }

            int parse_long_opt(const char *opt, const char **argv,
                            const char **optarg)
            {
                    const char *arg = argv[0];
                    if (!skip_prefix(arg, "--", &arg))
                            return 0;
                    if (!skip_prefix(arg, opt, &arg))
                            return 0;
                    if (*arg == '=') { /* stuck form: --option=value */
                            *optarg = arg + 1;
                            return 1;
                    }
                    if (*arg != '\0')
                            return 0;
                    /* separate form: --option value */
                    if (!argv[1])
                            die("Option '--%s' requires a value", opt);
                    *optarg = argv[1];
                    return 2;
            }

            static int diff_opt_stat(const struct option *opt, const char *value, int unset)
            {
                    struct diff_options *options = opt->value;
                    int width = options->stat_width;
                    int name_width = options->stat_name_width;
                    int graph_width = options->stat_graph_width;
                    int count = options->stat_count;
                    char *end;

                    BUG_ON_OPT_NEG(unset);

                    if (!strcmp(opt->long_name, "stat")) {
                            if (value) {
                                    width = strtoul(value, &end, 10);
                                    if (*end == ',')
                                            name_width = strtoul(end+1, &end, 10);
                                    if (*end == ',')
                                            count = strtoul(end+1, &end, 10);
                                    if (*end)
                                            return error(_("invalid --stat value: %s"), value);
                            }
                    } else if (!strcmp(opt->long_name, "stat-width")) {
                            width = strtoul(value, &end, 10);
                            if (*end)
                                    return error(_("%s expects a numerical value"),
                                            opt->long_name);
                    } else if (!strcmp(opt->long_name, "stat-name-width")) {
                            name_width = strtoul(value, &end, 10);
                            if (*end)
                                    return error(_("%s expects a numerical value"),
                                            opt->long_name);
                    } else if (!strcmp(opt->long_name, "stat-graph-width")) {
                            graph_width = strtoul(value, &end, 10);
                            if (*end)
                                    return error(_("%s expects a numerical value"),
                                            opt->long_name);
                    } else if (!strcmp(opt->long_name, "stat-count")) {
                            count = strtoul(value, &end, 10);
                            if (*end)
                                    return error(_("%s expects a numerical value"),
                                            opt->long_name);
                    } else
                            BUG("%s should not get here", opt->long_name);

                    options->output_format &= ~DIFF_FORMAT_NO_OUTPUT;
                    options->output_format |= DIFF_FORMAT_DIFFSTAT;
                    options->stat_name_width = name_width;
                    options->stat_graph_width = graph_width;
                    options->stat_width = width;
                    options->stat_count = count;
                    return 0;
            }

            static int parse_dirstat_opt(struct diff_options *options, const char *params)
            {
                    struct strbuf errmsg = STRBUF_INIT;
                    if (parse_dirstat_params(options, params, &errmsg))
                            die(_("Failed to parse --dirstat/-X option parameter:\n%s"),
                            errmsg.buf);
                    strbuf_release(&errmsg);
                    /*
                    * The caller knows a dirstat-related option is given from the command
                    * line; allow it to say "return this_function();"
                    */
                    options->output_format &= ~DIFF_FORMAT_NO_OUTPUT;
                    options->output_format |= DIFF_FORMAT_DIRSTAT;
                    return 1;
            }

            static int diff_opt_diff_filter(const struct option *option,
                                            const char *optarg, int unset)
            {
                    struct diff_options *opt = option->value;
                    int i, optch;

                    BUG_ON_OPT_NEG(unset);
                    prepare_filter_bits();

                    for (i = 0; (optch = optarg[i]) != '\0'; i++) {
                            unsigned int bit;
                            int negate;

                            if ('a' <= optch && optch <= 'z') {
                                    negate = 1;
                                    optch = toupper(optch);
                            } else {
                                    negate = 0;
                            }

                            bit = (0 <= optch && optch <= 'Z') ? filter_bit[optch] : 0;
                            if (!bit)
                                    return error(_("unknown change class '%c' in --diff-filter=%s"),
                                            optarg[i], optarg);
                            if (negate)
                                    opt->filter_not |= bit;
                            else
                                    opt->filter |= bit;
                    }
                    return 0;
            }

            static void enable_patch_output(int *fmt)
            {
                    *fmt &= ~DIFF_FORMAT_NO_OUTPUT;
                    *fmt |= DIFF_FORMAT_PATCH;
            }

            static int diff_opt_ws_error_highlight(const struct option *option,
                                            const char *arg, int unset)
            {
                    struct diff_options *opt = option->value;
                    int val = parse_ws_error_highlight(arg);

                    BUG_ON_OPT_NEG(unset);
                    if (val < 0)
                            return error(_("unknown value after ws-error-highlight=%.*s"),
                                    -1 - val, arg);
                    opt->ws_error_highlight = val;
                    return 0;
            }

            static int diff_opt_find_object(const struct option *option,
                                            const char *arg, int unset)
            {
                    struct diff_options *opt = option->value;
                    struct object_id oid;

                    BUG_ON_OPT_NEG(unset);
                    if (repo_get_oid(the_repository, arg, &oid))
                            return error(_("unable to resolve '%s'"), arg);

                    if (!opt->objfind)
                            CALLOC_ARRAY(opt->objfind, 1);

                    opt->pickaxe_opts |= DIFF_PICKAXE_KIND_OBJFIND;
                    opt->flags.recursive = 1;
                    opt->flags.tree_in_recursive = 1;
                    oidset_insert(opt->objfind, &oid);
                    return 0;
            }

            static int diff_opt_anchored(const struct option *opt,
                                    const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;

                    BUG_ON_OPT_NEG(unset);
                    options->xdl_opts = DIFF_WITH_ALG(options, PATIENCE_DIFF);
                    ALLOC_GROW(options->anchors, options->anchors_nr + 1,
                            options->anchors_alloc);
                    options->anchors[options->anchors_nr++] = xstrdup(arg);
                    return 0;
            }

            static int diff_opt_binary(const struct option *opt,
                                    const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;

                    BUG_ON_OPT_NEG(unset);
                    BUG_ON_OPT_ARG(arg);
                    enable_patch_output(&options->output_format);
                    options->flags.binary = 1;
                    return 0;
            }

            static int diff_opt_break_rewrites(const struct option *opt,
                                            const char *arg, int unset)
            {
                    int *break_opt = opt->value;
                    int opt1, opt2;

                    BUG_ON_OPT_NEG(unset);
                    if (!arg)
                            arg = "";
                    opt1 = parse_rename_score(&arg);
                    if (*arg == 0)
                            opt2 = 0;
                    else if (*arg != '/')
                            return error(_("%s expects <n>/<m> form"), opt->long_name);
                    else {
                            arg++;
                            opt2 = parse_rename_score(&arg);
                    }
                    if (*arg != 0)
                            return error(_("%s expects <n>/<m> form"), opt->long_name);
                    *break_opt = opt1 | (opt2 << 16);
                    return 0;
            }

            static int diff_opt_char(const struct option *opt,
                                    const char *arg, int unset)
            {
                    char *value = opt->value;

                    BUG_ON_OPT_NEG(unset);
                    if (arg[1])
                            return error(_("%s expects a character, got '%s'"),
                                    opt->long_name, arg);
                    *value = arg[0];
                    return 0;
            }

            static int diff_opt_color_moved(const struct option *opt,
                                            const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;

                    if (unset) {
                            options->color_moved = COLOR_MOVED_NO;
                    } else if (!arg) {
                            if (diff_color_moved_default)
                                    options->color_moved = diff_color_moved_default;
                            if (options->color_moved == COLOR_MOVED_NO)
                                    options->color_moved = COLOR_MOVED_DEFAULT;
                    } else {
                            int cm = parse_color_moved(arg);
                            if (cm < 0)
                                    return error(_("bad --color-moved argument: %s"), arg);
                            options->color_moved = cm;
                    }
                    return 0;
            }

            static int diff_opt_color_moved_ws(const struct option *opt,
                                            const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;
                    unsigned cm;

                    if (unset) {
                            options->color_moved_ws_handling = 0;
                            return 0;
                    }

                    cm = parse_color_moved_ws(arg);
                    if (cm & COLOR_MOVED_WS_ERROR)
                            return error(_("invalid mode '%s' in --color-moved-ws"), arg);
                    options->color_moved_ws_handling = cm;
                    return 0;
            }

            static int diff_opt_color_words(const struct option *opt,
                                            const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;

                    BUG_ON_OPT_NEG(unset);
                    options->use_color = 1;
                    options->word_diff = DIFF_WORDS_COLOR;
                    options->word_regex = arg;
                    return 0;
            }

            static int diff_opt_compact_summary(const struct option *opt,
                                            const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;

                    BUG_ON_OPT_ARG(arg);
                    if (unset) {
                            options->flags.stat_with_summary = 0;
                    } else {
                            options->flags.stat_with_summary = 1;
                            options->output_format &= ~DIFF_FORMAT_NO_OUTPUT;
                            options->output_format |= DIFF_FORMAT_DIFFSTAT;
                    }
                    return 0;
            }

            static int diff_opt_diff_algorithm(const struct option *opt,
                                            const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;

                    BUG_ON_OPT_NEG(unset);

                    if (set_diff_algorithm(options, arg))
                            return error(_("option diff-algorithm accepts \"myers\", "
                                    "\"minimal\", \"patience\" and \"histogram\""));

                    options->ignore_driver_algorithm = 1;

                    return 0;
            }

            static int diff_opt_diff_algorithm_no_arg(const struct option *opt,
                                            const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;

                    BUG_ON_OPT_NEG(unset);
                    BUG_ON_OPT_ARG(arg);

                    if (set_diff_algorithm(options, opt->long_name))
                            BUG("available diff algorithms include \"myers\", "
                                    "\"minimal\", \"patience\" and \"histogram\"");

                    options->ignore_driver_algorithm = 1;

                    return 0;
            }

            static int diff_opt_dirstat(const struct option *opt,
                                    const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;

                    BUG_ON_OPT_NEG(unset);
                    if (!strcmp(opt->long_name, "cumulative")) {
                            if (arg)
                                    BUG("how come --cumulative take a value?");
                            arg = "cumulative";
                    } else if (!strcmp(opt->long_name, "dirstat-by-file"))
                            parse_dirstat_opt(options, "files");
                    parse_dirstat_opt(options, arg ? arg : "");
                    return 0;
            }

            static int diff_opt_find_copies(const struct option *opt,
                                            const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;

                    BUG_ON_OPT_NEG(unset);
                    if (!arg)
                            arg = "";
                    options->rename_score = parse_rename_score(&arg);
                    if (*arg != 0)
                            return error(_("invalid argument to %s"), opt->long_name);

                    if (options->detect_rename == DIFF_DETECT_COPY)
                            options->flags.find_copies_harder = 1;
                    else
                            options->detect_rename = DIFF_DETECT_COPY;

                    return 0;
            }

            static int diff_opt_find_renames(const struct option *opt,
                                            const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;

                    BUG_ON_OPT_NEG(unset);
                    if (!arg)
                            arg = "";
                    options->rename_score = parse_rename_score(&arg);
                    if (*arg != 0)
                            return error(_("invalid argument to %s"), opt->long_name);

                    options->detect_rename = DIFF_DETECT_RENAME;
                    return 0;
            }

            static int diff_opt_follow(const struct option *opt,
                                    const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;

                    BUG_ON_OPT_ARG(arg);
                    if (unset) {
                            options->flags.follow_renames = 0;
                            options->flags.default_follow_renames = 0;
                    } else {
                            options->flags.follow_renames = 1;
                    }
                    return 0;
            }

            static int diff_opt_ignore_submodules(const struct option *opt,
                                            const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;

                    BUG_ON_OPT_NEG(unset);
                    if (!arg)
                            arg = "all";
                    options->flags.override_submodule_config = 1;
                    handle_ignore_submodules_arg(options, arg);
                    return 0;
            }

            static int diff_opt_line_prefix(const struct option *opt,
                                            const char *optarg, int unset)
            {
                    struct diff_options *options = opt->value;

                    BUG_ON_OPT_NEG(unset);
                    options->line_prefix = optarg;
                    graph_setup_line_prefix(options);
                    return 0;
            }

            static int diff_opt_no_prefix(const struct option *opt,
                                    const char *optarg, int unset)
            {
                    struct diff_options *options = opt->value;

                    BUG_ON_OPT_NEG(unset);
                    BUG_ON_OPT_ARG(optarg);
                    diff_set_noprefix(options);
                    return 0;
            }

            static int diff_opt_default_prefix(const struct option *opt,
                                            const char *optarg, int unset)
            {
                    struct diff_options *options = opt->value;

                    BUG_ON_OPT_NEG(unset);
                    BUG_ON_OPT_ARG(optarg);
                    FREE_AND_NULL(diff_src_prefix);
                    FREE_AND_NULL(diff_dst_prefix);
                    diff_set_default_prefix(options);
                    return 0;
            }

            static enum parse_opt_result diff_opt_output(struct parse_opt_ctx_t *ctx,
                                                    const struct option *opt,
                                                    const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;
                    char *path;

                    BUG_ON_OPT_NEG(unset);
                    path = prefix_filename(ctx->prefix, arg);
                    options->file = xfopen(path, "w");
                    options->close_file = 1;
                    if (options->use_color != GIT_COLOR_ALWAYS)
                            options->use_color = GIT_COLOR_NEVER;
                    free(path);
                    return 0;
            }

            static int diff_opt_patience(const struct option *opt,
                                    const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;
                    int i;

                    BUG_ON_OPT_NEG(unset);
                    BUG_ON_OPT_ARG(arg);
                    /*
                    * Both --patience and --anchored use PATIENCE_DIFF
                    * internally, so remove any anchors previously
                    * specified.
                    */
                    for (i = 0; i < options->anchors_nr; i++)
                            free(options->anchors[i]);
                    options->anchors_nr = 0;
                    options->ignore_driver_algorithm = 1;

                    return set_diff_algorithm(options, "patience");
            }

            static int diff_opt_ignore_regex(const struct option *opt,
                                            const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;
                    regex_t *regex;

                    BUG_ON_OPT_NEG(unset);

                    regex = xmalloc(sizeof(*regex));
                    if (regcomp(regex, arg, REG_EXTENDED | REG_NEWLINE)) {
                            free(regex);
                            return error(_("invalid regex given to -I: '%s'"), arg);
                    }

                    ALLOC_GROW(options->ignore_regex, options->ignore_regex_nr + 1,
                            options->ignore_regex_alloc);
                    options->ignore_regex[options->ignore_regex_nr++] = regex;
                    return 0;
            }

            static int diff_opt_pickaxe_regex(const struct option *opt,
                                            const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;

                    BUG_ON_OPT_NEG(unset);
                    options->pickaxe = arg;
                    options->pickaxe_opts |= DIFF_PICKAXE_KIND_G;
                    return 0;
            }

            static int diff_opt_pickaxe_string(const struct option *opt,
                                            const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;

                    BUG_ON_OPT_NEG(unset);
                    options->pickaxe = arg;
                    options->pickaxe_opts |= DIFF_PICKAXE_KIND_S;
                    return 0;
            }

            static int diff_opt_relative(const struct option *opt,
                                    const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;

                    options->flags.relative_name = !unset;
                    if (arg)
                            options->prefix = arg;
                    return 0;
            }

            static int diff_opt_submodule(const struct option *opt,
                                    const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;

                    BUG_ON_OPT_NEG(unset);
                    if (!arg)
                            arg = "log";
                    if (parse_submodule_params(options, arg))
                            return error(_("failed to parse --submodule option parameter: '%s'"),
                                    arg);
                    return 0;
            }

            static int diff_opt_textconv(const struct option *opt,
                                    const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;

                    BUG_ON_OPT_ARG(arg);
                    if (unset) {
                            options->flags.allow_textconv = 0;
                    } else {
                            options->flags.allow_textconv = 1;
                            options->flags.textconv_set_via_cmdline = 1;
                    }
                    return 0;
            }

            static int diff_opt_unified(const struct option *opt,
                                    const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;
                    char *s;

                    BUG_ON_OPT_NEG(unset);

                    if (arg) {
                            options->context = strtol(arg, &s, 10);
                            if (*s)
                                    return error(_("%s expects a numerical value"), "--unified");
                    }
                    enable_patch_output(&options->output_format);

                    return 0;
            }

            static int diff_opt_word_diff(const struct option *opt,
                                    const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;

                    BUG_ON_OPT_NEG(unset);
                    if (arg) {
                            if (!strcmp(arg, "plain"))
                                    options->word_diff = DIFF_WORDS_PLAIN;
                            else if (!strcmp(arg, "color")) {
                                    options->use_color = 1;
                                    options->word_diff = DIFF_WORDS_COLOR;
                            }
                            else if (!strcmp(arg, "porcelain"))
                                    options->word_diff = DIFF_WORDS_PORCELAIN;
                            else if (!strcmp(arg, "none"))
                                    options->word_diff = DIFF_WORDS_NONE;
                            else
                                    return error(_("bad --word-diff argument: %s"), arg);
                    } else {
                            if (options->word_diff == DIFF_WORDS_NONE)
                                    options->word_diff = DIFF_WORDS_PLAIN;
                    }
                    return 0;
            }

            static int diff_opt_word_diff_regex(const struct option *opt,
                                            const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;

                    BUG_ON_OPT_NEG(unset);
                    if (options->word_diff == DIFF_WORDS_NONE)
                            options->word_diff = DIFF_WORDS_PLAIN;
                    options->word_regex = arg;
                    return 0;
            }

            static int diff_opt_rotate_to(const struct option *opt, const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;

                    BUG_ON_OPT_NEG(unset);
                    if (!strcmp(opt->long_name, "skip-to"))
                            options->skip_instead_of_rotate = 1;
                    else
                            options->skip_instead_of_rotate = 0;
                    options->rotate_to = arg;
                    return 0;
            }

            /*
            * Consider adding new flags to __git_diff_common_options
            * in contrib/completion/git-completion.bash
            */
            struct option *add_diff_options(const struct option *opts,
                                            struct diff_options *options)
            {
                    struct option parseopts[] = {
                            OPT_GROUP(N_("Diff output format options")),
                            OPT_BITOP('p', "patch", &options->output_format,
                                    N_("generate patch"),
                                    DIFF_FORMAT_PATCH, DIFF_FORMAT_NO_OUTPUT),
                            OPT_SET_INT('s', "no-patch", &options->output_format,
                                    N_("suppress diff output"), DIFF_FORMAT_NO_OUTPUT),
                            OPT_BITOP('u', NULL, &options->output_format,
                                    N_("generate patch"),
                                    DIFF_FORMAT_PATCH, DIFF_FORMAT_NO_OUTPUT),
                            OPT_CALLBACK_F('U', "unified", options, N_("<n>"),
                                    N_("generate diffs with <n> lines context"),
                                    PARSE_OPT_NONEG | PARSE_OPT_OPTARG, diff_opt_unified),
                            OPT_BOOL('W', "function-context", &options->flags.funccontext,
                                    N_("generate diffs with <n> lines context")),
                            OPT_BITOP(0, "raw", &options->output_format,
                                    N_("generate the diff in raw format"),
                                    DIFF_FORMAT_RAW, DIFF_FORMAT_NO_OUTPUT),
                            OPT_BITOP(0, "patch-with-raw", &options->output_format,
                                    N_("synonym for '-p --raw'"),
                                    DIFF_FORMAT_PATCH | DIFF_FORMAT_RAW,
                                    DIFF_FORMAT_NO_OUTPUT),
                            OPT_BITOP(0, "patch-with-stat", &options->output_format,
                                    N_("synonym for '-p --stat'"),
                                    DIFF_FORMAT_PATCH | DIFF_FORMAT_DIFFSTAT,
                                    DIFF_FORMAT_NO_OUTPUT),
                            OPT_BITOP(0, "numstat", &options->output_format,
                                    N_("machine friendly --stat"),
                                    DIFF_FORMAT_NUMSTAT, DIFF_FORMAT_NO_OUTPUT),
                            OPT_BITOP(0, "shortstat", &options->output_format,
                                    N_("output only the last line of --stat"),
                                    DIFF_FORMAT_SHORTSTAT, DIFF_FORMAT_NO_OUTPUT),
                            OPT_CALLBACK_F('X', "dirstat", options, N_("<param1>,<param2>..."),
                                    N_("output the distribution of relative amount of changes for each sub-directory"),
                                    PARSE_OPT_NONEG | PARSE_OPT_OPTARG,
                                    diff_opt_dirstat),
                            OPT_CALLBACK_F(0, "cumulative", options, NULL,
                                    N_("synonym for --dirstat=cumulative"),
                                    PARSE_OPT_NONEG | PARSE_OPT_NOARG,
                                    diff_opt_dirstat),
                            OPT_CALLBACK_F(0, "dirstat-by-file", options, N_("<param1>,<param2>..."),
                                    N_("synonym for --dirstat=files,<param1>,<param2>..."),
                                    PARSE_OPT_NONEG | PARSE_OPT_OPTARG,
                                    diff_opt_dirstat),
                            OPT_BIT_F(0, "check", &options->output_format,
                                    N_("warn if changes introduce conflict markers or whitespace errors"),
                                    DIFF_FORMAT_CHECKDIFF, PARSE_OPT_NONEG),
                            OPT_BITOP(0, "summary", &options->output_format,
                                    N_("condensed summary such as creations, renames and mode changes"),
                                    DIFF_FORMAT_SUMMARY, DIFF_FORMAT_NO_OUTPUT),
                            OPT_BIT_F(0, "name-only", &options->output_format,
                                    N_("show only names of changed files"),
                                    DIFF_FORMAT_NAME, PARSE_OPT_NONEG),
                            OPT_BIT_F(0, "name-status", &options->output_format,
                                    N_("show only names and status of changed files"),
                                    DIFF_FORMAT_NAME_STATUS, PARSE_OPT_NONEG),
                            OPT_CALLBACK_F(0, "stat", options, N_("<width>[,<name-width>[,<count>]]"),
                                    N_("generate diffstat"),
                                    PARSE_OPT_NONEG | PARSE_OPT_OPTARG, diff_opt_stat),
                            OPT_CALLBACK_F(0, "stat-width", options, N_("<width>"),
                                    N_("generate diffstat with a given width"),
                                    PARSE_OPT_NONEG, diff_opt_stat),
                            OPT_CALLBACK_F(0, "stat-name-width", options, N_("<width>"),
                                    N_("generate diffstat with a given name width"),
                                    PARSE_OPT_NONEG, diff_opt_stat),
                            OPT_CALLBACK_F(0, "stat-graph-width", options, N_("<width>"),
                                    N_("generate diffstat with a given graph width"),
                                    PARSE_OPT_NONEG, diff_opt_stat),
                            OPT_CALLBACK_F(0, "stat-count", options, N_("<count>"),
                                    N_("generate diffstat with limited lines"),
                                    PARSE_OPT_NONEG, diff_opt_stat),
                            OPT_CALLBACK_F(0, "compact-summary", options, NULL,
                                    N_("generate compact summary in diffstat"),
                                    PARSE_OPT_NOARG, diff_opt_compact_summary),
                            OPT_CALLBACK_F(0, "binary", options, NULL,
                                    N_("output a binary diff that can be applied"),
                                    PARSE_OPT_NONEG | PARSE_OPT_NOARG, diff_opt_binary),
                            OPT_BOOL(0, "full-index", &options->flags.full_index,
                                    N_("show full pre- and post-image object names on the \"index\" lines")),
                            OPT_COLOR_FLAG(0, "color", &options->use_color,
                                    N_("show colored diff")),
                            OPT_CALLBACK_F(0, "ws-error-highlight", options, N_("<kind>"),
                                    N_("highlight whitespace errors in the 'context', 'old' or 'new' lines in the diff"),
                                    PARSE_OPT_NONEG, diff_opt_ws_error_highlight),
                            OPT_SET_INT('z', NULL, &options->line_termination,
                                    N_("do not munge pathnames and use NULs as output field terminators in --raw or --numstat"),
                                    0),
                            OPT__ABBREV(&options->abbrev),
                            OPT_STRING_F(0, "src-prefix", &options->a_prefix, N_("<prefix>"),
                                    N_("show the given source prefix instead of \"a/\""),
                                    PARSE_OPT_NONEG),
                            OPT_STRING_F(0, "dst-prefix", &options->b_prefix, N_("<prefix>"),
                                    N_("show the given destination prefix instead of \"b/\""),
                                    PARSE_OPT_NONEG),
                            OPT_CALLBACK_F(0, "line-prefix", options, N_("<prefix>"),
                                    N_("prepend an additional prefix to every line of output"),
                                    PARSE_OPT_NONEG, diff_opt_line_prefix),
                            OPT_CALLBACK_F(0, "no-prefix", options, NULL,
                                    N_("do not show any source or destination prefix"),
                                    PARSE_OPT_NONEG | PARSE_OPT_NOARG, diff_opt_no_prefix),
                            OPT_CALLBACK_F(0, "default-prefix", options, NULL,
                                    N_("use default prefixes a/ and b/"),
                                    PARSE_OPT_NONEG | PARSE_OPT_NOARG, diff_opt_default_prefix),
                            OPT_INTEGER_F(0, "inter-hunk-context", &options->interhunkcontext,
                                    N_("show context between diff hunks up to the specified number of lines"),
                                    PARSE_OPT_NONEG),
                            OPT_CALLBACK_F(0, "output-indicator-new",
                                    &options->output_indicators[OUTPUT_INDICATOR_NEW],
                                    N_("<char>"),
                                    N_("specify the character to indicate a new line instead of '+'"),
                                    PARSE_OPT_NONEG, diff_opt_char),
                            OPT_CALLBACK_F(0, "output-indicator-old",
                                    &options->output_indicators[OUTPUT_INDICATOR_OLD],
                                    N_("<char>"),
                                    N_("specify the character to indicate an old line instead of '-'"),
                                    PARSE_OPT_NONEG, diff_opt_char),
                            OPT_CALLBACK_F(0, "output-indicator-context",
                                    &options->output_indicators[OUTPUT_INDICATOR_CONTEXT],
                                    N_("<char>"),
                                    N_("specify the character to indicate a context instead of ' '"),
                                    PARSE_OPT_NONEG, diff_opt_char),

                            OPT_GROUP(N_("Diff rename options")),
                            OPT_CALLBACK_F('B', "break-rewrites", &options->break_opt, N_("<n>[/<m>]"),
                                    N_("break complete rewrite changes into pairs of delete and create"),
                                    PARSE_OPT_NONEG | PARSE_OPT_OPTARG,
                                    diff_opt_break_rewrites),
                            OPT_CALLBACK_F('M', "find-renames", options, N_("<n>"),
                                    N_("detect renames"),
                                    PARSE_OPT_NONEG | PARSE_OPT_OPTARG,
                                    diff_opt_find_renames),
                            OPT_SET_INT_F('D', "irreversible-delete", &options->irreversible_delete,
                                    N_("omit the preimage for deletes"),
                                    1, PARSE_OPT_NONEG),
                            OPT_CALLBACK_F('C', "find-copies", options, N_("<n>"),
                                    N_("detect copies"),
                                    PARSE_OPT_NONEG | PARSE_OPT_OPTARG,
                                    diff_opt_find_copies),
                            OPT_BOOL(0, "find-copies-harder", &options->flags.find_copies_harder,
                                    N_("use unmodified files as source to find copies")),
                            OPT_SET_INT_F(0, "no-renames", &options->detect_rename,
                                    N_("disable rename detection"),
                                    0, PARSE_OPT_NONEG),
                            OPT_BOOL(0, "rename-empty", &options->flags.rename_empty,
                                    N_("use empty blobs as rename source")),
                            OPT_CALLBACK_F(0, "follow", options, NULL,
                                    N_("continue listing the history of a file beyond renames"),
                                    PARSE_OPT_NOARG, diff_opt_follow),
                            OPT_INTEGER('l', NULL, &options->rename_limit,
                                    N_("prevent rename/copy detection if the number of rename/copy targets exceeds given limit")),

                            OPT_GROUP(N_("Diff algorithm options")),
                            OPT_CALLBACK_F(0, "minimal", options, NULL,
                                    N_("produce the smallest possible diff"),
                                    PARSE_OPT_NONEG | PARSE_OPT_NOARG,
                                    diff_opt_diff_algorithm_no_arg),
                            OPT_BIT_F('w', "ignore-all-space", &options->xdl_opts,
                                    N_("ignore whitespace when comparing lines"),
                                    XDF_IGNORE_WHITESPACE, PARSE_OPT_NONEG),
                            OPT_BIT_F('b', "ignore-space-change", &options->xdl_opts,
                                    N_("ignore changes in amount of whitespace"),
                                    XDF_IGNORE_WHITESPACE_CHANGE, PARSE_OPT_NONEG),
                            OPT_BIT_F(0, "ignore-space-at-eol", &options->xdl_opts,
                                    N_("ignore changes in whitespace at EOL"),
                                    XDF_IGNORE_WHITESPACE_AT_EOL, PARSE_OPT_NONEG),
                            OPT_BIT_F(0, "ignore-cr-at-eol", &options->xdl_opts,
                                    N_("ignore carrier-return at the end of line"),
                                    XDF_IGNORE_CR_AT_EOL, PARSE_OPT_NONEG),
                            OPT_BIT_F(0, "ignore-blank-lines", &options->xdl_opts,
                                    N_("ignore changes whose lines are all blank"),
                                    XDF_IGNORE_BLANK_LINES, PARSE_OPT_NONEG),
                            OPT_CALLBACK_F('I', "ignore-matching-lines", options, N_("<regex>"),
                                    N_("ignore changes whose all lines match <regex>"),
                                    0, diff_opt_ignore_regex),
                            OPT_BIT(0, "indent-heuristic", &options->xdl_opts,
                                    N_("heuristic to shift diff hunk boundaries for easy reading"),
                                    XDF_INDENT_HEURISTIC),
                            OPT_CALLBACK_F(0, "patience", options, NULL,
                                    N_("generate diff using the \"patience diff\" algorithm"),
                                    PARSE_OPT_NONEG | PARSE_OPT_NOARG,
                                    diff_opt_patience),
                            OPT_CALLBACK_F(0, "histogram", options, NULL,
                                    N_("generate diff using the \"histogram diff\" algorithm"),
                                    PARSE_OPT_NONEG | PARSE_OPT_NOARG,
                                    diff_opt_diff_algorithm_no_arg),
                            OPT_CALLBACK_F(0, "diff-algorithm", options, N_("<algorithm>"),
                                    N_("choose a diff algorithm"),
                                    PARSE_OPT_NONEG, diff_opt_diff_algorithm),
                            OPT_CALLBACK_F(0, "anchored", options, N_("<text>"),
                                    N_("generate diff using the \"anchored diff\" algorithm"),
                                    PARSE_OPT_NONEG, diff_opt_anchored),
                            OPT_CALLBACK_F(0, "word-diff", options, N_("<mode>"),
                                    N_("show word diff, using <mode> to delimit changed words"),
                                    PARSE_OPT_NONEG | PARSE_OPT_OPTARG, diff_opt_word_diff),
                            OPT_CALLBACK_F(0, "word-diff-regex", options, N_("<regex>"),
                                    N_("use <regex> to decide what a word is"),
                                    PARSE_OPT_NONEG, diff_opt_word_diff_regex),
                            OPT_CALLBACK_F(0, "color-words", options, N_("<regex>"),
                                    N_("equivalent to --word-diff=color --word-diff-regex=<regex>"),
                                    PARSE_OPT_NONEG | PARSE_OPT_OPTARG, diff_opt_color_words),
                            OPT_CALLBACK_F(0, "color-moved", options, N_("<mode>"),
                                    N_("moved lines of code are colored differently"),
                                    PARSE_OPT_OPTARG, diff_opt_color_moved),
                            OPT_CALLBACK_F(0, "color-moved-ws", options, N_("<mode>"),
                                    N_("how white spaces are ignored in --color-moved"),
                                    0, diff_opt_color_moved_ws),

                            OPT_GROUP(N_("Other diff options")),
                            OPT_CALLBACK_F(0, "relative", options, N_("<prefix>"),
                                    N_("when run from subdir, exclude changes outside and show relative paths"),
                                    PARSE_OPT_OPTARG,
                                    diff_opt_relative),
                            OPT_BOOL('a', "text", &options->flags.text,
                                    N_("treat all files as text")),
                            OPT_BOOL('R', NULL, &options->flags.reverse_diff,
                                    N_("swap two inputs, reverse the diff")),
                            OPT_BOOL(0, "exit-code", &options->flags.exit_with_status,
                                    N_("exit with 1 if there were differences, 0 otherwise")),
                            OPT_BOOL(0, "quiet", &options->flags.quick,
                                    N_("disable all output of the program")),
                            OPT_BOOL(0, "ext-diff", &options->flags.allow_external,
                                    N_("allow an external diff helper to be executed")),
                            OPT_CALLBACK_F(0, "textconv", options, NULL,
                                    N_("run external text conversion filters when comparing binary files"),
                                    PARSE_OPT_NOARG, diff_opt_textconv),
                            OPT_CALLBACK_F(0, "ignore-submodules", options, N_("<when>"),
                                    N_("ignore changes to submodules in the diff generation"),
                                    PARSE_OPT_NONEG | PARSE_OPT_OPTARG,
                                    diff_opt_ignore_submodules),
                            OPT_CALLBACK_F(0, "submodule", options, N_("<format>"),
                                    N_("specify how differences in submodules are shown"),
                                    PARSE_OPT_NONEG | PARSE_OPT_OPTARG,
                                    diff_opt_submodule),
                            OPT_SET_INT_F(0, "ita-invisible-in-index", &options->ita_invisible_in_index,
                                    N_("hide 'git add -N' entries from the index"),
                                    1, PARSE_OPT_NONEG),
                            OPT_SET_INT_F(0, "ita-visible-in-index", &options->ita_invisible_in_index,
                                    N_("treat 'git add -N' entries as real in the index"),
                                    0, PARSE_OPT_NONEG),
                            OPT_CALLBACK_F('S', NULL, options, N_("<string>"),
                                    N_("look for differences that change the number of occurrences of the specified string"),
                                    0, diff_opt_pickaxe_string),
                            OPT_CALLBACK_F('G', NULL, options, N_("<regex>"),
                                    N_("look for differences that change the number of occurrences of the specified regex"),
                                    0, diff_opt_pickaxe_regex),
                            OPT_BIT_F(0, "pickaxe-all", &options->pickaxe_opts,
                                    N_("show all changes in the changeset with -S or -G"),
                                    DIFF_PICKAXE_ALL, PARSE_OPT_NONEG),
                            OPT_BIT_F(0, "pickaxe-regex", &options->pickaxe_opts,
                                    N_("treat <string> in -S as extended POSIX regular expression"),
                                    DIFF_PICKAXE_REGEX, PARSE_OPT_NONEG),
                            OPT_FILENAME('O', NULL, &options->orderfile,
                                    N_("control the order in which files appear in the output")),
                            OPT_CALLBACK_F(0, "rotate-to", options, N_("<path>"),
                                    N_("show the change in the specified path first"),
                                    PARSE_OPT_NONEG, diff_opt_rotate_to),
                            OPT_CALLBACK_F(0, "skip-to", options, N_("<path>"),
                                    N_("skip the output to the specified path"),
                                    PARSE_OPT_NONEG, diff_opt_rotate_to),
                            OPT_CALLBACK_F(0, "find-object", options, N_("<object-id>"),
                                    N_("look for differences that change the number of occurrences of the specified object"),
                                    PARSE_OPT_NONEG, diff_opt_find_object),
                            OPT_CALLBACK_F(0, "diff-filter", options, N_("[(A|C|D|M|R|T|U|X|B)...[*]]"),
                                    N_("select files by diff type"),
                                    PARSE_OPT_NONEG, diff_opt_diff_filter),
                            { OPTION_CALLBACK, 0, "output", options, N_("<file>"),
                            N_("output to a specific file"),
                            PARSE_OPT_NONEG, NULL, 0, diff_opt_output },

                            OPT_END()
                    };

                    return parse_options_concat(opts, parseopts);
            }

            int diff_opt_parse(struct diff_options *options,
                            const char **av, int ac, const char *prefix)
            {
                    struct option no_options[] = { OPT_END() };
                    struct option *parseopts = add_diff_options(no_options, options);

                    if (!prefix)
                            prefix = "";

                    ac = parse_options(ac, av, prefix, parseopts, NULL,
                                    PARSE_OPT_KEEP_DASHDASH |
                                    PARSE_OPT_KEEP_UNKNOWN_OPT |
                                    PARSE_OPT_NO_INTERNAL_HELP |
                                    PARSE_OPT_ONE_SHOT |
                                    PARSE_OPT_STOP_AT_NON_OPTION);
                    free(parseopts);

                    return ac;
            }

            int parse_rename_score(const char **cp_p)
            {
                    unsigned long num, scale;
                    int ch, dot;
                    const char *cp = *cp_p;

                    num = 0;
                    scale = 1;
                    dot = 0;
                    for (;;) {
                            ch = *cp;
                            if ( !dot && ch == '.' ) {
                                    scale = 1;
                                    dot = 1;
                            } else if ( ch == '%' ) {
                                    scale = dot ? scale*100 : 100;
                                    cp++;   /* % is always at the end */
                                    break;
                            } else if ( ch >= '0' && ch <= '9' ) {
                                    if ( scale < 100000 ) {
                                            scale *= 10;
                                            num = (num*10) + (ch-'0');
                                    }
                            } else {
                                    break;
                            }
                            cp++;
                    }
                    *cp_p = cp;

                    /* user says num divided by scale and we say internally that
                    * is MAX_SCORE * num / scale.
                    */
                    return (int)((num >= scale) ? MAX_SCORE : (MAX_SCORE * num / scale));
            }

            struct diff_queue_struct diff_queued_diff;

            void diff_q(struct diff_queue_struct *queue, struct diff_filepair *dp)
            {
                    ALLOC_GROW(queue->queue, queue->nr + 1, queue->alloc);
                    queue->queue[queue->nr++] = dp;
            }

            struct diff_filepair *diff_queue(struct diff_queue_struct *queue,
                                            struct diff_filespec *one,
                                            struct diff_filespec *two)
            {
                    struct diff_filepair *dp = xcalloc(1, sizeof(*dp));
                    dp->one = one;
                    dp->two = two;
                    if (queue)
                            diff_q(queue, dp);
                    return dp;
            }

            void diff_free_filepair(struct diff_filepair *p)
            {
                    free_filespec(p->one);
                    free_filespec(p->two);
                    free(p);
            }

            void diff_queue_init(struct diff_queue_struct *q)
            {
                    struct diff_queue_struct blank = DIFF_QUEUE_INIT;
                    memcpy(q, &blank, sizeof(*q));
            }

            void diff_queue_clear(struct diff_queue_struct *q)
            {
                    for (int i = 0; i < q->nr; i++)
                            diff_free_filepair(q->queue[i]);
                    free(q->queue);
                    diff_queue_init(q);
            }

            const char *diff_aligned_abbrev(const struct object_id *oid, int len)
            {
                    int abblen;
                    const char *abbrev;

                    /* Do we want all 40 hex characters? */
                    if (len == the_hash_algo->hexsz)
                            return oid_to_hex(oid);

                    /* An abbreviated value is fine, possibly followed by an ellipsis. */
                    abbrev = diff_abbrev_oid(oid, len);

                    if (!print_sha1_ellipsis())
                            return abbrev;

                    abblen = strlen(abbrev);

                    /*
                    * In well-behaved cases, where the abbreviated result is the
                    * same as the requested length, append three dots after the
                    * abbreviation (hence the whole logic is limited to the case
                    * where abblen < 37); when the actual abbreviated result is a
                    * bit longer than the requested length, we reduce the number
                    * of dots so that they match the well-behaved ones.  However,
                    * if the actual abbreviation is longer than the requested
                    * length by more than three, we give up on aligning, and add
                    * three dots anyway, to indicate that the output is not the
                    * full object name.  Yes, this may be suboptimal, but this
                    * appears only in "diff --raw --abbrev" output and it is not
                    * worth the effort to change it now.  Note that this would
                    * likely to work fine when the automatic sizing of default
                    * abbreviation length is used--we would be fed -1 in "len" in
                    * that case, and will end up always appending three-dots, but
                    * the automatic sizing is supposed to give abblen that ensures
                    * uniqueness across all objects (statistically speaking).
                    */
                    if (abblen < the_hash_algo->hexsz - 3) {
                            static char hex[GIT_MAX_HEXSZ + 1];
                            if (len < abblen && abblen <= len + 2)
                                    xsnprintf(hex, sizeof(hex), "%s%.*s", abbrev, len+3-abblen, "..");
                            else
                                    xsnprintf(hex, sizeof(hex), "%s...", abbrev);
                            return hex;
                    }

                    return oid_to_hex(oid);
            }

            static void diff_flush_raw(struct diff_filepair *p, struct diff_options *opt)
            {
                    int line_termination = opt->line_termination;
                    int inter_name_termination = line_termination ? '\t' : '\0';

                    fprintf(opt->file, "%s", diff_line_prefix(opt));
                    if (!(opt->output_format & DIFF_FORMAT_NAME_STATUS)) {
                            fprintf(opt->file, ":%06o %06o %s ", p->one->mode, p->two->mode,
                                    diff_aligned_abbrev(&p->one->oid, opt->abbrev));
                            fprintf(opt->file, "%s ",
                                    diff_aligned_abbrev(&p->two->oid, opt->abbrev));
                    }
                    if (p->score) {
                            fprintf(opt->file, "%c%03d%c", p->status, similarity_index(p),
                                    inter_name_termination);
                    } else {
                            fprintf(opt->file, "%c%c", p->status, inter_name_termination);
                    }

                    if (p->status == DIFF_STATUS_COPIED ||
                    p->status == DIFF_STATUS_RENAMED) {
                            const char *name_a, *name_b;
                            name_a = p->one->path;
                            name_b = p->two->path;
                            strip_prefix(opt->prefix_length, &name_a, &name_b);
                            write_name_quoted(name_a, opt->file, inter_name_termination);
                            write_name_quoted(name_b, opt->file, line_termination);
                    } else {
                            const char *name_a, *name_b;
                            name_a = p->one->mode ? p->one->path : p->two->path;
                            name_b = NULL;
                            strip_prefix(opt->prefix_length, &name_a, &name_b);
                            write_name_quoted(name_a, opt->file, line_termination);
                    }
            }

            int diff_unmodified_pair(struct diff_filepair *p)
            {
                    /* This function is written stricter than necessary to support
                    * the currently implemented transformers, but the idea is to
                    * let transformers to produce diff_filepairs any way they want,
                    * and filter and clean them up here before producing the output.
                    */
                    struct diff_filespec *one = p->one, *two = p->two;

                    if (DIFF_PAIR_UNMERGED(p))
                            return 0; /* unmerged is interesting */

                    /* deletion, addition, mode or type change
                    * and rename are all interesting.
                    */
                    if (DIFF_FILE_VALID(one) != DIFF_FILE_VALID(two) ||
                    DIFF_PAIR_MODE_CHANGED(p) ||
                    strcmp(one->path, two->path))
                            return 0;

                    /* both are valid and point at the same path.  that is, we are
                    * dealing with a change.
                    */
                    if (one->oid_valid && two->oid_valid &&
                    oideq(&one->oid, &two->oid) &&
                    !one->dirty_submodule && !two->dirty_submodule)
                            return 1; /* no change */
                    if (!one->oid_valid && !two->oid_valid)
                            return 1; /* both look at the same file on the filesystem. */
                    return 0;
            }

            static void diff_flush_patch(struct diff_filepair *p, struct diff_options *o)
            {
                    int include_conflict_headers =
                    (additional_headers(o, p->one->path) &&
                    !o->pickaxe_opts &&
                    (!o->filter || filter_bit_tst(DIFF_STATUS_UNMERGED, o)));

                    /*
                    * Check if we can return early without showing a diff.  Note that
                    * diff_filepair only stores {oid, path, mode, is_valid}
                    * information for each path, and thus diff_unmodified_pair() only
                    * considers those bits of info.  However, we do not want pairs
                    * created by create_filepairs_for_header_only_notifications()
                    * (which always look like unmodified pairs) to be ignored, so
                    * return early if both p is unmodified AND we don't want to
                    * include_conflict_headers.
                    */
                    if (diff_unmodified_pair(p) && !include_conflict_headers)
                            return;

                    /* Actually, we can also return early to avoid showing tree diffs */
                    if ((DIFF_FILE_VALID(p->one) && S_ISDIR(p->one->mode)) ||
                    (DIFF_FILE_VALID(p->two) && S_ISDIR(p->two->mode)))
                            return;

                    run_diff(p, o);
            }

            static void diff_flush_stat(struct diff_filepair *p, struct diff_options *o,
                                    struct diffstat_t *diffstat)
            {
                    if (diff_unmodified_pair(p))
                            return;

                    if ((DIFF_FILE_VALID(p->one) && S_ISDIR(p->one->mode)) ||
                    (DIFF_FILE_VALID(p->two) && S_ISDIR(p->two->mode)))
                            return; /* no useful stat for tree diffs */

                    run_diffstat(p, o, diffstat);
            }

            static void diff_flush_checkdiff(struct diff_filepair *p,
                            struct diff_options *o)
            {
                    if (diff_unmodified_pair(p))
                            return;

                    if ((DIFF_FILE_VALID(p->one) && S_ISDIR(p->one->mode)) ||
                    (DIFF_FILE_VALID(p->two) && S_ISDIR(p->two->mode)))
                            return; /* nothing to check in tree diffs */

                    run_checkdiff(p, o);
            }

            int diff_queue_is_empty(struct diff_options *o)
            {
                    struct diff_queue_struct *q = &diff_queued_diff;
                    int i;
                    int include_conflict_headers =
                    (o->additional_path_headers &&
                    strmap_get_size(o->additional_path_headers) &&
                    !o->pickaxe_opts &&
                    (!o->filter || filter_bit_tst(DIFF_STATUS_UNMERGED, o)));

                    if (include_conflict_headers)
                            return 0;

                    for (i = 0; i < q->nr; i++)
                            if (!diff_unmodified_pair(q->queue[i]))
                                    return 0;
                    return 1;
            }

            #if DIFF_DEBUG
            void diff_debug_filespec(struct diff_filespec *s, int x, const char *one)
            {
                    fprintf(stderr, "queue[%d] %s (%s) %s %06o %s\n",
                            x, one ? one : "",
                            s->path,
                            DIFF_FILE_VALID(s) ? "valid" : "invalid",
                            s->mode,
                            s->oid_valid ? oid_to_hex(&s->oid) : "");
                    fprintf(stderr, "queue[%d] %s size %lu\n",
                            x, one ? one : "",
                            s->size);
            }

            void diff_debug_filepair(const struct diff_filepair *p, int i)
            {
                    diff_debug_filespec(p->one, i, "one");
                    diff_debug_filespec(p->two, i, "two");
                    fprintf(stderr, "score %d, status %c rename_used %d broken %d\n",
                            p->score, p->status ? p->status : '?',
                            p->one->rename_used, p->broken_pair);
            }

            void diff_debug_queue(const char *msg, struct diff_queue_struct *q)
            {
                    int i;
                    if (msg)
                            fprintf(stderr, "%s\n", msg);
                    fprintf(stderr, "q->nr = %d\n", q->nr);
                    for (i = 0; i < q->nr; i++) {
                            struct diff_filepair *p = q->queue[i];
                            diff_debug_filepair(p, i);
                    }
            }
            #endif

            static void diff_resolve_rename_copy(void)
            {
                    int i;
                    struct diff_filepair *p;
                    struct diff_queue_struct *q = &diff_queued_diff;

                    diff_debug_queue("resolve-rename-copy", q);

                    for (i = 0; i < q->nr; i++) {
                            p = q->queue[i];
                            p->status = 0; /* undecided */
                            if (DIFF_PAIR_UNMERGED(p))
                                    p->status = DIFF_STATUS_UNMERGED;
                            else if (!DIFF_FILE_VALID(p->one))
                                    p->status = DIFF_STATUS_ADDED;
                            else if (!DIFF_FILE_VALID(p->two))
                                    p->status = DIFF_STATUS_DELETED;
                            else if (DIFF_PAIR_TYPE_CHANGED(p))
                                    p->status = DIFF_STATUS_TYPE_CHANGED;

                            /* from this point on, we are dealing with a pair
                            * whose both sides are valid and of the same type, i.e.
                            * either in-place edit or rename/copy edit.
                            */
                            else if (DIFF_PAIR_RENAME(p)) {
                                    /*
                                    * A rename might have re-connected a broken
                                    * pair up, causing the pathnames to be the
                                    * same again. If so, that's not a rename at
                                    * all, just a modification..
                                    *
                                    * Otherwise, see if this source was used for
                                    * multiple renames, in which case we decrement
                                    * the count, and call it a copy.
                                    */
                                    if (!strcmp(p->one->path, p->two->path))
                                            p->status = DIFF_STATUS_MODIFIED;
                                    else if (--p->one->rename_used > 0)
                                            p->status = DIFF_STATUS_COPIED;
                                    else
                                            p->status = DIFF_STATUS_RENAMED;
                            }
                            else if (!oideq(&p->one->oid, &p->two->oid) ||
                                    p->one->mode != p->two->mode ||
                                    p->one->dirty_submodule ||
                                    p->two->dirty_submodule ||
                                    is_null_oid(&p->one->oid))
                                    p->status = DIFF_STATUS_MODIFIED;
                            else {
                                    /* This is a "no-change" entry and should not
                            * happen anymore, but prepare for broken callers.
                            */
                            error("feeding unmodified %s to diffcore",
                            p->one->path);
                            p->status = DIFF_STATUS_UNKNOWN;
                    }
            }
            diff_debug_queue("resolve-rename-copy done", q);
    }

    static int check_pair_status(struct diff_filepair *p)
    {
            switch (p->status) {
            case DIFF_STATUS_UNKNOWN:
                    return 0;
            case 0:
                    die("internal error in diff-resolve-rename-copy");
            default:
                    return 1;
            }
    }

    static void flush_one_pair(struct diff_filepair *p, struct diff_options *opt)
    {
            int fmt = opt->output_format;

            if (fmt & DIFF_FORMAT_CHECKDIFF)
                    diff_flush_checkdiff(p, opt);
            else if (fmt & (DIFF_FORMAT_RAW | DIFF_FORMAT_NAME_STATUS))
                    diff_flush_raw(p, opt);
            else if (fmt & DIFF_FORMAT_NAME) {
                    const char *name_a, *name_b;
                    name_a = p->two->path;
                    name_b = NULL;
                    strip_prefix(opt->prefix_length, &name_a, &name_b);
                    fprintf(opt->file, "%s", diff_line_prefix(opt));
                    write_name_quoted(name_a, opt->file, opt->line_termination);
            }

            opt->found_changes = 1;
    }

    static void show_file_mode_name(struct diff_options *opt, const char *newdelete, struct diff_filespec *fs)
    {
            struct strbuf sb = STRBUF_INIT;
            if (fs->mode)
                    strbuf_addf(&sb, " %s mode %06o ", newdelete, fs->mode);
            else
                    strbuf_addf(&sb, " %s ", newdelete);

            quote_c_style(fs->path, &sb, NULL, 0);
            strbuf_addch(&sb, '\n');
            emit_diff_symbol(opt, DIFF_SYMBOL_SUMMARY,
                            sb.buf, sb.len, 0);
            strbuf_release(&sb);
    }

    static void show_mode_change(struct diff_options *opt, struct diff_filepair *p,
                    int show_name)
    {
            if (p->one->mode && p->two->mode && p->one->mode != p->two->mode) {
                    struct strbuf sb = STRBUF_INIT;
                    strbuf_addf(&sb, " mode change %06o => %06o",
                            p->one->mode, p->two->mode);
                    if (show_name) {
                            strbuf_addch(&sb, ' ');
                            quote_c_style(p->two->path, &sb, NULL, 0);
                    }
                    strbuf_addch(&sb, '\n');
                    emit_diff_symbol(opt, DIFF_SYMBOL_SUMMARY,
                                    sb.buf, sb.len, 0);
                    strbuf_release(&sb);
            }
    }

    static void show_rename_copy(struct diff_options *opt, const char *renamecopy,
                    struct diff_filepair *p)
    {
            struct strbuf sb = STRBUF_INIT;
            struct strbuf names = STRBUF_INIT;

            pprint_rename(&names, p->one->path, p->two->path);
            strbuf_addf(&sb, " %s %s (%d%%)\n",
                    renamecopy, names.buf, similarity_index(p));
            strbuf_release(&names);
            emit_diff_symbol(opt, DIFF_SYMBOL_SUMMARY,
                                    sb.buf, sb.len, 0);
            show_mode_change(opt, p, 0);
            strbuf_release(&sb);
    }

    static void diff_summary(struct diff_options *opt, struct diff_filepair *p)
    {
            switch(p->status) {
            case DIFF_STATUS_DELETED:
                    show_file_mode_name(opt, "delete", p->one);
                    break;
            case DIFF_STATUS_ADDED:
                    show_file_mode_name(opt, "create", p->two);
                    break;
            case DIFF_STATUS_COPIED:
                    show_rename_copy(opt, "copy", p);
                    break;
            case DIFF_STATUS_RENAMED:
                    show_rename_copy(opt, "rename", p);
                    break;
            default:
                    if (p->score) {
                            struct strbuf sb = STRBUF_INIT;
                            strbuf_addstr(&sb, " rewrite ");
                            quote_c_style(p->two->path, &sb, NULL, 0);
                            strbuf_addf(&sb, " (%d%%)\n", similarity_index(p));
                            emit_diff_symbol(opt, DIFF_SYMBOL_SUMMARY,
                                            sb.buf, sb.len, 0);
                            strbuf_release(&sb);
                    }
                    show_mode_change(opt, p, !p->score);
                    break;
            }
    }

    struct patch_id_t {
            git_hash_ctx *ctx;
            int patchlen;
    };

    static int remove_space(char *line, int len)
    {
            int i;
            char *dst = line;
            unsigned char c;

            for (i = 0; i < len; i++)
                    if (!isspace((c = line[i])))
                            *dst++ = c;

            return dst - line;
    }

    void flush_one_hunk(struct object_id *result, git_hash_ctx *ctx)
    {
            unsigned char hash[GIT_MAX_RAWSZ];
            unsigned short carry = 0;
            int i;

            the_hash_algo->final_fn(hash, ctx);
            the_hash_algo->init_fn(ctx);
            /* 20-byte sum, with carry */
            for (i = 0; i < the_hash_algo->rawsz; ++i) {
                    carry += result->hash[i] + hash[i];
                    result->hash[i] = carry;
                    carry >>= 8;
            }
    }

    static int patch_id_consume(void *priv, char *line, unsigned long len)
    {
            struct patch_id_t *data = priv;
            int new_len;

            if (len > 12 && starts_with(line, "\\ "))
                    return 0;
            new_len = remove_space(line, len);

            the_hash_algo->update_fn(data->ctx, line, new_len);
            data->patchlen += new_len;
            return 0;
    }

    static void patch_id_add_string(git_hash_ctx *ctx, const char *str)
    {
            the_hash_algo->update_fn(ctx, str, strlen(str));
    }

    static void patch_id_add_mode(git_hash_ctx *ctx, unsigned mode)
    {
            /* large enough for 2^32 in octal */
            char buf[12];
            int len = xsnprintf(buf, sizeof(buf), "%06o", mode);
            the_hash_algo->update_fn(ctx, buf, len);
    }

    /* returns 0 upon success, and writes result into oid */
    static int diff_get_patch_id(struct diff_options *options, struct object_id *oid, int diff_header_only)
    {
            struct diff_queue_struct *q = &diff_queued_diff;
            int i;
            git_hash_ctx ctx;
            struct patch_id_t data;

            the_hash_algo->init_fn(&ctx);
            memset(&data, 0, sizeof(struct patch_id_t));
            data.ctx = &ctx;
            oidclr(oid, the_repository->hash_algo);

            for (i = 0; i < q->nr; i++) {
                    xpparam_t xpp;
                    xdemitconf_t xecfg;
                    mmfile_t mf1, mf2;
                    struct diff_filepair *p = q->queue[i];
                    int len1, len2;

                    memset(&xpp, 0, sizeof(xpp));
                    memset(&xecfg, 0, sizeof(xecfg));
                    if (p->status == 0)
                            return error("internal diff status error");
                    if (p->status == DIFF_STATUS_UNKNOWN)
                            continue;
                    if (diff_unmodified_pair(p))
                            continue;
                    if ((DIFF_FILE_VALID(p->one) && S_ISDIR(p->one->mode)) ||
                    (DIFF_FILE_VALID(p->two) && S_ISDIR(p->two->mode)))
                            continue;
                    if (DIFF_PAIR_UNMERGED(p))
                            continue;

                    diff_fill_oid_info(p->one, options->repo->index);
                    diff_fill_oid_info(p->two, options->repo->index);

                    len1 = remove_space(p->one->path, strlen(p->one->path));
                    len2 = remove_space(p->two->path, strlen(p->two->path));
                    patch_id_add_string(&ctx, "diff--git");
                    patch_id_add_string(&ctx, "a/");
                    the_hash_algo->update_fn(&ctx, p->one->path, len1);
                    patch_id_add_string(&ctx, "b/");
                    the_hash_algo->update_fn(&ctx, p->two->path, len2);

                    if (p->one->mode == 0) {
                            patch_id_add_string(&ctx, "newfilemode");
                            patch_id_add_mode(&ctx, p->two->mode);
                    } else if (p->two->mode == 0) {
                            patch_id_add_string(&ctx, "deletedfilemode");
                            patch_id_add_mode(&ctx, p->one->mode);
                    } else if (p->one->mode != p->two->mode) {
                            patch_id_add_string(&ctx, "oldmode");
                            patch_id_add_mode(&ctx, p->one->mode);
                            patch_id_add_string(&ctx, "newmode");
                            patch_id_add_mode(&ctx, p->two->mode);
                    }

                    if (diff_header_only) {
                            /* don't do anything since we're only populating header info */
                    } else if (diff_filespec_is_binary(options->repo, p->one) ||
                    diff_filespec_is_binary(options->repo, p->two)) {
                            the_hash_algo->update_fn(&ctx, oid_to_hex(&p->one->oid),
                                            the_hash_algo->hexsz);
                            the_hash_algo->update_fn(&ctx, oid_to_hex(&p->two->oid),
                                            the_hash_algo->hexsz);
                    } else {
                            if (p->one->mode == 0) {
                                    patch_id_add_string(&ctx, "---/dev/null");
                                    patch_id_add_string(&ctx, "+++b/");
                                    the_hash_algo->update_fn(&ctx, p->two->path, len2);
                            } else if (p->two->mode == 0) {
                                    patch_id_add_string(&ctx, "---a/");
                                    the_hash_algo->update_fn(&ctx, p->one->path, len1);
                                    patch_id_add_string(&ctx, "+++/dev/null");
                            } else {
                                    patch_id_add_string(&ctx, "---a/");
                                    the_hash_algo->update_fn(&ctx, p->one->path, len1);
                                    patch_id_add_string(&ctx, "+++b/");
                                    the_hash_algo->update_fn(&ctx, p->two->path, len2);
                            }

                            if (fill_mmfile(options->repo, &mf1, p->one) < 0 ||
                            fill_mmfile(options->repo, &mf2, p->two) < 0)
                                    return error("unable to read files to diff");
                            xpp.flags = 0;
                            xecfg.ctxlen = 3;
                            xecfg.flags = XDL_EMIT_NO_HUNK_HDR;
                            if (xdi_diff_outf(&mf1, &mf2, NULL,
                                            patch_id_consume, &data, &xpp, &xecfg))
                                    return error("unable to generate patch-id diff for %s",
                                            p->one->path);
                    }
                    flush_one_hunk(oid, &ctx);
            }

            return 0;
    }

    int diff_flush_patch_id(struct diff_options *options, struct object_id *oid, int diff_header_only)
    {
            struct diff_queue_struct *q = &diff_queued_diff;
            int result = diff_get_patch_id(options, oid, diff_header_only);

            diff_queue_clear(q);

            return result;
    }

    static int is_summary_empty(const struct diff_queue_struct *q)
    {
            int i;

            for (i = 0; i < q->nr; i++) {
                    const struct diff_filepair *p = q->queue[i];

                    switch (p->status) {
                    case DIFF_STATUS_DELETED:
                    case DIFF_STATUS_ADDED:
                    case DIFF_STATUS_COPIED:
                    case DIFF_STATUS_RENAMED:
                            return 0;
                    default:
                            if (p->score)
                                    return 0;
                            if (p->one->mode && p->two->mode &&
                            p->one->mode != p->two->mode)
                                    return 0;
                            break;
                    }
            }
            return 1;
    }

    static const char rename_limit_warning[] =
    N_("exhaustive rename detection was skipped due to too many files.");

    static const char degrade_cc_to_c_warning[] =
    N_("only found copies from modified paths due to too many files.");

    static const char rename_limit_advice[] =
    N_("you may want to set your %s variable to at least "
    "%d and retry the command.");

    void diff_warn_rename_limit(const char *varname, int needed, int degraded_cc)
    {
            fflush(stdout);
            if (degraded_cc)
                    warning(_(degrade_cc_to_c_warning));
            else if (needed)
                    warning(_(rename_limit_warning));
            else
                    return;
            if (0 < needed)
                    warning(_(rename_limit_advice), varname, needed);
    }

    static void create_filepairs_for_header_only_notifications(struct diff_options *o)
    {
            struct strset present;
            struct diff_queue_struct *q = &diff_queued_diff;
            struct hashmap_iter iter;
            struct strmap_entry *e;
            int i;

            strset_init_with_options(&present, /*pool*/ NULL, /*strdup*/ 0);

            /*
            * Find out which paths exist in diff_queued_diff, preferring
            * one->path for any pair that has multiple paths.
            */
            for (i = 0; i < q->nr; i++) {
                    struct diff_filepair *p = q->queue[i];
                    char *path = p->one->path ? p->one->path : p->two->path;

                    if (strmap_contains(o->additional_path_headers, path))
                            strset_add(&present, path);
            }

            /*
            * Loop over paths in additional_path_headers; for each NOT already
            * in diff_queued_diff, create a synthetic filepair and insert that
            * into diff_queued_diff.
            */
            strmap_for_each_entry(o->additional_path_headers, &iter, e) {
                    if (!strset_contains(&present, e->key)) {
                            struct diff_filespec *one, *two;
                            struct diff_filepair *p;

                            one = alloc_filespec(e->key);
                            two = alloc_filespec(e->key);
                            fill_filespec(one, null_oid(), 0, 0);
                            fill_filespec(two, null_oid(), 0, 0);
                            p = diff_queue(q, one, two);
                            p->status = DIFF_STATUS_MODIFIED;
                    }
            }

            /* Re-sort the filepairs */
            diffcore_fix_diff_index();

            /* Cleanup */
            strset_clear(&present);
    }

    static void diff_flush_patch_all_file_pairs(struct diff_options *o)
    {
            int i;
            static struct emitted_diff_symbols esm = EMITTED_DIFF_SYMBOLS_INIT;
            struct diff_queue_struct *q = &diff_queued_diff;

            if (WSEH_NEW & WS_RULE_MASK)
                    BUG("WS rules bit mask overlaps with diff symbol flags");

            if (o->color_moved)
                    o->emitted_symbols = &esm;

            if (o->additional_path_headers)
                    create_filepairs_for_header_only_notifications(o);

            for (i = 0; i < q->nr; i++) {
                    struct diff_filepair *p = q->queue[i];
                    if (check_pair_status(p))
                            diff_flush_patch(p, o);
            }

            if (o->emitted_symbols) {
                    if (o->color_moved) {
                            struct mem_pool entry_pool;
                            struct moved_entry_list *entry_list;

                            mem_pool_init(&entry_pool, 1024 * 1024);
                            entry_list = add_lines_to_move_detection(o,
                                                                    &entry_pool);
                            mark_color_as_moved(o, entry_list);
                            if (o->color_moved == COLOR_MOVED_ZEBRA_DIM)
                                    dim_moved_lines(o);

                            mem_pool_discard(&entry_pool, 0);
                            free(entry_list);
                    }

                    for (i = 0; i < esm.nr; i++)
                            emit_diff_symbol_from_struct(o, &esm.buf[i]);

                    for (i = 0; i < esm.nr; i++)
                            free((void *)esm.buf[i].line);
                    esm.nr = 0;

                    o->emitted_symbols = NULL;
            }
    }

    static void diff_free_file(struct diff_options *options)
    {
            if (options->close_file && options->file) {
                    fclose(options->file);
                    options->file = NULL;
            }
    }

    static void diff_free_ignore_regex(struct diff_options *options)
    {
            int i;

            for (i = 0; i < options->ignore_regex_nr; i++) {
                    regfree(options->ignore_regex[i]);
                    free(options->ignore_regex[i]);
            }

            FREE_AND_NULL(options->ignore_regex);
            options->ignore_regex_nr = 0;
    }

    void diff_free(struct diff_options *options)
    {
            if (options->no_free)
                    return;

            if (options->objfind) {
                    oidset_clear(options->objfind);
                    FREE_AND_NULL(options->objfind);
            }

            FREE_AND_NULL(options->orderfile);
            for (size_t i = 0; i < options->anchors_nr; i++)
                    free(options->anchors[i]);
            FREE_AND_NULL(options->anchors);
            options->anchors_nr = options->anchors_alloc = 0;

            diff_free_file(options);
            diff_free_ignore_regex(options);
            clear_pathspec(&options->pathspec);
    }

    void diff_flush(struct diff_options *options)
    {
            struct diff_queue_struct *q = &diff_queued_diff;
            int i, output_format = options->output_format;
            int separator = 0;
            int dirstat_by_line = 0;

            /*
            * Order: raw, stat, summary, patch
            * or:    name/name-status/checkdiff (other bits clear)
            */
            if (!q->nr && !options->additional_path_headers)
                    goto free_queue;

            if (output_format & (DIFF_FORMAT_RAW |
                            DIFF_FORMAT_NAME |
                            DIFF_FORMAT_NAME_STATUS |
                            DIFF_FORMAT_CHECKDIFF)) {
                    for (i = 0; i < q->nr; i++) {
                            struct diff_filepair *p = q->queue[i];
                            if (check_pair_status(p))
                                    flush_one_pair(p, options);
                    }
                    separator++;
            }

            if (output_format & DIFF_FORMAT_DIRSTAT && options->flags.dirstat_by_line)
                    dirstat_by_line = 1;

            if (output_format & (DIFF_FORMAT_DIFFSTAT|DIFF_FORMAT_SHORTSTAT|DIFF_FORMAT_NUMSTAT) ||
            dirstat_by_line) {
                    struct diffstat_t diffstat;

                    compute_diffstat(options, &diffstat, q);
                    if (output_format & DIFF_FORMAT_NUMSTAT)
                            show_numstat(&diffstat, options);
                    if (output_format & DIFF_FORMAT_DIFFSTAT)
                            show_stats(&diffstat, options);
                    if (output_format & DIFF_FORMAT_SHORTSTAT)
                            show_shortstats(&diffstat, options);
                    if (output_format & DIFF_FORMAT_DIRSTAT && dirstat_by_line)
                            show_dirstat_by_line(&diffstat, options);
                    free_diffstat_info(&diffstat);
                    separator++;
            }
            if ((output_format & DIFF_FORMAT_DIRSTAT) && !dirstat_by_line)
                    show_dirstat(options);

            if (output_format & DIFF_FORMAT_SUMMARY && !is_summary_empty(q)) {
                    for (i = 0; i < q->nr; i++) {
                            diff_summary(options, q->queue[i]);
                    }
                    separator++;
            }

            if (output_format & DIFF_FORMAT_PATCH) {
                    if (separator) {
                            emit_diff_symbol(options, DIFF_SYMBOL_SEPARATOR, NULL, 0, 0);
                            if (options->stat_sep)
                                    /* attach patch instead of inline */
                                    emit_diff_symbol(options, DIFF_SYMBOL_STAT_SEP,
                                                    NULL, 0, 0);
                    }

                    diff_flush_patch_all_file_pairs(options);
            }

            if (output_format & DIFF_FORMAT_CALLBACK)
                    options->format_callback(q, options, options->format_callback_data);

            if (output_format & DIFF_FORMAT_NO_OUTPUT &&
            options->flags.exit_with_status &&
            options->flags.diff_from_contents) {
                    /*
                    * run diff_flush_patch for the exit status. setting
                    * options->file to /dev/null should be safe, because we
                    * aren't supposed to produce any output anyway.
                    */
                    diff_free_file(options);
                    options->file = xfopen("/dev/null", "w");
                    options->close_file = 1;
                    options->color_moved = 0;
                    for (i = 0; i < q->nr; i++) {
                            struct diff_filepair *p = q->queue[i];
                            if (check_pair_status(p))
                                    diff_flush_patch(p, options);
                            if (options->found_changes)
                                    break;
                    }
            }

    free_queue:
            diff_queue_clear(q);
            diff_free(options);

            /*
            * Report the content-level differences with HAS_CHANGES;
            * diff_addremove/diff_change does not set the bit when
            * DIFF_FROM_CONTENTS is in effect (e.g. with -w).
            */
            if (options->flags.diff_from_contents) {
                    if (options->found_changes)
                            options->flags.has_changes = 1;
                    else
                            options->flags.has_changes = 0;
            }
    }

    static int match_filter(const struct diff_options *options, const struct diff_filepair *p)
    {
            return (((p->status == DIFF_STATUS_MODIFIED) &&
                    ((p->score &&
                    filter_bit_tst(DIFF_STATUS_FILTER_BROKEN, options)) ||
                    (!p->score &&
                    filter_bit_tst(DIFF_STATUS_MODIFIED, options)))) ||
                    ((p->status != DIFF_STATUS_MODIFIED) &&
                    filter_bit_tst(p->status, options)));
    }

    static void diffcore_apply_filter(struct diff_options *options)
    {
            int i;
            struct diff_queue_struct *q = &diff_queued_diff;
            struct diff_queue_struct outq = DIFF_QUEUE_INIT;

            if (!options->filter)
                    return;

            if (filter_bit_tst(DIFF_STATUS_FILTER_AON, options)) {
                    int found;
                    for (i = found = 0; !found && i < q->nr; i++) {
                            if (match_filter(options, q->queue[i]))
                                    found++;
                    }
                    if (found)
                            return;

                    /* otherwise we will clear the whole queue
                    * by copying the empty outq at the end of this
                    * function, but first clear the current entries
                    * in the queue.
                    */
                    for (i = 0; i < q->nr; i++)
                            diff_free_filepair(q->queue[i]);
            }
            else {
                    /* Only the matching ones */
                    for (i = 0; i < q->nr; i++) {
                            struct diff_filepair *p = q->queue[i];
                            if (match_filter(options, p))
                                    diff_q(&outq, p);
                            else
                                    diff_free_filepair(p);
                    }
            }
            free(q->queue);
            *q = outq;
    }

    /* Check whether two filespecs with the same mode and size are identical */
    static int diff_filespec_is_identical(struct repository *r,
                                    struct diff_filespec *one,
                                    struct diff_filespec *two)
    {
            if (S_ISGITLINK(one->mode))
                    return 0;
            if (diff_populate_filespec(r, one, NULL))
                    return 0;
            if (diff_populate_filespec(r, two, NULL))
                    return 0;
            return !memcmp(one->data, two->data, one->size);
    }

    static int diff_filespec_check_stat_unmatch(struct repository *r,
                                            struct diff_filepair *p)
    {
            struct diff_populate_filespec_options dpf_options = {
                    .check_size_only = 1,
                    .missing_object_cb = diff_queued_diff_prefetch,
                    .missing_object_data = r,
            };

            if (p->done_skip_stat_unmatch)
                    return p->skip_stat_unmatch_result;

            p->done_skip_stat_unmatch = 1;
            p->skip_stat_unmatch_result = 0;
            /*
            * 1. Entries that come from stat info dirtiness
            *    always have both sides (iow, not create/delete),
            *    one side of the object name is unknown, with
            *    the same mode and size.  Keep the ones that
            *    do not match these criteria.  They have real
            *    differences.
            *
            * 2. At this point, the file is known to be modified,
            *    with the same mode and size, and the object
            *    name of one side is unknown.  Need to inspect
            *    the identical contents.
            */
            if (!DIFF_FILE_VALID(p->one) || /* (1) */
            !DIFF_FILE_VALID(p->two) ||
            (p->one->oid_valid && p->two->oid_valid) ||
            (p->one->mode != p->two->mode) ||
            diff_populate_filespec(r, p->one, &dpf_options) ||
            diff_populate_filespec(r, p->two, &dpf_options) ||
            (p->one->size != p->two->size) ||
            !diff_filespec_is_identical(r, p->one, p->two)) /* (2) */
                    p->skip_stat_unmatch_result = 1;
            return p->skip_stat_unmatch_result;
    }

    static void diffcore_skip_stat_unmatch(struct diff_options *diffopt)
    {
            int i;
            struct diff_queue_struct *q = &diff_queued_diff;
            struct diff_queue_struct outq = DIFF_QUEUE_INIT;

            for (i = 0; i < q->nr; i++) {
                    struct diff_filepair *p = q->queue[i];

                    if (diff_filespec_check_stat_unmatch(diffopt->repo, p))
                            diff_q(&outq, p);
                    else {
                            /*
                            * The caller can subtract 1 from skip_stat_unmatch
                            * to determine how many paths were dirty only
                            * due to stat info mismatch.
                            */
                            if (!diffopt->flags.no_index)
                                    diffopt->skip_stat_unmatch++;
                            diff_free_filepair(p);
                    }
            }
            free(q->queue);
            *q = outq;
    }

    static int diffnamecmp(const void *a_, const void *b_)
    {
            const struct diff_filepair *a = *((const struct diff_filepair **)a_);
            const struct diff_filepair *b = *((const struct diff_filepair **)b_);
            const char *name_a, *name_b;

            name_a = a->one ? a->one->path : a->two->path;
            name_b = b->one ? b->one->path : b->two->path;
            return strcmp(name_a, name_b);
    }

    void diffcore_fix_diff_index(void)
    {
            struct diff_queue_struct *q = &diff_queued_diff;
            QSORT(q->queue, q->nr, diffnamecmp);
    }

    void diff_add_if_missing(struct repository *r,
                            struct oid_array *to_fetch,
                            const struct diff_filespec *filespec)
    {
            if (filespec && filespec->oid_valid &&
            !S_ISGITLINK(filespec->mode) &&
            oid_object_info_extended(r, &filespec->oid, NULL,
                                    OBJECT_INFO_FOR_PREFETCH))
                    oid_array_append(to_fetch, &filespec->oid);
    }

    void diff_queued_diff_prefetch(void *repository)
    {
            struct repository *repo = repository;
            int i;
            struct diff_queue_struct *q = &diff_queued_diff;
            struct oid_array to_fetch = OID_ARRAY_INIT;

            for (i = 0; i < q->nr; i++) {
                    struct diff_filepair *p = q->queue[i];
                    diff_add_if_missing(repo, &to_fetch, p->one);
                    diff_add_if_missing(repo, &to_fetch, p->two);
            }

            /*
            * NEEDSWORK: Consider deduplicating the OIDs sent.
            */
            promisor_remote_get_direct(repo, to_fetch.oid, to_fetch.nr);

            oid_array_clear(&to_fetch);
    }

    void init_diffstat_widths(struct diff_options *options)
    {
            options->stat_width = -1;        /* use full terminal width */
            options->stat_name_width = -1;   /* respect diff.statNameWidth config */
            options->stat_graph_width = -1;  /* respect diff.statGraphWidth config */
    }

    void diffcore_std(struct diff_options *options)
    {
            int output_formats_to_prefetch = DIFF_FORMAT_DIFFSTAT |
                    DIFF_FORMAT_NUMSTAT |
                    DIFF_FORMAT_PATCH |
                    DIFF_FORMAT_SHORTSTAT |
                    DIFF_FORMAT_DIRSTAT;

            /*
            * Check if the user requested a blob-data-requiring diff output and/or
            * break-rewrite detection (which requires blob data). If yes, prefetch
            * the diff pairs.
            *
            * If no prefetching occurs, diffcore_rename() will prefetch if it
            * decides that it needs inexact rename detection.
            */
            if (options->repo == the_repository && repo_has_promisor_remote(the_repository) &&
            (options->output_format & output_formats_to_prefetch ||
            options->pickaxe_opts & DIFF_PICKAXE_KINDS_MASK))
                    diff_queued_diff_prefetch(options->repo);

            /* NOTE please keep the following in sync with diff_tree_combined() */
            if (options->skip_stat_unmatch)
                    diffcore_skip_stat_unmatch(options);
            if (!options->found_follow) {
                    /* See try_to_follow_renames() in tree-diff.c */
                    if (options->break_opt != -1)
                            diffcore_break(options->repo,
                                    options->break_opt);
                    if (options->detect_rename)
                            diffcore_rename(options);
                    if (options->break_opt != -1)
                            diffcore_merge_broken();
            }
            if (options->pickaxe_opts & DIFF_PICKAXE_KINDS_MASK)
                    diffcore_pickaxe(options);
            if (options->orderfile)
                    diffcore_order(options->orderfile);
            if (options->rotate_to)
                    diffcore_rotate(options);
            if (!options->found_follow)
                    /* See try_to_follow_renames() in tree-diff.c */
                    diff_resolve_rename_copy();
            diffcore_apply_filter(options);

            if (diff_queued_diff.nr && !options->flags.diff_from_contents)
                    options->flags.has_changes = 1;
            else
                    options->flags.has_changes = 0;

            options->found_follow = 0;
    }

    int diff_result_code(struct rev_info *revs)
    {
            struct diff_options *opt = &revs->diffopt;
            int result = 0;

            if (revs->remerge_diff) {
                    tmp_objdir_destroy(revs->remerge_objdir);
                    revs->remerge_objdir = NULL;
            }

            diff_warn_rename_limit("diff.renameLimit",
                            opt->needed_rename_limit,
                            opt->degraded_cc_to_c);

            if (opt->flags.exit_with_status &&
            opt->flags.has_changes)
                    result |= 01;
            if ((opt->output_format & DIFF_FORMAT_CHECKDIFF) &&
            opt->flags.check_failed)
                    result |= 02;
            return result;
    }

    int diff_can_quit_early(struct diff_options *opt)
    {
            return (opt->flags.quick &&
                    !opt->filter &&
                    opt->flags.has_changes);
    }

    /*
    * Shall changes to this submodule be ignored?
    *
    * Submodule changes can be configured to be ignored separately for each path,
    * but that configuration can be overridden from the command line.
    */
    static int is_submodule_ignored(const char *path, struct diff_options *options)
    {
            int ignored = 0;
            struct diff_flags orig_flags = options->flags;
            if (!options->flags.override_submodule_config)
                    set_diffopt_flags_from_submodule_config(options, path);
            if (options->flags.ignore_submodules)
                    ignored = 1;
            options->flags = orig_flags;
            return ignored;
    }

    void compute_diffstat(struct diff_options *options,
                    struct diffstat_t *diffstat,
                    struct diff_queue_struct *q)
    {
            int i;

            memset(diffstat, 0, sizeof(struct diffstat_t));
            for (i = 0; i < q->nr; i++) {
                    struct diff_filepair *p = q->queue[i];
                    if (check_pair_status(p))
                            diff_flush_stat(p, options, diffstat);
            }
            options->found_changes = !!diffstat->nr;
    }

    void diff_addremove(struct diff_options *options,
                    int addremove, unsigned mode,
                    const struct object_id *oid,
                    int oid_valid,
                    const char *concatpath, unsigned dirty_submodule)
    {
            struct diff_filespec *one, *two;

            if (S_ISGITLINK(mode) && is_submodule_ignored(concatpath, options))
                    return;

            /* This may look odd, but it is a preparation for
            * feeding "there are unchanged files which should
            * not produce diffs, but when you are doing copy
            * detection you would need them, so here they are"
            * entries to the diff-core.  They will be prefixed
            * with something like '=' or '*' (I haven't decided
            * which but should not make any difference).
            * Feeding the same new and old to diff_change()
            * also has the same effect.
            * Before the final output happens, they are pruned after
            * merged into rename/copy pairs as appropriate.
            */
            if (options->flags.reverse_diff)
                    addremove = (addremove == '+' ? '-' :
                            addremove == '-' ? '+' : addremove);

            if (options->prefix &&
            strncmp(concatpath, options->prefix, options->prefix_length))
                    return;

            one = alloc_filespec(concatpath);
            two = alloc_filespec(concatpath);

            if (addremove != '+')
                    fill_filespec(one, oid, oid_valid, mode);
            if (addremove != '-') {
                    fill_filespec(two, oid, oid_valid, mode);
                    two->dirty_submodule = dirty_submodule;
            }

            diff_queue(&diff_queued_diff, one, two);
            if (!options->flags.diff_from_contents)
                    options->flags.has_changes = 1;
    }

    void diff_change(struct diff_options *options,
                    unsigned old_mode, unsigned new_mode,
                    const struct object_id *old_oid,
                    const struct object_id *new_oid,
                    int old_oid_valid, int new_oid_valid,
                    const char *concatpath,
                    unsigned old_dirty_submodule, unsigned new_dirty_submodule)
    {
            struct diff_filespec *one, *two;
            struct diff_filepair *p;

            if (S_ISGITLINK(old_mode) && S_ISGITLINK(new_mode) &&
            is_submodule_ignored(concatpath, options))
                    return;

            if (options->flags.reverse_diff) {
                    SWAP(old_mode, new_mode);
                    SWAP(old_oid, new_oid);
                    SWAP(old_oid_valid, new_oid_valid);
                    SWAP(old_dirty_submodule, new_dirty_submodule);
            }

            if (options->prefix &&
            strncmp(concatpath, options->prefix, options->prefix_length))
                    return;

            one = alloc_filespec(concatpath);
            two = alloc_filespec(concatpath);
            fill_filespec(one, old_oid, old_oid_valid, old_mode);
            fill_filespec(two, new_oid, new_oid_valid, new_mode);
            one->dirty_submodule = old_dirty_submodule;
            two->dirty_submodule = new_dirty_submodule;
            p = diff_queue(&diff_queued_diff, one, two);

            if (options->flags.diff_from_contents)
                    return;

            if (options->flags.quick && options->skip_stat_unmatch &&
            !diff_filespec_check_stat_unmatch(options->repo, p)) {
                    diff_free_filespec_data(p->one);
                    diff_free_filespec_data(p->two);
                    return;
            }

            options->flags.has_changes = 1;
    }

    struct diff_filepair *diff_unmerge(struct diff_options *options, const char *path)
    {
            struct diff_filepair *pair;
            struct diff_filespec *one, *two;

            if (options->prefix &&
            strncmp(path, options->prefix, options->prefix_length))
                    return NULL;

            one = alloc_filespec(path);
            two = alloc_filespec(path);
            pair = diff_queue(&diff_queued_diff, one, two);
            pair->is_unmerged = 1;
            return pair;
    }

    static char *run_textconv(struct repository *r,
                            const char *pgm,
                            struct diff_filespec *spec,
                            size_t *outsize)
    {
            struct diff_tempfile *temp;
            struct child_process child = CHILD_PROCESS_INIT;
            struct strbuf buf = STRBUF_INIT;
            int err = 0;

            temp = prepare_temp_file(r, spec);
            strvec_push(&child.args, pgm);
            strvec_push(&child.args, temp->name);

            child.use_shell = 1;
            child.out = -1;
            if (start_command(&child)) {
                    remove_tempfile();
                    return NULL;
            }

            if (strbuf_read(&buf, child.out, 0) < 0)
                    err = error("error reading from textconv command '%s'", pgm);
            close(child.out);

            if (finish_command(&child) || err) {
                    strbuf_release(&buf);
                    remove_tempfile();
                    return NULL;
            }
            remove_tempfile();

            return strbuf_detach(&buf, outsize);
    }

    size_t fill_textconv(struct repository *r,
                    struct userdiff_driver *driver,
                    struct diff_filespec *df,
                    char **outbuf)
    {
            size_t size;

            if (!driver) {
                    if (!DIFF_FILE_VALID(df)) {
                            *outbuf = (char *) "";
                            return 0;
                    }
                    if (diff_populate_filespec(r, df, NULL))
                            die("unable to read files to diff");
                    *outbuf = df->data;
                    return df->size;
            }

            if (!driver->textconv)
                    BUG("fill_textconv called with non-textconv driver");

            if (driver->textconv_cache && df->oid_valid) {
                    *outbuf = notes_cache_get(driver->textconv_cache,
                                            &df->oid,
                                            &size);
                    if (*outbuf)
                            return size;
            }

            *outbuf = run_textconv(r, driver->textconv, df, &size);
            if (!*outbuf)
                    die("unable to read files to diff");

            if (driver->textconv_cache && df->oid_valid) {
                    /* ignore errors, as we might be in a readonly repository */
                    notes_cache_put(driver->textconv_cache, &df->oid, *outbuf,
                                    size);
                    /*
                    * we could save up changes and flush them all at the end,
                    * but we would need an extra call after all diffing is done.
                    * Since generating a cache entry is the slow path anyway,
                    * this extra overhead probably isn't a big deal.
                    */
                    notes_cache_write(driver->textconv_cache);
            }

            return size;
    }

    int textconv_object(struct repository *r,
                    const char *path,
                    unsigned mode,
                    const struct object_id *oid,
                    int oid_valid,
                    char **buf,
                    unsigned long *buf_size)
    {
            struct diff_filespec *df;
            struct userdiff_driver *textconv;

            df = alloc_filespec(path);
            fill_filespec(df, oid, oid_valid, mode);
            textconv = get_textconv(r, df);
            if (!textconv) {
                    free_filespec(df);
                    return 0;
            }

            *buf_size = fill_textconv(r, textconv, df, buf);
            free_filespec(df);
            return 1;
    }

    void setup_diff_pager(struct diff_options *opt)
    {
            /*
            * If the user asked for our exit code, then either they want --quiet
            * or --exit-code. We should definitely not bother with a pager in the
            * former case, as we will generate no output. Since we still properly
            * report our exit code even when a pager is run, we _could_ run a
            * pager with --exit-code. But since we have not done so historically,
            * and because it is easy to find people oneline advising "git diff
            * --exit-code" in hooks and other scripts, we do not do so.
            */
            if (!opt->flags.exit_with_status &&
            check_pager_config("diff") != 0)
                    setup_pager();
    }


            """,

            "Error":"he patch ensures that files on z/OS are handled correctly, with appropriate checks and handling for encoding (EBCDIC to ASCII).
                     It prevents unwanted conversions and ensures that Git operations like diffing and temporary file handling work properly.",
             "Error category":"functionality Patches",

             "Corrected Code":

             """
                            /*
            * Copyright (C) 2005 Junio C Hamano
            */

            #define USE_THE_REPOSITORY_VARIABLE
            #define DISABLE_SIGN_COMPARE_WARNINGS

            #include "git-compat-util.h"
            #include "abspath.h"
            #include "base85.h"
            #include "config.h"
            #include "convert.h"
            #include "environment.h"
            #include "gettext.h"
            #include "tempfile.h"
            #include "revision.h"
            #include "quote.h"
            #include "diff.h"
            #include "diffcore.h"
            #include "delta.h"
            #include "hex.h"
            #include "xdiff-interface.h"
            #include "color.h"
            #include "run-command.h"
            #include "utf8.h"
            #include "object-store-ll.h"
            #include "userdiff.h"
            #include "submodule.h"
            #include "hashmap.h"
            #include "mem-pool.h"
            #include "merge-ll.h"
            #include "string-list.h"
            #include "strvec.h"
            #include "tmp-objdir.h"
            #include "graph.h"
            #include "oid-array.h"
            #include "packfile.h"
            #include "pager.h"
            #include "parse-options.h"
            #include "help.h"
            #include "promisor-remote.h"
            #include "dir.h"
            #include "object-file.h"
            #include "object-name.h"
            #include "read-cache-ll.h"
            #include "setup.h"
            #include "strmap.h"
            #include "ws.h"

            #ifdef NO_FAST_WORKING_DIRECTORY
            #define FAST_WORKING_DIRECTORY 0
            #else
            #define FAST_WORKING_DIRECTORY 1
            #endif

            static int diff_detect_rename_default;
            static int diff_indent_heuristic = 1;
            static int diff_rename_limit_default = 1000;
            static int diff_suppress_blank_empty;
            static int diff_use_color_default = -1;
            static int diff_color_moved_default;
            static int diff_color_moved_ws_default;
            static int diff_context_default = 3;
            static int diff_interhunk_context_default;
            static char *diff_word_regex_cfg;
            static struct external_diff external_diff_cfg;
            static char *diff_order_file_cfg;
            int diff_auto_refresh_index = 1;
            static int diff_mnemonic_prefix;
            static int diff_no_prefix;
            static char *diff_src_prefix;
            static char *diff_dst_prefix;
            static int diff_relative;
            static int diff_stat_name_width;
            static int diff_stat_graph_width;
            static int diff_dirstat_permille_default = 30;
            static struct diff_options default_diff_options;
            static long diff_algorithm;
            static unsigned ws_error_highlight_default = WSEH_NEW;

            static char diff_colors[][COLOR_MAXLEN] = {
                    GIT_COLOR_RESET,
                    GIT_COLOR_NORMAL,       /* CONTEXT */
                    GIT_COLOR_BOLD,         /* METAINFO */
                    GIT_COLOR_CYAN,         /* FRAGINFO */
                    GIT_COLOR_RED,          /* OLD */
                    GIT_COLOR_GREEN,        /* NEW */
                    GIT_COLOR_YELLOW,       /* COMMIT */
                    GIT_COLOR_BG_RED,       /* WHITESPACE */
                    GIT_COLOR_NORMAL,       /* FUNCINFO */
                    GIT_COLOR_BOLD_MAGENTA, /* OLD_MOVED */
                    GIT_COLOR_BOLD_BLUE,    /* OLD_MOVED ALTERNATIVE */
                    GIT_COLOR_FAINT,        /* OLD_MOVED_DIM */
                    GIT_COLOR_FAINT_ITALIC, /* OLD_MOVED_ALTERNATIVE_DIM */
                    GIT_COLOR_BOLD_CYAN,    /* NEW_MOVED */
                    GIT_COLOR_BOLD_YELLOW,  /* NEW_MOVED ALTERNATIVE */
                    GIT_COLOR_FAINT,        /* NEW_MOVED_DIM */
                    GIT_COLOR_FAINT_ITALIC, /* NEW_MOVED_ALTERNATIVE_DIM */
                    GIT_COLOR_FAINT,        /* CONTEXT_DIM */
                    GIT_COLOR_FAINT_RED,    /* OLD_DIM */
                    GIT_COLOR_FAINT_GREEN,  /* NEW_DIM */
                    GIT_COLOR_BOLD,         /* CONTEXT_BOLD */
                    GIT_COLOR_BOLD_RED,     /* OLD_BOLD */
                    GIT_COLOR_BOLD_GREEN,   /* NEW_BOLD */
            };

            static const char *color_diff_slots[] = {
                    [DIFF_CONTEXT]                = "context",
                    [DIFF_METAINFO]               = "meta",
                    [DIFF_FRAGINFO]               = "frag",
                    [DIFF_FILE_OLD]               = "old",
                    [DIFF_FILE_NEW]               = "new",
                    [DIFF_COMMIT]                 = "commit",
                    [DIFF_WHITESPACE]             = "whitespace",
                    [DIFF_FUNCINFO]               = "func",
                    [DIFF_FILE_OLD_MOVED]         = "oldMoved",
                    [DIFF_FILE_OLD_MOVED_ALT]     = "oldMovedAlternative",
                    [DIFF_FILE_OLD_MOVED_DIM]     = "oldMovedDimmed",
                    [DIFF_FILE_OLD_MOVED_ALT_DIM] = "oldMovedAlternativeDimmed",
                    [DIFF_FILE_NEW_MOVED]         = "newMoved",
                    [DIFF_FILE_NEW_MOVED_ALT]     = "newMovedAlternative",
                    [DIFF_FILE_NEW_MOVED_DIM]     = "newMovedDimmed",
                    [DIFF_FILE_NEW_MOVED_ALT_DIM] = "newMovedAlternativeDimmed",
                    [DIFF_CONTEXT_DIM]            = "contextDimmed",
                    [DIFF_FILE_OLD_DIM]           = "oldDimmed",
                    [DIFF_FILE_NEW_DIM]           = "newDimmed",
                    [DIFF_CONTEXT_BOLD]           = "contextBold",
                    [DIFF_FILE_OLD_BOLD]          = "oldBold",
                    [DIFF_FILE_NEW_BOLD]          = "newBold",
            };

            define_list_config_array_extra(color_diff_slots, {"plain"});

            static int parse_diff_color_slot(const char *var)
            {
                    if (!strcasecmp(var, "plain"))
                            return DIFF_CONTEXT;
                    return LOOKUP_CONFIG(color_diff_slots, var);
            }

            static int parse_dirstat_params(struct diff_options *options, const char *params_string,
                                            struct strbuf *errmsg)
            {
                    char *params_copy = xstrdup(params_string);
                    struct string_list params = STRING_LIST_INIT_NODUP;
                    int ret = 0;
                    int i;

                    if (*params_copy)
                            string_list_split_in_place(&params, params_copy, ",", -1);
                    for (i = 0; i < params.nr; i++) {
                            const char *p = params.items[i].string;
                            if (!strcmp(p, "changes")) {
                                    options->flags.dirstat_by_line = 0;
                                    options->flags.dirstat_by_file = 0;
                            } else if (!strcmp(p, "lines")) {
                                    options->flags.dirstat_by_line = 1;
                                    options->flags.dirstat_by_file = 0;
                            } else if (!strcmp(p, "files")) {
                                    options->flags.dirstat_by_line = 0;
                                    options->flags.dirstat_by_file = 1;
                            } else if (!strcmp(p, "noncumulative")) {
                                    options->flags.dirstat_cumulative = 0;
                            } else if (!strcmp(p, "cumulative")) {
                                    options->flags.dirstat_cumulative = 1;
                            } else if (isdigit(*p)) {
                                    char *end;
                                    int permille = strtoul(p, &end, 10) * 10;
                                    if (*end == '.' && isdigit(*++end)) {
                                            /* only use first digit */
                                            permille += *end - '0';
                                            /* .. and ignore any further digits */
                                            while (isdigit(*++end))
                                                    ; /* nothing */
                                    }
                                    if (!*end)
                                            options->dirstat_permille = permille;
                                    else {
                                            strbuf_addf(errmsg, _("  Failed to parse dirstat cut-off percentage '%s'\n"),
                                                    p);
                                            ret++;
                                    }
                            } else {
                                    strbuf_addf(errmsg, _("  Unknown dirstat parameter '%s'\n"), p);
                                    ret++;
                            }

                    }
                    string_list_clear(&params, 0);
                    free(params_copy);
                    return ret;
            }

            static int parse_submodule_params(struct diff_options *options, const char *value)
            {
                    if (!strcmp(value, "log"))
                            options->submodule_format = DIFF_SUBMODULE_LOG;
                    else if (!strcmp(value, "short"))
                            options->submodule_format = DIFF_SUBMODULE_SHORT;
                    else if (!strcmp(value, "diff"))
                            options->submodule_format = DIFF_SUBMODULE_INLINE_DIFF;
                    /*
                    * Please update $__git_diff_submodule_formats in
                    * git-completion.bash when you add new formats.
                    */
                    else
                            return -1;
                    return 0;
            }

            int git_config_rename(const char *var, const char *value)
            {
                    if (!value)
                            return DIFF_DETECT_RENAME;
                    if (!strcasecmp(value, "copies") || !strcasecmp(value, "copy"))
                            return  DIFF_DETECT_COPY;
                    return git_config_bool(var,value) ? DIFF_DETECT_RENAME : 0;
            }

            long parse_algorithm_value(const char *value)
            {
                    if (!value)
                            return -1;
                    else if (!strcasecmp(value, "myers") || !strcasecmp(value, "default"))
                            return 0;
                    else if (!strcasecmp(value, "minimal"))
                            return XDF_NEED_MINIMAL;
                    else if (!strcasecmp(value, "patience"))
                            return XDF_PATIENCE_DIFF;
                    else if (!strcasecmp(value, "histogram"))
                            return XDF_HISTOGRAM_DIFF;
                    /*
                    * Please update $__git_diff_algorithms in git-completion.bash
                    * when you add new algorithms.
                    */
                    return -1;
            }

            static int parse_one_token(const char **arg, const char *token)
            {
                    const char *rest;
                    if (skip_prefix(*arg, token, &rest) && (!*rest || *rest == ',')) {
                            *arg = rest;
                            return 1;
                    }
                    return 0;
            }

            static int parse_ws_error_highlight(const char *arg)
            {
                    const char *orig_arg = arg;
                    unsigned val = 0;

                    while (*arg) {
                            if (parse_one_token(&arg, "none"))
                                    val = 0;
                            else if (parse_one_token(&arg, "default"))
                                    val = WSEH_NEW;
                            else if (parse_one_token(&arg, "all"))
                                    val = WSEH_NEW | WSEH_OLD | WSEH_CONTEXT;
                            else if (parse_one_token(&arg, "new"))
                                    val |= WSEH_NEW;
                            else if (parse_one_token(&arg, "old"))
                                    val |= WSEH_OLD;
                            else if (parse_one_token(&arg, "context"))
                                    val |= WSEH_CONTEXT;
                            else {
                                    return -1 - (int)(arg - orig_arg);
                            }
                            if (*arg)
                                    arg++;
                    }
                    return val;
            }

            /*
            * These are to give UI layer defaults.
            * The core-level commands such as git-diff-files should
            * never be affected by the setting of diff.renames
            * the user happens to have in the configuration file.
            */
            void init_diff_ui_defaults(void)
            {
                    diff_detect_rename_default = DIFF_DETECT_RENAME;
            }

            int git_diff_heuristic_config(const char *var, const char *value,
                                    void *cb UNUSED)
            {
                    if (!strcmp(var, "diff.indentheuristic"))
                            diff_indent_heuristic = git_config_bool(var, value);
                    return 0;
            }

            static int parse_color_moved(const char *arg)
            {
                    switch (git_parse_maybe_bool(arg)) {
                    case 0:
                            return COLOR_MOVED_NO;
                    case 1:
                            return COLOR_MOVED_DEFAULT;
                    default:
                            break;
                    }

                    if (!strcmp(arg, "no"))
                            return COLOR_MOVED_NO;
                    else if (!strcmp(arg, "plain"))
                            return COLOR_MOVED_PLAIN;
                    else if (!strcmp(arg, "blocks"))
                            return COLOR_MOVED_BLOCKS;
                    else if (!strcmp(arg, "zebra"))
                            return COLOR_MOVED_ZEBRA;
                    else if (!strcmp(arg, "default"))
                            return COLOR_MOVED_DEFAULT;
                    else if (!strcmp(arg, "dimmed-zebra"))
                            return COLOR_MOVED_ZEBRA_DIM;
                    else if (!strcmp(arg, "dimmed_zebra"))
                            return COLOR_MOVED_ZEBRA_DIM;
                    else
                            return error(_("color moved setting must be one of 'no', 'default', 'blocks', 'zebra', 'dimmed-zebra', 'plain'"));
            }

            static unsigned parse_color_moved_ws(const char *arg)
            {
                    int ret = 0;
                    struct string_list l = STRING_LIST_INIT_DUP;
                    struct string_list_item *i;

                    string_list_split(&l, arg, ',', -1);

                    for_each_string_list_item(i, &l) {
                            struct strbuf sb = STRBUF_INIT;
                            strbuf_addstr(&sb, i->string);
                            strbuf_trim(&sb);

                            if (!strcmp(sb.buf, "no"))
                                    ret = 0;
                            else if (!strcmp(sb.buf, "ignore-space-change"))
                                    ret |= XDF_IGNORE_WHITESPACE_CHANGE;
                            else if (!strcmp(sb.buf, "ignore-space-at-eol"))
                                    ret |= XDF_IGNORE_WHITESPACE_AT_EOL;
                            else if (!strcmp(sb.buf, "ignore-all-space"))
                                    ret |= XDF_IGNORE_WHITESPACE;
                            else if (!strcmp(sb.buf, "allow-indentation-change"))
                                    ret |= COLOR_MOVED_WS_ALLOW_INDENTATION_CHANGE;
                            else {
                                    ret |= COLOR_MOVED_WS_ERROR;
                                    error(_("unknown color-moved-ws mode '%s', possible values are 'ignore-space-change', 'ignore-space-at-eol', 'ignore-all-space', 'allow-indentation-change'"), sb.buf);
                            }

                            strbuf_release(&sb);
                    }

                    if ((ret & COLOR_MOVED_WS_ALLOW_INDENTATION_CHANGE) &&
                    (ret & XDF_WHITESPACE_FLAGS)) {
                            error(_("color-moved-ws: allow-indentation-change cannot be combined with other whitespace modes"));
                            ret |= COLOR_MOVED_WS_ERROR;
                    }

                    string_list_clear(&l, 0);

                    return ret;
            }

            int git_diff_ui_config(const char *var, const char *value,
                            const struct config_context *ctx, void *cb)
            {
                    if (!strcmp(var, "diff.color") || !strcmp(var, "color.diff")) {
                            diff_use_color_default = git_config_colorbool(var, value);
                            return 0;
                    }
                    if (!strcmp(var, "diff.colormoved")) {
                            int cm = parse_color_moved(value);
                            if (cm < 0)
                                    return -1;
                            diff_color_moved_default = cm;
                            return 0;
                    }
                    if (!strcmp(var, "diff.colormovedws")) {
                            unsigned cm;
                            if (!value)
                                    return config_error_nonbool(var);
                            cm = parse_color_moved_ws(value);
                            if (cm & COLOR_MOVED_WS_ERROR)
                                    return -1;
                            diff_color_moved_ws_default = cm;
                            return 0;
                    }
                    if (!strcmp(var, "diff.context")) {
                            diff_context_default = git_config_int(var, value, ctx->kvi);
                            if (diff_context_default < 0)
                                    return -1;
                            return 0;
                    }
                    if (!strcmp(var, "diff.interhunkcontext")) {
                            diff_interhunk_context_default = git_config_int(var, value,
                                                                            ctx->kvi);
                            if (diff_interhunk_context_default < 0)
                                    return -1;
                            return 0;
                    }
                    if (!strcmp(var, "diff.renames")) {
                            diff_detect_rename_default = git_config_rename(var, value);
                            return 0;
                    }
                    if (!strcmp(var, "diff.autorefreshindex")) {
                            diff_auto_refresh_index = git_config_bool(var, value);
                            return 0;
                    }
                    if (!strcmp(var, "diff.mnemonicprefix")) {
                            diff_mnemonic_prefix = git_config_bool(var, value);
                            return 0;
                    }
                    if (!strcmp(var, "diff.noprefix")) {
                            diff_no_prefix = git_config_bool(var, value);
                            return 0;
                    }
                    if (!strcmp(var, "diff.srcprefix")) {
                            FREE_AND_NULL(diff_src_prefix);
                            return git_config_string(&diff_src_prefix, var, value);
                    }
                    if (!strcmp(var, "diff.dstprefix")) {
                            FREE_AND_NULL(diff_dst_prefix);
                            return git_config_string(&diff_dst_prefix, var, value);
                    }
                    if (!strcmp(var, "diff.relative")) {
                            diff_relative = git_config_bool(var, value);
                            return 0;
                    }
                    if (!strcmp(var, "diff.statnamewidth")) {
                            diff_stat_name_width = git_config_int(var, value, ctx->kvi);
                            return 0;
                    }
                    if (!strcmp(var, "diff.statgraphwidth")) {
                            diff_stat_graph_width = git_config_int(var, value, ctx->kvi);
                            return 0;
                    }
                    if (!strcmp(var, "diff.external"))
                            return git_config_string(&external_diff_cfg.cmd, var, value);
                    if (!strcmp(var, "diff.trustexitcode")) {
                            external_diff_cfg.trust_exit_code = git_config_bool(var, value);
                            return 0;
                    }
                    if (!strcmp(var, "diff.wordregex"))
                            return git_config_string(&diff_word_regex_cfg, var, value);
                    if (!strcmp(var, "diff.orderfile")) {
                            FREE_AND_NULL(diff_order_file_cfg);
                            return git_config_pathname(&diff_order_file_cfg, var, value);
                    }

                    if (!strcmp(var, "diff.ignoresubmodules")) {
                            if (!value)
                                    return config_error_nonbool(var);
                            handle_ignore_submodules_arg(&default_diff_options, value);
                    }

                    if (!strcmp(var, "diff.submodule")) {
                            if (!value)
                                    return config_error_nonbool(var);
                            if (parse_submodule_params(&default_diff_options, value))
                                    warning(_("Unknown value for 'diff.submodule' config variable: '%s'"),
                                            value);
                            return 0;
                    }

                    if (!strcmp(var, "diff.algorithm")) {
                            if (!value)
                                    return config_error_nonbool(var);
                            diff_algorithm = parse_algorithm_value(value);
                            if (diff_algorithm < 0)
                                    return error(_("unknown value for config '%s': %s"),
                                            var, value);
                            return 0;
                    }

                    if (git_color_config(var, value, cb) < 0)
                            return -1;

                    return git_diff_basic_config(var, value, ctx, cb);
            }

            int git_diff_basic_config(const char *var, const char *value,
                                    const struct config_context *ctx, void *cb)
            {
                    const char *name;

                    if (!strcmp(var, "diff.renamelimit")) {
                            diff_rename_limit_default = git_config_int(var, value, ctx->kvi);
                            return 0;
                    }

                    if (userdiff_config(var, value) < 0)
                            return -1;

                    if (skip_prefix(var, "diff.color.", &name) ||
                    skip_prefix(var, "color.diff.", &name)) {
                            int slot = parse_diff_color_slot(name);
                            if (slot < 0)
                                    return 0;
                            if (!value)
                                    return config_error_nonbool(var);
                            return color_parse(value, diff_colors[slot]);
                    }

                    if (!strcmp(var, "diff.wserrorhighlight")) {
                            int val;
                            if (!value)
                                    return config_error_nonbool(var);
                            val = parse_ws_error_highlight(value);
                            if (val < 0)
                                    return error(_("unknown value for config '%s': %s"),
                                            var, value);
                            ws_error_highlight_default = val;
                            return 0;
                    }

                    /* like GNU diff's --suppress-blank-empty option  */
                    if (!strcmp(var, "diff.suppressblankempty") ||
                                    /* for backwards compatibility */
                                    !strcmp(var, "diff.suppress-blank-empty")) {
                            diff_suppress_blank_empty = git_config_bool(var, value);
                            return 0;
                    }

                    if (!strcmp(var, "diff.dirstat")) {
                            struct strbuf errmsg = STRBUF_INIT;
                            if (!value)
                                    return config_error_nonbool(var);
                            default_diff_options.dirstat_permille = diff_dirstat_permille_default;
                            if (parse_dirstat_params(&default_diff_options, value, &errmsg))
                                    warning(_("Found errors in 'diff.dirstat' config variable:\n%s"),
                                            errmsg.buf);
                            strbuf_release(&errmsg);
                            diff_dirstat_permille_default = default_diff_options.dirstat_permille;
                            return 0;
                    }

                    if (git_diff_heuristic_config(var, value, cb) < 0)
                            return -1;

                    return git_default_config(var, value, ctx, cb);
            }

            static char *quote_two(const char *one, const char *two)
            {
                    int need_one = quote_c_style(one, NULL, NULL, CQUOTE_NODQ);
                    int need_two = quote_c_style(two, NULL, NULL, CQUOTE_NODQ);
                    struct strbuf res = STRBUF_INIT;

                    if (need_one + need_two) {
                            strbuf_addch(&res, '"');
                            quote_c_style(one, &res, NULL, CQUOTE_NODQ);
                            quote_c_style(two, &res, NULL, CQUOTE_NODQ);
                            strbuf_addch(&res, '"');
                    } else {
                            strbuf_addstr(&res, one);
                            strbuf_addstr(&res, two);
                    }
                    return strbuf_detach(&res, NULL);
            }

            static const struct external_diff *external_diff(void)
            {
                    static struct external_diff external_diff_env, *external_diff_ptr;
                    static int done_preparing = 0;

                    if (done_preparing)
                            return external_diff_ptr;
                    external_diff_env.cmd = xstrdup_or_null(getenv("GIT_EXTERNAL_DIFF"));
                    if (git_env_bool("GIT_EXTERNAL_DIFF_TRUST_EXIT_CODE", 0))
                            external_diff_env.trust_exit_code = 1;
                    if (external_diff_env.cmd)
                            external_diff_ptr = &external_diff_env;
                    else if (external_diff_cfg.cmd)
                            external_diff_ptr = &external_diff_cfg;
                    done_preparing = 1;
                    return external_diff_ptr;
            }

            /*
            * Keep track of files used for diffing. Sometimes such an entry
            * refers to a temporary file, sometimes to an existing file, and
            * sometimes to "/dev/null".
            */
            static struct diff_tempfile {
                    /*
                    * filename external diff should read from, or NULL if this
                    * entry is currently not in use:
                    */
                    const char *name;

                    char hex[GIT_MAX_HEXSZ + 1];
                    char mode[10];

                    /*
                    * If this diff_tempfile instance refers to a temporary file,
                    * this tempfile object is used to manage its lifetime.
                    */
                    struct tempfile *tempfile;
            } diff_temp[2];

            struct emit_callback {
                    int color_diff;
                    unsigned ws_rule;
                    int blank_at_eof_in_preimage;
                    int blank_at_eof_in_postimage;
                    int lno_in_preimage;
                    int lno_in_postimage;
                    const char **label_path;
                    struct diff_words_data *diff_words;
                    struct diff_options *opt;
                    struct strbuf *header;
            };

            static int count_lines(const char *data, int size)
            {
                    int count, ch, completely_empty = 1, nl_just_seen = 0;
                    count = 0;
                    while (0 < size--) {
                            ch = *data++;
                            if (ch == '\n') {
                                    count++;
                                    nl_just_seen = 1;
                                    completely_empty = 0;
                            }
                            else {
                                    nl_just_seen = 0;
                                    completely_empty = 0;
                            }
                    }
                    if (completely_empty)
                            return 0;
                    if (!nl_just_seen)
                            count++; /* no trailing newline */
                    return count;
            }

            static int fill_mmfile(struct repository *r, mmfile_t *mf,
                            struct diff_filespec *one)
            {
                    if (!DIFF_FILE_VALID(one)) {
                            mf->ptr = (char *)""; /* does not matter */
                            mf->size = 0;
                            return 0;
                    }
                    else if (diff_populate_filespec(r, one, NULL))
                            return -1;

                    mf->ptr = one->data;
                    mf->size = one->size;
                    return 0;
            }

            /* like fill_mmfile, but only for size, so we can avoid retrieving blob */
            static unsigned long diff_filespec_size(struct repository *r,
                                                    struct diff_filespec *one)
            {
                    struct diff_populate_filespec_options dpf_options = {
                            .check_size_only = 1,
                    };

                    if (!DIFF_FILE_VALID(one))
                            return 0;
                    diff_populate_filespec(r, one, &dpf_options);
                    return one->size;
            }

            static int count_trailing_blank(mmfile_t *mf)
            {
                    char *ptr = mf->ptr;
                    long size = mf->size;
                    int cnt = 0;

                    if (!size)
                            return cnt;
                    ptr += size - 1; /* pointing at the very end */
                    if (*ptr != '\n')
                            ; /* incomplete line */
                    else
                            ptr--; /* skip the last LF */
                    while (mf->ptr < ptr) {
                            char *prev_eol;
                            for (prev_eol = ptr; mf->ptr <= prev_eol; prev_eol--)
                                    if (*prev_eol == '\n')
                                            break;
                            if (!ws_blank_line(prev_eol + 1, ptr - prev_eol))
                                    break;
                            cnt++;
                            ptr = prev_eol - 1;
                    }
                    return cnt;
            }

            static void check_blank_at_eof(mmfile_t *mf1, mmfile_t *mf2,
                                    struct emit_callback *ecbdata)
            {
                    int l1, l2, at;
                    l1 = count_trailing_blank(mf1);
                    l2 = count_trailing_blank(mf2);
                    if (l2 <= l1) {
                            ecbdata->blank_at_eof_in_preimage = 0;
                            ecbdata->blank_at_eof_in_postimage = 0;
                            return;
                    }
                    at = count_lines(mf1->ptr, mf1->size);
                    ecbdata->blank_at_eof_in_preimage = (at - l1) + 1;

                    at = count_lines(mf2->ptr, mf2->size);
                    ecbdata->blank_at_eof_in_postimage = (at - l2) + 1;
            }

            static void emit_line_0(struct diff_options *o,
                                    const char *set_sign, const char *set, unsigned reverse, const char *reset,
                                    int first, const char *line, int len)
            {
                    int has_trailing_newline, has_trailing_carriage_return;
                    int needs_reset = 0; /* at the end of the line */
                    FILE *file = o->file;

                    fputs(diff_line_prefix(o), file);

                    has_trailing_newline = (len > 0 && line[len-1] == '\n');
                    if (has_trailing_newline)
                            len--;

                    has_trailing_carriage_return = (len > 0 && line[len-1] == '\r');
                    if (has_trailing_carriage_return)
                            len--;

                    if (!len && !first)
                            goto end_of_line;

                    if (reverse && want_color(o->use_color)) {
                            fputs(GIT_COLOR_REVERSE, file);
                            needs_reset = 1;
                    }

                    if (set_sign) {
                            fputs(set_sign, file);
                            needs_reset = 1;
                    }

                    if (first)
                            fputc(first, file);

                    if (!len)
                            goto end_of_line;

                    if (set) {
                            if (set_sign && set != set_sign)
                                    fputs(reset, file);
                            fputs(set, file);
                            needs_reset = 1;
                    }
                    fwrite(line, len, 1, file);
                    needs_reset = 1; /* 'line' may contain color codes. */

            end_of_line:
                    if (needs_reset)
                            fputs(reset, file);
                    if (has_trailing_carriage_return)
                            fputc('\r', file);
                    if (has_trailing_newline)
                            fputc('\n', file);
            }

            static void emit_line(struct diff_options *o, const char *set, const char *reset,
                            const char *line, int len)
            {
                    emit_line_0(o, set, NULL, 0, reset, 0, line, len);
            }

            enum diff_symbol {
                    DIFF_SYMBOL_BINARY_DIFF_HEADER,
                    DIFF_SYMBOL_BINARY_DIFF_HEADER_DELTA,
                    DIFF_SYMBOL_BINARY_DIFF_HEADER_LITERAL,
                    DIFF_SYMBOL_BINARY_DIFF_BODY,
                    DIFF_SYMBOL_BINARY_DIFF_FOOTER,
                    DIFF_SYMBOL_STATS_SUMMARY_NO_FILES,
                    DIFF_SYMBOL_STATS_SUMMARY_ABBREV,
                    DIFF_SYMBOL_STATS_SUMMARY_INSERTS_DELETES,
                    DIFF_SYMBOL_STATS_LINE,
                    DIFF_SYMBOL_WORD_DIFF,
                    DIFF_SYMBOL_STAT_SEP,
                    DIFF_SYMBOL_SUMMARY,
                    DIFF_SYMBOL_SUBMODULE_ADD,
                    DIFF_SYMBOL_SUBMODULE_DEL,
                    DIFF_SYMBOL_SUBMODULE_UNTRACKED,
                    DIFF_SYMBOL_SUBMODULE_MODIFIED,
                    DIFF_SYMBOL_SUBMODULE_HEADER,
                    DIFF_SYMBOL_SUBMODULE_ERROR,
                    DIFF_SYMBOL_SUBMODULE_PIPETHROUGH,
                    DIFF_SYMBOL_REWRITE_DIFF,
                    DIFF_SYMBOL_BINARY_FILES,
                    DIFF_SYMBOL_HEADER,
                    DIFF_SYMBOL_FILEPAIR_PLUS,
                    DIFF_SYMBOL_FILEPAIR_MINUS,
                    DIFF_SYMBOL_WORDS_PORCELAIN,
                    DIFF_SYMBOL_WORDS,
                    DIFF_SYMBOL_CONTEXT,
                    DIFF_SYMBOL_CONTEXT_INCOMPLETE,
                    DIFF_SYMBOL_PLUS,
                    DIFF_SYMBOL_MINUS,
                    DIFF_SYMBOL_NO_LF_EOF,
                    DIFF_SYMBOL_CONTEXT_FRAGINFO,
                    DIFF_SYMBOL_CONTEXT_MARKER,
                    DIFF_SYMBOL_SEPARATOR
            };
            /*
            * Flags for content lines:
            * 0..12 are whitespace rules
            * 13-15 are WSEH_NEW | WSEH_OLD | WSEH_CONTEXT
            * 16 is marking if the line is blank at EOF
            */
            #define DIFF_SYMBOL_CONTENT_BLANK_LINE_EOF      (1<<16)
            #define DIFF_SYMBOL_MOVED_LINE                  (1<<17)
            #define DIFF_SYMBOL_MOVED_LINE_ALT              (1<<18)
            #define DIFF_SYMBOL_MOVED_LINE_UNINTERESTING    (1<<19)
            #define DIFF_SYMBOL_CONTENT_WS_MASK (WSEH_NEW | WSEH_OLD | WSEH_CONTEXT | WS_RULE_MASK)

            /*
            * This struct is used when we need to buffer the output of the diff output.
            *
            * NEEDSWORK: Instead of storing a copy of the line, add an offset pointer
            * into the pre/post image file. This pointer could be a union with the
            * line pointer. By storing an offset into the file instead of the literal line,
            * we can decrease the memory footprint for the buffered output. At first we
            * may want to only have indirection for the content lines, but we could also
            * enhance the state for emitting prefabricated lines, e.g. the similarity
            * score line or hunk/file headers would only need to store a number or path
            * and then the output can be constructed later on depending on state.
            */
            struct emitted_diff_symbol {
                    const char *line;
                    int len;
                    int flags;
                    int indent_off;   /* Offset to first non-whitespace character */
                    int indent_width; /* The visual width of the indentation */
                    unsigned id;
                    enum diff_symbol s;
            };
            #define EMITTED_DIFF_SYMBOL_INIT { 0 }

            struct emitted_diff_symbols {
                    struct emitted_diff_symbol *buf;
                    int nr, alloc;
            };
            #define EMITTED_DIFF_SYMBOLS_INIT { 0 }

            static void append_emitted_diff_symbol(struct diff_options *o,
                                            struct emitted_diff_symbol *e)
            {
                    struct emitted_diff_symbol *f;

                    ALLOC_GROW(o->emitted_symbols->buf,
                            o->emitted_symbols->nr + 1,
                            o->emitted_symbols->alloc);
                    f = &o->emitted_symbols->buf[o->emitted_symbols->nr++];

                    memcpy(f, e, sizeof(struct emitted_diff_symbol));
                    f->line = e->line ? xmemdupz(e->line, e->len) : NULL;
            }

            static void free_emitted_diff_symbols(struct emitted_diff_symbols *e)
            {
                    if (!e)
                            return;
                    free(e->buf);
                    free(e);
            }

            struct moved_entry {
                    const struct emitted_diff_symbol *es;
                    struct moved_entry *next_line;
                    struct moved_entry *next_match;
            };

            struct moved_block {
                    struct moved_entry *match;
                    int wsd; /* The whitespace delta of this block */
            };

            #define INDENT_BLANKLINE INT_MIN

            static void fill_es_indent_data(struct emitted_diff_symbol *es)
            {
                    unsigned int off = 0, i;
                    int width = 0, tab_width = es->flags & WS_TAB_WIDTH_MASK;
                    const char *s = es->line;
                    const int len = es->len;

                    /* skip any \v \f \r at start of indentation */
                    while (s[off] == '\f' || s[off] == '\v' ||
                    (s[off] == '\r' && off < len - 1))
                            off++;

                    /* calculate the visual width of indentation */
                    while(1) {
                            if (s[off] == ' ') {
                                    width++;
                                    off++;
                            } else if (s[off] == '\t') {
                                    width += tab_width - (width % tab_width);
                                    while (s[++off] == '\t')
                                            width += tab_width;
                            } else {
                                    break;
                            }
                    }

                    /* check if this line is blank */
                    for (i = off; i < len; i++)
                            if (!isspace(s[i]))
                            break;

                    if (i == len) {
                            es->indent_width = INDENT_BLANKLINE;
                            es->indent_off = len;
                    } else {
                            es->indent_off = off;
                            es->indent_width = width;
                    }
            }

            static int compute_ws_delta(const struct emitted_diff_symbol *a,
                                    const struct emitted_diff_symbol *b)
            {
                    int a_width = a->indent_width,
                    b_width = b->indent_width;

                    if (a_width == INDENT_BLANKLINE && b_width == INDENT_BLANKLINE)
                            return INDENT_BLANKLINE;

                    return a_width - b_width;
            }

            static int cmp_in_block_with_wsd(const struct moved_entry *cur,
                                            const struct emitted_diff_symbol *l,
                                            struct moved_block *pmb)
            {
                    int a_width = cur->es->indent_width, b_width = l->indent_width;
                    int delta;

                    /* The text of each line must match */
                    if (cur->es->id != l->id)
                            return 1;

                    /*
                    * If 'l' and 'cur' are both blank then we don't need to check the
                    * indent. We only need to check cur as we know the strings match.
                    * */
                    if (a_width == INDENT_BLANKLINE)
                            return 0;

                    /*
                    * The indent changes of the block are known and stored in pmb->wsd;
                    * however we need to check if the indent changes of the current line
                    * match those of the current block.
                    */
                    delta = b_width - a_width;

                    /*
                    * If the previous lines of this block were all blank then set its
                    * whitespace delta.
                    */
                    if (pmb->wsd == INDENT_BLANKLINE)
                            pmb->wsd = delta;

                    return delta != pmb->wsd;
            }

            struct interned_diff_symbol {
                    struct hashmap_entry ent;
                    struct emitted_diff_symbol *es;
            };

            static int interned_diff_symbol_cmp(const void *hashmap_cmp_fn_data,
                                            const struct hashmap_entry *eptr,
                                            const struct hashmap_entry *entry_or_key,
                                            const void *keydata UNUSED)
            {
                    const struct diff_options *diffopt = hashmap_cmp_fn_data;
                    const struct emitted_diff_symbol *a, *b;
                    unsigned flags = diffopt->color_moved_ws_handling
                                    & XDF_WHITESPACE_FLAGS;

                    a = container_of(eptr, const struct interned_diff_symbol, ent)->es;
                    b = container_of(entry_or_key, const struct interned_diff_symbol, ent)->es;

                    return !xdiff_compare_lines(a->line + a->indent_off,
                                            a->len - a->indent_off,
                                            b->line + b->indent_off,
                                            b->len - b->indent_off, flags);
            }

            static void prepare_entry(struct diff_options *o, struct emitted_diff_symbol *l,
                                    struct interned_diff_symbol *s)
            {
                    unsigned flags = o->color_moved_ws_handling & XDF_WHITESPACE_FLAGS;
                    unsigned int hash = xdiff_hash_string(l->line + l->indent_off,
                                                    l->len - l->indent_off, flags);

                    hashmap_entry_init(&s->ent, hash);
                    s->es = l;
            }

            struct moved_entry_list {
                    struct moved_entry *add, *del;
            };

            static struct moved_entry_list *add_lines_to_move_detection(struct diff_options *o,
                                                                    struct mem_pool *entry_mem_pool)
            {
                    struct moved_entry *prev_line = NULL;
                    struct mem_pool interned_pool;
                    struct hashmap interned_map;
                    struct moved_entry_list *entry_list = NULL;
                    size_t entry_list_alloc = 0;
                    unsigned id = 0;
                    int n;

                    hashmap_init(&interned_map, interned_diff_symbol_cmp, o, 8096);
                    mem_pool_init(&interned_pool, 1024 * 1024);

                    for (n = 0; n < o->emitted_symbols->nr; n++) {
                            struct interned_diff_symbol key;
                            struct emitted_diff_symbol *l = &o->emitted_symbols->buf[n];
                            struct interned_diff_symbol *s;
                            struct moved_entry *entry;

                            if (l->s != DIFF_SYMBOL_PLUS && l->s != DIFF_SYMBOL_MINUS) {
                                    prev_line = NULL;
                                    continue;
                            }

                            if (o->color_moved_ws_handling &
                            COLOR_MOVED_WS_ALLOW_INDENTATION_CHANGE)
                                    fill_es_indent_data(l);

                            prepare_entry(o, l, &key);
                            s = hashmap_get_entry(&interned_map, &key, ent, &key.ent);
                            if (s) {
                                    l->id = s->es->id;
                            } else {
                                    l->id = id;
                                    ALLOC_GROW_BY(entry_list, id, 1, entry_list_alloc);
                                    hashmap_add(&interned_map,
                                            memcpy(mem_pool_alloc(&interned_pool,
                                                                    sizeof(key)),
                                                    &key, sizeof(key)));
                            }
                            entry = mem_pool_alloc(entry_mem_pool, sizeof(*entry));
                            entry->es = l;
                            entry->next_line = NULL;
                            if (prev_line && prev_line->es->s == l->s)
                                    prev_line->next_line = entry;
                            prev_line = entry;
                            if (l->s == DIFF_SYMBOL_PLUS) {
                                    entry->next_match = entry_list[l->id].add;
                                    entry_list[l->id].add = entry;
                            } else {
                                    entry->next_match = entry_list[l->id].del;
                                    entry_list[l->id].del = entry;
                            }
                    }

                    hashmap_clear(&interned_map);
                    mem_pool_discard(&interned_pool, 0);

                    return entry_list;
            }

            static void pmb_advance_or_null(struct diff_options *o,
                                            struct emitted_diff_symbol *l,
                                            struct moved_block *pmb,
                                            int *pmb_nr)
            {
                    int i, j;

                    for (i = 0, j = 0; i < *pmb_nr; i++) {
                            int match;
                            struct moved_entry *prev = pmb[i].match;
                            struct moved_entry *cur = (prev && prev->next_line) ?
                                            prev->next_line : NULL;

                            if (o->color_moved_ws_handling &
                            COLOR_MOVED_WS_ALLOW_INDENTATION_CHANGE)
                                    match = cur &&
                                            !cmp_in_block_with_wsd(cur, l, &pmb[i]);
                            else
                                    match = cur && cur->es->id == l->id;

                            if (match) {
                                    pmb[j] = pmb[i];
                                    pmb[j++].match = cur;
                            }
                    }
                    *pmb_nr = j;
            }

            static void fill_potential_moved_blocks(struct diff_options *o,
                                                    struct moved_entry *match,
                                                    struct emitted_diff_symbol *l,
                                                    struct moved_block **pmb_p,
                                                    int *pmb_alloc_p, int *pmb_nr_p)

            {
                    struct moved_block *pmb = *pmb_p;
                    int pmb_alloc = *pmb_alloc_p, pmb_nr = *pmb_nr_p;

                    /*
                    * The current line is the start of a new block.
                    * Setup the set of potential blocks.
                    */
                    for (; match; match = match->next_match) {
                            ALLOC_GROW(pmb, pmb_nr + 1, pmb_alloc);
                            if (o->color_moved_ws_handling &
                            COLOR_MOVED_WS_ALLOW_INDENTATION_CHANGE)
                                    pmb[pmb_nr].wsd = compute_ws_delta(l, match->es);
                            else
                                    pmb[pmb_nr].wsd = 0;
                            pmb[pmb_nr++].match = match;
                    }

                    *pmb_p = pmb;
                    *pmb_alloc_p = pmb_alloc;
                    *pmb_nr_p = pmb_nr;
            }

            /*
            * If o->color_moved is COLOR_MOVED_PLAIN, this function does nothing.
            *
            * Otherwise, if the last block has fewer alphanumeric characters than
            * COLOR_MOVED_MIN_ALNUM_COUNT, unset DIFF_SYMBOL_MOVED_LINE on all lines in
            * that block.
            *
            * The last block consists of the (n - block_length)'th line up to but not
            * including the nth line.
            *
            * Returns 0 if the last block is empty or is unset by this function, non zero
            * otherwise.
            *
            * NEEDSWORK: This uses the same heuristic as blame_entry_score() in blame.c.
            * Think of a way to unify them.
            */
            #define DIFF_SYMBOL_MOVED_LINE_ZEBRA_MASK \
            (DIFF_SYMBOL_MOVED_LINE | DIFF_SYMBOL_MOVED_LINE_ALT)
            static int adjust_last_block(struct diff_options *o, int n, int block_length)
            {
                    int i, alnum_count = 0;
                    if (o->color_moved == COLOR_MOVED_PLAIN)
                            return block_length;
                    for (i = 1; i < block_length + 1; i++) {
                            const char *c = o->emitted_symbols->buf[n - i].line;
                            for (; *c; c++) {
                                    if (!isalnum(*c))
                                            continue;
                                    alnum_count++;
                                    if (alnum_count >= COLOR_MOVED_MIN_ALNUM_COUNT)
                                            return 1;
                            }
                    }
                    for (i = 1; i < block_length + 1; i++)
                            o->emitted_symbols->buf[n - i].flags &= ~DIFF_SYMBOL_MOVED_LINE_ZEBRA_MASK;
                    return 0;
            }

            /* Find blocks of moved code, delegate actual coloring decision to helper */
            static void mark_color_as_moved(struct diff_options *o,
                                            struct moved_entry_list *entry_list)
            {
                    struct moved_block *pmb = NULL; /* potentially moved blocks */
                    int pmb_nr = 0, pmb_alloc = 0;
                    int n, flipped_block = 0, block_length = 0;
                    enum diff_symbol moved_symbol = DIFF_SYMBOL_BINARY_DIFF_HEADER;


                    for (n = 0; n < o->emitted_symbols->nr; n++) {
                            struct moved_entry *match = NULL;
                            struct emitted_diff_symbol *l = &o->emitted_symbols->buf[n];

                            switch (l->s) {
                            case DIFF_SYMBOL_PLUS:
                                    match = entry_list[l->id].del;
                                    break;
                            case DIFF_SYMBOL_MINUS:
                                    match = entry_list[l->id].add;
                                    break;
                            default:
                                    flipped_block = 0;
                            }

                            if (pmb_nr && (!match || l->s != moved_symbol)) {
                                    if (!adjust_last_block(o, n, block_length) &&
                                    block_length > 1) {
                                            /*
                                            * Rewind in case there is another match
                                            * starting at the second line of the block
                                            */
                                            match = NULL;
                                            n -= block_length;
                                    }
                                    pmb_nr = 0;
                                    block_length = 0;
                                    flipped_block = 0;
                            }
                            if (!match) {
                                    moved_symbol = DIFF_SYMBOL_BINARY_DIFF_HEADER;
                                    continue;
                            }

                            if (o->color_moved == COLOR_MOVED_PLAIN) {
                                    l->flags |= DIFF_SYMBOL_MOVED_LINE;
                                    continue;
                            }

                            pmb_advance_or_null(o, l, pmb, &pmb_nr);

                            if (pmb_nr == 0) {
                                    int contiguous = adjust_last_block(o, n, block_length);

                                    if (!contiguous && block_length > 1)
                                            /*
                                            * Rewind in case there is another match
                                            * starting at the second line of the block
                                            */
                                            n -= block_length;
                                    else
                                            fill_potential_moved_blocks(o, match, l,
                                                                    &pmb, &pmb_alloc,
                                                                    &pmb_nr);

                                    if (contiguous && pmb_nr && moved_symbol == l->s)
                                            flipped_block = (flipped_block + 1) % 2;
                                    else
                                            flipped_block = 0;

                                    if (pmb_nr)
                                            moved_symbol = l->s;
                                    else
                                            moved_symbol = DIFF_SYMBOL_BINARY_DIFF_HEADER;

                                    block_length = 0;
                            }

                            if (pmb_nr) {
                                    block_length++;
                                    l->flags |= DIFF_SYMBOL_MOVED_LINE;
                                    if (flipped_block && o->color_moved != COLOR_MOVED_BLOCKS)
                                            l->flags |= DIFF_SYMBOL_MOVED_LINE_ALT;
                            }
                    }
                    adjust_last_block(o, n, block_length);

                    free(pmb);
            }

            static void dim_moved_lines(struct diff_options *o)
            {
                    int n;
                    for (n = 0; n < o->emitted_symbols->nr; n++) {
                            struct emitted_diff_symbol *prev = (n != 0) ?
                                            &o->emitted_symbols->buf[n - 1] : NULL;
                            struct emitted_diff_symbol *l = &o->emitted_symbols->buf[n];
                            struct emitted_diff_symbol *next =
                                            (n < o->emitted_symbols->nr - 1) ?
                                            &o->emitted_symbols->buf[n + 1] : NULL;

                            /* Not a plus or minus line? */
                            if (l->s != DIFF_SYMBOL_PLUS && l->s != DIFF_SYMBOL_MINUS)
                                    continue;

                            /* Not a moved line? */
                            if (!(l->flags & DIFF_SYMBOL_MOVED_LINE))
                                    continue;

                            /*
                            * If prev or next are not a plus or minus line,
                            * pretend they don't exist
                            */
                            if (prev && prev->s != DIFF_SYMBOL_PLUS &&
                                    prev->s != DIFF_SYMBOL_MINUS)
                                    prev = NULL;
                            if (next && next->s != DIFF_SYMBOL_PLUS &&
                                    next->s != DIFF_SYMBOL_MINUS)
                                    next = NULL;

                            /* Inside a block? */
                            if ((prev &&
                            (prev->flags & DIFF_SYMBOL_MOVED_LINE_ZEBRA_MASK) ==
                            (l->flags & DIFF_SYMBOL_MOVED_LINE_ZEBRA_MASK)) &&
                            (next &&
                            (next->flags & DIFF_SYMBOL_MOVED_LINE_ZEBRA_MASK) ==
                            (l->flags & DIFF_SYMBOL_MOVED_LINE_ZEBRA_MASK))) {
                                    l->flags |= DIFF_SYMBOL_MOVED_LINE_UNINTERESTING;
                                    continue;
                            }

                            /* Check if we are at an interesting bound: */
                            if (prev && (prev->flags & DIFF_SYMBOL_MOVED_LINE) &&
                            (prev->flags & DIFF_SYMBOL_MOVED_LINE_ALT) !=
                            (l->flags & DIFF_SYMBOL_MOVED_LINE_ALT))
                                    continue;
                            if (next && (next->flags & DIFF_SYMBOL_MOVED_LINE) &&
                            (next->flags & DIFF_SYMBOL_MOVED_LINE_ALT) !=
                            (l->flags & DIFF_SYMBOL_MOVED_LINE_ALT))
                                    continue;

                            /*
                            * The boundary to prev and next are not interesting,
                            * so this line is not interesting as a whole
                            */
                            l->flags |= DIFF_SYMBOL_MOVED_LINE_UNINTERESTING;
                    }
            }

            static void emit_line_ws_markup(struct diff_options *o,
                                            const char *set_sign, const char *set,
                                            const char *reset,
                                            int sign_index, const char *line, int len,
                                            unsigned ws_rule, int blank_at_eof)
            {
                    const char *ws = NULL;
                    int sign = o->output_indicators[sign_index];

                    if (o->ws_error_highlight & ws_rule) {
                            ws = diff_get_color_opt(o, DIFF_WHITESPACE);
                            if (!*ws)
                                    ws = NULL;
                    }

                    if (!ws && !set_sign)
                            emit_line_0(o, set, NULL, 0, reset, sign, line, len);
                    else if (!ws) {
                            emit_line_0(o, set_sign, set, !!set_sign, reset, sign, line, len);
                    } else if (blank_at_eof)
                            /* Blank line at EOF - paint '+' as well */
                            emit_line_0(o, ws, NULL, 0, reset, sign, line, len);
                    else {
                            /* Emit just the prefix, then the rest. */
                            emit_line_0(o, set_sign ? set_sign : set, NULL, !!set_sign, reset,
                                    sign, "", 0);
                            ws_check_emit(line, len, ws_rule,
                                    o->file, set, reset, ws);
                    }
            }

            static void emit_diff_symbol_from_struct(struct diff_options *o,
                                                    struct emitted_diff_symbol *eds)
            {
                    static const char *nneof = " No newline at end of file\n";
                    const char *context, *reset, *set, *set_sign, *meta, *fraginfo;

                    enum diff_symbol s = eds->s;
                    const char *line = eds->line;
                    int len = eds->len;
                    unsigned flags = eds->flags;

                    switch (s) {
                    case DIFF_SYMBOL_NO_LF_EOF:
                            context = diff_get_color_opt(o, DIFF_CONTEXT);
                            reset = diff_get_color_opt(o, DIFF_RESET);
                            putc('\n', o->file);
                            emit_line_0(o, context, NULL, 0, reset, '\\',
                                    nneof, strlen(nneof));
                            break;
                    case DIFF_SYMBOL_SUBMODULE_HEADER:
                    case DIFF_SYMBOL_SUBMODULE_ERROR:
                    case DIFF_SYMBOL_SUBMODULE_PIPETHROUGH:
                    case DIFF_SYMBOL_STATS_SUMMARY_INSERTS_DELETES:
                    case DIFF_SYMBOL_SUMMARY:
                    case DIFF_SYMBOL_STATS_LINE:
                    case DIFF_SYMBOL_BINARY_DIFF_BODY:
                    case DIFF_SYMBOL_CONTEXT_FRAGINFO:
                            emit_line(o, "", "", line, len);
                            break;
                    case DIFF_SYMBOL_CONTEXT_INCOMPLETE:
                    case DIFF_SYMBOL_CONTEXT_MARKER:
                            context = diff_get_color_opt(o, DIFF_CONTEXT);
                            reset = diff_get_color_opt(o, DIFF_RESET);
                            emit_line(o, context, reset, line, len);
                            break;
                    case DIFF_SYMBOL_SEPARATOR:
                            fprintf(o->file, "%s%c",
                                    diff_line_prefix(o),
                                    o->line_termination);
                            break;
                    case DIFF_SYMBOL_CONTEXT:
                            set = diff_get_color_opt(o, DIFF_CONTEXT);
                            reset = diff_get_color_opt(o, DIFF_RESET);
                            set_sign = NULL;
                            if (o->flags.dual_color_diffed_diffs) {
                                    char c = !len ? 0 : line[0];

                                    if (c == '+')
                                            set = diff_get_color_opt(o, DIFF_FILE_NEW);
                                    else if (c == '@')
                                            set = diff_get_color_opt(o, DIFF_FRAGINFO);
                                    else if (c == '-')
                                            set = diff_get_color_opt(o, DIFF_FILE_OLD);
                            }
                            emit_line_ws_markup(o, set_sign, set, reset,
                                            OUTPUT_INDICATOR_CONTEXT, line, len,
                                            flags & (DIFF_SYMBOL_CONTENT_WS_MASK), 0);
                            break;
                    case DIFF_SYMBOL_PLUS:
                            switch (flags & (DIFF_SYMBOL_MOVED_LINE |
                                            DIFF_SYMBOL_MOVED_LINE_ALT |
                                            DIFF_SYMBOL_MOVED_LINE_UNINTERESTING)) {
                            case DIFF_SYMBOL_MOVED_LINE |
                            DIFF_SYMBOL_MOVED_LINE_ALT |
                            DIFF_SYMBOL_MOVED_LINE_UNINTERESTING:
                                    set = diff_get_color_opt(o, DIFF_FILE_NEW_MOVED_ALT_DIM);
                                    break;
                            case DIFF_SYMBOL_MOVED_LINE |
                            DIFF_SYMBOL_MOVED_LINE_ALT:
                                    set = diff_get_color_opt(o, DIFF_FILE_NEW_MOVED_ALT);
                                    break;
                            case DIFF_SYMBOL_MOVED_LINE |
                            DIFF_SYMBOL_MOVED_LINE_UNINTERESTING:
                                    set = diff_get_color_opt(o, DIFF_FILE_NEW_MOVED_DIM);
                                    break;
                            case DIFF_SYMBOL_MOVED_LINE:
                                    set = diff_get_color_opt(o, DIFF_FILE_NEW_MOVED);
                                    break;
                            default:
                                    set = diff_get_color_opt(o, DIFF_FILE_NEW);
                            }
                            reset = diff_get_color_opt(o, DIFF_RESET);
                            if (!o->flags.dual_color_diffed_diffs)
                                    set_sign = NULL;
                            else {
                                    char c = !len ? 0 : line[0];

                                    set_sign = set;
                                    if (c == '-')
                                            set = diff_get_color_opt(o, DIFF_FILE_OLD_BOLD);
                                    else if (c == '@')
                                            set = diff_get_color_opt(o, DIFF_FRAGINFO);
                                    else if (c == '+')
                                            set = diff_get_color_opt(o, DIFF_FILE_NEW_BOLD);
                                    else
                                            set = diff_get_color_opt(o, DIFF_CONTEXT_BOLD);
                                    flags &= ~DIFF_SYMBOL_CONTENT_WS_MASK;
                            }
                            emit_line_ws_markup(o, set_sign, set, reset,
                                            OUTPUT_INDICATOR_NEW, line, len,
                                            flags & DIFF_SYMBOL_CONTENT_WS_MASK,
                                            flags & DIFF_SYMBOL_CONTENT_BLANK_LINE_EOF);
                            break;
                    case DIFF_SYMBOL_MINUS:
                            switch (flags & (DIFF_SYMBOL_MOVED_LINE |
                                            DIFF_SYMBOL_MOVED_LINE_ALT |
                                            DIFF_SYMBOL_MOVED_LINE_UNINTERESTING)) {
                            case DIFF_SYMBOL_MOVED_LINE |
                            DIFF_SYMBOL_MOVED_LINE_ALT |
                            DIFF_SYMBOL_MOVED_LINE_UNINTERESTING:
                                    set = diff_get_color_opt(o, DIFF_FILE_OLD_MOVED_ALT_DIM);
                                    break;
                            case DIFF_SYMBOL_MOVED_LINE |
                            DIFF_SYMBOL_MOVED_LINE_ALT:
                                    set = diff_get_color_opt(o, DIFF_FILE_OLD_MOVED_ALT);
                                    break;
                            case DIFF_SYMBOL_MOVED_LINE |
                            DIFF_SYMBOL_MOVED_LINE_UNINTERESTING:
                                    set = diff_get_color_opt(o, DIFF_FILE_OLD_MOVED_DIM);
                                    break;
                            case DIFF_SYMBOL_MOVED_LINE:
                                    set = diff_get_color_opt(o, DIFF_FILE_OLD_MOVED);
                                    break;
                            default:
                                    set = diff_get_color_opt(o, DIFF_FILE_OLD);
                            }
                            reset = diff_get_color_opt(o, DIFF_RESET);
                            if (!o->flags.dual_color_diffed_diffs)
                                    set_sign = NULL;
                            else {
                                    char c = !len ? 0 : line[0];

                                    set_sign = set;
                                    if (c == '+')
                                            set = diff_get_color_opt(o, DIFF_FILE_NEW_DIM);
                                    else if (c == '@')
                                            set = diff_get_color_opt(o, DIFF_FRAGINFO);
                                    else if (c == '-')
                                            set = diff_get_color_opt(o, DIFF_FILE_OLD_DIM);
                                    else
                                            set = diff_get_color_opt(o, DIFF_CONTEXT_DIM);
                            }
                            emit_line_ws_markup(o, set_sign, set, reset,
                                            OUTPUT_INDICATOR_OLD, line, len,
                                            flags & DIFF_SYMBOL_CONTENT_WS_MASK, 0);
                            break;
                    case DIFF_SYMBOL_WORDS_PORCELAIN:
                            context = diff_get_color_opt(o, DIFF_CONTEXT);
                            reset = diff_get_color_opt(o, DIFF_RESET);
                            emit_line(o, context, reset, line, len);
                            fputs("~\n", o->file);
                            break;
                    case DIFF_SYMBOL_WORDS:
                            context = diff_get_color_opt(o, DIFF_CONTEXT);
                            reset = diff_get_color_opt(o, DIFF_RESET);
                            /*
                            * Skip the prefix character, if any.  With
                            * diff_suppress_blank_empty, there may be
                            * none.
                            */
                            if (line[0] != '\n') {
                                    line++;
                                    len--;
                            }
                            emit_line(o, context, reset, line, len);
                            break;
                    case DIFF_SYMBOL_FILEPAIR_PLUS:
                            meta = diff_get_color_opt(o, DIFF_METAINFO);
                            reset = diff_get_color_opt(o, DIFF_RESET);
                            fprintf(o->file, "%s%s+++ %s%s%s\n", diff_line_prefix(o), meta,
                                    line, reset,
                                    strchr(line, ' ') ? "\t" : "");
                            break;
                    case DIFF_SYMBOL_FILEPAIR_MINUS:
                            meta = diff_get_color_opt(o, DIFF_METAINFO);
                            reset = diff_get_color_opt(o, DIFF_RESET);
                            fprintf(o->file, "%s%s--- %s%s%s\n", diff_line_prefix(o), meta,
                                    line, reset,
                                    strchr(line, ' ') ? "\t" : "");
                            break;
                    case DIFF_SYMBOL_BINARY_FILES:
                    case DIFF_SYMBOL_HEADER:
                            fprintf(o->file, "%s", line);
                            break;
                    case DIFF_SYMBOL_BINARY_DIFF_HEADER:
                            fprintf(o->file, "%sGIT binary patch\n", diff_line_prefix(o));
                            break;
                    case DIFF_SYMBOL_BINARY_DIFF_HEADER_DELTA:
                            fprintf(o->file, "%sdelta %s\n", diff_line_prefix(o), line);
                            break;
                    case DIFF_SYMBOL_BINARY_DIFF_HEADER_LITERAL:
                            fprintf(o->file, "%sliteral %s\n", diff_line_prefix(o), line);
                            break;
                    case DIFF_SYMBOL_BINARY_DIFF_FOOTER:
                            fputs(diff_line_prefix(o), o->file);
                            fputc('\n', o->file);
                            break;
                    case DIFF_SYMBOL_REWRITE_DIFF:
                            fraginfo = diff_get_color(o->use_color, DIFF_FRAGINFO);
                            reset = diff_get_color_opt(o, DIFF_RESET);
                            emit_line(o, fraginfo, reset, line, len);
                            break;
                    case DIFF_SYMBOL_SUBMODULE_ADD:
                            set = diff_get_color_opt(o, DIFF_FILE_NEW);
                            reset = diff_get_color_opt(o, DIFF_RESET);
                            emit_line(o, set, reset, line, len);
                            break;
                    case DIFF_SYMBOL_SUBMODULE_DEL:
                            set = diff_get_color_opt(o, DIFF_FILE_OLD);
                            reset = diff_get_color_opt(o, DIFF_RESET);
                            emit_line(o, set, reset, line, len);
                            break;
                    case DIFF_SYMBOL_SUBMODULE_UNTRACKED:
                            fprintf(o->file, "%sSubmodule %s contains untracked content\n",
                                    diff_line_prefix(o), line);
                            break;
                    case DIFF_SYMBOL_SUBMODULE_MODIFIED:
                            fprintf(o->file, "%sSubmodule %s contains modified content\n",
                                    diff_line_prefix(o), line);
                            break;
                    case DIFF_SYMBOL_STATS_SUMMARY_NO_FILES:
                            emit_line(o, "", "", " 0 files changed\n",
                                    strlen(" 0 files changed\n"));
                            break;
                    case DIFF_SYMBOL_STATS_SUMMARY_ABBREV:
                            emit_line(o, "", "", " ...\n", strlen(" ...\n"));
                            break;
                    case DIFF_SYMBOL_WORD_DIFF:
                            fprintf(o->file, "%.*s", len, line);
                            break;
                    case DIFF_SYMBOL_STAT_SEP:
                            fputs(o->stat_sep, o->file);
                            break;
                    default:
                            BUG("unknown diff symbol");
                    }
            }

            static void emit_diff_symbol(struct diff_options *o, enum diff_symbol s,
                                    const char *line, int len, unsigned flags)
            {
                    struct emitted_diff_symbol e = {
                            .line = line, .len = len, .flags = flags, .s = s
                    };

                    if (o->emitted_symbols)
                            append_emitted_diff_symbol(o, &e);
                    else
                            emit_diff_symbol_from_struct(o, &e);
            }

            void diff_emit_submodule_del(struct diff_options *o, const char *line)
            {
                    emit_diff_symbol(o, DIFF_SYMBOL_SUBMODULE_DEL, line, strlen(line), 0);
            }

            void diff_emit_submodule_add(struct diff_options *o, const char *line)
            {
                    emit_diff_symbol(o, DIFF_SYMBOL_SUBMODULE_ADD, line, strlen(line), 0);
            }

            void diff_emit_submodule_untracked(struct diff_options *o, const char *path)
            {
                    emit_diff_symbol(o, DIFF_SYMBOL_SUBMODULE_UNTRACKED,
                                    path, strlen(path), 0);
            }

            void diff_emit_submodule_modified(struct diff_options *o, const char *path)
            {
                    emit_diff_symbol(o, DIFF_SYMBOL_SUBMODULE_MODIFIED,
                                    path, strlen(path), 0);
            }

            void diff_emit_submodule_header(struct diff_options *o, const char *header)
            {
                    emit_diff_symbol(o, DIFF_SYMBOL_SUBMODULE_HEADER,
                                    header, strlen(header), 0);
            }

            void diff_emit_submodule_error(struct diff_options *o, const char *err)
            {
                    emit_diff_symbol(o, DIFF_SYMBOL_SUBMODULE_ERROR, err, strlen(err), 0);
            }

            void diff_emit_submodule_pipethrough(struct diff_options *o,
                                            const char *line, int len)
            {
                    emit_diff_symbol(o, DIFF_SYMBOL_SUBMODULE_PIPETHROUGH, line, len, 0);
            }

            static int new_blank_line_at_eof(struct emit_callback *ecbdata, const char *line, int len)
            {
                    if (!((ecbdata->ws_rule & WS_BLANK_AT_EOF) &&
                    ecbdata->blank_at_eof_in_preimage &&
                    ecbdata->blank_at_eof_in_postimage &&
                    ecbdata->blank_at_eof_in_preimage <= ecbdata->lno_in_preimage &&
                    ecbdata->blank_at_eof_in_postimage <= ecbdata->lno_in_postimage))
                            return 0;
                    return ws_blank_line(line, len);
            }

            static void emit_add_line(struct emit_callback *ecbdata,
                                    const char *line, int len)
            {
                    unsigned flags = WSEH_NEW | ecbdata->ws_rule;
                    if (new_blank_line_at_eof(ecbdata, line, len))
                            flags |= DIFF_SYMBOL_CONTENT_BLANK_LINE_EOF;

                    emit_diff_symbol(ecbdata->opt, DIFF_SYMBOL_PLUS, line, len, flags);
            }

            static void emit_del_line(struct emit_callback *ecbdata,
                                    const char *line, int len)
            {
                    unsigned flags = WSEH_OLD | ecbdata->ws_rule;
                    emit_diff_symbol(ecbdata->opt, DIFF_SYMBOL_MINUS, line, len, flags);
            }

            static void emit_context_line(struct emit_callback *ecbdata,
                                    const char *line, int len)
            {
                    unsigned flags = WSEH_CONTEXT | ecbdata->ws_rule;
                    emit_diff_symbol(ecbdata->opt, DIFF_SYMBOL_CONTEXT, line, len, flags);
            }

            static void emit_hunk_header(struct emit_callback *ecbdata,
                                    const char *line, int len)
            {
                    const char *context = diff_get_color(ecbdata->color_diff, DIFF_CONTEXT);
                    const char *frag = diff_get_color(ecbdata->color_diff, DIFF_FRAGINFO);
                    const char *func = diff_get_color(ecbdata->color_diff, DIFF_FUNCINFO);
                    const char *reset = diff_get_color(ecbdata->color_diff, DIFF_RESET);
                    const char *reverse = ecbdata->color_diff ? GIT_COLOR_REVERSE : "";
                    static const char atat[2] = { '@', '@' };
                    const char *cp, *ep;
                    struct strbuf msgbuf = STRBUF_INIT;
                    int org_len = len;
                    int i = 1;

                    /*
                    * As a hunk header must begin with "@@ -<old>, +<new> @@",
                    * it always is at least 10 bytes long.
                    */
                    if (len < 10 ||
                    memcmp(line, atat, 2) ||
                    !(ep = memmem(line + 2, len - 2, atat, 2))) {
                            emit_diff_symbol(ecbdata->opt,
                                            DIFF_SYMBOL_CONTEXT_MARKER, line, len, 0);
                            return;
                    }
                    ep += 2; /* skip over @@ */

                    /* The hunk header in fraginfo color */
                    if (ecbdata->opt->flags.dual_color_diffed_diffs)
                            strbuf_addstr(&msgbuf, reverse);
                    strbuf_addstr(&msgbuf, frag);
                    if (ecbdata->opt->flags.suppress_hunk_header_line_count)
                            strbuf_add(&msgbuf, atat, sizeof(atat));
                    else
                            strbuf_add(&msgbuf, line, ep - line);
                    strbuf_addstr(&msgbuf, reset);

                    /*
                    * trailing "\r\n"
                    */
                    for ( ; i < 3; i++)
                            if (line[len - i] == '\r' || line[len - i] == '\n')
                                    len--;

                    /* blank before the func header */
                    for (cp = ep; ep - line < len; ep++)
                            if (*ep != ' ' && *ep != '\t')
                                    break;
                    if (ep != cp) {
                            strbuf_addstr(&msgbuf, context);
                            strbuf_add(&msgbuf, cp, ep - cp);
                            strbuf_addstr(&msgbuf, reset);
                    }

                    if (ep < line + len) {
                            strbuf_addstr(&msgbuf, func);
                            strbuf_add(&msgbuf, ep, line + len - ep);
                            strbuf_addstr(&msgbuf, reset);
                    }

                    strbuf_add(&msgbuf, line + len, org_len - len);
                    strbuf_complete_line(&msgbuf);
                    emit_diff_symbol(ecbdata->opt,
                                    DIFF_SYMBOL_CONTEXT_FRAGINFO, msgbuf.buf, msgbuf.len, 0);
                    strbuf_release(&msgbuf);
            }

            static struct diff_tempfile *claim_diff_tempfile(void)
            {
                    int i;
                    for (i = 0; i < ARRAY_SIZE(diff_temp); i++)
                            if (!diff_temp[i].name)
                                    return diff_temp + i;
                    BUG("diff is failing to clean up its tempfiles");
            }

            static void remove_tempfile(void)
            {
                    int i;
                    for (i = 0; i < ARRAY_SIZE(diff_temp); i++) {
                            if (is_tempfile_active(diff_temp[i].tempfile))
                                    delete_tempfile(&diff_temp[i].tempfile);
                            diff_temp[i].name = NULL;
                    }
            }

            static void add_line_count(struct strbuf *out, int count)
            {
                    switch (count) {
                    case 0:
                            strbuf_addstr(out, "0,0");
                            break;
                    case 1:
                            strbuf_addstr(out, "1");
                            break;
                    default:
                            strbuf_addf(out, "1,%d", count);
                            break;
                    }
            }

            static void emit_rewrite_lines(struct emit_callback *ecb,
                                    int prefix, const char *data, int size)
            {
                    const char *endp = NULL;

                    while (0 < size) {
                            int len;

                            endp = memchr(data, '\n', size);
                            len = endp ? (endp - data + 1) : size;
                            if (prefix != '+') {
                                    ecb->lno_in_preimage++;
                                    emit_del_line(ecb, data, len);
                            } else {
                                    ecb->lno_in_postimage++;
                                    emit_add_line(ecb, data, len);
                            }
                            size -= len;
                            data += len;
                    }
                    if (!endp)
                            emit_diff_symbol(ecb->opt, DIFF_SYMBOL_NO_LF_EOF, NULL, 0, 0);
            }

            static void emit_rewrite_diff(const char *name_a,
                                    const char *name_b,
                                    struct diff_filespec *one,
                                    struct diff_filespec *two,
                                    struct userdiff_driver *textconv_one,
                                    struct userdiff_driver *textconv_two,
                                    struct diff_options *o)
            {
                    int lc_a, lc_b;
                    static struct strbuf a_name = STRBUF_INIT, b_name = STRBUF_INIT;
                    const char *a_prefix, *b_prefix;
                    char *data_one, *data_two;
                    size_t size_one, size_two;
                    struct emit_callback ecbdata;
                    struct strbuf out = STRBUF_INIT;

                    if (diff_mnemonic_prefix && o->flags.reverse_diff) {
                            a_prefix = o->b_prefix;
                            b_prefix = o->a_prefix;
                    } else {
                            a_prefix = o->a_prefix;
                            b_prefix = o->b_prefix;
                    }

                    name_a += (*name_a == '/');
                    name_b += (*name_b == '/');

                    strbuf_reset(&a_name);
                    strbuf_reset(&b_name);
                    quote_two_c_style(&a_name, a_prefix, name_a, 0);
                    quote_two_c_style(&b_name, b_prefix, name_b, 0);

                    size_one = fill_textconv(o->repo, textconv_one, one, &data_one);
                    size_two = fill_textconv(o->repo, textconv_two, two, &data_two);

                    memset(&ecbdata, 0, sizeof(ecbdata));
                    ecbdata.color_diff = want_color(o->use_color);
                    ecbdata.ws_rule = whitespace_rule(o->repo->index, name_b);
                    ecbdata.opt = o;
                    if (ecbdata.ws_rule & WS_BLANK_AT_EOF) {
                            mmfile_t mf1, mf2;
                            mf1.ptr = (char *)data_one;
                            mf2.ptr = (char *)data_two;
                            mf1.size = size_one;
                            mf2.size = size_two;
                            check_blank_at_eof(&mf1, &mf2, &ecbdata);
                    }
                    ecbdata.lno_in_preimage = 1;
                    ecbdata.lno_in_postimage = 1;

                    lc_a = count_lines(data_one, size_one);
                    lc_b = count_lines(data_two, size_two);

                    emit_diff_symbol(o, DIFF_SYMBOL_FILEPAIR_MINUS,
                                    a_name.buf, a_name.len, 0);
                    emit_diff_symbol(o, DIFF_SYMBOL_FILEPAIR_PLUS,
                                    b_name.buf, b_name.len, 0);

                    strbuf_addstr(&out, "@@ -");
                    if (!o->irreversible_delete)
                            add_line_count(&out, lc_a);
                    else
                            strbuf_addstr(&out, "?,?");
                    strbuf_addstr(&out, " +");
                    add_line_count(&out, lc_b);
                    strbuf_addstr(&out, " @@\n");
                    emit_diff_symbol(o, DIFF_SYMBOL_REWRITE_DIFF, out.buf, out.len, 0);
                    strbuf_release(&out);

                    if (lc_a && !o->irreversible_delete)
                            emit_rewrite_lines(&ecbdata, '-', data_one, size_one);
                    if (lc_b)
                            emit_rewrite_lines(&ecbdata, '+', data_two, size_two);
                    if (textconv_one)
                            free((char *)data_one);
                    if (textconv_two)
                            free((char *)data_two);
            }

            struct diff_words_buffer {
                    mmfile_t text;
                    unsigned long alloc;
                    struct diff_words_orig {
                            const char *begin, *end;
                    } *orig;
                    int orig_nr, orig_alloc;
            };

            static void diff_words_append(char *line, unsigned long len,
                            struct diff_words_buffer *buffer)
            {
                    ALLOC_GROW(buffer->text.ptr, buffer->text.size + len, buffer->alloc);
                    line++;
                    len--;
                    memcpy(buffer->text.ptr + buffer->text.size, line, len);
                    buffer->text.size += len;
                    buffer->text.ptr[buffer->text.size] = '\0';
            }

            struct diff_words_style_elem {
                    const char *prefix;
                    const char *suffix;
                    const char *color; /* NULL; filled in by the setup code if
                                    * color is enabled */
            };

            struct diff_words_style {
                    enum diff_words_type type;
                    struct diff_words_style_elem new_word, old_word, ctx;
                    const char *newline;
            };

            static struct diff_words_style diff_words_styles[] = {
                    { DIFF_WORDS_PORCELAIN, {"+", "\n"}, {"-", "\n"}, {" ", "\n"}, "~\n" },
                    { DIFF_WORDS_PLAIN, {"{+", "+}"}, {"[-", "-]"}, {"", ""}, "\n" },
                    { DIFF_WORDS_COLOR, {"", ""}, {"", ""}, {"", ""}, "\n" }
            };

            struct diff_words_data {
                    struct diff_words_buffer minus, plus;
                    const char *current_plus;
                    int last_minus;
                    struct diff_options *opt;
                    regex_t *word_regex;
                    enum diff_words_type type;
                    struct diff_words_style *style;
            };

            static int fn_out_diff_words_write_helper(struct diff_options *o,
                                                    struct diff_words_style_elem *st_el,
                                                    const char *newline,
                                                    size_t count, const char *buf)
            {
                    int print = 0;
                    struct strbuf sb = STRBUF_INIT;

                    while (count) {
                            char *p = memchr(buf, '\n', count);
                            if (print)
                                    strbuf_addstr(&sb, diff_line_prefix(o));

                            if (p != buf) {
                                    const char *reset = st_el->color && *st_el->color ?
                                                    GIT_COLOR_RESET : NULL;
                                    if (st_el->color && *st_el->color)
                                            strbuf_addstr(&sb, st_el->color);
                                    strbuf_addstr(&sb, st_el->prefix);
                                    strbuf_add(&sb, buf, p ? p - buf : count);
                                    strbuf_addstr(&sb, st_el->suffix);
                                    if (reset)
                                            strbuf_addstr(&sb, reset);
                            }
                            if (!p)
                                    goto out;

                            strbuf_addstr(&sb, newline);
                            count -= p + 1 - buf;
                            buf = p + 1;
                            print = 1;
                            if (count) {
                                    emit_diff_symbol(o, DIFF_SYMBOL_WORD_DIFF,
                                                    sb.buf, sb.len, 0);
                                    strbuf_reset(&sb);
                            }
                    }

            out:
                    if (sb.len)
                            emit_diff_symbol(o, DIFF_SYMBOL_WORD_DIFF,
                                            sb.buf, sb.len, 0);
                    strbuf_release(&sb);
                    return 0;
            }

            /*
            * '--color-words' algorithm can be described as:
            *
            *   1. collect the minus/plus lines of a diff hunk, divided into
            *      minus-lines and plus-lines;
            *
            *   2. break both minus-lines and plus-lines into words and
            *      place them into two mmfile_t with one word for each line;
            *
            *   3. use xdiff to run diff on the two mmfile_t to get the words level diff;
            *
            * And for the common parts of the both file, we output the plus side text.
            * diff_words->current_plus is used to trace the current position of the plus file
            * which printed. diff_words->last_minus is used to trace the last minus word
            * printed.
            *
            * For '--graph' to work with '--color-words', we need to output the graph prefix
            * on each line of color words output. Generally, there are two conditions on
            * which we should output the prefix.
            *
            *   1. diff_words->last_minus == 0 &&
            *      diff_words->current_plus == diff_words->plus.text.ptr
            *
            *      that is: the plus text must start as a new line, and if there is no minus
            *      word printed, a graph prefix must be printed.
            *
            *   2. diff_words->current_plus > diff_words->plus.text.ptr &&
            *      *(diff_words->current_plus - 1) == '\n'
            *
            *      that is: a graph prefix must be printed following a '\n'
            */
            static int color_words_output_graph_prefix(struct diff_words_data *diff_words)
            {
                    if ((diff_words->last_minus == 0 &&
                            diff_words->current_plus == diff_words->plus.text.ptr) ||
                            (diff_words->current_plus > diff_words->plus.text.ptr &&
                            *(diff_words->current_plus - 1) == '\n')) {
                            return 1;
                    } else {
                            return 0;
                    }
            }

            static void fn_out_diff_words_aux(void *priv,
                                            long minus_first, long minus_len,
                                            long plus_first, long plus_len,
                                            const char *func UNUSED, long funclen UNUSED)
            {
                    struct diff_words_data *diff_words = priv;
                    struct diff_words_style *style = diff_words->style;
                    const char *minus_begin, *minus_end, *plus_begin, *plus_end;
                    struct diff_options *opt = diff_words->opt;
                    const char *line_prefix;

                    assert(opt);
                    line_prefix = diff_line_prefix(opt);

                    /* POSIX requires that first be decremented by one if len == 0... */
                    if (minus_len) {
                            minus_begin = diff_words->minus.orig[minus_first].begin;
                            minus_end =
                                    diff_words->minus.orig[minus_first + minus_len - 1].end;
                    } else
                            minus_begin = minus_end =
                                    diff_words->minus.orig[minus_first].end;

                    if (plus_len) {
                            plus_begin = diff_words->plus.orig[plus_first].begin;
                            plus_end = diff_words->plus.orig[plus_first + plus_len - 1].end;
                    } else
                            plus_begin = plus_end = diff_words->plus.orig[plus_first].end;

                    if (color_words_output_graph_prefix(diff_words)) {
                            fputs(line_prefix, diff_words->opt->file);
                    }
                    if (diff_words->current_plus != plus_begin) {
                            fn_out_diff_words_write_helper(diff_words->opt,
                                            &style->ctx, style->newline,
                                            plus_begin - diff_words->current_plus,
                                            diff_words->current_plus);
                    }
                    if (minus_begin != minus_end) {
                            fn_out_diff_words_write_helper(diff_words->opt,
                                            &style->old_word, style->newline,
                                            minus_end - minus_begin, minus_begin);
                    }
                    if (plus_begin != plus_end) {
                            fn_out_diff_words_write_helper(diff_words->opt,
                                            &style->new_word, style->newline,
                                            plus_end - plus_begin, plus_begin);
                    }

                    diff_words->current_plus = plus_end;
                    diff_words->last_minus = minus_first;
            }

            /* This function starts looking at *begin, and returns 0 iff a word was found. */
            static int find_word_boundaries(mmfile_t *buffer, regex_t *word_regex,
                            int *begin, int *end)
            {
                    while (word_regex && *begin < buffer->size) {
                            regmatch_t match[1];
                            if (!regexec_buf(word_regex, buffer->ptr + *begin,
                                            buffer->size - *begin, 1, match, 0)) {
                                    char *p = memchr(buffer->ptr + *begin + match[0].rm_so,
                                                    '\n', match[0].rm_eo - match[0].rm_so);
                                    *end = p ? p - buffer->ptr : match[0].rm_eo + *begin;
                                    *begin += match[0].rm_so;
                                    if (*begin == *end)
                                            (*begin)++;
                                    else
                                            return *begin > *end;
                            } else {
                                    return -1;
                            }
                    }

                    /* find the next word */
                    while (*begin < buffer->size && isspace(buffer->ptr[*begin]))
                            (*begin)++;
                    if (*begin >= buffer->size)
                            return -1;

                    /* find the end of the word */
                    *end = *begin + 1;
                    while (*end < buffer->size && !isspace(buffer->ptr[*end]))
                            (*end)++;

                    return 0;
            }

            /*
            * This function splits the words in buffer->text, stores the list with
            * newline separator into out, and saves the offsets of the original words
            * in buffer->orig.
            */
            static void diff_words_fill(struct diff_words_buffer *buffer, mmfile_t *out,
                            regex_t *word_regex)
            {
                    int i, j;
                    long alloc = 0;

                    out->size = 0;
                    out->ptr = NULL;

                    /* fake an empty "0th" word */
                    ALLOC_GROW(buffer->orig, 1, buffer->orig_alloc);
                    buffer->orig[0].begin = buffer->orig[0].end = buffer->text.ptr;
                    buffer->orig_nr = 1;

                    for (i = 0; i < buffer->text.size; i++) {
                            if (find_word_boundaries(&buffer->text, word_regex, &i, &j))
                                    return;

                            /* store original boundaries */
                            ALLOC_GROW(buffer->orig, buffer->orig_nr + 1,
                                            buffer->orig_alloc);
                            buffer->orig[buffer->orig_nr].begin = buffer->text.ptr + i;
                            buffer->orig[buffer->orig_nr].end = buffer->text.ptr + j;
                            buffer->orig_nr++;

                            /* store one word */
                            ALLOC_GROW(out->ptr, out->size + j - i + 1, alloc);
                            memcpy(out->ptr + out->size, buffer->text.ptr + i, j - i);
                            out->ptr[out->size + j - i] = '\n';
                            out->size += j - i + 1;

                            i = j - 1;
                    }
            }

            /* this executes the word diff on the accumulated buffers */
            static void diff_words_show(struct diff_words_data *diff_words)
            {
                    xpparam_t xpp;
                    xdemitconf_t xecfg;
                    mmfile_t minus, plus;
                    struct diff_words_style *style = diff_words->style;

                    struct diff_options *opt = diff_words->opt;
                    const char *line_prefix;

                    assert(opt);
                    line_prefix = diff_line_prefix(opt);

                    /* special case: only removal */
                    if (!diff_words->plus.text.size) {
                            emit_diff_symbol(diff_words->opt, DIFF_SYMBOL_WORD_DIFF,
                                            line_prefix, strlen(line_prefix), 0);
                            fn_out_diff_words_write_helper(diff_words->opt,
                                    &style->old_word, style->newline,
                                    diff_words->minus.text.size,
                                    diff_words->minus.text.ptr);
                            diff_words->minus.text.size = 0;
                            return;
                    }

                    diff_words->current_plus = diff_words->plus.text.ptr;
                    diff_words->last_minus = 0;

                    memset(&xpp, 0, sizeof(xpp));
                    memset(&xecfg, 0, sizeof(xecfg));
                    diff_words_fill(&diff_words->minus, &minus, diff_words->word_regex);
                    diff_words_fill(&diff_words->plus, &plus, diff_words->word_regex);
                    xpp.flags = 0;
                    /* as only the hunk header will be parsed, we need a 0-context */
                    xecfg.ctxlen = 0;
                    if (xdi_diff_outf(&minus, &plus, fn_out_diff_words_aux, NULL,
                                    diff_words, &xpp, &xecfg))
                            die("unable to generate word diff");
                    free(minus.ptr);
                    free(plus.ptr);
                    if (diff_words->current_plus != diff_words->plus.text.ptr +
                                    diff_words->plus.text.size) {
                            if (color_words_output_graph_prefix(diff_words))
                                    emit_diff_symbol(diff_words->opt, DIFF_SYMBOL_WORD_DIFF,
                                                    line_prefix, strlen(line_prefix), 0);
                            fn_out_diff_words_write_helper(diff_words->opt,
                                    &style->ctx, style->newline,
                                    diff_words->plus.text.ptr + diff_words->plus.text.size
                                    - diff_words->current_plus, diff_words->current_plus);
                    }
                    diff_words->minus.text.size = diff_words->plus.text.size = 0;
            }

            /* In "color-words" mode, show word-diff of words accumulated in the buffer */
            static void diff_words_flush(struct emit_callback *ecbdata)
            {
                    struct diff_options *wo = ecbdata->diff_words->opt;

                    if (ecbdata->diff_words->minus.text.size ||
                    ecbdata->diff_words->plus.text.size)
                            diff_words_show(ecbdata->diff_words);

                    if (wo->emitted_symbols) {
                            struct diff_options *o = ecbdata->opt;
                            struct emitted_diff_symbols *wol = wo->emitted_symbols;
                            int i;

                            /*
                            * NEEDSWORK:
                            * Instead of appending each, concat all words to a line?
                            */
                            for (i = 0; i < wol->nr; i++)
                                    append_emitted_diff_symbol(o, &wol->buf[i]);

                            for (i = 0; i < wol->nr; i++)
                                    free((void *)wol->buf[i].line);

                            wol->nr = 0;
                    }
            }

            static void diff_filespec_load_driver(struct diff_filespec *one,
                                            struct index_state *istate)
            {
                    /* Use already-loaded driver */
                    if (one->driver)
                            return;

                    if (S_ISREG(one->mode))
                            one->driver = userdiff_find_by_path(istate, one->path);

                    /* Fallback to default settings */
                    if (!one->driver)
                            one->driver = userdiff_find_by_name("default");
            }

            static const char *userdiff_word_regex(struct diff_filespec *one,
                                            struct index_state *istate)
            {
                    diff_filespec_load_driver(one, istate);
                    return one->driver->word_regex;
            }

            static void init_diff_words_data(struct emit_callback *ecbdata,
                                            struct diff_options *orig_opts,
                                            struct diff_filespec *one,
                                            struct diff_filespec *two)
            {
                    int i;
                    struct diff_options *o = xmalloc(sizeof(struct diff_options));
                    memcpy(o, orig_opts, sizeof(struct diff_options));

                    CALLOC_ARRAY(ecbdata->diff_words, 1);
                    ecbdata->diff_words->type = o->word_diff;
                    ecbdata->diff_words->opt = o;

                    if (orig_opts->emitted_symbols)
                            CALLOC_ARRAY(o->emitted_symbols, 1);

                    if (!o->word_regex)
                            o->word_regex = userdiff_word_regex(one, o->repo->index);
                    if (!o->word_regex)
                            o->word_regex = userdiff_word_regex(two, o->repo->index);
                    if (!o->word_regex)
                            o->word_regex = diff_word_regex_cfg;
                    if (o->word_regex) {
                            ecbdata->diff_words->word_regex = (regex_t *)
                                    xmalloc(sizeof(regex_t));
                            if (regcomp(ecbdata->diff_words->word_regex,
                                    o->word_regex,
                                    REG_EXTENDED | REG_NEWLINE))
                                    die("invalid regular expression: %s",
                                    o->word_regex);
                    }
                    for (i = 0; i < ARRAY_SIZE(diff_words_styles); i++) {
                            if (o->word_diff == diff_words_styles[i].type) {
                                    ecbdata->diff_words->style =
                                            &diff_words_styles[i];
                                    break;
                            }
                    }
                    if (want_color(o->use_color)) {
                            struct diff_words_style *st = ecbdata->diff_words->style;
                            st->old_word.color = diff_get_color_opt(o, DIFF_FILE_OLD);
                            st->new_word.color = diff_get_color_opt(o, DIFF_FILE_NEW);
                            st->ctx.color = diff_get_color_opt(o, DIFF_CONTEXT);
                    }
            }

            static void free_diff_words_data(struct emit_callback *ecbdata)
            {
                    if (ecbdata->diff_words) {
                            diff_words_flush(ecbdata);
                            free_emitted_diff_symbols(ecbdata->diff_words->opt->emitted_symbols);
                            free (ecbdata->diff_words->opt);
                            free (ecbdata->diff_words->minus.text.ptr);
                            free (ecbdata->diff_words->minus.orig);
                            free (ecbdata->diff_words->plus.text.ptr);
                            free (ecbdata->diff_words->plus.orig);
                            if (ecbdata->diff_words->word_regex) {
                                    regfree(ecbdata->diff_words->word_regex);
                                    free(ecbdata->diff_words->word_regex);
                            }
                            FREE_AND_NULL(ecbdata->diff_words);
                    }
            }

            const char *diff_get_color(int diff_use_color, enum color_diff ix)
            {
                    if (want_color(diff_use_color))
                            return diff_colors[ix];
                    return "";
            }

            const char *diff_line_prefix(struct diff_options *opt)
            {
                    return opt->output_prefix ?
                            opt->output_prefix(opt, opt->output_prefix_data) :
                            "";
            }

            static unsigned long sane_truncate_line(char *line, unsigned long len)
            {
                    const char *cp;
                    unsigned long allot;
                    size_t l = len;

                    cp = line;
                    allot = l;
                    while (0 < l) {
                            (void) utf8_width(&cp, &l);
                            if (!cp)
                                    break; /* truncated in the middle? */
                    }
                    return allot - l;
            }

            static void find_lno(const char *line, struct emit_callback *ecbdata)
            {
                    const char *p;
                    ecbdata->lno_in_preimage = 0;
                    ecbdata->lno_in_postimage = 0;
                    p = strchr(line, '-');
                    if (!p)
                            return; /* cannot happen */
                    ecbdata->lno_in_preimage = strtol(p + 1, NULL, 10);
                    p = strchr(p, '+');
                    if (!p)
                            return; /* cannot happen */
                    ecbdata->lno_in_postimage = strtol(p + 1, NULL, 10);
            }

            static int fn_out_consume(void *priv, char *line, unsigned long len)
            {
                    struct emit_callback *ecbdata = priv;
                    struct diff_options *o = ecbdata->opt;

                    o->found_changes = 1;

                    if (ecbdata->header) {
                            emit_diff_symbol(o, DIFF_SYMBOL_HEADER,
                                            ecbdata->header->buf, ecbdata->header->len, 0);
                            strbuf_reset(ecbdata->header);
                            ecbdata->header = NULL;
                    }

                    if (ecbdata->label_path[0]) {
                            emit_diff_symbol(o, DIFF_SYMBOL_FILEPAIR_MINUS,
                                            ecbdata->label_path[0],
                                            strlen(ecbdata->label_path[0]), 0);
                            emit_diff_symbol(o, DIFF_SYMBOL_FILEPAIR_PLUS,
                                            ecbdata->label_path[1],
                                            strlen(ecbdata->label_path[1]), 0);
                            ecbdata->label_path[0] = ecbdata->label_path[1] = NULL;
                    }

                    if (diff_suppress_blank_empty
                    && len == 2 && line[0] == ' ' && line[1] == '\n') {
                            line[0] = '\n';
                            len = 1;
                    }

                    if (line[0] == '@') {
                            if (ecbdata->diff_words)
                                    diff_words_flush(ecbdata);
                            len = sane_truncate_line(line, len);
                            find_lno(line, ecbdata);
                            emit_hunk_header(ecbdata, line, len);
                            return 0;
                    }

                    if (ecbdata->diff_words) {
                            enum diff_symbol s =
                                    ecbdata->diff_words->type == DIFF_WORDS_PORCELAIN ?
                                    DIFF_SYMBOL_WORDS_PORCELAIN : DIFF_SYMBOL_WORDS;
                            if (line[0] == '-') {
                                    diff_words_append(line, len,
                                                    &ecbdata->diff_words->minus);
                                    return 0;
                            } else if (line[0] == '+') {
                                    diff_words_append(line, len,
                                                    &ecbdata->diff_words->plus);
                                    return 0;
                            } else if (starts_with(line, "\\ ")) {
                                    /*
                                    * Eat the "no newline at eof" marker as if we
                                    * saw a "+" or "-" line with nothing on it,
                                    * and return without diff_words_flush() to
                                    * defer processing. If this is the end of
                                    * preimage, more "+" lines may come after it.
                                    */
                                    return 0;
                            }
                            diff_words_flush(ecbdata);
                            emit_diff_symbol(o, s, line, len, 0);
                            return 0;
                    }

                    switch (line[0]) {
                    case '+':
                            ecbdata->lno_in_postimage++;
                            emit_add_line(ecbdata, line + 1, len - 1);
                            break;
                    case '-':
                            ecbdata->lno_in_preimage++;
                            emit_del_line(ecbdata, line + 1, len - 1);
                            break;
                    case ' ':
                            ecbdata->lno_in_postimage++;
                            ecbdata->lno_in_preimage++;
                            emit_context_line(ecbdata, line + 1, len - 1);
                            break;
                    default:
                            /* incomplete line at the end */
                            ecbdata->lno_in_preimage++;
                            emit_diff_symbol(o, DIFF_SYMBOL_CONTEXT_INCOMPLETE,
                                            line, len, 0);
                            break;
                    }
                    return 0;
            }

            static void pprint_rename(struct strbuf *name, const char *a, const char *b)
            {
                    const char *old_name = a;
                    const char *new_name = b;
                    int pfx_length, sfx_length;
                    int pfx_adjust_for_slash;
                    int len_a = strlen(a);
                    int len_b = strlen(b);
                    int a_midlen, b_midlen;
                    int qlen_a = quote_c_style(a, NULL, NULL, 0);
                    int qlen_b = quote_c_style(b, NULL, NULL, 0);

                    if (qlen_a || qlen_b) {
                            quote_c_style(a, name, NULL, 0);
                            strbuf_addstr(name, " => ");
                            quote_c_style(b, name, NULL, 0);
                            return;
                    }

                    /* Find common prefix */
                    pfx_length = 0;
                    while (*old_name && *new_name && *old_name == *new_name) {
                            if (*old_name == '/')
                                    pfx_length = old_name - a + 1;
                            old_name++;
                            new_name++;
                    }

                    /* Find common suffix */
                    old_name = a + len_a;
                    new_name = b + len_b;
                    sfx_length = 0;
                    /*
                    * If there is a common prefix, it must end in a slash.  In
                    * that case we let this loop run 1 into the prefix to see the
                    * same slash.
                    *
                    * If there is no common prefix, we cannot do this as it would
                    * underrun the input strings.
                    */
                    pfx_adjust_for_slash = (pfx_length ? 1 : 0);
                    while (a + pfx_length - pfx_adjust_for_slash <= old_name &&
                    b + pfx_length - pfx_adjust_for_slash <= new_name &&
                    *old_name == *new_name) {
                            if (*old_name == '/')
                                    sfx_length = len_a - (old_name - a);
                            old_name--;
                            new_name--;
                    }

                    /*
                    * pfx{mid-a => mid-b}sfx
                    * {pfx-a => pfx-b}sfx
                    * pfx{sfx-a => sfx-b}
                    * name-a => name-b
                    */
                    a_midlen = len_a - pfx_length - sfx_length;
                    b_midlen = len_b - pfx_length - sfx_length;
                    if (a_midlen < 0)
                            a_midlen = 0;
                    if (b_midlen < 0)
                            b_midlen = 0;

                    strbuf_grow(name, pfx_length + a_midlen + b_midlen + sfx_length + 7);
                    if (pfx_length + sfx_length) {
                            strbuf_add(name, a, pfx_length);
                            strbuf_addch(name, '{');
                    }
                    strbuf_add(name, a + pfx_length, a_midlen);
                    strbuf_addstr(name, " => ");
                    strbuf_add(name, b + pfx_length, b_midlen);
                    if (pfx_length + sfx_length) {
                            strbuf_addch(name, '}');
                            strbuf_add(name, a + len_a - sfx_length, sfx_length);
                    }
            }

            static struct diffstat_file *diffstat_add(struct diffstat_t *diffstat,
                                                    const char *name_a,
                                                    const char *name_b)
            {
                    struct diffstat_file *x;
                    CALLOC_ARRAY(x, 1);
                    ALLOC_GROW(diffstat->files, diffstat->nr + 1, diffstat->alloc);
                    diffstat->files[diffstat->nr++] = x;
                    if (name_b) {
                            x->from_name = xstrdup(name_a);
                            x->name = xstrdup(name_b);
                            x->is_renamed = 1;
                    }
                    else {
                            x->from_name = NULL;
                            x->name = xstrdup(name_a);
                    }
                    return x;
            }

            static int diffstat_consume(void *priv, char *line, unsigned long len)
            {
                    struct diffstat_t *diffstat = priv;
                    struct diffstat_file *x = diffstat->files[diffstat->nr - 1];

                    if (!len)
                            BUG("xdiff fed us an empty line");

                    if (line[0] == '+')
                            x->added++;
                    else if (line[0] == '-')
                            x->deleted++;
                    return 0;
            }

            const char mime_boundary_leader[] = "------------";

            static int scale_linear(int it, int width, int max_change)
            {
                    if (!it)
                            return 0;
                    /*
                    * make sure that at least one '-' or '+' is printed if
                    * there is any change to this path. The easiest way is to
                    * scale linearly as if the allotted width is one column shorter
                    * than it is, and then add 1 to the result.
                    */
                    return 1 + (it * (width - 1) / max_change);
            }

            static void show_graph(struct strbuf *out, char ch, int cnt,
                            const char *set, const char *reset)
            {
                    if (cnt <= 0)
                            return;
                    strbuf_addstr(out, set);
                    strbuf_addchars(out, ch, cnt);
                    strbuf_addstr(out, reset);
            }

            static void fill_print_name(struct diffstat_file *file)
            {
                    struct strbuf pname = STRBUF_INIT;

                    if (file->print_name)
                            return;

                    if (file->is_renamed)
                            pprint_rename(&pname, file->from_name, file->name);
                    else
                            quote_c_style(file->name, &pname, NULL, 0);

                    if (file->comments)
                            strbuf_addf(&pname, " (%s)", file->comments);

                    file->print_name = strbuf_detach(&pname, NULL);
            }

            static void print_stat_summary_inserts_deletes(struct diff_options *options,
                            int files, int insertions, int deletions)
            {
                    struct strbuf sb = STRBUF_INIT;

                    if (!files) {
                            assert(insertions == 0 && deletions == 0);
                            emit_diff_symbol(options, DIFF_SYMBOL_STATS_SUMMARY_NO_FILES,
                                            NULL, 0, 0);
                            return;
                    }

                    strbuf_addf(&sb,
                            (files == 1) ? " %d file changed" : " %d files changed",
                            files);

                    /*
                    * For binary diff, the caller may want to print "x files
                    * changed" with insertions == 0 && deletions == 0.
                    *
                    * Not omitting "0 insertions(+), 0 deletions(-)" in this case
                    * is probably less confusing (i.e skip over "2 files changed
                    * but nothing about added/removed lines? Is this a bug in Git?").
                    */
                    if (insertions || deletions == 0) {
                            strbuf_addf(&sb,
                                    (insertions == 1) ? ", %d insertion(+)" : ", %d insertions(+)",
                                    insertions);
                    }

                    if (deletions || insertions == 0) {
                            strbuf_addf(&sb,
                                    (deletions == 1) ? ", %d deletion(-)" : ", %d deletions(-)",
                                    deletions);
                    }
                    strbuf_addch(&sb, '\n');
                    emit_diff_symbol(options, DIFF_SYMBOL_STATS_SUMMARY_INSERTS_DELETES,
                                    sb.buf, sb.len, 0);
                    strbuf_release(&sb);
            }

            void print_stat_summary(FILE *fp, int files,
                                    int insertions, int deletions)
            {
                    struct diff_options o;
                    memset(&o, 0, sizeof(o));
                    o.file = fp;

                    print_stat_summary_inserts_deletes(&o, files, insertions, deletions);
            }

            static void show_stats(struct diffstat_t *data, struct diff_options *options)
            {
                    int i, len, add, del, adds = 0, dels = 0;
                    uintmax_t max_change = 0, max_len = 0;
                    int total_files = data->nr, count;
                    int width, name_width, graph_width, number_width = 0, bin_width = 0;
                    const char *reset, *add_c, *del_c;
                    int extra_shown = 0;
                    const char *line_prefix = diff_line_prefix(options);
                    struct strbuf out = STRBUF_INIT;

                    if (data->nr == 0)
                            return;

                    count = options->stat_count ? options->stat_count : data->nr;

                    reset = diff_get_color_opt(options, DIFF_RESET);
                    add_c = diff_get_color_opt(options, DIFF_FILE_NEW);
                    del_c = diff_get_color_opt(options, DIFF_FILE_OLD);

                    /*
                    * Find the longest filename and max number of changes
                    */
                    for (i = 0; (i < count) && (i < data->nr); i++) {
                            struct diffstat_file *file = data->files[i];
                            uintmax_t change = file->added + file->deleted;

                            if (!file->is_interesting && (change == 0)) {
                                    count++; /* not shown == room for one more */
                                    continue;
                            }
                            fill_print_name(file);
                            len = utf8_strwidth(file->print_name);
                            if (max_len < len)
                                    max_len = len;

                            if (file->is_unmerged) {
                                    /* "Unmerged" is 8 characters */
                                    bin_width = bin_width < 8 ? 8 : bin_width;
                                    continue;
                            }
                            if (file->is_binary) {
                                    /* "Bin XXX -> YYY bytes" */
                                    int w = 14 + decimal_width(file->added)
                                            + decimal_width(file->deleted);
                                    bin_width = bin_width < w ? w : bin_width;
                                    /* Display change counts aligned with "Bin" */
                                    number_width = 3;
                                    continue;
                            }

                            if (max_change < change)
                                    max_change = change;
                    }
                    count = i; /* where we can stop scanning in data->files[] */

                    /*
                    * We have width = stat_width or term_columns() columns total.
                    * We want a maximum of min(max_len, stat_name_width) for the name part.
                    * We want a maximum of min(max_change, stat_graph_width) for the +- part.
                    * We also need 1 for " " and 4 + decimal_width(max_change)
                    * for " | NNNN " and one the empty column at the end, altogether
                    * 6 + decimal_width(max_change).
                    *
                    * If there's not enough space, we will use the smaller of
                    * stat_name_width (if set) and 5/8*width for the filename,
                    * and the rest for constant elements + graph part, but no more
                    * than stat_graph_width for the graph part.
                    * (5/8 gives 50 for filename and 30 for the constant parts + graph
                    * for the standard terminal size).
                    *
                    * In other words: stat_width limits the maximum width, and
                    * stat_name_width fixes the maximum width of the filename,
                    * and is also used to divide available columns if there
                    * aren't enough.
                    *
                    * Binary files are displayed with "Bin XXX -> YYY bytes"
                    * instead of the change count and graph. This part is treated
                    * similarly to the graph part, except that it is not
                    * "scaled". If total width is too small to accommodate the
                    * guaranteed minimum width of the filename part and the
                    * separators and this message, this message will "overflow"
                    * making the line longer than the maximum width.
                    */

                    /*
                    * NEEDSWORK: line_prefix is often used for "log --graph" output
                    * and contains ANSI-colored string.  utf8_strnwidth() should be
                    * used to correctly count the display width instead of strlen().
                    */
                    if (options->stat_width == -1)
                            width = term_columns() - strlen(line_prefix);
                    else
                            width = options->stat_width ? options->stat_width : 80;
                    number_width = decimal_width(max_change) > number_width ?
                            decimal_width(max_change) : number_width;

                    if (options->stat_name_width == -1)
                            options->stat_name_width = diff_stat_name_width;
                    if (options->stat_graph_width == -1)
                            options->stat_graph_width = diff_stat_graph_width;

                    /*
                    * Guarantee 3/8*16 == 6 for the graph part
                    * and 5/8*16 == 10 for the filename part
                    */
                    if (width < 16 + 6 + number_width)
                            width = 16 + 6 + number_width;

                    /*
                    * First assign sizes that are wanted, ignoring available width.
                    * strlen("Bin XXX -> YYY bytes") == bin_width, and the part
                    * starting from "XXX" should fit in graph_width.
                    */
                    graph_width = max_change + 4 > bin_width ? max_change : bin_width - 4;
                    if (options->stat_graph_width &&
                    options->stat_graph_width < graph_width)
                            graph_width = options->stat_graph_width;

                    name_width = (options->stat_name_width > 0 &&
                            options->stat_name_width < max_len) ?
                            options->stat_name_width : max_len;

                    /*
                    * Adjust adjustable widths not to exceed maximum width
                    */
                    if (name_width + number_width + 6 + graph_width > width) {
                            if (graph_width > width * 3/8 - number_width - 6) {
                                    graph_width = width * 3/8 - number_width - 6;
                                    if (graph_width < 6)
                                            graph_width = 6;
                            }

                            if (options->stat_graph_width &&
                            graph_width > options->stat_graph_width)
                                    graph_width = options->stat_graph_width;
                            if (name_width > width - number_width - 6 - graph_width)
                                    name_width = width - number_width - 6 - graph_width;
                            else
                                    graph_width = width - number_width - 6 - name_width;
                    }

                    /*
                    * From here name_width is the width of the name area,
                    * and graph_width is the width of the graph area.
                    * max_change is used to scale graph properly.
                    */
                    for (i = 0; i < count; i++) {
                            const char *prefix = "";
                            struct diffstat_file *file = data->files[i];
                            char *name = file->print_name;
                            uintmax_t added = file->added;
                            uintmax_t deleted = file->deleted;
                            int name_len, padding;

                            if (!file->is_interesting && (added + deleted == 0))
                                    continue;

                            /*
                            * "scale" the filename
                            */
                            len = name_width;
                            name_len = utf8_strwidth(name);
                            if (name_width < name_len) {
                                    char *slash;
                                    prefix = "...";
                                    len -= 3;
                                    /*
                                    * NEEDSWORK: (name_len - len) counts the display
                                    * width, which would be shorter than the byte
                                    * length of the corresponding substring.
                                    * Advancing "name" by that number of bytes does
                                    * *NOT* skip over that many columns, so it is
                                    * very likely that chomping the pathname at the
                                    * slash we will find starting from "name" will
                                    * leave the resulting string still too long.
                                    */
                                    name += name_len - len;
                                    slash = strchr(name, '/');
                                    if (slash)
                                            name = slash;
                            }
                            padding = len - utf8_strwidth(name);
                            if (padding < 0)
                                    padding = 0;

                            if (file->is_binary) {
                                    strbuf_addf(&out, " %s%s%*s | %*s",
                                            prefix, name, padding, "",
                                            number_width, "Bin");
                                    if (!added && !deleted) {
                                            strbuf_addch(&out, '\n');
                                            emit_diff_symbol(options, DIFF_SYMBOL_STATS_LINE,
                                                            out.buf, out.len, 0);
                                            strbuf_reset(&out);
                                            continue;
                                    }
                                    strbuf_addf(&out, " %s%"PRIuMAX"%s",
                                            del_c, deleted, reset);
                                    strbuf_addstr(&out, " -> ");
                                    strbuf_addf(&out, "%s%"PRIuMAX"%s",
                                            add_c, added, reset);
                                    strbuf_addstr(&out, " bytes\n");
                                    emit_diff_symbol(options, DIFF_SYMBOL_STATS_LINE,
                                                    out.buf, out.len, 0);
                                    strbuf_reset(&out);
                                    continue;
                            }
                            else if (file->is_unmerged) {
                                    strbuf_addf(&out, " %s%s%*s | %*s",
                                            prefix, name, padding, "",
                                            number_width, "Unmerged\n");
                                    emit_diff_symbol(options, DIFF_SYMBOL_STATS_LINE,
                                                    out.buf, out.len, 0);
                                    strbuf_reset(&out);
                                    continue;
                            }

                            /*
                            * scale the add/delete
                            */
                            add = added;
                            del = deleted;

                            if (graph_width <= max_change) {
                                    int total = scale_linear(add + del, graph_width, max_change);
                                    if (total < 2 && add && del)
                                            /* width >= 2 due to the sanity check */
                                            total = 2;
                                    if (add < del) {
                                            add = scale_linear(add, graph_width, max_change);
                                            del = total - add;
                                    } else {
                                            del = scale_linear(del, graph_width, max_change);
                                            add = total - del;
                                    }
                            }
                            strbuf_addf(&out, " %s%s%*s | %*"PRIuMAX"%s",
                                    prefix, name, padding, "",
                                    number_width, added + deleted,
                                    added + deleted ? " " : "");
                            show_graph(&out, '+', add, add_c, reset);
                            show_graph(&out, '-', del, del_c, reset);
                            strbuf_addch(&out, '\n');
                            emit_diff_symbol(options, DIFF_SYMBOL_STATS_LINE,
                                            out.buf, out.len, 0);
                            strbuf_reset(&out);
                    }

                    for (i = 0; i < data->nr; i++) {
                            struct diffstat_file *file = data->files[i];
                            uintmax_t added = file->added;
                            uintmax_t deleted = file->deleted;

                            if (file->is_unmerged ||
                            (!file->is_interesting && (added + deleted == 0))) {
                                    total_files--;
                                    continue;
                            }

                            if (!file->is_binary) {
                                    adds += added;
                                    dels += deleted;
                            }
                            if (i < count)
                                    continue;
                            if (!extra_shown)
                                    emit_diff_symbol(options,
                                                    DIFF_SYMBOL_STATS_SUMMARY_ABBREV,
                                                    NULL, 0, 0);
                            extra_shown = 1;
                    }

                    print_stat_summary_inserts_deletes(options, total_files, adds, dels);
                    strbuf_release(&out);
            }

            static void show_shortstats(struct diffstat_t *data, struct diff_options *options)
            {
                    int i, adds = 0, dels = 0, total_files = data->nr;

                    if (data->nr == 0)
                            return;

                    for (i = 0; i < data->nr; i++) {
                            int added = data->files[i]->added;
                            int deleted = data->files[i]->deleted;

                            if (data->files[i]->is_unmerged ||
                            (!data->files[i]->is_interesting && (added + deleted == 0))) {
                                    total_files--;
                            } else if (!data->files[i]->is_binary) { /* don't count bytes */
                                    adds += added;
                                    dels += deleted;
                            }
                    }
                    print_stat_summary_inserts_deletes(options, total_files, adds, dels);
            }

            static void show_numstat(struct diffstat_t *data, struct diff_options *options)
            {
                    int i;

                    if (data->nr == 0)
                            return;

                    for (i = 0; i < data->nr; i++) {
                            struct diffstat_file *file = data->files[i];

                            fprintf(options->file, "%s", diff_line_prefix(options));

                            if (file->is_binary)
                                    fprintf(options->file, "-\t-\t");
                            else
                                    fprintf(options->file,
                                            "%"PRIuMAX"\t%"PRIuMAX"\t",
                                            file->added, file->deleted);
                            if (options->line_termination) {
                                    fill_print_name(file);
                                    if (!file->is_renamed)
                                            write_name_quoted(file->name, options->file,
                                                            options->line_termination);
                                    else {
                                            fputs(file->print_name, options->file);
                                            putc(options->line_termination, options->file);
                                    }
                            } else {
                                    if (file->is_renamed) {
                                            putc('\0', options->file);
                                            write_name_quoted(file->from_name, options->file, '\0');
                                    }
                                    write_name_quoted(file->name, options->file, '\0');
                            }
                    }
            }

            struct dirstat_file {
                    const char *name;
                    unsigned long changed;
            };

            struct dirstat_dir {
                    struct dirstat_file *files;
                    int alloc, nr, permille, cumulative;
            };

            static long gather_dirstat(struct diff_options *opt, struct dirstat_dir *dir,
                            unsigned long changed, const char *base, int baselen)
            {
                    unsigned long sum_changes = 0;
                    unsigned int sources = 0;
                    const char *line_prefix = diff_line_prefix(opt);

                    while (dir->nr) {
                            struct dirstat_file *f = dir->files;
                            int namelen = strlen(f->name);
                            unsigned long changes;
                            char *slash;

                            if (namelen < baselen)
                                    break;
                            if (memcmp(f->name, base, baselen))
                                    break;
                            slash = strchr(f->name + baselen, '/');
                            if (slash) {
                                    int newbaselen = slash + 1 - f->name;
                                    changes = gather_dirstat(opt, dir, changed, f->name, newbaselen);
                                    sources++;
                            } else {
                                    changes = f->changed;
                                    dir->files++;
                                    dir->nr--;
                                    sources += 2;
                            }
                            sum_changes += changes;
                    }

                    /*
                    * We don't report dirstat's for
                    *  - the top level
                    *  - or cases where everything came from a single directory
                    *    under this directory (sources == 1).
                    */
                    if (baselen && sources != 1) {
                            if (sum_changes) {
                                    int permille = sum_changes * 1000 / changed;
                                    if (permille >= dir->permille) {
                                            fprintf(opt->file, "%s%4d.%01d%% %.*s\n", line_prefix,
                                                    permille / 10, permille % 10, baselen, base);
                                            if (!dir->cumulative)
                                                    return 0;
                                    }
                            }
                    }
                    return sum_changes;
            }

            static int dirstat_compare(const void *_a, const void *_b)
            {
                    const struct dirstat_file *a = _a;
                    const struct dirstat_file *b = _b;
                    return strcmp(a->name, b->name);
            }

            static void conclude_dirstat(struct diff_options *options,
                                    struct dirstat_dir *dir,
                                    unsigned long changed)
            {
                    struct dirstat_file *to_free = dir->files;

                    if (!changed) {
                            /* This can happen even with many files, if everything was renames */
                            ;
                    } else {
                            /* Show all directories with more than x% of the changes */
                            QSORT(dir->files, dir->nr, dirstat_compare);
                            gather_dirstat(options, dir, changed, "", 0);
                    }

                    free(to_free);
            }

            static void show_dirstat(struct diff_options *options)
            {
                    int i;
                    unsigned long changed;
                    struct dirstat_dir dir;
                    struct diff_queue_struct *q = &diff_queued_diff;

                    dir.files = NULL;
                    dir.alloc = 0;
                    dir.nr = 0;
                    dir.permille = options->dirstat_permille;
                    dir.cumulative = options->flags.dirstat_cumulative;

                    changed = 0;
                    for (i = 0; i < q->nr; i++) {
                            struct diff_filepair *p = q->queue[i];
                            const char *name;
                            unsigned long copied, added, damage;
                            struct diff_populate_filespec_options dpf_options = {
                                    .check_size_only = 1,
                            };

                            name = p->two->path ? p->two->path : p->one->path;

                            if (p->one->oid_valid && p->two->oid_valid &&
                            oideq(&p->one->oid, &p->two->oid)) {
                                    /*
                                    * The SHA1 has not changed, so pre-/post-content is
                                    * identical. We can therefore skip looking at the
                                    * file contents altogether.
                                    */
                                    damage = 0;
                                    goto found_damage;
                            }

                            if (options->flags.dirstat_by_file) {
                                    /*
                                    * In --dirstat-by-file mode, we don't really need to
                                    * look at the actual file contents at all.
                                    * The fact that the SHA1 changed is enough for us to
                                    * add this file to the list of results
                                    * (with each file contributing equal damage).
                                    */
                                    damage = 1;
                                    goto found_damage;
                            }

                            if (DIFF_FILE_VALID(p->one) && DIFF_FILE_VALID(p->two)) {
                                    diff_populate_filespec(options->repo, p->one, NULL);
                                    diff_populate_filespec(options->repo, p->two, NULL);
                                    diffcore_count_changes(options->repo,
                                                    p->one, p->two, NULL, NULL,
                                                    &copied, &added);
                                    diff_free_filespec_data(p->one);
                                    diff_free_filespec_data(p->two);
                            } else if (DIFF_FILE_VALID(p->one)) {
                                    diff_populate_filespec(options->repo, p->one, &dpf_options);
                                    copied = added = 0;
                                    diff_free_filespec_data(p->one);
                            } else if (DIFF_FILE_VALID(p->two)) {
                                    diff_populate_filespec(options->repo, p->two, &dpf_options);
                                    copied = 0;
                                    added = p->two->size;
                                    diff_free_filespec_data(p->two);
                            } else
                                    continue;

                            /*
                            * Original minus copied is the removed material,
                            * added is the new material.  They are both damages
                            * made to the preimage.
                            * If the resulting damage is zero, we know that
                            * diffcore_count_changes() considers the two entries to
                            * be identical, but since the oid changed, we
                            * know that there must have been _some_ kind of change,
                            * so we force all entries to have damage > 0.
                            */
                            damage = (p->one->size - copied) + added;
                            if (!damage)
                                    damage = 1;

            found_damage:
                            ALLOC_GROW(dir.files, dir.nr + 1, dir.alloc);
                            dir.files[dir.nr].name = name;
                            dir.files[dir.nr].changed = damage;
                            changed += damage;
                            dir.nr++;
                    }

                    conclude_dirstat(options, &dir, changed);
            }

            static void show_dirstat_by_line(struct diffstat_t *data, struct diff_options *options)
            {
                    int i;
                    unsigned long changed;
                    struct dirstat_dir dir;

                    if (data->nr == 0)
                            return;

                    dir.files = NULL;
                    dir.alloc = 0;
                    dir.nr = 0;
                    dir.permille = options->dirstat_permille;
                    dir.cumulative = options->flags.dirstat_cumulative;

                    changed = 0;
                    for (i = 0; i < data->nr; i++) {
                            struct diffstat_file *file = data->files[i];
                            unsigned long damage = file->added + file->deleted;
                            if (file->is_binary)
                                    /*
                                    * binary files counts bytes, not lines. Must find some
                                    * way to normalize binary bytes vs. textual lines.
                                    * The following heuristic assumes that there are 64
                                    * bytes per "line".
                                    * This is stupid and ugly, but very cheap...
                                    */
                                    damage = DIV_ROUND_UP(damage, 64);
                            ALLOC_GROW(dir.files, dir.nr + 1, dir.alloc);
                            dir.files[dir.nr].name = file->name;
                            dir.files[dir.nr].changed = damage;
                            changed += damage;
                            dir.nr++;
                    }

                    conclude_dirstat(options, &dir, changed);
            }

            static void free_diffstat_file(struct diffstat_file *f)
            {
                    free(f->print_name);
                    free(f->name);
                    free(f->from_name);
                    free(f);
            }

            void free_diffstat_info(struct diffstat_t *diffstat)
            {
                    int i;
                    for (i = 0; i < diffstat->nr; i++)
                            free_diffstat_file(diffstat->files[i]);
                    free(diffstat->files);
            }

            struct checkdiff_t {
                    const char *filename;
                    int lineno;
                    int conflict_marker_size;
                    struct diff_options *o;
                    unsigned ws_rule;
                    unsigned status;
            };

            static int is_conflict_marker(const char *line, int marker_size, unsigned long len)
            {
                    char firstchar;
                    int cnt;

                    if (len < marker_size + 1)
                            return 0;
                    firstchar = line[0];
                    switch (firstchar) {
                    case '=': case '>': case '<': case '|':
                            break;
                    default:
                            return 0;
                    }
                    for (cnt = 1; cnt < marker_size; cnt++)
                            if (line[cnt] != firstchar)
                                    return 0;
                    /* line[1] through line[marker_size-1] are same as firstchar */
                    if (len < marker_size + 1 || !isspace(line[marker_size]))
                            return 0;
                    return 1;
            }

            static void checkdiff_consume_hunk(void *priv,
                                            long ob UNUSED, long on UNUSED,
                                            long nb, long nn UNUSED,
                                            const char *func UNUSED, long funclen UNUSED)

            {
                    struct checkdiff_t *data = priv;
                    data->lineno = nb - 1;
            }

            static int checkdiff_consume(void *priv, char *line, unsigned long len)
            {
                    struct checkdiff_t *data = priv;
                    int marker_size = data->conflict_marker_size;
                    const char *ws = diff_get_color(data->o->use_color, DIFF_WHITESPACE);
                    const char *reset = diff_get_color(data->o->use_color, DIFF_RESET);
                    const char *set = diff_get_color(data->o->use_color, DIFF_FILE_NEW);
                    char *err;
                    const char *line_prefix;

                    assert(data->o);
                    line_prefix = diff_line_prefix(data->o);

                    if (line[0] == '+') {
                            unsigned bad;
                            data->lineno++;
                            if (is_conflict_marker(line + 1, marker_size, len - 1)) {
                                    data->status |= 1;
                                    fprintf(data->o->file,
                                            "%s%s:%d: leftover conflict marker\n",
                                            line_prefix, data->filename, data->lineno);
                            }
                            bad = ws_check(line + 1, len - 1, data->ws_rule);
                            if (!bad)
                                    return 0;
                            data->status |= bad;
                            err = whitespace_error_string(bad);
                            fprintf(data->o->file, "%s%s:%d: %s.\n",
                                    line_prefix, data->filename, data->lineno, err);
                            free(err);
                            emit_line(data->o, set, reset, line, 1);
                            ws_check_emit(line + 1, len - 1, data->ws_rule,
                                    data->o->file, set, reset, ws);
                    } else if (line[0] == ' ') {
                            data->lineno++;
                    }
                    return 0;
            }

            static unsigned char *deflate_it(char *data,
                                            unsigned long size,
                                            unsigned long *result_size)
            {
                    int bound;
                    unsigned char *deflated;
                    git_zstream stream;

                    git_deflate_init(&stream, zlib_compression_level);
                    bound = git_deflate_bound(&stream, size);
                    deflated = xmalloc(bound);
                    stream.next_out = deflated;
                    stream.avail_out = bound;

                    stream.next_in = (unsigned char *)data;
                    stream.avail_in = size;
                    while (git_deflate(&stream, Z_FINISH) == Z_OK)
                            ; /* nothing */
                    git_deflate_end(&stream);
                    *result_size = stream.total_out;
                    return deflated;
            }

            static void emit_binary_diff_body(struct diff_options *o,
                                            mmfile_t *one, mmfile_t *two)
            {
                    void *cp;
                    void *delta;
                    void *deflated;
                    void *data;
                    unsigned long orig_size;
                    unsigned long delta_size;
                    unsigned long deflate_size;
                    unsigned long data_size;

                    /* We could do deflated delta, or we could do just deflated two,
                    * whichever is smaller.
                    */
                    delta = NULL;
                    deflated = deflate_it(two->ptr, two->size, &deflate_size);
                    if (one->size && two->size) {
                            delta = diff_delta(one->ptr, one->size,
                                            two->ptr, two->size,
                                            &delta_size, deflate_size);
                            if (delta) {
                                    void *to_free = delta;
                                    orig_size = delta_size;
                                    delta = deflate_it(delta, delta_size, &delta_size);
                                    free(to_free);
                            }
                    }

                    if (delta && delta_size < deflate_size) {
                            char *s = xstrfmt("%"PRIuMAX , (uintmax_t)orig_size);
                            emit_diff_symbol(o, DIFF_SYMBOL_BINARY_DIFF_HEADER_DELTA,
                                            s, strlen(s), 0);
                            free(s);
                            free(deflated);
                            data = delta;
                            data_size = delta_size;
                    } else {
                            char *s = xstrfmt("%lu", two->size);
                            emit_diff_symbol(o, DIFF_SYMBOL_BINARY_DIFF_HEADER_LITERAL,
                                            s, strlen(s), 0);
                            free(s);
                            free(delta);
                            data = deflated;
                            data_size = deflate_size;
                    }

                    /* emit data encoded in base85 */
                    cp = data;
                    while (data_size) {
                            int len;
                            int bytes = (52 < data_size) ? 52 : data_size;
                            char line[71];
                            data_size -= bytes;
                            if (bytes <= 26)
                                    line[0] = bytes + 'A' - 1;
                            else
                                    line[0] = bytes - 26 + 'a' - 1;
                            encode_85(line + 1, cp, bytes);
                            cp = (char *) cp + bytes;

                            len = strlen(line);
                            line[len++] = '\n';
                            line[len] = '\0';

                            emit_diff_symbol(o, DIFF_SYMBOL_BINARY_DIFF_BODY,
                                            line, len, 0);
                    }
                    emit_diff_symbol(o, DIFF_SYMBOL_BINARY_DIFF_FOOTER, NULL, 0, 0);
                    free(data);
            }

            static void emit_binary_diff(struct diff_options *o,
                                    mmfile_t *one, mmfile_t *two)
            {
                    emit_diff_symbol(o, DIFF_SYMBOL_BINARY_DIFF_HEADER, NULL, 0, 0);
                    emit_binary_diff_body(o, one, two);
                    emit_binary_diff_body(o, two, one);
            }

            int diff_filespec_is_binary(struct repository *r,
                                    struct diff_filespec *one)
            {
                    struct diff_populate_filespec_options dpf_options = {
                            .check_binary = 1,
                    };

                    if (one->is_binary == -1) {
                            diff_filespec_load_driver(one, r->index);
                            if (one->driver->binary != -1)
                                    one->is_binary = one->driver->binary;
                            else {
                                    if (!one->data && DIFF_FILE_VALID(one))
                                            diff_populate_filespec(r, one, &dpf_options);
                                    if (one->is_binary == -1 && one->data)
                                            one->is_binary = buffer_is_binary(one->data,
                                                            one->size);
                                    if (one->is_binary == -1)
                                            one->is_binary = 0;
                            }
                    }
                    return one->is_binary;
            }

            static const struct userdiff_funcname *
            diff_funcname_pattern(struct diff_options *o, struct diff_filespec *one)
            {
                    diff_filespec_load_driver(one, o->repo->index);
                    return one->driver->funcname.pattern ? &one->driver->funcname : NULL;
            }

            void diff_set_mnemonic_prefix(struct diff_options *options, const char *a, const char *b)
            {
                    if (!options->a_prefix)
                            options->a_prefix = a;
                    if (!options->b_prefix)
                            options->b_prefix = b;
            }

            void diff_set_noprefix(struct diff_options *options)
            {
                    options->a_prefix = options->b_prefix = "";
            }

            void diff_set_default_prefix(struct diff_options *options)
            {
                    options->a_prefix = diff_src_prefix ? diff_src_prefix : "a/";
                    options->b_prefix = diff_dst_prefix ? diff_dst_prefix : "b/";
            }

            struct userdiff_driver *get_textconv(struct repository *r,
                                            struct diff_filespec *one)
            {
                    if (!DIFF_FILE_VALID(one))
                            return NULL;

                    diff_filespec_load_driver(one, r->index);
                    return userdiff_get_textconv(r, one->driver);
            }

            static struct string_list *additional_headers(struct diff_options *o,
                                                    const char *path)
            {
                    if (!o->additional_path_headers)
                            return NULL;
                    return strmap_get(o->additional_path_headers, path);
            }

            static void add_formatted_header(struct strbuf *msg,
                                            const char *header,
                                            const char *line_prefix,
                                            const char *meta,
                                            const char *reset)
            {
                    const char *next, *newline;

                    for (next = header; *next; next = newline) {
                            newline = strchrnul(next, '\n');
                            strbuf_addf(msg, "%s%s%.*s%s\n", line_prefix, meta,
                                    (int)(newline - next), next, reset);
                            if (*newline)
                                    newline++;
                    }
            }

            static void add_formatted_headers(struct strbuf *msg,
                                            struct string_list *more_headers,
                                            const char *line_prefix,
                                            const char *meta,
                                            const char *reset)
            {
                    int i;

                    for (i = 0; i < more_headers->nr; i++)
                            add_formatted_header(msg, more_headers->items[i].string,
                                            line_prefix, meta, reset);
            }

            static int diff_filepair_is_phoney(struct diff_filespec *one,
                                            struct diff_filespec *two)
            {
                    /*
                    * This function specifically looks for pairs injected by
                    * create_filepairs_for_header_only_notifications().  Such
                    * pairs are "phoney" in that they do not represent any
                    * content or even mode difference, but were inserted because
                    * diff_queued_diff previously had no pair associated with
                    * that path but we needed some pair to avoid losing the
                    * "remerge CONFLICT" header associated with the path.
                    */
                    return !DIFF_FILE_VALID(one) && !DIFF_FILE_VALID(two);
            }

            static int set_diff_algorithm(struct diff_options *opts,
                                    const char *alg)
            {
                    long value = parse_algorithm_value(alg);

                    if (value < 0)
                            return -1;

                    /* clear out previous settings */
                    DIFF_XDL_CLR(opts, NEED_MINIMAL);
                    opts->xdl_opts &= ~XDF_DIFF_ALGORITHM_MASK;
                    opts->xdl_opts |= value;

                    return 0;
            }

            static void builtin_diff(const char *name_a,
                                    const char *name_b,
                                    struct diff_filespec *one,
                                    struct diff_filespec *two,
                                    const char *xfrm_msg,
                                    int must_show_header,
                                    struct diff_options *o,
                                    int complete_rewrite)
            {
                    mmfile_t mf1, mf2;
                    const char *lbl[2];
                    char *a_one, *b_two;
                    const char *meta = diff_get_color_opt(o, DIFF_METAINFO);
                    const char *reset = diff_get_color_opt(o, DIFF_RESET);
                    const char *a_prefix, *b_prefix;
                    struct userdiff_driver *textconv_one = NULL;
                    struct userdiff_driver *textconv_two = NULL;
                    struct strbuf header = STRBUF_INIT;
                    const char *line_prefix = diff_line_prefix(o);

                    diff_set_mnemonic_prefix(o, "a/", "b/");
                    if (o->flags.reverse_diff) {
                            a_prefix = o->b_prefix;
                            b_prefix = o->a_prefix;
                    } else {
                            a_prefix = o->a_prefix;
                            b_prefix = o->b_prefix;
                    }

                    if (o->submodule_format == DIFF_SUBMODULE_LOG &&
                    (!one->mode || S_ISGITLINK(one->mode)) &&
                    (!two->mode || S_ISGITLINK(two->mode)) &&
                    (!diff_filepair_is_phoney(one, two))) {
                            show_submodule_diff_summary(o, one->path ? one->path : two->path,
                                            &one->oid, &two->oid,
                                            two->dirty_submodule);
                            o->found_changes = 1;
                            return;
                    } else if (o->submodule_format == DIFF_SUBMODULE_INLINE_DIFF &&
                            (!one->mode || S_ISGITLINK(one->mode)) &&
                            (!two->mode || S_ISGITLINK(two->mode)) &&
                            (!diff_filepair_is_phoney(one, two))) {
                            show_submodule_inline_diff(o, one->path ? one->path : two->path,
                                            &one->oid, &two->oid,
                                            two->dirty_submodule);
                            o->found_changes = 1;
                            return;
                    }

                    if (o->flags.allow_textconv) {
                            textconv_one = get_textconv(o->repo, one);
                            textconv_two = get_textconv(o->repo, two);
                    }

                    /* Never use a non-valid filename anywhere if at all possible */
                    name_a = DIFF_FILE_VALID(one) ? name_a : name_b;
                    name_b = DIFF_FILE_VALID(two) ? name_b : name_a;

                    a_one = quote_two(a_prefix, name_a + (*name_a == '/'));
                    b_two = quote_two(b_prefix, name_b + (*name_b == '/'));
                    lbl[0] = DIFF_FILE_VALID(one) ? a_one : "/dev/null";
                    lbl[1] = DIFF_FILE_VALID(two) ? b_two : "/dev/null";
                    if (diff_filepair_is_phoney(one, two)) {
                            /*
                            * We should only reach this point for pairs generated from
                            * create_filepairs_for_header_only_notifications().  For
                            * these, we want to avoid the "/dev/null" special casing
                            * above, because we do not want such pairs shown as either
                            * "new file" or "deleted file" below.
                            */
                            lbl[0] = a_one;
                            lbl[1] = b_two;
                    }
                    strbuf_addf(&header, "%s%sdiff --git %s %s%s\n", line_prefix, meta, a_one, b_two, reset);
                    if (lbl[0][0] == '/') {
                            /* /dev/null */
                            strbuf_addf(&header, "%s%snew file mode %06o%s\n", line_prefix, meta, two->mode, reset);
                            if (xfrm_msg)
                                    strbuf_addstr(&header, xfrm_msg);
                            o->found_changes = 1;
                            must_show_header = 1;
                    }
                    else if (lbl[1][0] == '/') {
                            strbuf_addf(&header, "%s%sdeleted file mode %06o%s\n", line_prefix, meta, one->mode, reset);
                            if (xfrm_msg)
                                    strbuf_addstr(&header, xfrm_msg);
                            o->found_changes = 1;
                            must_show_header = 1;
                    }
                    else {
                            if (one->mode != two->mode) {
                                    strbuf_addf(&header, "%s%sold mode %06o%s\n", line_prefix, meta, one->mode, reset);
                                    strbuf_addf(&header, "%s%snew mode %06o%s\n", line_prefix, meta, two->mode, reset);
                                    o->found_changes = 1;
                                    must_show_header = 1;
                            }
                            if (xfrm_msg)
                                    strbuf_addstr(&header, xfrm_msg);

                            /*
                            * we do not run diff between different kind
                            * of objects.
                            */
                            if ((one->mode ^ two->mode) & S_IFMT)
                                    goto free_ab_and_return;
                            if (complete_rewrite &&
                            (textconv_one || !diff_filespec_is_binary(o->repo, one)) &&
                            (textconv_two || !diff_filespec_is_binary(o->repo, two))) {
                                    emit_diff_symbol(o, DIFF_SYMBOL_HEADER,
                                                    header.buf, header.len, 0);
                                    strbuf_reset(&header);
                                    emit_rewrite_diff(name_a, name_b, one, two,
                                                    textconv_one, textconv_two, o);
                                    o->found_changes = 1;
                                    goto free_ab_and_return;
                            }
                    }

                    if (o->irreversible_delete && lbl[1][0] == '/') {
                            emit_diff_symbol(o, DIFF_SYMBOL_HEADER, header.buf,
                                            header.len, 0);
                            strbuf_reset(&header);
                            goto free_ab_and_return;
                    } else if (!o->flags.text &&
                            ( (!textconv_one && diff_filespec_is_binary(o->repo, one)) ||
                            (!textconv_two && diff_filespec_is_binary(o->repo, two)) )) {
                            struct strbuf sb = STRBUF_INIT;
                            if (!one->data && !two->data &&
                            S_ISREG(one->mode) && S_ISREG(two->mode) &&
                            !o->flags.binary) {
                                    if (oideq(&one->oid, &two->oid)) {
                                            if (must_show_header)
                                                    emit_diff_symbol(o, DIFF_SYMBOL_HEADER,
                                                                    header.buf, header.len,
                                                                    0);
                                            goto free_ab_and_return;
                                    }
                                    emit_diff_symbol(o, DIFF_SYMBOL_HEADER,
                                                    header.buf, header.len, 0);
                                    strbuf_addf(&sb, "%sBinary files %s and %s differ\n",
                                            diff_line_prefix(o), lbl[0], lbl[1]);
                                    emit_diff_symbol(o, DIFF_SYMBOL_BINARY_FILES,
                                                    sb.buf, sb.len, 0);
                                    strbuf_release(&sb);
                                    o->found_changes = 1;
                                    goto free_ab_and_return;
                            }
                            if (fill_mmfile(o->repo, &mf1, one) < 0 ||
                            fill_mmfile(o->repo, &mf2, two) < 0)
                                    die("unable to read files to diff");
                            /* Quite common confusing case */
                            if (mf1.size == mf2.size &&
                            !memcmp(mf1.ptr, mf2.ptr, mf1.size)) {
                                    if (must_show_header)
                                            emit_diff_symbol(o, DIFF_SYMBOL_HEADER,
                                                            header.buf, header.len, 0);
                                    goto free_ab_and_return;
                            }
                            emit_diff_symbol(o, DIFF_SYMBOL_HEADER, header.buf, header.len, 0);
                            strbuf_reset(&header);
                            if (o->flags.binary)
                                    emit_binary_diff(o, &mf1, &mf2);
                            else {
                                    strbuf_addf(&sb, "%sBinary files %s and %s differ\n",
                                            diff_line_prefix(o), lbl[0], lbl[1]);
                                    emit_diff_symbol(o, DIFF_SYMBOL_BINARY_FILES,
                                                    sb.buf, sb.len, 0);
                                    strbuf_release(&sb);
                            }
                            o->found_changes = 1;
                    } else {
                            /* Crazy xdl interfaces.. */
                            const char *diffopts;
                            const char *v;
                            xpparam_t xpp;
                            xdemitconf_t xecfg;
                            struct emit_callback ecbdata;
                            const struct userdiff_funcname *pe;

                            if (must_show_header) {
                                    emit_diff_symbol(o, DIFF_SYMBOL_HEADER,
                                                    header.buf, header.len, 0);
                                    strbuf_reset(&header);
                            }

                            mf1.size = fill_textconv(o->repo, textconv_one, one, &mf1.ptr);
                            mf2.size = fill_textconv(o->repo, textconv_two, two, &mf2.ptr);

                            pe = diff_funcname_pattern(o, one);
                            if (!pe)
                                    pe = diff_funcname_pattern(o, two);

                            memset(&xpp, 0, sizeof(xpp));
                            memset(&xecfg, 0, sizeof(xecfg));
                            memset(&ecbdata, 0, sizeof(ecbdata));
                            if (o->flags.suppress_diff_headers)
                                    lbl[0] = NULL;
                            ecbdata.label_path = lbl;
                            ecbdata.color_diff = want_color(o->use_color);
                            ecbdata.ws_rule = whitespace_rule(o->repo->index, name_b);
                            if (ecbdata.ws_rule & WS_BLANK_AT_EOF)
                                    check_blank_at_eof(&mf1, &mf2, &ecbdata);
                            ecbdata.opt = o;
                            if (header.len && !o->flags.suppress_diff_headers)
                                    ecbdata.header = &header;
                            xpp.flags = o->xdl_opts;
                            xpp.ignore_regex = o->ignore_regex;
                            xpp.ignore_regex_nr = o->ignore_regex_nr;
                            xpp.anchors = o->anchors;
                            xpp.anchors_nr = o->anchors_nr;
                            xecfg.ctxlen = o->context;
                            xecfg.interhunkctxlen = o->interhunkcontext;
                            xecfg.flags = XDL_EMIT_FUNCNAMES;
                            if (o->flags.funccontext)
                                    xecfg.flags |= XDL_EMIT_FUNCCONTEXT;
                            if (pe)
                                    xdiff_set_find_func(&xecfg, pe->pattern, pe->cflags);

                            diffopts = getenv("GIT_DIFF_OPTS");
                            if (!diffopts)
                                    ;
                            else if (skip_prefix(diffopts, "--unified=", &v))
                                    xecfg.ctxlen = strtoul(v, NULL, 10);
                            else if (skip_prefix(diffopts, "-u", &v))
                                    xecfg.ctxlen = strtoul(v, NULL, 10);

                            if (o->word_diff)
                                    init_diff_words_data(&ecbdata, o, one, two);
                            if (xdi_diff_outf(&mf1, &mf2, NULL, fn_out_consume,
                                            &ecbdata, &xpp, &xecfg))
                                    die("unable to generate diff for %s", one->path);
                            if (o->word_diff)
                                    free_diff_words_data(&ecbdata);
                            if (textconv_one)
                                    free(mf1.ptr);
                            if (textconv_two)
                                    free(mf2.ptr);
                            xdiff_clear_find_func(&xecfg);
                    }

            free_ab_and_return:
                    strbuf_release(&header);
                    diff_free_filespec_data(one);
                    diff_free_filespec_data(two);
                    free(a_one);
                    free(b_two);
                    return;
            }

            static const char *get_compact_summary(const struct diff_filepair *p, int is_renamed)
            {
                    if (!is_renamed) {
                            if (p->status == DIFF_STATUS_ADDED) {
                                    if (S_ISLNK(p->two->mode))
                                            return "new +l";
                                    else if ((p->two->mode & 0777) == 0755)
                                            return "new +x";
                                    else
                                            return "new";
                            } else if (p->status == DIFF_STATUS_DELETED)
                                    return "gone";
                    }
                    if (S_ISLNK(p->one->mode) && !S_ISLNK(p->two->mode))
                            return "mode -l";
                    else if (!S_ISLNK(p->one->mode) && S_ISLNK(p->two->mode))
                            return "mode +l";
                    else if ((p->one->mode & 0777) == 0644 &&
                            (p->two->mode & 0777) == 0755)
                            return "mode +x";
                    else if ((p->one->mode & 0777) == 0755 &&
                            (p->two->mode & 0777) == 0644)
                            return "mode -x";
                    return NULL;
            }

            static void builtin_diffstat(const char *name_a, const char *name_b,
                                    struct diff_filespec *one,
                                    struct diff_filespec *two,
                                    struct diffstat_t *diffstat,
                                    struct diff_options *o,
                                    struct diff_filepair *p)
            {
                    mmfile_t mf1, mf2;
                    struct diffstat_file *data;
                    int may_differ;
                    int complete_rewrite = 0;

                    if (!DIFF_PAIR_UNMERGED(p)) {
                            if (p->status == DIFF_STATUS_MODIFIED && p->score)
                                    complete_rewrite = 1;
                    }

                    data = diffstat_add(diffstat, name_a, name_b);
                    data->is_interesting = p->status != DIFF_STATUS_UNKNOWN;
                    if (o->flags.stat_with_summary)
                            data->comments = get_compact_summary(p, data->is_renamed);

                    if (!one || !two) {
                            data->is_unmerged = 1;
                            return;
                    }

                    /* saves some reads if true, not a guarantee of diff outcome */
                    may_differ = !(one->oid_valid && two->oid_valid &&
                                    oideq(&one->oid, &two->oid));

                    if (diff_filespec_is_binary(o->repo, one) ||
                    diff_filespec_is_binary(o->repo, two)) {
                            data->is_binary = 1;
                            if (!may_differ) {
                                    data->added = 0;
                                    data->deleted = 0;
                            } else {
                                    data->added = diff_filespec_size(o->repo, two);
                                    data->deleted = diff_filespec_size(o->repo, one);
                            }
                    }

                    else if (complete_rewrite) {
                            diff_populate_filespec(o->repo, one, NULL);
                            diff_populate_filespec(o->repo, two, NULL);
                            data->deleted = count_lines(one->data, one->size);
                            data->added = count_lines(two->data, two->size);
                    }

                    else if (may_differ) {
                            /* Crazy xdl interfaces.. */
                            xpparam_t xpp;
                            xdemitconf_t xecfg;

                            if (fill_mmfile(o->repo, &mf1, one) < 0 ||
                            fill_mmfile(o->repo, &mf2, two) < 0)
                                    die("unable to read files to diff");

                            memset(&xpp, 0, sizeof(xpp));
                            memset(&xecfg, 0, sizeof(xecfg));
                            xpp.flags = o->xdl_opts;
                            xpp.ignore_regex = o->ignore_regex;
                            xpp.ignore_regex_nr = o->ignore_regex_nr;
                            xpp.anchors = o->anchors;
                            xpp.anchors_nr = o->anchors_nr;
                            xecfg.ctxlen = o->context;
                            xecfg.interhunkctxlen = o->interhunkcontext;
                            xecfg.flags = XDL_EMIT_NO_HUNK_HDR;
                            if (xdi_diff_outf(&mf1, &mf2, NULL,
                                            diffstat_consume, diffstat, &xpp, &xecfg))
                                    die("unable to generate diffstat for %s", one->path);

                            if (DIFF_FILE_VALID(one) && DIFF_FILE_VALID(two)) {
                                    struct diffstat_file *file =
                                            diffstat->files[diffstat->nr - 1];
                                    /*
                                    * Omit diffstats of modified files where nothing changed.
                                    * Even if may_differ, this might be the case due to
                                    * ignoring whitespace changes, etc.
                                    *
                                    * But note that we special-case additions, deletions,
                                    * renames, and mode changes as adding an empty file,
                                    * for example is still of interest.
                                    */
                                    if ((p->status == DIFF_STATUS_MODIFIED)
                                            && !file->added
                                            && !file->deleted
                                            && one->mode == two->mode) {
                                            free_diffstat_file(file);
                                            diffstat->nr--;
                                    }
                            }
                    }

                    diff_free_filespec_data(one);
                    diff_free_filespec_data(two);
            }

            static void builtin_checkdiff(const char *name_a, const char *name_b,
                                    const char *attr_path,
                                    struct diff_filespec *one,
                                    struct diff_filespec *two,
                                    struct diff_options *o)
            {
                    mmfile_t mf1, mf2;
                    struct checkdiff_t data;

                    if (!two)
                            return;

                    memset(&data, 0, sizeof(data));
                    data.filename = name_b ? name_b : name_a;
                    data.lineno = 0;
                    data.o = o;
                    data.ws_rule = whitespace_rule(o->repo->index, attr_path);
                    data.conflict_marker_size = ll_merge_marker_size(o->repo->index, attr_path);

                    if (fill_mmfile(o->repo, &mf1, one) < 0 ||
                    fill_mmfile(o->repo, &mf2, two) < 0)
                            die("unable to read files to diff");

                    /*
                    * All the other codepaths check both sides, but not checking
                    * the "old" side here is deliberate.  We are checking the newly
                    * introduced changes, and as long as the "new" side is text, we
                    * can and should check what it introduces.
                    */
                    if (diff_filespec_is_binary(o->repo, two))
                            goto free_and_return;
                    else {
                            /* Crazy xdl interfaces.. */
                            xpparam_t xpp;
                            xdemitconf_t xecfg;

                            memset(&xpp, 0, sizeof(xpp));
                            memset(&xecfg, 0, sizeof(xecfg));
                            xecfg.ctxlen = 1; /* at least one context line */
                            xpp.flags = 0;
                            if (xdi_diff_outf(&mf1, &mf2, checkdiff_consume_hunk,
                                            checkdiff_consume, &data,
                                            &xpp, &xecfg))
                                    die("unable to generate checkdiff for %s", one->path);

                            if (data.ws_rule & WS_BLANK_AT_EOF) {
                                    struct emit_callback ecbdata;
                                    int blank_at_eof;

                                    ecbdata.ws_rule = data.ws_rule;
                                    check_blank_at_eof(&mf1, &mf2, &ecbdata);
                                    blank_at_eof = ecbdata.blank_at_eof_in_postimage;

                                    if (blank_at_eof) {
                                            static char *err;
                                            if (!err)
                                                    err = whitespace_error_string(WS_BLANK_AT_EOF);
                                            fprintf(o->file, "%s:%d: %s.\n",
                                                    data.filename, blank_at_eof, err);
                                            data.status = 1; /* report errors */
                                    }
                            }
                    }
            free_and_return:
                    diff_free_filespec_data(one);
                    diff_free_filespec_data(two);
                    if (data.status)
                            o->flags.check_failed = 1;
            }

            struct diff_filespec *alloc_filespec(const char *path)
            {
                    struct diff_filespec *spec;

                    FLEXPTR_ALLOC_STR(spec, path, path);
                    spec->count = 1;
                    spec->is_binary = -1;
                    return spec;
            }

            void free_filespec(struct diff_filespec *spec)
            {
                    if (!--spec->count) {
                            diff_free_filespec_data(spec);
                            free(spec);
                    }
            }

            void fill_filespec(struct diff_filespec *spec, const struct object_id *oid,
                            int oid_valid, unsigned short mode)
            {
                    if (mode) {
                            spec->mode = canon_mode(mode);
                            oidcpy(&spec->oid, oid);
                            spec->oid_valid = oid_valid;
                    }
            }

            /*
            * Given a name and sha1 pair, if the index tells us the file in
            * the work tree has that object contents, return true, so that
            * prepare_temp_file() does not have to inflate and extract.
            */
            static int reuse_worktree_file(struct index_state *istate,
                                    const char *name,
                                    const struct object_id *oid,
                                    int want_file)
            {
                    const struct cache_entry *ce;
                    struct stat st;
                    int pos, len;

                    /*
                    * We do not read the cache ourselves here, because the
                    * benchmark with my previous version that always reads cache
                    * shows that it makes things worse for diff-tree comparing
                    * two linux-2.6 kernel trees in an already checked out work
                    * tree.  This is because most diff-tree comparisons deal with
                    * only a small number of files, while reading the cache is
                    * expensive for a large project, and its cost outweighs the
                    * savings we get by not inflating the object to a temporary
                    * file.  Practically, this code only helps when we are used
                    * by diff-cache --cached, which does read the cache before
                    * calling us.
                    */
                    if (!istate->cache)
                            return 0;

                    /* We want to avoid the working directory if our caller
                    * doesn't need the data in a normal file, this system
                    * is rather slow with its stat/open/mmap/close syscalls,
                    * and the object is contained in a pack file.  The pack
                    * is probably already open and will be faster to obtain
                    * the data through than the working directory.  Loose
                    * objects however would tend to be slower as they need
                    * to be individually opened and inflated.
                    */
                    if (!FAST_WORKING_DIRECTORY && !want_file &&
                    has_object_pack(istate->repo, oid))
                            return 0;

                    /*
                    * Similarly, if we'd have to convert the file contents anyway, that
                    * makes the optimization not worthwhile.
                    */
                    if (!want_file && would_convert_to_git(istate, name))
                            return 0;

                    /*
                    * If this path does not match our sparse-checkout definition,
                    * then the file will not be in the working directory.
                    */
                    if (!path_in_sparse_checkout(name, istate))
                            return 0;

                    len = strlen(name);
                    pos = index_name_pos(istate, name, len);
                    if (pos < 0)
                            return 0;
                    ce = istate->cache[pos];

                    /*
                    * This is not the sha1 we are looking for, or
                    * unreusable because it is not a regular file.
                    */
                    if (!oideq(oid, &ce->oid) || !S_ISREG(ce->ce_mode))
                            return 0;

                    /*
                    * If ce is marked as "assume unchanged", there is no
                    * guarantee that work tree matches what we are looking for.
                    */
                    if ((ce->ce_flags & CE_VALID) || ce_skip_worktree(ce))
                            return 0;

                    /*
                    * If ce matches the file in the work tree, we can reuse it.
                    */
                    if (ce_uptodate(ce) ||
                    (!lstat(name, &st) && !ie_match_stat(istate, ce, &st, 0)))
                            return 1;

                    return 0;
            }

            static int diff_populate_gitlink(struct diff_filespec *s, int size_only)
            {
                    struct strbuf buf = STRBUF_INIT;
                    const char *dirty = "";

                    /* Are we looking at the work tree? */
                    if (s->dirty_submodule)
                            dirty = "-dirty";

                    strbuf_addf(&buf, "Subproject commit %s%s\n",
                            oid_to_hex(&s->oid), dirty);
                    s->size = buf.len;
                    if (size_only) {
                            s->data = NULL;
                            strbuf_release(&buf);
                    } else {
                            s->data = strbuf_detach(&buf, NULL);
                            s->should_free = 1;
                    }
                    return 0;
            }

            /*
            * While doing rename detection and pickaxe operation, we may need to
            * grab the data for the blob (or file) for our own in-core comparison.
            * diff_filespec has data and size fields for this purpose.
            */
            int diff_populate_filespec(struct repository *r,
                                    struct diff_filespec *s,
                                    const struct diff_populate_filespec_options *options)
            {
                    int size_only = options ? options->check_size_only : 0;
                    int check_binary = options ? options->check_binary : 0;
                    int err = 0;
                    int conv_flags = global_conv_flags_eol;
            int autocvtToASCII;
                    /*
                    * demote FAIL to WARN to allow inspecting the situation
                    * instead of refusing.
                    */
                    if (conv_flags & CONV_EOL_RNDTRP_DIE)
                            conv_flags = CONV_EOL_RNDTRP_WARN;

                    if (!DIFF_FILE_VALID(s))
                            die("internal error: asking to populate invalid file.");
                    if (S_ISDIR(s->mode))
                            return -1;

                    if (s->data)
                            return 0;

                    if (size_only && 0 < s->size)
                            return 0;

                    if (S_ISGITLINK(s->mode))
                            return diff_populate_gitlink(s, size_only);

                    if (!s->oid_valid ||
                    reuse_worktree_file(r->index, s->path, &s->oid, 0)) {
                            struct strbuf buf = STRBUF_INIT;
                            struct stat st;
                            int fd;

                            if (lstat(s->path, &st) < 0) {
                            err_empty:
                                    err = -1;
                            empty:
                                    s->data = (char *)"";
                                    s->size = 0;
                                    return err;
                            }
                            s->size = xsize_t(st.st_size);
                            if (!s->size)
                                    goto empty;
                            if (S_ISLNK(st.st_mode)) {
                                    struct strbuf sb = STRBUF_INIT;

                                    if (strbuf_readlink(&sb, s->path, s->size))
                                            goto err_empty;
                                    s->size = sb.len;
                                    s->data = strbuf_detach(&sb, NULL);
                                    s->should_free = 1;
                                    return 0;
                            }

                            /*
                            * Even if the caller would be happy with getting
                            * only the size, we cannot return early at this
                            * point if the path requires us to run the content
                            * conversion.
                            */
                            if (size_only && !would_convert_to_git(r->index, s->path))
                                    return 0;

                            /*
                            * Note: this check uses xsize_t(st.st_size) that may
                            * not be the true size of the blob after it goes
                            * through convert_to_git().  This may not strictly be
                            * correct, but the whole point of big_file_threshold
                            * and is_binary check being that we want to avoid
                            * opening the file and inspecting the contents, this
                            * is probably fine.
                            */
                            if (check_binary &&
                            s->size > big_file_threshold && s->is_binary == -1) {
                                    s->is_binary = 1;
                                    return 0;
                            }
            #ifdef __MVS__
            validate_codeset(r->index, s->path, &autocvtToASCII);
            #endif
                            fd = open(s->path, O_RDONLY);
                            if (fd < 0)
                                    goto err_empty;

            #ifdef __MVS__
            if (!autocvtToASCII)
            __disableautocvt(fd);
            #endif

                            s->data = xmmap(NULL, s->size, PROT_READ, MAP_PRIVATE, fd, 0);
                            close(fd);
                            s->should_munmap = 1;

                            /*
                            * Convert from working tree format to canonical git format
                            */
                            if (convert_to_git(r->index, s->path, s->data, s->size, &buf, conv_flags)) {
                                    size_t size = 0;
                                    munmap(s->data, s->size);
                                    s->should_munmap = 0;
                                    s->data = strbuf_detach(&buf, &size);
                                    s->size = size;
                                    s->should_free = 1;
                            }
                    }
                    else {
                            struct object_info info = {
                                    .sizep = &s->size
                            };

                            if (!(size_only || check_binary))
                                    /*
                                    * Set contentp, since there is no chance that merely
                                    * the size is sufficient.
                                    */
                                    info.contentp = &s->data;

                            if (options && options->missing_object_cb) {
                                    if (!oid_object_info_extended(r, &s->oid, &info,
                                                            OBJECT_INFO_LOOKUP_REPLACE |
                                                            OBJECT_INFO_SKIP_FETCH_OBJECT))
                                            goto object_read;
                                    options->missing_object_cb(options->missing_object_data);
                            }
                            if (oid_object_info_extended(r, &s->oid, &info,
                                                    OBJECT_INFO_LOOKUP_REPLACE))
                                    die("unable to read %s", oid_to_hex(&s->oid));

            object_read:
                            if (size_only || check_binary) {
                                    if (size_only)
                                            return 0;
                                    if (s->size > big_file_threshold && s->is_binary == -1) {
                                            s->is_binary = 1;
                                            return 0;
                                    }
                            }
                            if (!info.contentp) {
                                    info.contentp = &s->data;
                                    if (oid_object_info_extended(r, &s->oid, &info,
                                                            OBJECT_INFO_LOOKUP_REPLACE))
                                            die("unable to read %s", oid_to_hex(&s->oid));
                            }
                            s->should_free = 1;
                    }
                    return 0;
            }

            void diff_free_filespec_blob(struct diff_filespec *s)
            {
                    if (s->should_free)
                            free(s->data);
                    else if (s->should_munmap)
                            munmap(s->data, s->size);

                    if (s->should_free || s->should_munmap) {
                            s->should_free = s->should_munmap = 0;
                            s->data = NULL;
                    }
            }

            void diff_free_filespec_data(struct diff_filespec *s)
            {
                    if (!s)
                            return;

                    diff_free_filespec_blob(s);
                    FREE_AND_NULL(s->cnt_data);
            }

            static void prep_temp_blob(struct index_state *istate,
                                    const char *path, struct diff_tempfile *temp,
                                    void *blob,
                                    unsigned long size,
                                    const struct object_id *oid,
                                    int mode)
            {
                    struct strbuf buf = STRBUF_INIT;
                    char *path_dup = xstrdup(path);
                    const char *base = basename(path_dup);
                    struct checkout_metadata meta;

                    init_checkout_metadata(&meta, NULL, NULL, oid);

                    temp->tempfile = mks_tempfile_dt("git-blob-XXXXXX", base);
                    if (!temp->tempfile)
                            die_errno("unable to create temp-file");
                    if (convert_to_working_tree(istate, path,
                                    (const char *)blob, (size_t)size, &buf, &meta)) {
                            blob = buf.buf;
                            size = buf.len;
                    }

            #ifdef __MVS__
            tag_file_as_working_tree_encoding(istate, path, temp->tempfile->fd);
            #endif
                    if (write_in_full(temp->tempfile->fd, blob, size) < 0 ||
                    close_tempfile_gently(temp->tempfile))
                            die_errno("unable to write temp-file");
                    temp->name = get_tempfile_path(temp->tempfile);
                    oid_to_hex_r(temp->hex, oid);
                    xsnprintf(temp->mode, sizeof(temp->mode), "%06o", mode);
                    strbuf_release(&buf);
                    free(path_dup);
            }

            static struct diff_tempfile *prepare_temp_file(struct repository *r,
                                                    struct diff_filespec *one)
            {
                    struct diff_tempfile *temp = claim_diff_tempfile();

                    if (!DIFF_FILE_VALID(one)) {
                    not_a_valid_file:
                            /* A '-' entry produces this for file-2, and
                            * a '+' entry produces this for file-1.
                            */
                            temp->name = "/dev/null";
                            xsnprintf(temp->hex, sizeof(temp->hex), ".");
                            xsnprintf(temp->mode, sizeof(temp->mode), ".");
                            return temp;
                    }

                    if (!S_ISGITLINK(one->mode) &&
                    (!one->oid_valid ||
                    reuse_worktree_file(r->index, one->path, &one->oid, 1))) {
                            struct stat st;
                            if (lstat(one->path, &st) < 0) {
                                    if (errno == ENOENT)
                                            goto not_a_valid_file;
                                    die_errno("stat(%s)", one->path);
                            }
                            if (S_ISLNK(st.st_mode)) {
                                    struct strbuf sb = STRBUF_INIT;
                                    if (strbuf_readlink(&sb, one->path, st.st_size) < 0)
                                            die_errno("readlink(%s)", one->path);
                                    prep_temp_blob(r->index, one->path, temp, sb.buf, sb.len,
                                            (one->oid_valid ?
                                                    &one->oid : null_oid()),
                                            (one->oid_valid ?
                                                    one->mode : S_IFLNK));
                                    strbuf_release(&sb);
                            }
                            else {
                                    /* we can borrow from the file in the work tree */
                                    temp->name = one->path;
                                    if (!one->oid_valid)
                                            oid_to_hex_r(temp->hex, null_oid());
                                    else
                                            oid_to_hex_r(temp->hex, &one->oid);
                                    /* Even though we may sometimes borrow the
                                    * contents from the work tree, we always want
                                    * one->mode.  mode is trustworthy even when
                                    * !(one->oid_valid), as long as
                                    * DIFF_FILE_VALID(one).
                                    */
                                    xsnprintf(temp->mode, sizeof(temp->mode), "%06o", one->mode);
                            }
                            return temp;
                    }
                    else {
                            if (diff_populate_filespec(r, one, NULL))
                                    die("cannot read data blob for %s", one->path);
                            prep_temp_blob(r->index, one->path, temp,
                                    one->data, one->size,
                                    &one->oid, one->mode);
                    }
                    return temp;
            }

            static void add_external_diff_name(struct repository *r,
                                            struct strvec *argv,
                                            struct diff_filespec *df)
            {
                    struct diff_tempfile *temp = prepare_temp_file(r, df);
                    strvec_push(argv, temp->name);
                    strvec_push(argv, temp->hex);
                    strvec_push(argv, temp->mode);
            }

            /* An external diff command takes:
            *
            * diff-cmd name infile1 infile1-sha1 infile1-mode \
            *               infile2 infile2-sha1 infile2-mode [ rename-to ]
            *
            */
            static void run_external_diff(const struct external_diff *pgm,
                                    const char *name,
                                    const char *other,
                                    struct diff_filespec *one,
                                    struct diff_filespec *two,
                                    const char *xfrm_msg,
                                    struct diff_options *o)
            {
                    struct child_process cmd = CHILD_PROCESS_INIT;
                    struct diff_queue_struct *q = &diff_queued_diff;
                    int quiet = !(o->output_format & DIFF_FORMAT_PATCH);
                    int rc;

                    /*
                    * Trivial equality is handled by diff_unmodified_pair() before
                    * we get here.  If we don't need to show the diff and the
                    * external diff program lacks the ability to tell us whether
                    * it's empty then we consider it non-empty without even asking.
                    */
                    if (!pgm->trust_exit_code && quiet) {
                            o->found_changes = 1;
                            return;
                    }

                    strvec_push(&cmd.args, pgm->cmd);
                    strvec_push(&cmd.args, name);

                    if (one && two) {
                            add_external_diff_name(o->repo, &cmd.args, one);
                            add_external_diff_name(o->repo, &cmd.args, two);
                            if (other) {
                                    strvec_push(&cmd.args, other);
                                    if (xfrm_msg)
                                            strvec_push(&cmd.args, xfrm_msg);
                            }
                    }

                    strvec_pushf(&cmd.env, "GIT_DIFF_PATH_COUNTER=%d",
                            ++o->diff_path_counter);
                    strvec_pushf(&cmd.env, "GIT_DIFF_PATH_TOTAL=%d", q->nr);

                    diff_free_filespec_data(one);
                    diff_free_filespec_data(two);
                    cmd.use_shell = 1;
                    cmd.no_stdout = quiet;
                    rc = run_command(&cmd);
                    if (!pgm->trust_exit_code && rc == 0)
                            o->found_changes = 1;
                    else if (pgm->trust_exit_code && rc == 0)
                            ; /* nothing */
                    else if (pgm->trust_exit_code && rc == 1)
                            o->found_changes = 1;
                    else
                            die(_("external diff died, stopping at %s"), name);

                    remove_tempfile();
            }

            static int similarity_index(struct diff_filepair *p)
            {
                    return p->score * 100 / MAX_SCORE;
            }

            static const char *diff_abbrev_oid(const struct object_id *oid, int abbrev)
            {
                    if (startup_info->have_repository)
                            return repo_find_unique_abbrev(the_repository, oid, abbrev);
                    else {
                            char *hex = oid_to_hex(oid);
                            if (abbrev < 0)
                                    abbrev = FALLBACK_DEFAULT_ABBREV;
                            if (abbrev > the_hash_algo->hexsz)
                                    BUG("oid abbreviation out of range: %d", abbrev);
                            if (abbrev)
                                    hex[abbrev] = '\0';
                            return hex;
                    }
            }

            static void fill_metainfo(struct strbuf *msg,
                                    const char *name,
                                    const char *other,
                                    struct diff_filespec *one,
                                    struct diff_filespec *two,
                                    struct diff_options *o,
                                    struct diff_filepair *p,
                                    int *must_show_header,
                                    int use_color)
            {
                    const char *set = diff_get_color(use_color, DIFF_METAINFO);
                    const char *reset = diff_get_color(use_color, DIFF_RESET);
                    const char *line_prefix = diff_line_prefix(o);
                    struct string_list *more_headers = NULL;

                    *must_show_header = 1;
                    strbuf_init(msg, PATH_MAX * 2 + 300);
                    switch (p->status) {
                    case DIFF_STATUS_COPIED:
                            strbuf_addf(msg, "%s%ssimilarity index %d%%",
                                    line_prefix, set, similarity_index(p));
                            strbuf_addf(msg, "%s\n%s%scopy from ",
                                    reset,  line_prefix, set);
                            quote_c_style(name, msg, NULL, 0);
                            strbuf_addf(msg, "%s\n%s%scopy to ", reset, line_prefix, set);
                            quote_c_style(other, msg, NULL, 0);
                            strbuf_addf(msg, "%s\n", reset);
                            break;
                    case DIFF_STATUS_RENAMED:
                            strbuf_addf(msg, "%s%ssimilarity index %d%%",
                                    line_prefix, set, similarity_index(p));
                            strbuf_addf(msg, "%s\n%s%srename from ",
                                    reset, line_prefix, set);
                            quote_c_style(name, msg, NULL, 0);
                            strbuf_addf(msg, "%s\n%s%srename to ",
                                    reset, line_prefix, set);
                            quote_c_style(other, msg, NULL, 0);
                            strbuf_addf(msg, "%s\n", reset);
                            break;
                    case DIFF_STATUS_MODIFIED:
                            if (p->score) {
                                    strbuf_addf(msg, "%s%sdissimilarity index %d%%%s\n",
                                            line_prefix,
                                            set, similarity_index(p), reset);
                                    break;
                            }
                            /* fallthru */
                    default:
                            *must_show_header = 0;
                    }
                    if ((more_headers = additional_headers(o, name))) {
                            add_formatted_headers(msg, more_headers,
                                            line_prefix, set, reset);
                            *must_show_header = 1;
                    }
                    if (one && two && !oideq(&one->oid, &two->oid)) {
                            const unsigned hexsz = the_hash_algo->hexsz;
                            int abbrev = o->abbrev ? o->abbrev : DEFAULT_ABBREV;

                            if (o->flags.full_index)
                                    abbrev = hexsz;

                            if (o->flags.binary) {
                                    mmfile_t mf;
                                    if ((!fill_mmfile(o->repo, &mf, one) &&
                                    diff_filespec_is_binary(o->repo, one)) ||
                                    (!fill_mmfile(o->repo, &mf, two) &&
                                    diff_filespec_is_binary(o->repo, two)))
                                            abbrev = hexsz;
                            }
                            strbuf_addf(msg, "%s%sindex %s..%s", line_prefix, set,
                                    diff_abbrev_oid(&one->oid, abbrev),
                                    diff_abbrev_oid(&two->oid, abbrev));
                            if (one->mode == two->mode)
                                    strbuf_addf(msg, " %06o", one->mode);
                            strbuf_addf(msg, "%s\n", reset);
                    }
            }

            static void run_diff_cmd(const struct external_diff *pgm,
                                    const char *name,
                                    const char *other,
                                    const char *attr_path,
                                    struct diff_filespec *one,
                                    struct diff_filespec *two,
                                    struct strbuf *msg,
                                    struct diff_options *o,
                                    struct diff_filepair *p)
            {
                    const char *xfrm_msg = NULL;
                    int complete_rewrite = (p->status == DIFF_STATUS_MODIFIED) && p->score;
                    int must_show_header = 0;
                    struct userdiff_driver *drv = NULL;

                    if (o->flags.allow_external || !o->ignore_driver_algorithm)
                            drv = userdiff_find_by_path(o->repo->index, attr_path);

                    if (o->flags.allow_external && drv && drv->external.cmd)
                            pgm = &drv->external;

                    if (msg) {
                            /*
                            * don't use colors when the header is intended for an
                            * external diff driver
                            */
                            fill_metainfo(msg, name, other, one, two, o, p,
                                    &must_show_header,
                                    want_color(o->use_color) && !pgm);
                            xfrm_msg = msg->len ? msg->buf : NULL;
                    }

                    if (pgm) {
                            run_external_diff(pgm, name, other, one, two, xfrm_msg, o);
                            return;
                    }
                    if (one && two) {
                            if (!o->ignore_driver_algorithm && drv && drv->algorithm)
                                    set_diff_algorithm(o, drv->algorithm);

                            builtin_diff(name, other ? other : name,
                                    one, two, xfrm_msg, must_show_header,
                                    o, complete_rewrite);
                            if (p->status == DIFF_STATUS_COPIED ||
                            p->status == DIFF_STATUS_RENAMED)
                                    o->found_changes = 1;
                    } else {
                            fprintf(o->file, "* Unmerged path %s\n", name);
                            o->found_changes = 1;
                    }
            }

            static void diff_fill_oid_info(struct diff_filespec *one, struct index_state *istate)
            {
                    if (DIFF_FILE_VALID(one)) {
                            if (!one->oid_valid) {
                                    struct stat st;
                                    if (one->is_stdin) {
                                            oidclr(&one->oid, the_repository->hash_algo);
                                            return;
                                    }
                                    if (lstat(one->path, &st) < 0)
                                            die_errno("stat '%s'", one->path);
                                    if (index_path(istate, &one->oid, one->path, &st, 0))
                                            die("cannot hash %s", one->path);
                            }
                    }
                    else
                            oidclr(&one->oid, the_repository->hash_algo);
            }

            static void strip_prefix(int prefix_length, const char **namep, const char **otherp)
            {
                    /* Strip the prefix but do not molest /dev/null and absolute paths */
                    if (*namep && !is_absolute_path(*namep)) {
                            *namep += prefix_length;
                            if (**namep == '/')
                                    ++*namep;
                    }
                    if (*otherp && !is_absolute_path(*otherp)) {
                            *otherp += prefix_length;
                            if (**otherp == '/')
                                    ++*otherp;
                    }
            }

            static void run_diff(struct diff_filepair *p, struct diff_options *o)
            {
                    const struct external_diff *pgm = external_diff();
                    struct strbuf msg;
                    struct diff_filespec *one = p->one;
                    struct diff_filespec *two = p->two;
                    const char *name;
                    const char *other;
                    const char *attr_path;

                    name  = one->path;
                    other = (strcmp(name, two->path) ? two->path : NULL);
                    attr_path = name;
                    if (o->prefix_length)
                            strip_prefix(o->prefix_length, &name, &other);

                    if (!o->flags.allow_external)
                            pgm = NULL;

                    if (DIFF_PAIR_UNMERGED(p)) {
                            run_diff_cmd(pgm, name, NULL, attr_path,
                                    NULL, NULL, NULL, o, p);
                            return;
                    }

                    diff_fill_oid_info(one, o->repo->index);
                    diff_fill_oid_info(two, o->repo->index);

                    if (!pgm &&
                    DIFF_FILE_VALID(one) && DIFF_FILE_VALID(two) &&
                    (S_IFMT & one->mode) != (S_IFMT & two->mode)) {
                            /*
                            * a filepair that changes between file and symlink
                            * needs to be split into deletion and creation.
                            */
                            struct diff_filespec *null = alloc_filespec(two->path);
                            run_diff_cmd(NULL, name, other, attr_path,
                                    one, null, &msg,
                                    o, p);
                            free(null);
                            strbuf_release(&msg);

                            null = alloc_filespec(one->path);
                            run_diff_cmd(NULL, name, other, attr_path,
                                    null, two, &msg, o, p);
                            free(null);
                    }
                    else
                            run_diff_cmd(pgm, name, other, attr_path,
                                    one, two, &msg, o, p);

                    strbuf_release(&msg);
            }

            static void run_diffstat(struct diff_filepair *p, struct diff_options *o,
                                    struct diffstat_t *diffstat)
            {
                    const char *name;
                    const char *other;

                    if (!o->ignore_driver_algorithm) {
                            struct userdiff_driver *drv = userdiff_find_by_path(o->repo->index,
                                                                            p->one->path);

                            if (drv && drv->algorithm)
                                    set_diff_algorithm(o, drv->algorithm);
                    }

                    if (DIFF_PAIR_UNMERGED(p)) {
                            /* unmerged */
                            builtin_diffstat(p->one->path, NULL, NULL, NULL,
                                            diffstat, o, p);
                            return;
                    }

                    name = p->one->path;
                    other = (strcmp(name, p->two->path) ? p->two->path : NULL);

                    if (o->prefix_length)
                            strip_prefix(o->prefix_length, &name, &other);

                    diff_fill_oid_info(p->one, o->repo->index);
                    diff_fill_oid_info(p->two, o->repo->index);

                    builtin_diffstat(name, other, p->one, p->two,
                                    diffstat, o, p);
            }

            static void run_checkdiff(struct diff_filepair *p, struct diff_options *o)
            {
                    const char *name;
                    const char *other;
                    const char *attr_path;

                    if (DIFF_PAIR_UNMERGED(p)) {
                            /* unmerged */
                            return;
                    }

                    name = p->one->path;
                    other = (strcmp(name, p->two->path) ? p->two->path : NULL);
                    attr_path = other ? other : name;

                    if (o->prefix_length)
                            strip_prefix(o->prefix_length, &name, &other);

                    diff_fill_oid_info(p->one, o->repo->index);
                    diff_fill_oid_info(p->two, o->repo->index);

                    builtin_checkdiff(name, other, attr_path, p->one, p->two, o);
            }

            void repo_diff_setup(struct repository *r, struct diff_options *options)
            {
                    memcpy(options, &default_diff_options, sizeof(*options));

                    options->file = stdout;
                    options->repo = r;

                    options->output_indicators[OUTPUT_INDICATOR_NEW] = '+';
                    options->output_indicators[OUTPUT_INDICATOR_OLD] = '-';
                    options->output_indicators[OUTPUT_INDICATOR_CONTEXT] = ' ';
                    options->abbrev = DEFAULT_ABBREV;
                    options->line_termination = '\n';
                    options->break_opt = -1;
                    options->rename_limit = -1;
                    options->dirstat_permille = diff_dirstat_permille_default;
                    options->context = diff_context_default;
                    options->interhunkcontext = diff_interhunk_context_default;
                    options->ws_error_highlight = ws_error_highlight_default;
                    options->flags.rename_empty = 1;
                    options->flags.relative_name = diff_relative;
                    options->objfind = NULL;

                    /* pathchange left =NULL by default */
                    options->change = diff_change;
                    options->add_remove = diff_addremove;
                    options->use_color = diff_use_color_default;
                    options->detect_rename = diff_detect_rename_default;
                    options->xdl_opts |= diff_algorithm;
                    if (diff_indent_heuristic)
                            DIFF_XDL_SET(options, INDENT_HEURISTIC);

                    options->orderfile = xstrdup_or_null(diff_order_file_cfg);

                    if (!options->flags.ignore_submodule_set)
                            options->flags.ignore_untracked_in_submodules = 1;

                    if (diff_no_prefix) {
                            diff_set_noprefix(options);
                    } else if (!diff_mnemonic_prefix) {
                            diff_set_default_prefix(options);
                    }

                    options->color_moved = diff_color_moved_default;
                    options->color_moved_ws_handling = diff_color_moved_ws_default;
            }

            static const char diff_status_letters[] = {
                    DIFF_STATUS_ADDED,
                    DIFF_STATUS_COPIED,
                    DIFF_STATUS_DELETED,
                    DIFF_STATUS_MODIFIED,
                    DIFF_STATUS_RENAMED,
                    DIFF_STATUS_TYPE_CHANGED,
                    DIFF_STATUS_UNKNOWN,
                    DIFF_STATUS_UNMERGED,
                    DIFF_STATUS_FILTER_AON,
                    DIFF_STATUS_FILTER_BROKEN,
                    '\0',
            };

            static unsigned int filter_bit['Z' + 1];

            static void prepare_filter_bits(void)
            {
                    int i;

                    if (!filter_bit[DIFF_STATUS_ADDED]) {
                            for (i = 0; diff_status_letters[i]; i++)
                                    filter_bit[(int) diff_status_letters[i]] = (1 << i);
                    }
            }

            static unsigned filter_bit_tst(char status, const struct diff_options *opt)
            {
                    return opt->filter & filter_bit[(int) status];
            }

            unsigned diff_filter_bit(char status)
            {
                    prepare_filter_bits();
                    return filter_bit[(int) status];
            }

            int diff_check_follow_pathspec(struct pathspec *ps, int die_on_error)
            {
                    unsigned forbidden_magic;

                    if (ps->nr != 1) {
                            if (die_on_error)
                                    die(_("--follow requires exactly one pathspec"));
                            return 0;
                    }

                    forbidden_magic = ps->items[0].magic & ~(PATHSPEC_FROMTOP |
                                                            PATHSPEC_LITERAL);
                    if (forbidden_magic) {
                            if (die_on_error) {
                                    struct strbuf sb = STRBUF_INIT;
                                    pathspec_magic_names(forbidden_magic, &sb);
                                    die(_("pathspec magic not supported by --follow: %s"),
                                    sb.buf);
                            }
                            return 0;
                    }

                    return 1;
            }

            void diff_setup_done(struct diff_options *options)
            {
                    unsigned check_mask = DIFF_FORMAT_NAME |
                                    DIFF_FORMAT_NAME_STATUS |
                                    DIFF_FORMAT_CHECKDIFF |
                                    DIFF_FORMAT_NO_OUTPUT;
                    /*
                    * This must be signed because we're comparing against a potentially
                    * negative value.
                    */
                    const int hexsz = the_hash_algo->hexsz;

                    if (options->set_default)
                            options->set_default(options);

                    if (HAS_MULTI_BITS(options->output_format & check_mask))
                            die(_("options '%s', '%s', '%s', and '%s' cannot be used together"),
                                    "--name-only", "--name-status", "--check", "-s");

                    if (HAS_MULTI_BITS(options->pickaxe_opts & DIFF_PICKAXE_KINDS_MASK))
                            die(_("options '%s', '%s', and '%s' cannot be used together"),
                                    "-G", "-S", "--find-object");

                    if (HAS_MULTI_BITS(options->pickaxe_opts & DIFF_PICKAXE_KINDS_G_REGEX_MASK))
                            die(_("options '%s' and '%s' cannot be used together, use '%s' with '%s'"),
                                    "-G", "--pickaxe-regex", "--pickaxe-regex", "-S");

                    if (HAS_MULTI_BITS(options->pickaxe_opts & DIFF_PICKAXE_KINDS_ALL_OBJFIND_MASK))
                            die(_("options '%s' and '%s' cannot be used together, use '%s' with '%s' and '%s'"),
                                    "--pickaxe-all", "--find-object", "--pickaxe-all", "-G", "-S");

                    /*
                    * Most of the time we can say "there are changes"
                    * only by checking if there are changed paths, but
                    * --ignore-whitespace* options force us to look
                    * inside contents.
                    */

                    if ((options->xdl_opts & XDF_WHITESPACE_FLAGS) ||
                    options->ignore_regex_nr)
                            options->flags.diff_from_contents = 1;
                    else
                            options->flags.diff_from_contents = 0;

                    if (options->flags.find_copies_harder)
                            options->detect_rename = DIFF_DETECT_COPY;

                    if (!options->flags.relative_name)
                            options->prefix = NULL;
                    if (options->prefix)
                            options->prefix_length = strlen(options->prefix);
                    else
                            options->prefix_length = 0;

                    /*
                    * --name-only, --name-status, --checkdiff, and -s
                    * turn other output format off.
                    */
                    if (options->output_format & (DIFF_FORMAT_NAME |
                                            DIFF_FORMAT_NAME_STATUS |
                                            DIFF_FORMAT_CHECKDIFF |
                                            DIFF_FORMAT_NO_OUTPUT))
                            options->output_format &= ~(DIFF_FORMAT_RAW |
                                                    DIFF_FORMAT_NUMSTAT |
                                                    DIFF_FORMAT_DIFFSTAT |
                                                    DIFF_FORMAT_SHORTSTAT |
                                                    DIFF_FORMAT_DIRSTAT |
                                                    DIFF_FORMAT_SUMMARY |
                                                    DIFF_FORMAT_PATCH);

                    /*
                    * These cases always need recursive; we do not drop caller-supplied
                    * recursive bits for other formats here.
                    */
                    if (options->output_format & (DIFF_FORMAT_PATCH |
                                            DIFF_FORMAT_NUMSTAT |
                                            DIFF_FORMAT_DIFFSTAT |
                                            DIFF_FORMAT_SHORTSTAT |
                                            DIFF_FORMAT_DIRSTAT |
                                            DIFF_FORMAT_SUMMARY |
                                            DIFF_FORMAT_CHECKDIFF))
                            options->flags.recursive = 1;
                    /*
                    * Also pickaxe would not work very well if you do not say recursive
                    */
                    if (options->pickaxe_opts & DIFF_PICKAXE_KINDS_MASK)
                            options->flags.recursive = 1;
                    /*
                    * When patches are generated, submodules diffed against the work tree
                    * must be checked for dirtiness too so it can be shown in the output
                    */
                    if (options->output_format & DIFF_FORMAT_PATCH)
                            options->flags.dirty_submodules = 1;

                    if (options->detect_rename && options->rename_limit < 0)
                            options->rename_limit = diff_rename_limit_default;
                    if (hexsz < options->abbrev)
                            options->abbrev = hexsz; /* full */

                    /*
                    * It does not make sense to show the first hit we happened
                    * to have found.  It does not make sense not to return with
                    * exit code in such a case either.
                    */
                    if (options->flags.quick) {
                            options->output_format = DIFF_FORMAT_NO_OUTPUT;
                            options->flags.exit_with_status = 1;
                    }

                    /*
                    * External diffs could declare non-identical contents equal
                    * (think diff --ignore-space-change).
                    */
                    if (options->flags.allow_external && options->flags.exit_with_status)
                            options->flags.diff_from_contents = 1;

                    options->diff_path_counter = 0;

                    if (options->flags.follow_renames)
                            diff_check_follow_pathspec(&options->pathspec, 1);

                    if (!options->use_color ||
                    (options->flags.allow_external && external_diff()))
                            options->color_moved = 0;

                    if (options->filter_not) {
                            if (!options->filter)
                                    options->filter = ~filter_bit[DIFF_STATUS_FILTER_AON];
                            options->filter &= ~options->filter_not;
                    }
            }

            int parse_long_opt(const char *opt, const char **argv,
                            const char **optarg)
            {
                    const char *arg = argv[0];
                    if (!skip_prefix(arg, "--", &arg))
                            return 0;
                    if (!skip_prefix(arg, opt, &arg))
                            return 0;
                    if (*arg == '=') { /* stuck form: --option=value */
                            *optarg = arg + 1;
                            return 1;
                    }
                    if (*arg != '\0')
                            return 0;
                    /* separate form: --option value */
                    if (!argv[1])
                            die("Option '--%s' requires a value", opt);
                    *optarg = argv[1];
                    return 2;
            }

            static int diff_opt_stat(const struct option *opt, const char *value, int unset)
            {
                    struct diff_options *options = opt->value;
                    int width = options->stat_width;
                    int name_width = options->stat_name_width;
                    int graph_width = options->stat_graph_width;
                    int count = options->stat_count;
                    char *end;

                    BUG_ON_OPT_NEG(unset);

                    if (!strcmp(opt->long_name, "stat")) {
                            if (value) {
                                    width = strtoul(value, &end, 10);
                                    if (*end == ',')
                                            name_width = strtoul(end+1, &end, 10);
                                    if (*end == ',')
                                            count = strtoul(end+1, &end, 10);
                                    if (*end)
                                            return error(_("invalid --stat value: %s"), value);
                            }
                    } else if (!strcmp(opt->long_name, "stat-width")) {
                            width = strtoul(value, &end, 10);
                            if (*end)
                                    return error(_("%s expects a numerical value"),
                                            opt->long_name);
                    } else if (!strcmp(opt->long_name, "stat-name-width")) {
                            name_width = strtoul(value, &end, 10);
                            if (*end)
                                    return error(_("%s expects a numerical value"),
                                            opt->long_name);
                    } else if (!strcmp(opt->long_name, "stat-graph-width")) {
                            graph_width = strtoul(value, &end, 10);
                            if (*end)
                                    return error(_("%s expects a numerical value"),
                                            opt->long_name);
                    } else if (!strcmp(opt->long_name, "stat-count")) {
                            count = strtoul(value, &end, 10);
                            if (*end)
                                    return error(_("%s expects a numerical value"),
                                            opt->long_name);
                    } else
                            BUG("%s should not get here", opt->long_name);

                    options->output_format &= ~DIFF_FORMAT_NO_OUTPUT;
                    options->output_format |= DIFF_FORMAT_DIFFSTAT;
                    options->stat_name_width = name_width;
                    options->stat_graph_width = graph_width;
                    options->stat_width = width;
                    options->stat_count = count;
                    return 0;
            }

            static int parse_dirstat_opt(struct diff_options *options, const char *params)
            {
                    struct strbuf errmsg = STRBUF_INIT;
                    if (parse_dirstat_params(options, params, &errmsg))
                            die(_("Failed to parse --dirstat/-X option parameter:\n%s"),
                            errmsg.buf);
                    strbuf_release(&errmsg);
                    /*
                    * The caller knows a dirstat-related option is given from the command
                    * line; allow it to say "return this_function();"
                    */
                    options->output_format &= ~DIFF_FORMAT_NO_OUTPUT;
                    options->output_format |= DIFF_FORMAT_DIRSTAT;
                    return 1;
            }

            static int diff_opt_diff_filter(const struct option *option,
                                            const char *optarg, int unset)
            {
                    struct diff_options *opt = option->value;
                    int i, optch;

                    BUG_ON_OPT_NEG(unset);
                    prepare_filter_bits();

                    for (i = 0; (optch = optarg[i]) != '\0'; i++) {
                            unsigned int bit;
                            int negate;

                            if ('a' <= optch && optch <= 'z') {
                                    negate = 1;
                                    optch = toupper(optch);
                            } else {
                                    negate = 0;
                            }

                            bit = (0 <= optch && optch <= 'Z') ? filter_bit[optch] : 0;
                            if (!bit)
                                    return error(_("unknown change class '%c' in --diff-filter=%s"),
                                            optarg[i], optarg);
                            if (negate)
                                    opt->filter_not |= bit;
                            else
                                    opt->filter |= bit;
                    }
                    return 0;
            }

            static void enable_patch_output(int *fmt)
            {
                    *fmt &= ~DIFF_FORMAT_NO_OUTPUT;
                    *fmt |= DIFF_FORMAT_PATCH;
            }

            static int diff_opt_ws_error_highlight(const struct option *option,
                                            const char *arg, int unset)
            {
                    struct diff_options *opt = option->value;
                    int val = parse_ws_error_highlight(arg);

                    BUG_ON_OPT_NEG(unset);
                    if (val < 0)
                            return error(_("unknown value after ws-error-highlight=%.*s"),
                                    -1 - val, arg);
                    opt->ws_error_highlight = val;
                    return 0;
            }

            static int diff_opt_find_object(const struct option *option,
                                            const char *arg, int unset)
            {
                    struct diff_options *opt = option->value;
                    struct object_id oid;

                    BUG_ON_OPT_NEG(unset);
                    if (repo_get_oid(the_repository, arg, &oid))
                            return error(_("unable to resolve '%s'"), arg);

                    if (!opt->objfind)
                            CALLOC_ARRAY(opt->objfind, 1);

                    opt->pickaxe_opts |= DIFF_PICKAXE_KIND_OBJFIND;
                    opt->flags.recursive = 1;
                    opt->flags.tree_in_recursive = 1;
                    oidset_insert(opt->objfind, &oid);
                    return 0;
            }

            static int diff_opt_anchored(const struct option *opt,
                                    const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;

                    BUG_ON_OPT_NEG(unset);
                    options->xdl_opts = DIFF_WITH_ALG(options, PATIENCE_DIFF);
                    ALLOC_GROW(options->anchors, options->anchors_nr + 1,
                            options->anchors_alloc);
                    options->anchors[options->anchors_nr++] = xstrdup(arg);
                    return 0;
            }

            static int diff_opt_binary(const struct option *opt,
                                    const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;

                    BUG_ON_OPT_NEG(unset);
                    BUG_ON_OPT_ARG(arg);
                    enable_patch_output(&options->output_format);
                    options->flags.binary = 1;
                    return 0;
            }

            static int diff_opt_break_rewrites(const struct option *opt,
                                            const char *arg, int unset)
            {
                    int *break_opt = opt->value;
                    int opt1, opt2;

                    BUG_ON_OPT_NEG(unset);
                    if (!arg)
                            arg = "";
                    opt1 = parse_rename_score(&arg);
                    if (*arg == 0)
                            opt2 = 0;
                    else if (*arg != '/')
                            return error(_("%s expects <n>/<m> form"), opt->long_name);
                    else {
                            arg++;
                            opt2 = parse_rename_score(&arg);
                    }
                    if (*arg != 0)
                            return error(_("%s expects <n>/<m> form"), opt->long_name);
                    *break_opt = opt1 | (opt2 << 16);
                    return 0;
            }

            static int diff_opt_char(const struct option *opt,
                                    const char *arg, int unset)
            {
                    char *value = opt->value;

                    BUG_ON_OPT_NEG(unset);
                    if (arg[1])
                            return error(_("%s expects a character, got '%s'"),
                                    opt->long_name, arg);
                    *value = arg[0];
                    return 0;
            }

            static int diff_opt_color_moved(const struct option *opt,
                                            const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;

                    if (unset) {
                            options->color_moved = COLOR_MOVED_NO;
                    } else if (!arg) {
                            if (diff_color_moved_default)
                                    options->color_moved = diff_color_moved_default;
                            if (options->color_moved == COLOR_MOVED_NO)
                                    options->color_moved = COLOR_MOVED_DEFAULT;
                    } else {
                            int cm = parse_color_moved(arg);
                            if (cm < 0)
                                    return error(_("bad --color-moved argument: %s"), arg);
                            options->color_moved = cm;
                    }
                    return 0;
            }

            static int diff_opt_color_moved_ws(const struct option *opt,
                                            const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;
                    unsigned cm;

                    if (unset) {
                            options->color_moved_ws_handling = 0;
                            return 0;
                    }

                    cm = parse_color_moved_ws(arg);
                    if (cm & COLOR_MOVED_WS_ERROR)
                            return error(_("invalid mode '%s' in --color-moved-ws"), arg);
                    options->color_moved_ws_handling = cm;
                    return 0;
            }

            static int diff_opt_color_words(const struct option *opt,
                                            const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;

                    BUG_ON_OPT_NEG(unset);
                    options->use_color = 1;
                    options->word_diff = DIFF_WORDS_COLOR;
                    options->word_regex = arg;
                    return 0;
            }

            static int diff_opt_compact_summary(const struct option *opt,
                                            const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;

                    BUG_ON_OPT_ARG(arg);
                    if (unset) {
                            options->flags.stat_with_summary = 0;
                    } else {
                            options->flags.stat_with_summary = 1;
                            options->output_format &= ~DIFF_FORMAT_NO_OUTPUT;
                            options->output_format |= DIFF_FORMAT_DIFFSTAT;
                    }
                    return 0;
            }

            static int diff_opt_diff_algorithm(const struct option *opt,
                                            const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;

                    BUG_ON_OPT_NEG(unset);

                    if (set_diff_algorithm(options, arg))
                            return error(_("option diff-algorithm accepts \"myers\", "
                                    "\"minimal\", \"patience\" and \"histogram\""));

                    options->ignore_driver_algorithm = 1;

                    return 0;
            }

            static int diff_opt_diff_algorithm_no_arg(const struct option *opt,
                                            const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;

                    BUG_ON_OPT_NEG(unset);
                    BUG_ON_OPT_ARG(arg);

                    if (set_diff_algorithm(options, opt->long_name))
                            BUG("available diff algorithms include \"myers\", "
                                    "\"minimal\", \"patience\" and \"histogram\"");

                    options->ignore_driver_algorithm = 1;

                    return 0;
            }

            static int diff_opt_dirstat(const struct option *opt,
                                    const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;

                    BUG_ON_OPT_NEG(unset);
                    if (!strcmp(opt->long_name, "cumulative")) {
                            if (arg)
                                    BUG("how come --cumulative take a value?");
                            arg = "cumulative";
                    } else if (!strcmp(opt->long_name, "dirstat-by-file"))
                            parse_dirstat_opt(options, "files");
                    parse_dirstat_opt(options, arg ? arg : "");
                    return 0;
            }

            static int diff_opt_find_copies(const struct option *opt,
                                            const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;

                    BUG_ON_OPT_NEG(unset);
                    if (!arg)
                            arg = "";
                    options->rename_score = parse_rename_score(&arg);
                    if (*arg != 0)
                            return error(_("invalid argument to %s"), opt->long_name);

                    if (options->detect_rename == DIFF_DETECT_COPY)
                            options->flags.find_copies_harder = 1;
                    else
                            options->detect_rename = DIFF_DETECT_COPY;

                    return 0;
            }

            static int diff_opt_find_renames(const struct option *opt,
                                            const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;

                    BUG_ON_OPT_NEG(unset);
                    if (!arg)
                            arg = "";
                    options->rename_score = parse_rename_score(&arg);
                    if (*arg != 0)
                            return error(_("invalid argument to %s"), opt->long_name);

                    options->detect_rename = DIFF_DETECT_RENAME;
                    return 0;
            }

            static int diff_opt_follow(const struct option *opt,
                                    const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;

                    BUG_ON_OPT_ARG(arg);
                    if (unset) {
                            options->flags.follow_renames = 0;
                            options->flags.default_follow_renames = 0;
                    } else {
                            options->flags.follow_renames = 1;
                    }
                    return 0;
            }

            static int diff_opt_ignore_submodules(const struct option *opt,
                                            const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;

                    BUG_ON_OPT_NEG(unset);
                    if (!arg)
                            arg = "all";
                    options->flags.override_submodule_config = 1;
                    handle_ignore_submodules_arg(options, arg);
                    return 0;
            }

            static int diff_opt_line_prefix(const struct option *opt,
                                            const char *optarg, int unset)
            {
                    struct diff_options *options = opt->value;

                    BUG_ON_OPT_NEG(unset);
                    options->line_prefix = optarg;
                    graph_setup_line_prefix(options);
                    return 0;
            }

            static int diff_opt_no_prefix(const struct option *opt,
                                    const char *optarg, int unset)
            {
                    struct diff_options *options = opt->value;

                    BUG_ON_OPT_NEG(unset);
                    BUG_ON_OPT_ARG(optarg);
                    diff_set_noprefix(options);
                    return 0;
            }

            static int diff_opt_default_prefix(const struct option *opt,
                                            const char *optarg, int unset)
            {
                    struct diff_options *options = opt->value;

                    BUG_ON_OPT_NEG(unset);
                    BUG_ON_OPT_ARG(optarg);
                    FREE_AND_NULL(diff_src_prefix);
                    FREE_AND_NULL(diff_dst_prefix);
                    diff_set_default_prefix(options);
                    return 0;
            }

            static enum parse_opt_result diff_opt_output(struct parse_opt_ctx_t *ctx,
                                                    const struct option *opt,
                                                    const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;
                    char *path;

                    BUG_ON_OPT_NEG(unset);
                    path = prefix_filename(ctx->prefix, arg);
                    options->file = xfopen(path, "w");
                    options->close_file = 1;
                    if (options->use_color != GIT_COLOR_ALWAYS)
                            options->use_color = GIT_COLOR_NEVER;
                    free(path);
                    return 0;
            }

            static int diff_opt_patience(const struct option *opt,
                                    const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;
                    int i;

                    BUG_ON_OPT_NEG(unset);
                    BUG_ON_OPT_ARG(arg);
                    /*
                    * Both --patience and --anchored use PATIENCE_DIFF
                    * internally, so remove any anchors previously
                    * specified.
                    */
                    for (i = 0; i < options->anchors_nr; i++)
                            free(options->anchors[i]);
                    options->anchors_nr = 0;
                    options->ignore_driver_algorithm = 1;

                    return set_diff_algorithm(options, "patience");
            }

            static int diff_opt_ignore_regex(const struct option *opt,
                                            const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;
                    regex_t *regex;

                    BUG_ON_OPT_NEG(unset);

                    regex = xmalloc(sizeof(*regex));
                    if (regcomp(regex, arg, REG_EXTENDED | REG_NEWLINE)) {
                            free(regex);
                            return error(_("invalid regex given to -I: '%s'"), arg);
                    }

                    ALLOC_GROW(options->ignore_regex, options->ignore_regex_nr + 1,
                            options->ignore_regex_alloc);
                    options->ignore_regex[options->ignore_regex_nr++] = regex;
                    return 0;
            }

            static int diff_opt_pickaxe_regex(const struct option *opt,
                                            const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;

                    BUG_ON_OPT_NEG(unset);
                    options->pickaxe = arg;
                    options->pickaxe_opts |= DIFF_PICKAXE_KIND_G;
                    return 0;
            }

            static int diff_opt_pickaxe_string(const struct option *opt,
                                            const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;

                    BUG_ON_OPT_NEG(unset);
                    options->pickaxe = arg;
                    options->pickaxe_opts |= DIFF_PICKAXE_KIND_S;
                    return 0;
            }

            static int diff_opt_relative(const struct option *opt,
                                    const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;

                    options->flags.relative_name = !unset;
                    if (arg)
                            options->prefix = arg;
                    return 0;
            }

            static int diff_opt_submodule(const struct option *opt,
                                    const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;

                    BUG_ON_OPT_NEG(unset);
                    if (!arg)
                            arg = "log";
                    if (parse_submodule_params(options, arg))
                            return error(_("failed to parse --submodule option parameter: '%s'"),
                                    arg);
                    return 0;
            }

            static int diff_opt_textconv(const struct option *opt,
                                    const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;

                    BUG_ON_OPT_ARG(arg);
                    if (unset) {
                            options->flags.allow_textconv = 0;
                    } else {
                            options->flags.allow_textconv = 1;
                            options->flags.textconv_set_via_cmdline = 1;
                    }
                    return 0;
            }

            static int diff_opt_unified(const struct option *opt,
                                    const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;
                    char *s;

                    BUG_ON_OPT_NEG(unset);

                    if (arg) {
                            options->context = strtol(arg, &s, 10);
                            if (*s)
                                    return error(_("%s expects a numerical value"), "--unified");
                    }
                    enable_patch_output(&options->output_format);

                    return 0;
            }

            static int diff_opt_word_diff(const struct option *opt,
                                    const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;

                    BUG_ON_OPT_NEG(unset);
                    if (arg) {
                            if (!strcmp(arg, "plain"))
                                    options->word_diff = DIFF_WORDS_PLAIN;
                            else if (!strcmp(arg, "color")) {
                                    options->use_color = 1;
                                    options->word_diff = DIFF_WORDS_COLOR;
                            }
                            else if (!strcmp(arg, "porcelain"))
                                    options->word_diff = DIFF_WORDS_PORCELAIN;
                            else if (!strcmp(arg, "none"))
                                    options->word_diff = DIFF_WORDS_NONE;
                            else
                                    return error(_("bad --word-diff argument: %s"), arg);
                    } else {
                            if (options->word_diff == DIFF_WORDS_NONE)
                                    options->word_diff = DIFF_WORDS_PLAIN;
                    }
                    return 0;
            }

            static int diff_opt_word_diff_regex(const struct option *opt,
                                            const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;

                    BUG_ON_OPT_NEG(unset);
                    if (options->word_diff == DIFF_WORDS_NONE)
                            options->word_diff = DIFF_WORDS_PLAIN;
                    options->word_regex = arg;
                    return 0;
            }

            static int diff_opt_rotate_to(const struct option *opt, const char *arg, int unset)
            {
                    struct diff_options *options = opt->value;

                    BUG_ON_OPT_NEG(unset);
                    if (!strcmp(opt->long_name, "skip-to"))
                            options->skip_instead_of_rotate = 1;
                    else
                            options->skip_instead_of_rotate = 0;
                    options->rotate_to = arg;
                    return 0;
            }

            /*
            * Consider adding new flags to __git_diff_common_options
            * in contrib/completion/git-completion.bash
            */
            struct option *add_diff_options(const struct option *opts,
                                            struct diff_options *options)
            {
                    struct option parseopts[] = {
                            OPT_GROUP(N_("Diff output format options")),
                            OPT_BITOP('p', "patch", &options->output_format,
                                    N_("generate patch"),
                                    DIFF_FORMAT_PATCH, DIFF_FORMAT_NO_OUTPUT),
                            OPT_SET_INT('s', "no-patch", &options->output_format,
                                    N_("suppress diff output"), DIFF_FORMAT_NO_OUTPUT),
                            OPT_BITOP('u', NULL, &options->output_format,
                                    N_("generate patch"),
                                    DIFF_FORMAT_PATCH, DIFF_FORMAT_NO_OUTPUT),
                            OPT_CALLBACK_F('U', "unified", options, N_("<n>"),
                                    N_("generate diffs with <n> lines context"),
                                    PARSE_OPT_NONEG | PARSE_OPT_OPTARG, diff_opt_unified),
                            OPT_BOOL('W', "function-context", &options->flags.funccontext,
                                    N_("generate diffs with <n> lines context")),
                            OPT_BITOP(0, "raw", &options->output_format,
                                    N_("generate the diff in raw format"),
                                    DIFF_FORMAT_RAW, DIFF_FORMAT_NO_OUTPUT),
                            OPT_BITOP(0, "patch-with-raw", &options->output_format,
                                    N_("synonym for '-p --raw'"),
                                    DIFF_FORMAT_PATCH | DIFF_FORMAT_RAW,
                                    DIFF_FORMAT_NO_OUTPUT),
                            OPT_BITOP(0, "patch-with-stat", &options->output_format,
                                    N_("synonym for '-p --stat'"),
                                    DIFF_FORMAT_PATCH | DIFF_FORMAT_DIFFSTAT,
                                    DIFF_FORMAT_NO_OUTPUT),
                            OPT_BITOP(0, "numstat", &options->output_format,
                                    N_("machine friendly --stat"),
                                    DIFF_FORMAT_NUMSTAT, DIFF_FORMAT_NO_OUTPUT),
                            OPT_BITOP(0, "shortstat", &options->output_format,
                                    N_("output only the last line of --stat"),
                                    DIFF_FORMAT_SHORTSTAT, DIFF_FORMAT_NO_OUTPUT),
                            OPT_CALLBACK_F('X', "dirstat", options, N_("<param1>,<param2>..."),
                                    N_("output the distribution of relative amount of changes for each sub-directory"),
                                    PARSE_OPT_NONEG | PARSE_OPT_OPTARG,
                                    diff_opt_dirstat),
                            OPT_CALLBACK_F(0, "cumulative", options, NULL,
                                    N_("synonym for --dirstat=cumulative"),
                                    PARSE_OPT_NONEG | PARSE_OPT_NOARG,
                                    diff_opt_dirstat),
                            OPT_CALLBACK_F(0, "dirstat-by-file", options, N_("<param1>,<param2>..."),
                                    N_("synonym for --dirstat=files,<param1>,<param2>..."),
                                    PARSE_OPT_NONEG | PARSE_OPT_OPTARG,
                                    diff_opt_dirstat),
                            OPT_BIT_F(0, "check", &options->output_format,
                                    N_("warn if changes introduce conflict markers or whitespace errors"),
                                    DIFF_FORMAT_CHECKDIFF, PARSE_OPT_NONEG),
                            OPT_BITOP(0, "summary", &options->output_format,
                                    N_("condensed summary such as creations, renames and mode changes"),
                                    DIFF_FORMAT_SUMMARY, DIFF_FORMAT_NO_OUTPUT),
                            OPT_BIT_F(0, "name-only", &options->output_format,
                                    N_("show only names of changed files"),
                                    DIFF_FORMAT_NAME, PARSE_OPT_NONEG),
                            OPT_BIT_F(0, "name-status", &options->output_format,
                                    N_("show only names and status of changed files"),
                                    DIFF_FORMAT_NAME_STATUS, PARSE_OPT_NONEG),
                            OPT_CALLBACK_F(0, "stat", options, N_("<width>[,<name-width>[,<count>]]"),
                                    N_("generate diffstat"),
                                    PARSE_OPT_NONEG | PARSE_OPT_OPTARG, diff_opt_stat),
                            OPT_CALLBACK_F(0, "stat-width", options, N_("<width>"),
                                    N_("generate diffstat with a given width"),
                                    PARSE_OPT_NONEG, diff_opt_stat),
                            OPT_CALLBACK_F(0, "stat-name-width", options, N_("<width>"),
                                    N_("generate diffstat with a given name width"),
                                    PARSE_OPT_NONEG, diff_opt_stat),
                            OPT_CALLBACK_F(0, "stat-graph-width", options, N_("<width>"),
                                    N_("generate diffstat with a given graph width"),
                                    PARSE_OPT_NONEG, diff_opt_stat),
                            OPT_CALLBACK_F(0, "stat-count", options, N_("<count>"),
                                    N_("generate diffstat with limited lines"),
                                    PARSE_OPT_NONEG, diff_opt_stat),
                            OPT_CALLBACK_F(0, "compact-summary", options, NULL,
                                    N_("generate compact summary in diffstat"),
                                    PARSE_OPT_NOARG, diff_opt_compact_summary),
                            OPT_CALLBACK_F(0, "binary", options, NULL,
                                    N_("output a binary diff that can be applied"),
                                    PARSE_OPT_NONEG | PARSE_OPT_NOARG, diff_opt_binary),
                            OPT_BOOL(0, "full-index", &options->flags.full_index,
                                    N_("show full pre- and post-image object names on the \"index\" lines")),
                            OPT_COLOR_FLAG(0, "color", &options->use_color,
                                    N_("show colored diff")),
                            OPT_CALLBACK_F(0, "ws-error-highlight", options, N_("<kind>"),
                                    N_("highlight whitespace errors in the 'context', 'old' or 'new' lines in the diff"),
                                    PARSE_OPT_NONEG, diff_opt_ws_error_highlight),
                            OPT_SET_INT('z', NULL, &options->line_termination,
                                    N_("do not munge pathnames and use NULs as output field terminators in --raw or --numstat"),
                                    0),
                            OPT__ABBREV(&options->abbrev),
                            OPT_STRING_F(0, "src-prefix", &options->a_prefix, N_("<prefix>"),
                                    N_("show the given source prefix instead of \"a/\""),
                                    PARSE_OPT_NONEG),
                            OPT_STRING_F(0, "dst-prefix", &options->b_prefix, N_("<prefix>"),
                                    N_("show the given destination prefix instead of \"b/\""),
                                    PARSE_OPT_NONEG),
                            OPT_CALLBACK_F(0, "line-prefix", options, N_("<prefix>"),
                                    N_("prepend an additional prefix to every line of output"),
                                    PARSE_OPT_NONEG, diff_opt_line_prefix),
                            OPT_CALLBACK_F(0, "no-prefix", options, NULL,
                                    N_("do not show any source or destination prefix"),
                                    PARSE_OPT_NONEG | PARSE_OPT_NOARG, diff_opt_no_prefix),
                            OPT_CALLBACK_F(0, "default-prefix", options, NULL,
                                    N_("use default prefixes a/ and b/"),
                                    PARSE_OPT_NONEG | PARSE_OPT_NOARG, diff_opt_default_prefix),
                            OPT_INTEGER_F(0, "inter-hunk-context", &options->interhunkcontext,
                                    N_("show context between diff hunks up to the specified number of lines"),
                                    PARSE_OPT_NONEG),
                            OPT_CALLBACK_F(0, "output-indicator-new",
                                    &options->output_indicators[OUTPUT_INDICATOR_NEW],
                                    N_("<char>"),
                                    N_("specify the character to indicate a new line instead of '+'"),
                                    PARSE_OPT_NONEG, diff_opt_char),
                            OPT_CALLBACK_F(0, "output-indicator-old",
                                    &options->output_indicators[OUTPUT_INDICATOR_OLD],
                                    N_("<char>"),
                                    N_("specify the character to indicate an old line instead of '-'"),
                                    PARSE_OPT_NONEG, diff_opt_char),
                            OPT_CALLBACK_F(0, "output-indicator-context",
                                    &options->output_indicators[OUTPUT_INDICATOR_CONTEXT],
                                    N_("<char>"),
                                    N_("specify the character to indicate a context instead of ' '"),
                                    PARSE_OPT_NONEG, diff_opt_char),

                            OPT_GROUP(N_("Diff rename options")),
                            OPT_CALLBACK_F('B', "break-rewrites", &options->break_opt, N_("<n>[/<m>]"),
                                    N_("break complete rewrite changes into pairs of delete and create"),
                                    PARSE_OPT_NONEG | PARSE_OPT_OPTARG,
                                    diff_opt_break_rewrites),
                            OPT_CALLBACK_F('M', "find-renames", options, N_("<n>"),
                                    N_("detect renames"),
                                    PARSE_OPT_NONEG | PARSE_OPT_OPTARG,
                                    diff_opt_find_renames),
                            OPT_SET_INT_F('D', "irreversible-delete", &options->irreversible_delete,
                                    N_("omit the preimage for deletes"),
                                    1, PARSE_OPT_NONEG),
                            OPT_CALLBACK_F('C', "find-copies", options, N_("<n>"),
                                    N_("detect copies"),
                                    PARSE_OPT_NONEG | PARSE_OPT_OPTARG,
                                    diff_opt_find_copies),
                            OPT_BOOL(0, "find-copies-harder", &options->flags.find_copies_harder,
                                    N_("use unmodified files as source to find copies")),
                            OPT_SET_INT_F(0, "no-renames", &options->detect_rename,
                                    N_("disable rename detection"),
                                    0, PARSE_OPT_NONEG),
                            OPT_BOOL(0, "rename-empty", &options->flags.rename_empty,
                                    N_("use empty blobs as rename source")),
                            OPT_CALLBACK_F(0, "follow", options, NULL,
                                    N_("continue listing the history of a file beyond renames"),
                                    PARSE_OPT_NOARG, diff_opt_follow),
                            OPT_INTEGER('l', NULL, &options->rename_limit,
                                    N_("prevent rename/copy detection if the number of rename/copy targets exceeds given limit")),

                            OPT_GROUP(N_("Diff algorithm options")),
                            OPT_CALLBACK_F(0, "minimal", options, NULL,
                                    N_("produce the smallest possible diff"),
                                    PARSE_OPT_NONEG | PARSE_OPT_NOARG,
                                    diff_opt_diff_algorithm_no_arg),
                            OPT_BIT_F('w', "ignore-all-space", &options->xdl_opts,
                                    N_("ignore whitespace when comparing lines"),
                                    XDF_IGNORE_WHITESPACE, PARSE_OPT_NONEG),
                            OPT_BIT_F('b', "ignore-space-change", &options->xdl_opts,
                                    N_("ignore changes in amount of whitespace"),
                                    XDF_IGNORE_WHITESPACE_CHANGE, PARSE_OPT_NONEG),
                            OPT_BIT_F(0, "ignore-space-at-eol", &options->xdl_opts,
                                    N_("ignore changes in whitespace at EOL"),
                                    XDF_IGNORE_WHITESPACE_AT_EOL, PARSE_OPT_NONEG),
                            OPT_BIT_F(0, "ignore-cr-at-eol", &options->xdl_opts,
                                    N_("ignore carrier-return at the end of line"),
                                    XDF_IGNORE_CR_AT_EOL, PARSE_OPT_NONEG),
                            OPT_BIT_F(0, "ignore-blank-lines", &options->xdl_opts,
                                    N_("ignore changes whose lines are all blank"),
                                    XDF_IGNORE_BLANK_LINES, PARSE_OPT_NONEG),
                            OPT_CALLBACK_F('I', "ignore-matching-lines", options, N_("<regex>"),
                                    N_("ignore changes whose all lines match <regex>"),
                                    0, diff_opt_ignore_regex),
                            OPT_BIT(0, "indent-heuristic", &options->xdl_opts,
                                    N_("heuristic to shift diff hunk boundaries for easy reading"),
                                    XDF_INDENT_HEURISTIC),
                            OPT_CALLBACK_F(0, "patience", options, NULL,
                                    N_("generate diff using the \"patience diff\" algorithm"),
                                    PARSE_OPT_NONEG | PARSE_OPT_NOARG,
                                    diff_opt_patience),
                            OPT_CALLBACK_F(0, "histogram", options, NULL,
                                    N_("generate diff using the \"histogram diff\" algorithm"),
                                    PARSE_OPT_NONEG | PARSE_OPT_NOARG,
                                    diff_opt_diff_algorithm_no_arg),
                            OPT_CALLBACK_F(0, "diff-algorithm", options, N_("<algorithm>"),
                                    N_("choose a diff algorithm"),
                                    PARSE_OPT_NONEG, diff_opt_diff_algorithm),
                            OPT_CALLBACK_F(0, "anchored", options, N_("<text>"),
                                    N_("generate diff using the \"anchored diff\" algorithm"),
                                    PARSE_OPT_NONEG, diff_opt_anchored),
                            OPT_CALLBACK_F(0, "word-diff", options, N_("<mode>"),
                                    N_("show word diff, using <mode> to delimit changed words"),
                                    PARSE_OPT_NONEG | PARSE_OPT_OPTARG, diff_opt_word_diff),
                            OPT_CALLBACK_F(0, "word-diff-regex", options, N_("<regex>"),
                                    N_("use <regex> to decide what a word is"),
                                    PARSE_OPT_NONEG, diff_opt_word_diff_regex),
                            OPT_CALLBACK_F(0, "color-words", options, N_("<regex>"),
                                    N_("equivalent to --word-diff=color --word-diff-regex=<regex>"),
                                    PARSE_OPT_NONEG | PARSE_OPT_OPTARG, diff_opt_color_words),
                            OPT_CALLBACK_F(0, "color-moved", options, N_("<mode>"),
                                    N_("moved lines of code are colored differently"),
                                    PARSE_OPT_OPTARG, diff_opt_color_moved),
                            OPT_CALLBACK_F(0, "color-moved-ws", options, N_("<mode>"),
                                    N_("how white spaces are ignored in --color-moved"),
                                    0, diff_opt_color_moved_ws),

                            OPT_GROUP(N_("Other diff options")),
                            OPT_CALLBACK_F(0, "relative", options, N_("<prefix>"),
                                    N_("when run from subdir, exclude changes outside and show relative paths"),
                                    PARSE_OPT_OPTARG,
                                    diff_opt_relative),
                            OPT_BOOL('a', "text", &options->flags.text,
                                    N_("treat all files as text")),
                            OPT_BOOL('R', NULL, &options->flags.reverse_diff,
                                    N_("swap two inputs, reverse the diff")),
                            OPT_BOOL(0, "exit-code", &options->flags.exit_with_status,
                                    N_("exit with 1 if there were differences, 0 otherwise")),
                            OPT_BOOL(0, "quiet", &options->flags.quick,
                                    N_("disable all output of the program")),
                            OPT_BOOL(0, "ext-diff", &options->flags.allow_external,
                                    N_("allow an external diff helper to be executed")),
                            OPT_CALLBACK_F(0, "textconv", options, NULL,
                                    N_("run external text conversion filters when comparing binary files"),
                                    PARSE_OPT_NOARG, diff_opt_textconv),
                            OPT_CALLBACK_F(0, "ignore-submodules", options, N_("<when>"),
                                    N_("ignore changes to submodules in the diff generation"),
                                    PARSE_OPT_NONEG | PARSE_OPT_OPTARG,
                                    diff_opt_ignore_submodules),
                            OPT_CALLBACK_F(0, "submodule", options, N_("<format>"),
                                    N_("specify how differences in submodules are shown"),
                                    PARSE_OPT_NONEG | PARSE_OPT_OPTARG,
                                    diff_opt_submodule),
                            OPT_SET_INT_F(0, "ita-invisible-in-index", &options->ita_invisible_in_index,
                                    N_("hide 'git add -N' entries from the index"),
                                    1, PARSE_OPT_NONEG),
                            OPT_SET_INT_F(0, "ita-visible-in-index", &options->ita_invisible_in_index,
                                    N_("treat 'git add -N' entries as real in the index"),
                                    0, PARSE_OPT_NONEG),
                            OPT_CALLBACK_F('S', NULL, options, N_("<string>"),
                                    N_("look for differences that change the number of occurrences of the specified string"),
                                    0, diff_opt_pickaxe_string),
                            OPT_CALLBACK_F('G', NULL, options, N_("<regex>"),
                                    N_("look for differences that change the number of occurrences of the specified regex"),
                                    0, diff_opt_pickaxe_regex),
                            OPT_BIT_F(0, "pickaxe-all", &options->pickaxe_opts,
                                    N_("show all changes in the changeset with -S or -G"),
                                    DIFF_PICKAXE_ALL, PARSE_OPT_NONEG),
                            OPT_BIT_F(0, "pickaxe-regex", &options->pickaxe_opts,
                                    N_("treat <string> in -S as extended POSIX regular expression"),
                                    DIFF_PICKAXE_REGEX, PARSE_OPT_NONEG),
                            OPT_FILENAME('O', NULL, &options->orderfile,
                                    N_("control the order in which files appear in the output")),
                            OPT_CALLBACK_F(0, "rotate-to", options, N_("<path>"),
                                    N_("show the change in the specified path first"),
                                    PARSE_OPT_NONEG, diff_opt_rotate_to),
                            OPT_CALLBACK_F(0, "skip-to", options, N_("<path>"),
                                    N_("skip the output to the specified path"),
                                    PARSE_OPT_NONEG, diff_opt_rotate_to),
                            OPT_CALLBACK_F(0, "find-object", options, N_("<object-id>"),
                                    N_("look for differences that change the number of occurrences of the specified object"),
                                    PARSE_OPT_NONEG, diff_opt_find_object),
                            OPT_CALLBACK_F(0, "diff-filter", options, N_("[(A|C|D|M|R|T|U|X|B)...[*]]"),
                                    N_("select files by diff type"),
                                    PARSE_OPT_NONEG, diff_opt_diff_filter),
                            { OPTION_CALLBACK, 0, "output", options, N_("<file>"),
                            N_("output to a specific file"),
                            PARSE_OPT_NONEG, NULL, 0, diff_opt_output },

                            OPT_END()
                    };

                    return parse_options_concat(opts, parseopts);
            }

            int diff_opt_parse(struct diff_options *options,
                            const char **av, int ac, const char *prefix)
            {
                    struct option no_options[] = { OPT_END() };
                    struct option *parseopts = add_diff_options(no_options, options);

                    if (!prefix)
                            prefix = "";

                    ac = parse_options(ac, av, prefix, parseopts, NULL,
                                    PARSE_OPT_KEEP_DASHDASH |
                                    PARSE_OPT_KEEP_UNKNOWN_OPT |
                                    PARSE_OPT_NO_INTERNAL_HELP |
                                    PARSE_OPT_ONE_SHOT |
                                    PARSE_OPT_STOP_AT_NON_OPTION);
                    free(parseopts);

                    return ac;
            }

            int parse_rename_score(const char **cp_p)
            {
                    unsigned long num, scale;
                    int ch, dot;
                    const char *cp = *cp_p;

                    num = 0;
                    scale = 1;
                    dot = 0;
                    for (;;) {
                            ch = *cp;
                            if ( !dot && ch == '.' ) {
                                    scale = 1;
                                    dot = 1;
                            } else if ( ch == '%' ) {
                                    scale = dot ? scale*100 : 100;
                                    cp++;   /* % is always at the end */
                                    break;
                            } else if ( ch >= '0' && ch <= '9' ) {
                                    if ( scale < 100000 ) {
                                            scale *= 10;
                                            num = (num*10) + (ch-'0');
                                    }
                            } else {
                                    break;
                            }
                            cp++;
                    }
                    *cp_p = cp;

                    /* user says num divided by scale and we say internally that
                    * is MAX_SCORE * num / scale.
                    */
                    return (int)((num >= scale) ? MAX_SCORE : (MAX_SCORE * num / scale));
            }

            struct diff_queue_struct diff_queued_diff;

            void diff_q(struct diff_queue_struct *queue, struct diff_filepair *dp)
            {
                    ALLOC_GROW(queue->queue, queue->nr + 1, queue->alloc);
                    queue->queue[queue->nr++] = dp;
            }

            struct diff_filepair *diff_queue(struct diff_queue_struct *queue,
                                            struct diff_filespec *one,
                                            struct diff_filespec *two)
            {
                    struct diff_filepair *dp = xcalloc(1, sizeof(*dp));
                    dp->one = one;
                    dp->two = two;
                    if (queue)
                            diff_q(queue, dp);
                    return dp;
            }

            void diff_free_filepair(struct diff_filepair *p)
            {
                    free_filespec(p->one);
                    free_filespec(p->two);
                    free(p);
            }

            void diff_queue_init(struct diff_queue_struct *q)
            {
                    struct diff_queue_struct blank = DIFF_QUEUE_INIT;
                    memcpy(q, &blank, sizeof(*q));
            }

            void diff_queue_clear(struct diff_queue_struct *q)
            {
                    for (int i = 0; i < q->nr; i++)
                            diff_free_filepair(q->queue[i]);
                    free(q->queue);
                    diff_queue_init(q);
            }

            const char *diff_aligned_abbrev(const struct object_id *oid, int len)
            {
                    int abblen;
                    const char *abbrev;

                    /* Do we want all 40 hex characters? */
                    if (len == the_hash_algo->hexsz)
                            return oid_to_hex(oid);

                    /* An abbreviated value is fine, possibly followed by an ellipsis. */
                    abbrev = diff_abbrev_oid(oid, len);

                    if (!print_sha1_ellipsis())
                            return abbrev;

                    abblen = strlen(abbrev);

                    /*
                    * In well-behaved cases, where the abbreviated result is the
                    * same as the requested length, append three dots after the
                    * abbreviation (hence the whole logic is limited to the case
                    * where abblen < 37); when the actual abbreviated result is a
                    * bit longer than the requested length, we reduce the number
                    * of dots so that they match the well-behaved ones.  However,
                    * if the actual abbreviation is longer than the requested
                    * length by more than three, we give up on aligning, and add
                    * three dots anyway, to indicate that the output is not the
                    * full object name.  Yes, this may be suboptimal, but this
                    * appears only in "diff --raw --abbrev" output and it is not
                    * worth the effort to change it now.  Note that this would
                    * likely to work fine when the automatic sizing of default
                    * abbreviation length is used--we would be fed -1 in "len" in
                    * that case, and will end up always appending three-dots, but
                    * the automatic sizing is supposed to give abblen that ensures
                    * uniqueness across all objects (statistically speaking).
                    */
                    if (abblen < the_hash_algo->hexsz - 3) {
                            static char hex[GIT_MAX_HEXSZ + 1];
                            if (len < abblen && abblen <= len + 2)
                                    xsnprintf(hex, sizeof(hex), "%s%.*s", abbrev, len+3-abblen, "..");
                            else
                                    xsnprintf(hex, sizeof(hex), "%s...", abbrev);
                            return hex;
                    }

                    return oid_to_hex(oid);
            }

            static void diff_flush_raw(struct diff_filepair *p, struct diff_options *opt)
            {
                    int line_termination = opt->line_termination;
                    int inter_name_termination = line_termination ? '\t' : '\0';

                    fprintf(opt->file, "%s", diff_line_prefix(opt));
                    if (!(opt->output_format & DIFF_FORMAT_NAME_STATUS)) {
                            fprintf(opt->file, ":%06o %06o %s ", p->one->mode, p->two->mode,
                                    diff_aligned_abbrev(&p->one->oid, opt->abbrev));
                            fprintf(opt->file, "%s ",
                                    diff_aligned_abbrev(&p->two->oid, opt->abbrev));
                    }
                    if (p->score) {
                            fprintf(opt->file, "%c%03d%c", p->status, similarity_index(p),
                                    inter_name_termination);
                    } else {
                            fprintf(opt->file, "%c%c", p->status, inter_name_termination);
                    }

                    if (p->status == DIFF_STATUS_COPIED ||
                    p->status == DIFF_STATUS_RENAMED) {
                            const char *name_a, *name_b;
                            name_a = p->one->path;
                            name_b = p->two->path;
                            strip_prefix(opt->prefix_length, &name_a, &name_b);
                            write_name_quoted(name_a, opt->file, inter_name_termination);
                            write_name_quoted(name_b, opt->file, line_termination);
                    } else {
                            const char *name_a, *name_b;
                            name_a = p->one->mode ? p->one->path : p->two->path;
                            name_b = NULL;
                            strip_prefix(opt->prefix_length, &name_a, &name_b);
                            write_name_quoted(name_a, opt->file, line_termination);
                    }
            }

            int diff_unmodified_pair(struct diff_filepair *p)
            {
                    /* This function is written stricter than necessary to support
                    * the currently implemented transformers, but the idea is to
                    * let transformers to produce diff_filepairs any way they want,
                    * and filter and clean them up here before producing the output.
                    */
                    struct diff_filespec *one = p->one, *two = p->two;

                    if (DIFF_PAIR_UNMERGED(p))
                            return 0; /* unmerged is interesting */

                    /* deletion, addition, mode or type change
                    * and rename are all interesting.
                    */
                    if (DIFF_FILE_VALID(one) != DIFF_FILE_VALID(two) ||
                    DIFF_PAIR_MODE_CHANGED(p) ||
                    strcmp(one->path, two->path))
                            return 0;

                    /* both are valid and point at the same path.  that is, we are
                    * dealing with a change.
                    */
                    if (one->oid_valid && two->oid_valid &&
                    oideq(&one->oid, &two->oid) &&
                    !one->dirty_submodule && !two->dirty_submodule)
                            return 1; /* no change */
                    if (!one->oid_valid && !two->oid_valid)
                            return 1; /* both look at the same file on the filesystem. */
                    return 0;
            }

            static void diff_flush_patch(struct diff_filepair *p, struct diff_options *o)
            {
                    int include_conflict_headers =
                    (additional_headers(o, p->one->path) &&
                    !o->pickaxe_opts &&
                    (!o->filter || filter_bit_tst(DIFF_STATUS_UNMERGED, o)));

                    /*
                    * Check if we can return early without showing a diff.  Note that
                    * diff_filepair only stores {oid, path, mode, is_valid}
                    * information for each path, and thus diff_unmodified_pair() only
                    * considers those bits of info.  However, we do not want pairs
                    * created by create_filepairs_for_header_only_notifications()
                    * (which always look like unmodified pairs) to be ignored, so
                    * return early if both p is unmodified AND we don't want to
                    * include_conflict_headers.
                    */
                    if (diff_unmodified_pair(p) && !include_conflict_headers)
                            return;

                    /* Actually, we can also return early to avoid showing tree diffs */
                    if ((DIFF_FILE_VALID(p->one) && S_ISDIR(p->one->mode)) ||
                    (DIFF_FILE_VALID(p->two) && S_ISDIR(p->two->mode)))
                            return;

                    run_diff(p, o);
            }

            static void diff_flush_stat(struct diff_filepair *p, struct diff_options *o,
                                    struct diffstat_t *diffstat)
            {
                    if (diff_unmodified_pair(p))
                            return;

                    if ((DIFF_FILE_VALID(p->one) && S_ISDIR(p->one->mode)) ||
                    (DIFF_FILE_VALID(p->two) && S_ISDIR(p->two->mode)))
                            return; /* no useful stat for tree diffs */

                    run_diffstat(p, o, diffstat);
            }

            static void diff_flush_checkdiff(struct diff_filepair *p,
                            struct diff_options *o)
            {
                    if (diff_unmodified_pair(p))
                            return;

                    if ((DIFF_FILE_VALID(p->one) && S_ISDIR(p->one->mode)) ||
                    (DIFF_FILE_VALID(p->two) && S_ISDIR(p->two->mode)))
                            return; /* nothing to check in tree diffs */

                    run_checkdiff(p, o);
            }

            int diff_queue_is_empty(struct diff_options *o)
            {
                    struct diff_queue_struct *q = &diff_queued_diff;
                    int i;
                    int include_conflict_headers =
                    (o->additional_path_headers &&
                    strmap_get_size(o->additional_path_headers) &&
                    !o->pickaxe_opts &&
                    (!o->filter || filter_bit_tst(DIFF_STATUS_UNMERGED, o)));

                    if (include_conflict_headers)
                            return 0;

                    for (i = 0; i < q->nr; i++)
                            if (!diff_unmodified_pair(q->queue[i]))
                                    return 0;
                    return 1;
            }

            #if DIFF_DEBUG
            void diff_debug_filespec(struct diff_filespec *s, int x, const char *one)
            {
                    fprintf(stderr, "queue[%d] %s (%s) %s %06o %s\n",
                            x, one ? one : "",
                            s->path,
                            DIFF_FILE_VALID(s) ? "valid" : "invalid",
                            s->mode,
                            s->oid_valid ? oid_to_hex(&s->oid) : "");
                    fprintf(stderr, "queue[%d] %s size %lu\n",
                            x, one ? one : "",
                            s->size);
            }

            void diff_debug_filepair(const struct diff_filepair *p, int i)
            {
                    diff_debug_filespec(p->one, i, "one");
                    diff_debug_filespec(p->two, i, "two");
                    fprintf(stderr, "score %d, status %c rename_used %d broken %d\n",
                            p->score, p->status ? p->status : '?',
                            p->one->rename_used, p->broken_pair);
            }

            void diff_debug_queue(const char *msg, struct diff_queue_struct *q)
            {
                    int i;
                    if (msg)
                            fprintf(stderr, "%s\n", msg);
                    fprintf(stderr, "q->nr = %d\n", q->nr);
                    for (i = 0; i < q->nr; i++) {
                            struct diff_filepair *p = q->queue[i];
                            diff_debug_filepair(p, i);
                    }
            }
            #endif

            static void diff_resolve_rename_copy(void)
            {
                    int i;
                    struct diff_filepair *p;
                    struct diff_queue_struct *q = &diff_queued_diff;

                    diff_debug_queue("resolve-rename-copy", q);

                    for (i = 0; i < q->nr; i++) {
                            p = q->queue[i];
                            p->status = 0; /* undecided */
                            if (DIFF_PAIR_UNMERGED(p))
                                    p->status = DIFF_STATUS_UNMERGED;
                            else if (!DIFF_FILE_VALID(p->one))
                                    p->status = DIFF_STATUS_ADDED;
                            else if (!DIFF_FILE_VALID(p->two))
                                    p->status = DIFF_STATUS_DELETED;
                            else if (DIFF_PAIR_TYPE_CHANGED(p))
                                    p->status = DIFF_STATUS_TYPE_CHANGED;

                            /* from this point on, we are dealing with a pair
                            * whose both sides are valid and of the same type, i.e.
                            * either in-place edit or rename/copy edit.
                            */
                            else if (DIFF_PAIR_RENAME(p)) {
                                    /*
                                    * A rename might have re-connected a broken
                                    * pair up, causing the pathnames to be the
                                    * same again. If so, that's not a rename at
                                    * all, just a modification..
                                    *
                                    * Otherwise, see if this source was used for
                                    * multiple renames, in which case we decrement
                                    * the count, and call it a copy.
                                    */
                                    if (!strcmp(p->one->path, p->two->path))
                                            p->status = DIFF_STATUS_MODIFIED;
                                    else if (--p->one->rename_used > 0)
                                            p->status = DIFF_STATUS_COPIED;
                                    else
                                            p->status = DIFF_STATUS_RENAMED;
                            }
                            else if (!oideq(&p->one->oid, &p->two->oid) ||
                                    p->one->mode != p->two->mode ||
                                    p->one->dirty_submodule ||
                                    p->two->dirty_submodule ||
                                    is_null_oid(&p->one->oid))
                                    p->status = DIFF_STATUS_MODIFIED;
                            else {
                                    /* This is a "no-change" entry and should not
                                    * happen anymore, but prepare for broken callers.
                                    */
                                    error("feeding unmodified %s to diffcore",
                                    p->one->path);
                                    p->status = DIFF_STATUS_UNKNOWN;
                            }
                    }
                    diff_debug_queue("resolve-rename-copy done", q);
            }

            static int check_pair_status(struct diff_filepair *p)
            {
                    switch (p->status) {
                    case DIFF_STATUS_UNKNOWN:
                            return 0;
                    case 0:
                            die("internal error in diff-resolve-rename-copy");
                    default:
                            return 1;
                    }
            }

            static void flush_one_pair(struct diff_filepair *p, struct diff_options *opt)
            {
                    int fmt = opt->output_format;

                    if (fmt & DIFF_FORMAT_CHECKDIFF)
                            diff_flush_checkdiff(p, opt);
                    else if (fmt & (DIFF_FORMAT_RAW | DIFF_FORMAT_NAME_STATUS))
                            diff_flush_raw(p, opt);
                    else if (fmt & DIFF_FORMAT_NAME) {
                            const char *name_a, *name_b;
                            name_a = p->two->path;
                            name_b = NULL;
                            strip_prefix(opt->prefix_length, &name_a, &name_b);
                            fprintf(opt->file, "%s", diff_line_prefix(opt));
                            write_name_quoted(name_a, opt->file, opt->line_termination);
                    }

                    opt->found_changes = 1;
            }

            static void show_file_mode_name(struct diff_options *opt, const char *newdelete, struct diff_filespec *fs)
            {
                    struct strbuf sb = STRBUF_INIT;
                    if (fs->mode)
                            strbuf_addf(&sb, " %s mode %06o ", newdelete, fs->mode);
                    else
                            strbuf_addf(&sb, " %s ", newdelete);

                    quote_c_style(fs->path, &sb, NULL, 0);
                    strbuf_addch(&sb, '\n');
                    emit_diff_symbol(opt, DIFF_SYMBOL_SUMMARY,
                                    sb.buf, sb.len, 0);
                    strbuf_release(&sb);
            }

            static void show_mode_change(struct diff_options *opt, struct diff_filepair *p,
                            int show_name)
            {
                    if (p->one->mode && p->two->mode && p->one->mode != p->two->mode) {
                            struct strbuf sb = STRBUF_INIT;
                            strbuf_addf(&sb, " mode change %06o => %06o",
                                    p->one->mode, p->two->mode);
                            if (show_name) {
                                    strbuf_addch(&sb, ' ');
                                    quote_c_style(p->two->path, &sb, NULL, 0);
                            }
                            strbuf_addch(&sb, '\n');
                            emit_diff_symbol(opt, DIFF_SYMBOL_SUMMARY,
                                            sb.buf, sb.len, 0);
                            strbuf_release(&sb);
                    }
            }

            static void show_rename_copy(struct diff_options *opt, const char *renamecopy,
                            struct diff_filepair *p)
            {
                    struct strbuf sb = STRBUF_INIT;
                    struct strbuf names = STRBUF_INIT;

                    pprint_rename(&names, p->one->path, p->two->path);
                    strbuf_addf(&sb, " %s %s (%d%%)\n",
                            renamecopy, names.buf, similarity_index(p));
                    strbuf_release(&names);
                    emit_diff_symbol(opt, DIFF_SYMBOL_SUMMARY,
                                            sb.buf, sb.len, 0);
                    show_mode_change(opt, p, 0);
                    strbuf_release(&sb);
            }

            static void diff_summary(struct diff_options *opt, struct diff_filepair *p)
            {
                    switch(p->status) {
                    case DIFF_STATUS_DELETED:
                            show_file_mode_name(opt, "delete", p->one);
                            break;
                    case DIFF_STATUS_ADDED:
                            show_file_mode_name(opt, "create", p->two);
                            break;
                    case DIFF_STATUS_COPIED:
                            show_rename_copy(opt, "copy", p);
                            break;
                    case DIFF_STATUS_RENAMED:
                            show_rename_copy(opt, "rename", p);
                            break;
                    default:
                            if (p->score) {
                                    struct strbuf sb = STRBUF_INIT;
                                    strbuf_addstr(&sb, " rewrite ");
                                    quote_c_style(p->two->path, &sb, NULL, 0);
                                    strbuf_addf(&sb, " (%d%%)\n", similarity_index(p));
                                    emit_diff_symbol(opt, DIFF_SYMBOL_SUMMARY,
                                                    sb.buf, sb.len, 0);
                                    strbuf_release(&sb);
                            }
                            show_mode_change(opt, p, !p->score);
                            break;
                    }
            }

            struct patch_id_t {
                    git_hash_ctx *ctx;
                    int patchlen;
            };

            static int remove_space(char *line, int len)
            {
                    int i;
                    char *dst = line;
                    unsigned char c;

                    for (i = 0; i < len; i++)
                            if (!isspace((c = line[i])))
                                    *dst++ = c;

                    return dst - line;
            }

            void flush_one_hunk(struct object_id *result, git_hash_ctx *ctx)
            {
                    unsigned char hash[GIT_MAX_RAWSZ];
                    unsigned short carry = 0;
                    int i;

                    the_hash_algo->final_fn(hash, ctx);
                    the_hash_algo->init_fn(ctx);
                    /* 20-byte sum, with carry */
                    for (i = 0; i < the_hash_algo->rawsz; ++i) {
                            carry += result->hash[i] + hash[i];
                            result->hash[i] = carry;
                            carry >>= 8;
                    }
            }

            static int patch_id_consume(void *priv, char *line, unsigned long len)
            {
                    struct patch_id_t *data = priv;
                    int new_len;

                    if (len > 12 && starts_with(line, "\\ "))
                            return 0;
                    new_len = remove_space(line, len);

                    the_hash_algo->update_fn(data->ctx, line, new_len);
                    data->patchlen += new_len;
                    return 0;
            }

            static void patch_id_add_string(git_hash_ctx *ctx, const char *str)
            {
                    the_hash_algo->update_fn(ctx, str, strlen(str));
            }

            static void patch_id_add_mode(git_hash_ctx *ctx, unsigned mode)
            {
                    /* large enough for 2^32 in octal */
                    char buf[12];
                    int len = xsnprintf(buf, sizeof(buf), "%06o", mode);
                    the_hash_algo->update_fn(ctx, buf, len);
            }

            /* returns 0 upon success, and writes result into oid */
            static int diff_get_patch_id(struct diff_options *options, struct object_id *oid, int diff_header_only)
            {
                    struct diff_queue_struct *q = &diff_queued_diff;
                    int i;
                    git_hash_ctx ctx;
                    struct patch_id_t data;

                    the_hash_algo->init_fn(&ctx);
                    memset(&data, 0, sizeof(struct patch_id_t));
                    data.ctx = &ctx;
                    oidclr(oid, the_repository->hash_algo);

                    for (i = 0; i < q->nr; i++) {
                            xpparam_t xpp;
                            xdemitconf_t xecfg;
                            mmfile_t mf1, mf2;
                            struct diff_filepair *p = q->queue[i];
                            int len1, len2;

                            memset(&xpp, 0, sizeof(xpp));
                            memset(&xecfg, 0, sizeof(xecfg));
                            if (p->status == 0)
                                    return error("internal diff status error");
                            if (p->status == DIFF_STATUS_UNKNOWN)
                                    continue;
                            if (diff_unmodified_pair(p))
                                    continue;
                            if ((DIFF_FILE_VALID(p->one) && S_ISDIR(p->one->mode)) ||
                            (DIFF_FILE_VALID(p->two) && S_ISDIR(p->two->mode)))
                                    continue;
                            if (DIFF_PAIR_UNMERGED(p))
                                    continue;

                            diff_fill_oid_info(p->one, options->repo->index);
                            diff_fill_oid_info(p->two, options->repo->index);

                            len1 = remove_space(p->one->path, strlen(p->one->path));
                            len2 = remove_space(p->two->path, strlen(p->two->path));
                            patch_id_add_string(&ctx, "diff--git");
                            patch_id_add_string(&ctx, "a/");
                            the_hash_algo->update_fn(&ctx, p->one->path, len1);
                            patch_id_add_string(&ctx, "b/");
                            the_hash_algo->update_fn(&ctx, p->two->path, len2);

                            if (p->one->mode == 0) {
                                    patch_id_add_string(&ctx, "newfilemode");
                                    patch_id_add_mode(&ctx, p->two->mode);
                            } else if (p->two->mode == 0) {
                                    patch_id_add_string(&ctx, "deletedfilemode");
                                    patch_id_add_mode(&ctx, p->one->mode);
                            } else if (p->one->mode != p->two->mode) {
                                    patch_id_add_string(&ctx, "oldmode");
                                    patch_id_add_mode(&ctx, p->one->mode);
                                    patch_id_add_string(&ctx, "newmode");
                                    patch_id_add_mode(&ctx, p->two->mode);
                            }

                            if (diff_header_only) {
                                    /* don't do anything since we're only populating header info */
                            } else if (diff_filespec_is_binary(options->repo, p->one) ||
                            diff_filespec_is_binary(options->repo, p->two)) {
                                    the_hash_algo->update_fn(&ctx, oid_to_hex(&p->one->oid),
                                                    the_hash_algo->hexsz);
                                    the_hash_algo->update_fn(&ctx, oid_to_hex(&p->two->oid),
                                                    the_hash_algo->hexsz);
                            } else {
                                    if (p->one->mode == 0) {
                                            patch_id_add_string(&ctx, "---/dev/null");
                                            patch_id_add_string(&ctx, "+++b/");
                                            the_hash_algo->update_fn(&ctx, p->two->path, len2);
                                    } else if (p->two->mode == 0) {
                                            patch_id_add_string(&ctx, "---a/");
                                            the_hash_algo->update_fn(&ctx, p->one->path, len1);
                                            patch_id_add_string(&ctx, "+++/dev/null");
                                    } else {
                                            patch_id_add_string(&ctx, "---a/");
                                            the_hash_algo->update_fn(&ctx, p->one->path, len1);
                                            patch_id_add_string(&ctx, "+++b/");
                                            the_hash_algo->update_fn(&ctx, p->two->path, len2);
                                    }

                                    if (fill_mmfile(options->repo, &mf1, p->one) < 0 ||
                                    fill_mmfile(options->repo, &mf2, p->two) < 0)
                                            return error("unable to read files to diff");
                                    xpp.flags = 0;
                                    xecfg.ctxlen = 3;
                                    xecfg.flags = XDL_EMIT_NO_HUNK_HDR;
                                    if (xdi_diff_outf(&mf1, &mf2, NULL,
                                                    patch_id_consume, &data, &xpp, &xecfg))
                                            return error("unable to generate patch-id diff for %s",
                                                    p->one->path);
                            }
                            flush_one_hunk(oid, &ctx);
                    }

                    return 0;
            }

            int diff_flush_patch_id(struct diff_options *options, struct object_id *oid, int diff_header_only)
            {
                    struct diff_queue_struct *q = &diff_queued_diff;
                    int result = diff_get_patch_id(options, oid, diff_header_only);

                    diff_queue_clear(q);

                    return result;
            }

            static int is_summary_empty(const struct diff_queue_struct *q)
            {
                    int i;

                    for (i = 0; i < q->nr; i++) {
                            const struct diff_filepair *p = q->queue[i];

                            switch (p->status) {
                            case DIFF_STATUS_DELETED:
                            case DIFF_STATUS_ADDED:
                            case DIFF_STATUS_COPIED:
                            case DIFF_STATUS_RENAMED:
                                    return 0;
                            default:
                                    if (p->score)
                                            return 0;
                                    if (p->one->mode && p->two->mode &&
                                    p->one->mode != p->two->mode)
                                            return 0;
                                    break;
                            }
                    }
                    return 1;
            }

            static const char rename_limit_warning[] =
            N_("exhaustive rename detection was skipped due to too many files.");

            static const char degrade_cc_to_c_warning[] =
            N_("only found copies from modified paths due to too many files.");

            static const char rename_limit_advice[] =
            N_("you may want to set your %s variable to at least "
            "%d and retry the command.");

            void diff_warn_rename_limit(const char *varname, int needed, int degraded_cc)
            {
                    fflush(stdout);
                    if (degraded_cc)
                            warning(_(degrade_cc_to_c_warning));
                    else if (needed)
                            warning(_(rename_limit_warning));
                    else
                            return;
                    if (0 < needed)
                            warning(_(rename_limit_advice), varname, needed);
            }

            static void create_filepairs_for_header_only_notifications(struct diff_options *o)
            {
                    struct strset present;
                    struct diff_queue_struct *q = &diff_queued_diff;
                    struct hashmap_iter iter;
                    struct strmap_entry *e;
                    int i;

                    strset_init_with_options(&present, /*pool*/ NULL, /*strdup*/ 0);

                    /*
                    * Find out which paths exist in diff_queued_diff, preferring
                    * one->path for any pair that has multiple paths.
                    */
                    for (i = 0; i < q->nr; i++) {
                            struct diff_filepair *p = q->queue[i];
                            char *path = p->one->path ? p->one->path : p->two->path;

                            if (strmap_contains(o->additional_path_headers, path))
                                    strset_add(&present, path);
                    }

                    /*
                    * Loop over paths in additional_path_headers; for each NOT already
                    * in diff_queued_diff, create a synthetic filepair and insert that
                    * into diff_queued_diff.
                    */
                    strmap_for_each_entry(o->additional_path_headers, &iter, e) {
                            if (!strset_contains(&present, e->key)) {
                                    struct diff_filespec *one, *two;
                                    struct diff_filepair *p;

                                    one = alloc_filespec(e->key);
                                    two = alloc_filespec(e->key);
                                    fill_filespec(one, null_oid(), 0, 0);
                                    fill_filespec(two, null_oid(), 0, 0);
                                    p = diff_queue(q, one, two);
                                    p->status = DIFF_STATUS_MODIFIED;
                            }
                    }

                    /* Re-sort the filepairs */
                    diffcore_fix_diff_index();

                    /* Cleanup */
                    strset_clear(&present);
            }

            static void diff_flush_patch_all_file_pairs(struct diff_options *o)
            {
                    int i;
                    static struct emitted_diff_symbols esm = EMITTED_DIFF_SYMBOLS_INIT;
                    struct diff_queue_struct *q = &diff_queued_diff;

                    if (WSEH_NEW & WS_RULE_MASK)
                            BUG("WS rules bit mask overlaps with diff symbol flags");

                    if (o->color_moved)
                            o->emitted_symbols = &esm;

                    if (o->additional_path_headers)
                            create_filepairs_for_header_only_notifications(o);

                    for (i = 0; i < q->nr; i++) {
                            struct diff_filepair *p = q->queue[i];
                            if (check_pair_status(p))
                                    diff_flush_patch(p, o);
                    }

                    if (o->emitted_symbols) {
                            if (o->color_moved) {
                                    struct mem_pool entry_pool;
                                    struct moved_entry_list *entry_list;

                                    mem_pool_init(&entry_pool, 1024 * 1024);
                                    entry_list = add_lines_to_move_detection(o,
                                                                            &entry_pool);
                                    mark_color_as_moved(o, entry_list);
                                    if (o->color_moved == COLOR_MOVED_ZEBRA_DIM)
                                            dim_moved_lines(o);

                                    mem_pool_discard(&entry_pool, 0);
                                    free(entry_list);
                            }

                            for (i = 0; i < esm.nr; i++)
                                    emit_diff_symbol_from_struct(o, &esm.buf[i]);

                            for (i = 0; i < esm.nr; i++)
                                    free((void *)esm.buf[i].line);
                            esm.nr = 0;

                            o->emitted_symbols = NULL;
                    }
            }

            static void diff_free_file(struct diff_options *options)
            {
                    if (options->close_file && options->file) {
                            fclose(options->file);
                            options->file = NULL;
                    }
            }

            static void diff_free_ignore_regex(struct diff_options *options)
            {
                    int i;

                    for (i = 0; i < options->ignore_regex_nr; i++) {
                            regfree(options->ignore_regex[i]);
                            free(options->ignore_regex[i]);
                    }

                    FREE_AND_NULL(options->ignore_regex);
                    options->ignore_regex_nr = 0;
            }

            void diff_free(struct diff_options *options)
            {
                    if (options->no_free)
                            return;

                    if (options->objfind) {
                            oidset_clear(options->objfind);
                            FREE_AND_NULL(options->objfind);
                    }

                    FREE_AND_NULL(options->orderfile);
                    for (size_t i = 0; i < options->anchors_nr; i++)
                            free(options->anchors[i]);
                    FREE_AND_NULL(options->anchors);
                    options->anchors_nr = options->anchors_alloc = 0;

                    diff_free_file(options);
                    diff_free_ignore_regex(options);
                    clear_pathspec(&options->pathspec);
            }

            void diff_flush(struct diff_options *options)
            {
                    struct diff_queue_struct *q = &diff_queued_diff;
                    int i, output_format = options->output_format;
                    int separator = 0;
                    int dirstat_by_line = 0;

                    /*
                    * Order: raw, stat, summary, patch
                    * or:    name/name-status/checkdiff (other bits clear)
                    */
                    if (!q->nr && !options->additional_path_headers)
                            goto free_queue;

                    if (output_format & (DIFF_FORMAT_RAW |
                                    DIFF_FORMAT_NAME |
                                    DIFF_FORMAT_NAME_STATUS |
                                    DIFF_FORMAT_CHECKDIFF)) {
                            for (i = 0; i < q->nr; i++) {
                                    struct diff_filepair *p = q->queue[i];
                                    if (check_pair_status(p))
                                            flush_one_pair(p, options);
                            }
                            separator++;
                    }

                    if (output_format & DIFF_FORMAT_DIRSTAT && options->flags.dirstat_by_line)
                            dirstat_by_line = 1;

                    if (output_format & (DIFF_FORMAT_DIFFSTAT|DIFF_FORMAT_SHORTSTAT|DIFF_FORMAT_NUMSTAT) ||
                    dirstat_by_line) {
                            struct diffstat_t diffstat;

                            compute_diffstat(options, &diffstat, q);
                            if (output_format & DIFF_FORMAT_NUMSTAT)
                                    show_numstat(&diffstat, options);
                            if (output_format & DIFF_FORMAT_DIFFSTAT)
                                    show_stats(&diffstat, options);
                            if (output_format & DIFF_FORMAT_SHORTSTAT)
                                    show_shortstats(&diffstat, options);
                            if (output_format & DIFF_FORMAT_DIRSTAT && dirstat_by_line)
                                    show_dirstat_by_line(&diffstat, options);
                            free_diffstat_info(&diffstat);
                            separator++;
                    }
                    if ((output_format & DIFF_FORMAT_DIRSTAT) && !dirstat_by_line)
                            show_dirstat(options);

                    if (output_format & DIFF_FORMAT_SUMMARY && !is_summary_empty(q)) {
                            for (i = 0; i < q->nr; i++) {
                                    diff_summary(options, q->queue[i]);
                            }
                            separator++;
                    }

                    if (output_format & DIFF_FORMAT_PATCH) {
                            if (separator) {
                                    emit_diff_symbol(options, DIFF_SYMBOL_SEPARATOR, NULL, 0, 0);
                                    if (options->stat_sep)
                                            /* attach patch instead of inline */
                                            emit_diff_symbol(options, DIFF_SYMBOL_STAT_SEP,
                                                            NULL, 0, 0);
                            }

                            diff_flush_patch_all_file_pairs(options);
                    }

                    if (output_format & DIFF_FORMAT_CALLBACK)
                            options->format_callback(q, options, options->format_callback_data);

                    if (output_format & DIFF_FORMAT_NO_OUTPUT &&
                    options->flags.exit_with_status &&
                    options->flags.diff_from_contents) {
                            /*
                            * run diff_flush_patch for the exit status. setting
                            * options->file to /dev/null should be safe, because we
                            * aren't supposed to produce any output anyway.
                            */
                            diff_free_file(options);
                            options->file = xfopen("/dev/null", "w");
                            options->close_file = 1;
                            options->color_moved = 0;
                            for (i = 0; i < q->nr; i++) {
                                    struct diff_filepair *p = q->queue[i];
                                    if (check_pair_status(p))
                                            diff_flush_patch(p, options);
                                    if (options->found_changes)
                                            break;
                            }
                    }

            free_queue:
                    diff_queue_clear(q);
                    diff_free(options);

                    /*
                    * Report the content-level differences with HAS_CHANGES;
                    * diff_addremove/diff_change does not set the bit when
                    * DIFF_FROM_CONTENTS is in effect (e.g. with -w).
                    */
                    if (options->flags.diff_from_contents) {
                            if (options->found_changes)
                                    options->flags.has_changes = 1;
                            else
                                    options->flags.has_changes = 0;
                    }
            }

            static int match_filter(const struct diff_options *options, const struct diff_filepair *p)
            {
                    return (((p->status == DIFF_STATUS_MODIFIED) &&
                            ((p->score &&
                            filter_bit_tst(DIFF_STATUS_FILTER_BROKEN, options)) ||
                            (!p->score &&
                            filter_bit_tst(DIFF_STATUS_MODIFIED, options)))) ||
                            ((p->status != DIFF_STATUS_MODIFIED) &&
                            filter_bit_tst(p->status, options)));
            }

            static void diffcore_apply_filter(struct diff_options *options)
            {
                    int i;
                    struct diff_queue_struct *q = &diff_queued_diff;
                    struct diff_queue_struct outq = DIFF_QUEUE_INIT;

                    if (!options->filter)
                            return;

                    if (filter_bit_tst(DIFF_STATUS_FILTER_AON, options)) {
                            int found;
                            for (i = found = 0; !found && i < q->nr; i++) {
                                    if (match_filter(options, q->queue[i]))
                                            found++;
                            }
                            if (found)
                                    return;

                            /* otherwise we will clear the whole queue
                            * by copying the empty outq at the end of this
                            * function, but first clear the current entries
                            * in the queue.
                            */
                            for (i = 0; i < q->nr; i++)
                                    diff_free_filepair(q->queue[i]);
                    }
                    else {
                            /* Only the matching ones */
                            for (i = 0; i < q->nr; i++) {
                                    struct diff_filepair *p = q->queue[i];
                                    if (match_filter(options, p))
                                            diff_q(&outq, p);
                                    else
                                            diff_free_filepair(p);
                            }
                    }
                    free(q->queue);
                    *q = outq;
            }

            /* Check whether two filespecs with the same mode and size are identical */
            static int diff_filespec_is_identical(struct repository *r,
                                            struct diff_filespec *one,
                                            struct diff_filespec *two)
            {
                    if (S_ISGITLINK(one->mode))
                            return 0;
                    if (diff_populate_filespec(r, one, NULL))
                            return 0;
                    if (diff_populate_filespec(r, two, NULL))
                            return 0;
                    return !memcmp(one->data, two->data, one->size);
            }

            static int diff_filespec_check_stat_unmatch(struct repository *r,
                                                    struct diff_filepair *p)
            {
                    struct diff_populate_filespec_options dpf_options = {
                            .check_size_only = 1,
                            .missing_object_cb = diff_queued_diff_prefetch,
                            .missing_object_data = r,
                    };

                    if (p->done_skip_stat_unmatch)
                            return p->skip_stat_unmatch_result;

                    p->done_skip_stat_unmatch = 1;
                    p->skip_stat_unmatch_result = 0;
                    /*
                    * 1. Entries that come from stat info dirtiness
                    *    always have both sides (iow, not create/delete),
                    *    one side of the object name is unknown, with
                    *    the same mode and size.  Keep the ones that
                    *    do not match these criteria.  They have real
                    *    differences.
                    *
                    * 2. At this point, the file is known to be modified,
                    *    with the same mode and size, and the object
                    *    name of one side is unknown.  Need to inspect
                    *    the identical contents.
                    */
                    if (!DIFF_FILE_VALID(p->one) || /* (1) */
                    !DIFF_FILE_VALID(p->two) ||
                    (p->one->oid_valid && p->two->oid_valid) ||
                    (p->one->mode != p->two->mode) ||
                    diff_populate_filespec(r, p->one, &dpf_options) ||
                    diff_populate_filespec(r, p->two, &dpf_options) ||
                    (p->one->size != p->two->size) ||
                    !diff_filespec_is_identical(r, p->one, p->two)) /* (2) */
                            p->skip_stat_unmatch_result = 1;
                    return p->skip_stat_unmatch_result;
            }

            static void diffcore_skip_stat_unmatch(struct diff_options *diffopt)
            {
                    int i;
                    struct diff_queue_struct *q = &diff_queued_diff;
                    struct diff_queue_struct outq = DIFF_QUEUE_INIT;

                    for (i = 0; i < q->nr; i++) {
                            struct diff_filepair *p = q->queue[i];

                            if (diff_filespec_check_stat_unmatch(diffopt->repo, p))
                                    diff_q(&outq, p);
                            else {
                                    /*
                                    * The caller can subtract 1 from skip_stat_unmatch
                                    * to determine how many paths were dirty only
                                    * due to stat info mismatch.
                                    */
                                    if (!diffopt->flags.no_index)
                                            diffopt->skip_stat_unmatch++;
                                    diff_free_filepair(p);
                            }
                    }
                    free(q->queue);
                    *q = outq;
            }

            static int diffnamecmp(const void *a_, const void *b_)
            {
                    const struct diff_filepair *a = *((const struct diff_filepair **)a_);
                    const struct diff_filepair *b = *((const struct diff_filepair **)b_);
                    const char *name_a, *name_b;

                    name_a = a->one ? a->one->path : a->two->path;
                    name_b = b->one ? b->one->path : b->two->path;
                    return strcmp(name_a, name_b);
            }

            void diffcore_fix_diff_index(void)
            {
                    struct diff_queue_struct *q = &diff_queued_diff;
                    QSORT(q->queue, q->nr, diffnamecmp);
            }

            void diff_add_if_missing(struct repository *r,
                                    struct oid_array *to_fetch,
                                    const struct diff_filespec *filespec)
            {
                    if (filespec && filespec->oid_valid &&
                    !S_ISGITLINK(filespec->mode) &&
                    oid_object_info_extended(r, &filespec->oid, NULL,
                                            OBJECT_INFO_FOR_PREFETCH))
                            oid_array_append(to_fetch, &filespec->oid);
            }

            void diff_queued_diff_prefetch(void *repository)
            {
                    struct repository *repo = repository;
                    int i;
                    struct diff_queue_struct *q = &diff_queued_diff;
                    struct oid_array to_fetch = OID_ARRAY_INIT;

                    for (i = 0; i < q->nr; i++) {
                            struct diff_filepair *p = q->queue[i];
                            diff_add_if_missing(repo, &to_fetch, p->one);
                            diff_add_if_missing(repo, &to_fetch, p->two);
                    }

                    /*
                    * NEEDSWORK: Consider deduplicating the OIDs sent.
                    */
                    promisor_remote_get_direct(repo, to_fetch.oid, to_fetch.nr);

                    oid_array_clear(&to_fetch);
            }

            void init_diffstat_widths(struct diff_options *options)
            {
                    options->stat_width = -1;        /* use full terminal width */
                    options->stat_name_width = -1;   /* respect diff.statNameWidth config */
                    options->stat_graph_width = -1;  /* respect diff.statGraphWidth config */
            }

            void diffcore_std(struct diff_options *options)
            {
                    int output_formats_to_prefetch = DIFF_FORMAT_DIFFSTAT |
                            DIFF_FORMAT_NUMSTAT |
                            DIFF_FORMAT_PATCH |
                            DIFF_FORMAT_SHORTSTAT |
                            DIFF_FORMAT_DIRSTAT;

                    /*
                    * Check if the user requested a blob-data-requiring diff output and/or
                    * break-rewrite detection (which requires blob data). If yes, prefetch
                    * the diff pairs.
                    *
                    * If no prefetching occurs, diffcore_rename() will prefetch if it
                    * decides that it needs inexact rename detection.
                    */
                    if (options->repo == the_repository && repo_has_promisor_remote(the_repository) &&
                    (options->output_format & output_formats_to_prefetch ||
                    options->pickaxe_opts & DIFF_PICKAXE_KINDS_MASK))
                            diff_queued_diff_prefetch(options->repo);

                    /* NOTE please keep the following in sync with diff_tree_combined() */
                    if (options->skip_stat_unmatch)
                            diffcore_skip_stat_unmatch(options);
                    if (!options->found_follow) {
                            /* See try_to_follow_renames() in tree-diff.c */
                            if (options->break_opt != -1)
                                    diffcore_break(options->repo,
                                            options->break_opt);
                            if (options->detect_rename)
                                    diffcore_rename(options);
                            if (options->break_opt != -1)
                                    diffcore_merge_broken();
                    }
                    if (options->pickaxe_opts & DIFF_PICKAXE_KINDS_MASK)
                            diffcore_pickaxe(options);
                    if (options->orderfile)
                            diffcore_order(options->orderfile);
                    if (options->rotate_to)
                            diffcore_rotate(options);
                    if (!options->found_follow)
                            /* See try_to_follow_renames() in tree-diff.c */
                            diff_resolve_rename_copy();
                    diffcore_apply_filter(options);

                    if (diff_queued_diff.nr && !options->flags.diff_from_contents)
                            options->flags.has_changes = 1;
                    else
                            options->flags.has_changes = 0;

                    options->found_follow = 0;
            }

            int diff_result_code(struct rev_info *revs)
            {
                    struct diff_options *opt = &revs->diffopt;
                    int result = 0;

                    if (revs->remerge_diff) {
                            tmp_objdir_destroy(revs->remerge_objdir);
                            revs->remerge_objdir = NULL;
                    }

                    diff_warn_rename_limit("diff.renameLimit",
                                    opt->needed_rename_limit,
                                    opt->degraded_cc_to_c);

                    if (opt->flags.exit_with_status &&
                    opt->flags.has_changes)
                            result |= 01;
                    if ((opt->output_format & DIFF_FORMAT_CHECKDIFF) &&
                    opt->flags.check_failed)
                            result |= 02;
                    return result;
            }

            int diff_can_quit_early(struct diff_options *opt)
            {
                    return (opt->flags.quick &&
                            !opt->filter &&
                            opt->flags.has_changes);
            }

            /*
            * Shall changes to this submodule be ignored?
            *
            * Submodule changes can be configured to be ignored separately for each path,
            * but that configuration can be overridden from the command line.
            */
            static int is_submodule_ignored(const char *path, struct diff_options *options)
            {
                    int ignored = 0;
                    struct diff_flags orig_flags = options->flags;
                    if (!options->flags.override_submodule_config)
                            set_diffopt_flags_from_submodule_config(options, path);
                    if (options->flags.ignore_submodules)
                            ignored = 1;
                    options->flags = orig_flags;
                    return ignored;
            }

            void compute_diffstat(struct diff_options *options,
                            struct diffstat_t *diffstat,
                            struct diff_queue_struct *q)
            {
                    int i;

                    memset(diffstat, 0, sizeof(struct diffstat_t));
                    for (i = 0; i < q->nr; i++) {
                            struct diff_filepair *p = q->queue[i];
                            if (check_pair_status(p))
                                    diff_flush_stat(p, options, diffstat);
                    }
                    options->found_changes = !!diffstat->nr;
            }

            void diff_addremove(struct diff_options *options,
                            int addremove, unsigned mode,
                            const struct object_id *oid,
                            int oid_valid,
                            const char *concatpath, unsigned dirty_submodule)
            {
                    struct diff_filespec *one, *two;

                    if (S_ISGITLINK(mode) && is_submodule_ignored(concatpath, options))
                            return;

                    /* This may look odd, but it is a preparation for
                    * feeding "there are unchanged files which should
                    * not produce diffs, but when you are doing copy
                    * detection you would need them, so here they are"
                    * entries to the diff-core.  They will be prefixed
                    * with something like '=' or '*' (I haven't decided
                    * which but should not make any difference).
                    * Feeding the same new and old to diff_change()
                    * also has the same effect.
                    * Before the final output happens, they are pruned after
                    * merged into rename/copy pairs as appropriate.
                    */
                    if (options->flags.reverse_diff)
                            addremove = (addremove == '+' ? '-' :
                                    addremove == '-' ? '+' : addremove);

                    if (options->prefix &&
                    strncmp(concatpath, options->prefix, options->prefix_length))
                            return;

                    one = alloc_filespec(concatpath);
                    two = alloc_filespec(concatpath);

                    if (addremove != '+')
                            fill_filespec(one, oid, oid_valid, mode);
                    if (addremove != '-') {
                            fill_filespec(two, oid, oid_valid, mode);
                            two->dirty_submodule = dirty_submodule;
                    }

                    diff_queue(&diff_queued_diff, one, two);
                    if (!options->flags.diff_from_contents)
                            options->flags.has_changes = 1;
            }

            void diff_change(struct diff_options *options,
                            unsigned old_mode, unsigned new_mode,
                            const struct object_id *old_oid,
                            const struct object_id *new_oid,
                            int old_oid_valid, int new_oid_valid,
                            const char *concatpath,
                            unsigned old_dirty_submodule, unsigned new_dirty_submodule)
            {
                    struct diff_filespec *one, *two;
                    struct diff_filepair *p;

                    if (S_ISGITLINK(old_mode) && S_ISGITLINK(new_mode) &&
                    is_submodule_ignored(concatpath, options))
                            return;

                    if (options->flags.reverse_diff) {
                            SWAP(old_mode, new_mode);
                            SWAP(old_oid, new_oid);
                            SWAP(old_oid_valid, new_oid_valid);
                            SWAP(old_dirty_submodule, new_dirty_submodule);
                    }

                    if (options->prefix &&
                    strncmp(concatpath, options->prefix, options->prefix_length))
                            return;

                    one = alloc_filespec(concatpath);
                    two = alloc_filespec(concatpath);
                    fill_filespec(one, old_oid, old_oid_valid, old_mode);
                    fill_filespec(two, new_oid, new_oid_valid, new_mode);
                    one->dirty_submodule = old_dirty_submodule;
                    two->dirty_submodule = new_dirty_submodule;
                    p = diff_queue(&diff_queued_diff, one, two);

                    if (options->flags.diff_from_contents)
                            return;

                    if (options->flags.quick && options->skip_stat_unmatch &&
                    !diff_filespec_check_stat_unmatch(options->repo, p)) {
                            diff_free_filespec_data(p->one);
                            diff_free_filespec_data(p->two);
                            return;
                    }

                    options->flags.has_changes = 1;
            }

            struct diff_filepair *diff_unmerge(struct diff_options *options, const char *path)
            {
                    struct diff_filepair *pair;
                    struct diff_filespec *one, *two;

                    if (options->prefix &&
                    strncmp(path, options->prefix, options->prefix_length))
                            return NULL;

                    one = alloc_filespec(path);
                    two = alloc_filespec(path);
                    pair = diff_queue(&diff_queued_diff, one, two);
                    pair->is_unmerged = 1;
                    return pair;
            }

            static char *run_textconv(struct repository *r,
                                    const char *pgm,
                                    struct diff_filespec *spec,
                                    size_t *outsize)
            {
                    struct diff_tempfile *temp;
                    struct child_process child = CHILD_PROCESS_INIT;
                    struct strbuf buf = STRBUF_INIT;
                    int err = 0;

                    temp = prepare_temp_file(r, spec);
                    strvec_push(&child.args, pgm);
                    strvec_push(&child.args, temp->name);

                    child.use_shell = 1;
                    child.out = -1;
                    if (start_command(&child)) {
                            remove_tempfile();
                            return NULL;
                    }

                    if (strbuf_read(&buf, child.out, 0) < 0)
                            err = error("error reading from textconv command '%s'", pgm);
                    close(child.out);

                    if (finish_command(&child) || err) {
                            strbuf_release(&buf);
                            remove_tempfile();
                            return NULL;
                    }
                    remove_tempfile();

                    return strbuf_detach(&buf, outsize);
            }

            size_t fill_textconv(struct repository *r,
                            struct userdiff_driver *driver,
                            struct diff_filespec *df,
                            char **outbuf)
            {
                    size_t size;

                    if (!driver) {
                            if (!DIFF_FILE_VALID(df)) {
                                    *outbuf = (char *) "";
                                    return 0;
                            }
                            if (diff_populate_filespec(r, df, NULL))
                                    die("unable to read files to diff");
                            *outbuf = df->data;
                            return df->size;
                    }

                    if (!driver->textconv)
                            BUG("fill_textconv called with non-textconv driver");

                    if (driver->textconv_cache && df->oid_valid) {
                            *outbuf = notes_cache_get(driver->textconv_cache,
                                                    &df->oid,
                                                    &size);
                            if (*outbuf)
                                    return size;
                    }

                    *outbuf = run_textconv(r, driver->textconv, df, &size);
                    if (!*outbuf)
                            die("unable to read files to diff");

                    if (driver->textconv_cache && df->oid_valid) {
                            /* ignore errors, as we might be in a readonly repository */
                            notes_cache_put(driver->textconv_cache, &df->oid, *outbuf,
                                            size);
                            /*
                            * we could save up changes and flush them all at the end,
                            * but we would need an extra call after all diffing is done.
                            * Since generating a cache entry is the slow path anyway,
                            * this extra overhead probably isn't a big deal.
                            */
                            notes_cache_write(driver->textconv_cache);
                    }

                    return size;
            }

            int textconv_object(struct repository *r,
                            const char *path,
                            unsigned mode,
                            const struct object_id *oid,
                            int oid_valid,
                            char **buf,
                            unsigned long *buf_size)
            {
                    struct diff_filespec *df;
                    struct userdiff_driver *textconv;

                    df = alloc_filespec(path);
                    fill_filespec(df, oid, oid_valid, mode);
                    textconv = get_textconv(r, df);
                    if (!textconv) {
                            free_filespec(df);
                            return 0;
                    }

                    *buf_size = fill_textconv(r, textconv, df, buf);
                    free_filespec(df);
                    return 1;
            }

            void setup_diff_pager(struct diff_options *opt)
            {
                    /*
                    * If the user asked for our exit code, then either they want --quiet
                    * or --exit-code. We should definitely not bother with a pager in the
                    * former case, as we will generate no output. Since we still properly
                    * report our exit code even when a pager is run, we _could_ run a
                    * pager with --exit-code. But since we have not done so historically,
                    * and because it is easy to find people oneline advising "git diff
                    * --exit-code" in hooks and other scripts, we do not do so.
                    */
                    if (!opt->flags.exit_with_status &&
                    check_pager_config("diff") != 0)
                            setup_pager();
            }

             """,
             "Patche":
             """
                            diff --git a/diff.c b/diff.c
            index 108c187577..3412fc392e 100644
            --- a/diff.c
            +++ b/diff.c
            @@ -4106,6 +4106,7 @@ int diff_populate_filespec(struct repository *r,
                    int check_binary = options ? options->check_binary : 0;
                    int err = 0;
                    int conv_flags = global_conv_flags_eol;
            +  int autocvtToASCII;
                    /*
                    * demote FAIL to WARN to allow inspecting the situation
                    * instead of refusing.
            @@ -4178,9 +4179,18 @@ int diff_populate_filespec(struct repository *r,
                                    s->is_binary = 1;
                                    return 0;
                            }
            +#ifdef __MVS__
            +    validate_codeset(r->index, s->path, &autocvtToASCII);
            +#endif
                            fd = open(s->path, O_RDONLY);
                            if (fd < 0)
                                    goto err_empty;
            +
            +#ifdef __MVS__
            +    if (!autocvtToASCII)
            +      __disableautocvt(fd);
            +#endif
            +
                            s->data = xmmap(NULL, s->size, PROT_READ, MAP_PRIVATE, fd, 0);
                            close(fd);
                            s->should_munmap = 1;
            @@ -4284,6 +4294,10 @@ static void prep_temp_blob(struct index_state *istate,
                            blob = buf.buf;
                            size = buf.len;
                    }
            +
            +#ifdef __MVS__
            +  tag_file_as_working_tree_encoding(istate, path, temp->tempfile->fd);
            +#endif
                    if (write_in_full(temp->tempfile->fd, blob, size) < 0 ||
                    close_tempfile_gently(temp->tempfile))
                            die_errno("unable to write temp-file");

             """,

              },


        {
              "wrong code":
              """
                            #define USE_THE_REPOSITORY_VARIABLE

            #include "git-compat-util.h"
            #include "object-store-ll.h"
            #include "dir.h"
            #include "environment.h"
            #include "gettext.h"
            #include "hex.h"
            #include "name-hash.h"
            #include "sparse-index.h"
            #include "streaming.h"
            #include "submodule.h"
            #include "symlinks.h"
            #include "progress.h"
            #include "fsmonitor.h"
            #include "entry.h"
            #include "parallel-checkout.h"

            static void create_directories(const char *path, int path_len,
                                    const struct checkout *state)
            {
                    char *buf = xmallocz(path_len);
                    int len = 0;

                    while (len < path_len) {
                            do {
                                    buf[len] = path[len];
                                    len++;
                            } while (len < path_len && path[len] != '/');
                            if (len >= path_len)
                                    break;
                            buf[len] = 0;

                            /*
                            * For 'checkout-index --prefix=<dir>', <dir> is
                            * allowed to be a symlink to an existing directory,
                            * and we set 'state->base_dir_len' below, such that
                            * we test the path components of the prefix with the
                            * stat() function instead of the lstat() function.
                            */
                            if (has_dirs_only_path(buf, len, state->base_dir_len))
                            continue; /* ok, it is already a directory. */

                    /*
                    * If this mkdir() would fail, it could be that there
                    * is already a symlink or something else exists
                    * there, therefore we then try to unlink it and try
                    * one more time to create the directory.
                    */
                    if (mkdir(buf, 0777)) {
                            if (errno == EEXIST && state->force &&
                            !unlink_or_warn(buf) && !mkdir(buf, 0777))
                                    continue;
                            die_errno("cannot create directory at '%s'", buf);
                    }
            }
            free(buf);
            }

            static void remove_subtree(struct strbuf *path)
            {
            DIR *dir = opendir(path->buf);
            struct dirent *de;
            int origlen = path->len;

            if (!dir)
                    die_errno("cannot opendir '%s'", path->buf);
            while ((de = readdir_skip_dot_and_dotdot(dir)) != NULL) {
                    struct stat st;

                    strbuf_addch(path, '/');
                    strbuf_addstr(path, de->d_name);
                    if (lstat(path->buf, &st))
                            die_errno("cannot lstat '%s'", path->buf);
                    if (S_ISDIR(st.st_mode))
                            remove_subtree(path);
                    else if (unlink(path->buf))
                            die_errno("cannot unlink '%s'", path->buf);
                    strbuf_setlen(path, origlen);
            }
            closedir(dir);
            if (rmdir(path->buf))
                    die_errno("cannot rmdir '%s'", path->buf);
            }

            static int create_file(const char *path, unsigned int mode)
            {
            mode = (mode & 0100) ? 0777 : 0666;
            return open(path, O_WRONLY | O_CREAT | O_EXCL, mode);
            }

            void *read_blob_entry(const struct cache_entry *ce, size_t *size)
            {
            enum object_type type;
            unsigned long ul;
            void *blob_data = repo_read_object_file(the_repository, &ce->oid,
                                                    &type, &ul);

            *size = ul;
            if (blob_data) {
                    if (type == OBJ_BLOB)
                            return blob_data;
                    free(blob_data);
            }
            return NULL;
            }

            static int open_output_fd(char *path, const struct cache_entry *ce, int to_tempfile)
            {
            int symlink = (ce->ce_mode & S_IFMT) != S_IFREG;
            if (to_tempfile) {
                    xsnprintf(path, TEMPORARY_FILENAME_LENGTH, "%s",
                            symlink ? ".merge_link_XXXXXX" : ".merge_file_XXXXXX");
                    return mkstemp(path);
            } else {
                    return create_file(path, !symlink ? ce->ce_mode : 0666);
            }
            }

            int fstat_checkout_output(int fd, const struct checkout *state, struct stat *st)
            {
            /* use fstat() only when path == ce->name */
            if (fstat_is_reliable() &&
            state->refresh_cache && !state->base_dir_len) {
                    return !fstat(fd, st);
            }
            return 0;
            }

            static int streaming_write_entry(const struct cache_entry *ce, char *path,
                                    struct stream_filter *filter,
                                    const struct checkout *state, int to_tempfile,
                                    int *fstat_done, struct stat *statbuf)
            {
            int result = 0;
            int fd;

            fd = open_output_fd(path, ce, to_tempfile);
            if (fd < 0)
                    return -1;

            result |= stream_blob_to_fd(fd, &ce->oid, filter, 1);
            *fstat_done = fstat_checkout_output(fd, state, statbuf);
            result |= close(fd);

            if (result)
                    unlink(path);
            return result;
            }

            void enable_delayed_checkout(struct checkout *state)
            {
            if (!state->delayed_checkout) {
                    state->delayed_checkout = xmalloc(sizeof(*state->delayed_checkout));
                    state->delayed_checkout->state = CE_CAN_DELAY;
                    string_list_init_nodup(&state->delayed_checkout->filters);
                    string_list_init_nodup(&state->delayed_checkout->paths);
            }
            }

            static int remove_available_paths(struct string_list_item *item, void *cb_data)
            {
            struct string_list *available_paths = cb_data;
            struct string_list_item *available;

            available = string_list_lookup(available_paths, item->string);
            if (available)
                    available->util = item->util;
            return !available;
            }

            static int string_is_not_null(struct string_list_item *item, void *data UNUSED)
            {
            return !!item->string;
            }

            int finish_delayed_checkout(struct checkout *state, int show_progress)
            {
            int errs = 0;
            unsigned processed_paths = 0;
            off_t filtered_bytes = 0;
            struct string_list_item *filter, *path;
            struct progress *progress = NULL;
            struct delayed_checkout *dco = state->delayed_checkout;

            if (!state->delayed_checkout)
                    return errs;

            dco->state = CE_RETRY;
            if (show_progress)
                    progress = start_delayed_progress(_("Filtering content"), dco->paths.nr);
            while (dco->filters.nr > 0) {
                    for_each_string_list_item(filter, &dco->filters) {
                            struct string_list available_paths = STRING_LIST_INIT_DUP;

                            if (!async_query_available_blobs(filter->string, &available_paths)) {
                                    /* Filter reported an error */
                                    errs = 1;
                                    filter->string = NULL;
                                    continue;
                            }
                            if (available_paths.nr <= 0) {
                                    /*
                                    * Filter responded with no entries. That means
                                    * the filter is done and we can remove the
                                    * filter from the list (see
                                    * "string_list_remove_empty_items" call below).
                                    */
                                    filter->string = NULL;
                                    continue;
                            }

                            /*
                            * In dco->paths we store a list of all delayed paths.
                            * The filter just send us a list of available paths.
                            * Remove them from the list.
                            */
                            filter_string_list(&dco->paths, 0,
                                    &remove_available_paths, &available_paths);

                            for_each_string_list_item(path, &available_paths) {
                                    struct cache_entry* ce;

                                    if (!path->util) {
                                            error("external filter '%s' signaled that '%s' "
                                            "is now available although it has not been "
                                            "delayed earlier",
                                            filter->string, path->string);
                                            errs |= 1;

                                            /*
                                            * Do not ask the filter for available blobs,
                                            * again, as the filter is likely buggy.
                                            */
                                            filter->string = NULL;
                                            continue;
                                    }
                                    ce = index_file_exists(state->istate, path->string,
                                                    strlen(path->string), 0);
                                    if (ce) {
                                            display_progress(progress, ++processed_paths);
                                            errs |= checkout_entry(ce, state, NULL, path->util);
                                            filtered_bytes += ce->ce_stat_data.sd_size;
                                            display_throughput(progress, filtered_bytes);
                                    } else
                                            errs = 1;
                            }

                            string_list_clear(&available_paths, 0);
                    }

                    filter_string_list(&dco->filters, 0, string_is_not_null, NULL);
            }
            stop_progress(&progress);
            string_list_clear(&dco->filters, 0);

            /* At this point we should not have any delayed paths anymore. */
            errs |= dco->paths.nr;
            for_each_string_list_item(path, &dco->paths) {
                    error("'%s' was not filtered properly", path->string);
            }
            string_list_clear(&dco->paths, 0);

            free(dco);
            state->delayed_checkout = NULL;

            return errs;
            }

            void update_ce_after_write(const struct checkout *state, struct cache_entry *ce,
                            struct stat *st)
            {
            if (state->refresh_cache) {
                    assert(state->istate);
                    fill_stat_cache_info(state->istate, ce, st);
                    ce->ce_flags |= CE_UPDATE_IN_BASE;
                    mark_fsmonitor_invalid(state->istate, ce);
                    state->istate->cache_changed |= CE_ENTRY_CHANGED;
            }
            }

            /* Note: ca is used (and required) iff the entry refers to a regular file. */
            static int write_entry(struct cache_entry *ce, char *path, struct conv_attrs *ca,
                    const struct checkout *state, int to_tempfile,
                    int *nr_checkouts)
            {
            unsigned int ce_mode_s_ifmt = ce->ce_mode & S_IFMT;
            struct delayed_checkout *dco = state->delayed_checkout;
            int fd, ret, fstat_done = 0;
            char *new_blob;
            struct strbuf buf = STRBUF_INIT;
            size_t size;
            ssize_t wrote;
            size_t newsize = 0;
            struct stat st;
            const struct submodule *sub;
            struct checkout_metadata meta;
            static int scratch_nr_checkouts;

            clone_checkout_metadata(&meta, &state->meta, &ce->oid);

            if (ce_mode_s_ifmt == S_IFREG) {
                    struct stream_filter *filter = get_stream_filter_ca(ca, &ce->oid);
                    if (filter &&
                    !streaming_write_entry(ce, path, filter,
                                            state, to_tempfile,
                                            &fstat_done, &st))
                            goto finish;
            }

            switch (ce_mode_s_ifmt) {
            case S_IFLNK:
                    new_blob = read_blob_entry(ce, &size);
                    if (!new_blob)
                            return error("unable to read sha1 file of %s (%s)",
                                    ce->name, oid_to_hex(&ce->oid));

                    /*
                    * We can't make a real symlink; write out a regular file entry
                    * with the symlink destination as its contents.
                    */
                    if (!has_symlinks || to_tempfile)
                            goto write_file_entry;

                    ret = symlink(new_blob, path);
                    free(new_blob);
                    if (ret)
                            return error_errno("unable to create symlink %s", path);
                    break;

            case S_IFREG:
                    /*
                    * We do not send the blob in case of a retry, so do not
                    * bother reading it at all.
                    */
                    if (dco && dco->state == CE_RETRY) {
                            new_blob = NULL;
                            size = 0;
                    } else {
                            new_blob = read_blob_entry(ce, &size);
                            if (!new_blob)
                                    return error("unable to read sha1 file of %s (%s)",
                                            ce->name, oid_to_hex(&ce->oid));
                    }

                    /*
                    * Convert from git internal format to working tree format
                    */
                    if (dco && dco->state != CE_NO_DELAY) {
                            ret = async_convert_to_working_tree_ca(ca, ce->name,
                                                            new_blob, size,
                                                            &buf, &meta, dco);
                            if (ret) {
                                    struct string_list_item *item =
                                            string_list_lookup(&dco->paths, ce->name);
                                    if (item) {
                                            item->util = nr_checkouts ? nr_checkouts
                                                            : &scratch_nr_checkouts;
                                            free(new_blob);
                                            goto delayed;
                                    }
                            }
                    } else {
                            ret = convert_to_working_tree_ca(ca, ce->name, new_blob,
                                                            size, &buf, &meta);
                    }

                    if (ret) {
                            free(new_blob);
                            new_blob = strbuf_detach(&buf, &newsize);
                            size = newsize;
                    }
                    /*
                    * No "else" here as errors from convert are OK at this
                    * point. If the error would have been fatal (e.g.
                    * filter is required), then we would have died already.
                    */

            write_file_entry:
                    fd = open_output_fd(path, ce, to_tempfile);
                    if (fd < 0) {
                            free(new_blob);
                            return error_errno("unable to create file %s", path);
                    }

                    wrote = write_in_full(fd, new_blob, size);
                    if (!to_tempfile)
                            fstat_done = fstat_checkout_output(fd, state, &st);
                    close(fd);
                    free(new_blob);
                    if (wrote < 0)
                            return error("unable to write file %s", path);
                    break;

            case S_IFGITLINK:
                    if (to_tempfile)
                            return error("cannot create temporary submodule %s", ce->name);
                    if (mkdir(path, 0777) < 0)
                            return error("cannot create submodule directory %s", path);
                    sub = submodule_from_ce(ce);
                    if (sub)
                            return submodule_move_head(ce->name, state->super_prefix,
                                    NULL, oid_to_hex(&ce->oid),
                                    state->force ? SUBMODULE_MOVE_HEAD_FORCE : 0);
                    break;

            default:
                    return error("unknown file mode for %s in index", ce->name);
            }

            finish:
            if (state->refresh_cache) {
                    if (!fstat_done && lstat(ce->name, &st) < 0)
                            return error_errno("unable to stat just-written file %s",
                                            ce->name);
                    update_ce_after_write(state, ce , &st);
            }
            if (nr_checkouts)
                    (*nr_checkouts)++;
            delayed:
            return 0;
            }

            /*
            * This is like 'lstat()', except it refuses to follow symlinks
            * in the path, after skipping "skiplen".
            */
            static int check_path(const char *path, int len, struct stat *st, int skiplen)
            {
            const char *slash = path + len;

            while (path < slash && *slash != '/')
                    slash--;
            if (!has_dirs_only_path(path, slash - path, skiplen)) {
                    errno = ENOENT;
                    return -1;
            }
            return lstat(path, st);
            }

            static void mark_colliding_entries(const struct checkout *state,
                                    struct cache_entry *ce, struct stat *st)
            {
            int trust_ino = check_stat;

            #if defined(GIT_WINDOWS_NATIVE) || defined(__CYGWIN__)
            trust_ino = 0;
            #endif

            ce->ce_flags |= CE_MATCHED;

            /* TODO: audit for interaction with sparse-index. */
            ensure_full_index(state->istate);
            for (size_t i = 0; i < state->istate->cache_nr; i++) {
                    struct cache_entry *dup = state->istate->cache[i];

                    if (dup == ce) {
                            /*
                            * Parallel checkout doesn't create the files in index
                            * order. So the other side of the collision may appear
                            * after the given cache_entry in the array.
                            */
                            if (parallel_checkout_status() == PC_RUNNING)
                                    continue;
                            else
                                    break;
                    }

                    if (dup->ce_flags & (CE_MATCHED | CE_VALID | CE_SKIP_WORKTREE))
                            continue;

                    if ((trust_ino && !match_stat_data(&dup->ce_stat_data, st)) ||
                    paths_collide(ce->name, dup->name)) {
                            dup->ce_flags |= CE_MATCHED;
                            break;
                    }
            }
            }

            int checkout_entry_ca(struct cache_entry *ce, struct conv_attrs *ca,
                    const struct checkout *state, char *topath,
                    int *nr_checkouts)
            {
            static struct strbuf path = STRBUF_INIT;
            struct stat st;
            struct conv_attrs ca_buf;

            if (ce->ce_flags & CE_WT_REMOVE) {
                    if (topath)
                            /*
                            * No content and thus no path to create, so we have
                            * no pathname to return.
                            */
                            BUG("Can't remove entry to a path");
                    unlink_entry(ce, state->super_prefix);
                    return 0;
            }

            if (topath) {
                    if (S_ISREG(ce->ce_mode) && !ca) {
                            convert_attrs(state->istate, &ca_buf, ce->name);
                            ca = &ca_buf;
                    }
                    return write_entry(ce, topath, ca, state, 1, nr_checkouts);
            }

            strbuf_reset(&path);
            strbuf_add(&path, state->base_dir, state->base_dir_len);
            strbuf_add(&path, ce->name, ce_namelen(ce));

            if (!check_path(path.buf, path.len, &st, state->base_dir_len)) {
                    const struct submodule *sub;
                    unsigned changed = ie_match_stat(state->istate, ce, &st,
                                                    CE_MATCH_IGNORE_VALID | CE_MATCH_IGNORE_SKIP_WORKTREE);
                    /*
                    * Needs to be checked before !changed returns early,
                    * as the possibly empty directory was not changed
                    */
                    sub = submodule_from_ce(ce);
                    if (sub) {
                            int err;
                            if (!is_submodule_populated_gently(ce->name, &err)) {
                                    struct stat sb;
                                    if (lstat(ce->name, &sb))
                                            die(_("could not stat file '%s'"), ce->name);
                                    if (!(st.st_mode & S_IFDIR))
                                            unlink_or_warn(ce->name);

                                    return submodule_move_head(ce->name, state->super_prefix,
                                            NULL, oid_to_hex(&ce->oid), 0);
                            } else
                                    return submodule_move_head(ce->name, state->super_prefix,
                                            "HEAD", oid_to_hex(&ce->oid),
                                            state->force ? SUBMODULE_MOVE_HEAD_FORCE : 0);
                    }

                    if (!changed)
                            return 0;
                    if (!state->force) {
                            if (!state->quiet)
                                    fprintf(stderr,
                                            "%s already exists, no checkout\n",
                                            path.buf);
                            return -1;
                    }

                    if (state->clone)
                            mark_colliding_entries(state, ce, &st);

                    /*
                    * We unlink the old file, to get the new one with the
                    * right permissions (including umask, which is nasty
                    * to emulate by hand - much easier to let the system
                    * just do the right thing)
                    */
                    if (S_ISDIR(st.st_mode)) {
                            /* If it is a gitlink, leave it alone! */
                            if (S_ISGITLINK(ce->ce_mode))
                                    return 0;
                            /*
                            * We must avoid replacing submodules' leading
                            * directories with symbolic links, lest recursive
                            * clones can write into arbitrary locations.
                            *
                            * Technically, this logic is not limited
                            * to recursive clones, or for that matter to
                            * submodules' paths colliding with symbolic links'
                            * paths. Yet it strikes a balance in favor of
                            * simplicity, and if paths are colliding, we might
                            * just as well keep the directories during a clone.
                            */
                            if (state->clone && S_ISLNK(ce->ce_mode))
                                    return 0;
                            remove_subtree(&path);
                    } else if (unlink(path.buf))
                            return error_errno("unable to unlink old '%s'", path.buf);
            } else if (state->not_new)
                    return 0;

            create_directories(path.buf, path.len, state);

            if (S_ISREG(ce->ce_mode) && !ca) {
                    convert_attrs(state->istate, &ca_buf, ce->name);
                    ca = &ca_buf;
            }

            if (!enqueue_checkout(ce, ca, nr_checkouts))
                    return 0;

            return write_entry(ce, path.buf, ca, state, 0, nr_checkouts);
            }

            void unlink_entry(const struct cache_entry *ce, const char *super_prefix)
            {
            const struct submodule *sub = submodule_from_ce(ce);
            if (sub) {
                    /* state.force is set at the caller. */
                    submodule_move_head(ce->name, super_prefix, "HEAD", NULL,
                                    SUBMODULE_MOVE_HEAD_FORCE);
            }
            if (check_leading_path(ce->name, ce_namelen(ce), 1) >= 0)
                    return;
            if (remove_or_warn(ce->ce_mode, ce->name))
                    return;
            schedule_dir_for_removal(ce->name, ce_namelen(ce));
            }

            int remove_or_warn(unsigned int mode, const char *file)
            {
            return S_ISGITLINK(mode) ? rmdir_or_warn(file) : unlink_or_warn(file);
            }


              """,

              "error":"The patch ensures that files are correctly processed according to z/OSs encoding and line-ending rules,
                       preventing corruption and ensuring that Git operations (e.g., checkout, write, diff) work correctly across different platforms.
                       By introducing platform-specific logic and environment variable handling, it enhances the flexibility and correctness of Git on z/OS.",
              "error category":"Functionality Patch",

              "Corrected code":
              """

                            #define USE_THE_REPOSITORY_VARIABLE

            #include "git-compat-util.h"
            #include "object-store-ll.h"
            #include "dir.h"
            #include "environment.h"
            #include "gettext.h"
            #include "hex.h"
            #include "name-hash.h"
            #include "sparse-index.h"
            #include "streaming.h"
            #include "submodule.h"
            #include "symlinks.h"
            #include "progress.h"
            #include "fsmonitor.h"
            #include "entry.h"
            #include "parallel-checkout.h"

            static void create_directories(const char *path, int path_len,
                                    const struct checkout *state)
            {
                    char *buf = xmallocz(path_len);
                    int len = 0;

                    while (len < path_len) {
                            do {
                                    buf[len] = path[len];
                                    len++;
                            } while (len < path_len && path[len] != '/');
                            if (len >= path_len)
                                    break;
                            buf[len] = 0;

                            /*
                            * For 'checkout-index --prefix=<dir>', <dir> is
                            * allowed to be a symlink to an existing directory,
                            * and we set 'state->base_dir_len' below, such that
                            * we test the path components of the prefix with the
                            * stat() function instead of the lstat() function.
                            */
                            if (has_dirs_only_path(buf, len, state->base_dir_len))
                                    continue; /* ok, it is already a directory. */

                            /*
                            * If this mkdir() would fail, it could be that there
                            * is already a symlink or something else exists
                            * there, therefore we then try to unlink it and try
                            * one more time to create the directory.
                            */
                            if (mkdir(buf, 0777)) {
                                    if (errno == EEXIST && state->force &&
                                    !unlink_or_warn(buf) && !mkdir(buf, 0777))
                                            continue;
                                    die_errno("cannot create directory at '%s'", buf);
                            }
                    }
                    free(buf);
            }

            static void remove_subtree(struct strbuf *path)
            {
                    DIR *dir = opendir(path->buf);
                    struct dirent *de;
                    int origlen = path->len;

                    if (!dir)
                            die_errno("cannot opendir '%s'", path->buf);
                    while ((de = readdir_skip_dot_and_dotdot(dir)) != NULL) {
                            struct stat st;

                            strbuf_addch(path, '/');
                            strbuf_addstr(path, de->d_name);
                            if (lstat(path->buf, &st))
                                    die_errno("cannot lstat '%s'", path->buf);
                            if (S_ISDIR(st.st_mode))
                                    remove_subtree(path);
                            else if (unlink(path->buf))
                                    die_errno("cannot unlink '%s'", path->buf);
                            strbuf_setlen(path, origlen);
                    }
                    closedir(dir);
                    if (rmdir(path->buf))
                            die_errno("cannot rmdir '%s'", path->buf);
            }

            static int create_file(const char *path, unsigned int mode)
            {
                    mode = (mode & 0100) ? 0777 : 0666;
                    return open(path, O_WRONLY | O_CREAT | O_EXCL, mode);
            }

            void *read_blob_entry(const struct cache_entry *ce, size_t *size)
            {
                    enum object_type type;
                    unsigned long ul;
                    void *blob_data = repo_read_object_file(the_repository, &ce->oid,
                                                            &type, &ul);

                    *size = ul;
                    if (blob_data) {
                            if (type == OBJ_BLOB)
                                    return blob_data;
                            free(blob_data);
                    }
                    return NULL;
            }

            static int open_output_fd(char *path, const struct cache_entry *ce, int to_tempfile)
            {
                    int symlink = (ce->ce_mode & S_IFMT) != S_IFREG;
                    if (to_tempfile) {
                            xsnprintf(path, TEMPORARY_FILENAME_LENGTH, "%s",
                                    symlink ? ".merge_link_XXXXXX" : ".merge_file_XXXXXX");
                            return mkstemp(path);
                    } else {
                            return create_file(path, !symlink ? ce->ce_mode : 0666);
                    }
            }

            int fstat_checkout_output(int fd, const struct checkout *state, struct stat *st)
            {
                    /* use fstat() only when path == ce->name */
                    if (fstat_is_reliable() &&
                    state->refresh_cache && !state->base_dir_len) {
                            return !fstat(fd, st);
                    }
                    return 0;
            }

            #ifdef __MVS__
            void tag_file_as_working_tree_encoding(struct index_state *istate, char* path, int fd) {
                    struct conv_attrs ca;
                    convert_attrs(istate, &ca, path);
            if (ca.attr_action != CRLF_BINARY) {
            if (ca.working_tree_encoding)
            __chgfdcodeset(fd, ca.working_tree_encoding);
            else
            __chgfdccsid(fd, utf8_ccsid);
            }
            else {
            __setfdbinary(fd);
            }

            __disableautocvt(fd);
            }
            #endif

            static int streaming_write_entry(const struct cache_entry *ce, char *path,
                                            struct stream_filter *filter,
                                            const struct checkout *state, int to_tempfile,
                                            int *fstat_done, struct stat *statbuf)
            {
                    int result = 0;
                    int fd;

                    fd = open_output_fd(path, ce, to_tempfile);
                    if (fd < 0)
                            return -1;

            #ifdef __MVS__
            tag_file_as_working_tree_encoding(state->istate, path, fd);
            #endif

                    result |= stream_blob_to_fd(fd, &ce->oid, filter, 1);
                    *fstat_done = fstat_checkout_output(fd, state, statbuf);
                    result |= close(fd);

                    if (result)
                            unlink(path);
                    return result;
            }

            void enable_delayed_checkout(struct checkout *state)
            {
                    if (!state->delayed_checkout) {
                            state->delayed_checkout = xmalloc(sizeof(*state->delayed_checkout));
                            state->delayed_checkout->state = CE_CAN_DELAY;
                            string_list_init_nodup(&state->delayed_checkout->filters);
                            string_list_init_nodup(&state->delayed_checkout->paths);
                    }
            }

            static int remove_available_paths(struct string_list_item *item, void *cb_data)
            {
                    struct string_list *available_paths = cb_data;
                    struct string_list_item *available;

                    available = string_list_lookup(available_paths, item->string);
                    if (available)
                            available->util = item->util;
                    return !available;
            }

            static int string_is_not_null(struct string_list_item *item, void *data UNUSED)
            {
                    return !!item->string;
            }

            int finish_delayed_checkout(struct checkout *state, int show_progress)
            {
                    int errs = 0;
                    unsigned processed_paths = 0;
                    off_t filtered_bytes = 0;
                    struct string_list_item *filter, *path;
                    struct progress *progress = NULL;
                    struct delayed_checkout *dco = state->delayed_checkout;

                    if (!state->delayed_checkout)
                            return errs;

                    dco->state = CE_RETRY;
                    if (show_progress)
                            progress = start_delayed_progress(_("Filtering content"), dco->paths.nr);
                    while (dco->filters.nr > 0) {
                            for_each_string_list_item(filter, &dco->filters) {
                                    struct string_list available_paths = STRING_LIST_INIT_DUP;

                                    if (!async_query_available_blobs(filter->string, &available_paths)) {
                                            /* Filter reported an error */
                                            errs = 1;
                                            filter->string = NULL;
                                            continue;
                                    }
                                    if (available_paths.nr <= 0) {
                                            /*
                                            * Filter responded with no entries. That means
                                            * the filter is done and we can remove the
                                            * filter from the list (see
                                            * "string_list_remove_empty_items" call below).
                                            */
                                            filter->string = NULL;
                                            continue;
                                    }

                                    /*
                                    * In dco->paths we store a list of all delayed paths.
                                    * The filter just send us a list of available paths.
                                    * Remove them from the list.
                                    */
                                    filter_string_list(&dco->paths, 0,
                                            &remove_available_paths, &available_paths);

                                    for_each_string_list_item(path, &available_paths) {
                                            struct cache_entry* ce;

                                            if (!path->util) {
                                                    error("external filter '%s' signaled that '%s' "
                                                    "is now available although it has not been "
                                                    "delayed earlier",
                                                    filter->string, path->string);
                                                    errs |= 1;

                                                    /*
                                                    * Do not ask the filter for available blobs,
                                                    * again, as the filter is likely buggy.
                                                    */
                                                    filter->string = NULL;
                                                    continue;
                                            }
                                            ce = index_file_exists(state->istate, path->string,
                                                            strlen(path->string), 0);
                                            if (ce) {
                                                    display_progress(progress, ++processed_paths);
                                                    errs |= checkout_entry(ce, state, NULL, path->util);
                                                    filtered_bytes += ce->ce_stat_data.sd_size;
                                                    display_throughput(progress, filtered_bytes);
                                            } else
                                                    errs = 1;
                                    }

                                    string_list_clear(&available_paths, 0);
                            }

                            filter_string_list(&dco->filters, 0, string_is_not_null, NULL);
                    }
                    stop_progress(&progress);
                    string_list_clear(&dco->filters, 0);

                    /* At this point we should not have any delayed paths anymore. */
                    errs |= dco->paths.nr;
                    for_each_string_list_item(path, &dco->paths) {
                            error("'%s' was not filtered properly", path->string);
                    }
                    string_list_clear(&dco->paths, 0);

                    free(dco);
                    state->delayed_checkout = NULL;

                    return errs;
            }

            void update_ce_after_write(const struct checkout *state, struct cache_entry *ce,
                                    struct stat *st)
            {
                    if (state->refresh_cache) {
                            assert(state->istate);
                            fill_stat_cache_info(state->istate, ce, st);
                            ce->ce_flags |= CE_UPDATE_IN_BASE;
                            mark_fsmonitor_invalid(state->istate, ce);
                            state->istate->cache_changed |= CE_ENTRY_CHANGED;
                    }
            }

            /* Note: ca is used (and required) iff the entry refers to a regular file. */
            static int write_entry(struct cache_entry *ce, char *path, struct conv_attrs *ca,
                            const struct checkout *state, int to_tempfile,
                            int *nr_checkouts)
            {
                    unsigned int ce_mode_s_ifmt = ce->ce_mode & S_IFMT;
                    struct delayed_checkout *dco = state->delayed_checkout;
                    int fd, ret, fstat_done = 0;
                    char *new_blob;
                    struct strbuf buf = STRBUF_INIT;
                    size_t size;
                    ssize_t wrote;
                    size_t newsize = 0;
                    struct stat st;
                    const struct submodule *sub;
                    struct checkout_metadata meta;
                    static int scratch_nr_checkouts;

                    clone_checkout_metadata(&meta, &state->meta, &ce->oid);

                    if (ce_mode_s_ifmt == S_IFREG) {
                            struct stream_filter *filter = get_stream_filter_ca(ca, &ce->oid);
                            if (filter &&
                            !streaming_write_entry(ce, path, filter,
                                                    state, to_tempfile,
                                                    &fstat_done, &st))
                                    goto finish;
                    }

                    switch (ce_mode_s_ifmt) {
                    case S_IFLNK:
                            new_blob = read_blob_entry(ce, &size);
                            if (!new_blob)
                                    return error("unable to read sha1 file of %s (%s)",
                                            ce->name, oid_to_hex(&ce->oid));

                            /*
                            * We can't make a real symlink; write out a regular file entry
                            * with the symlink destination as its contents.
                            */
                            if (!has_symlinks || to_tempfile)
                                    goto write_file_entry;

                            ret = symlink(new_blob, path);
                            free(new_blob);
                            if (ret)
                                    return error_errno("unable to create symlink %s", path);
                            break;

                    case S_IFREG:
                            /*
                            * We do not send the blob in case of a retry, so do not
                            * bother reading it at all.
                            */
                            if (dco && dco->state == CE_RETRY) {
                                    new_blob = NULL;
                                    size = 0;
                            } else {
                                    new_blob = read_blob_entry(ce, &size);
                                    if (!new_blob)
                                            return error("unable to read sha1 file of %s (%s)",
                                                    ce->name, oid_to_hex(&ce->oid));
                            }

                            /*
                            * Convert from git internal format to working tree format
                            */
                            if (dco && dco->state != CE_NO_DELAY) {
                                    ret = async_convert_to_working_tree_ca(ca, ce->name,
                                                                    new_blob, size,
                                                                    &buf, &meta, dco);
                                    if (ret) {
                                            struct string_list_item *item =
                                                    string_list_lookup(&dco->paths, ce->name);
                                            if (item) {
                                                    item->util = nr_checkouts ? nr_checkouts
                                                                    : &scratch_nr_checkouts;
                                                    free(new_blob);
                                                    goto delayed;
                                            }
                                    }
                            } else {
                                    ret = convert_to_working_tree_ca(ca, ce->name, new_blob,
                                                                    size, &buf, &meta);
                            }

                            if (ret) {
                                    free(new_blob);
                                    new_blob = strbuf_detach(&buf, &newsize);
                                    size = newsize;
                            }
                            /*
                            * No "else" here as errors from convert are OK at this
                            * point. If the error would have been fatal (e.g.
                            * filter is required), then we would have died already.
                            */

                    write_file_entry:
                            fd = open_output_fd(path, ce, to_tempfile);
                            if (fd < 0) {
                                    free(new_blob);
                                    return error_errno("unable to create file %s", path);
                            }

            #ifdef __MVS__
            tag_file_as_working_tree_encoding(state->istate, path, fd);
            #endif

                            wrote = write_in_full(fd, new_blob, size);
                            if (!to_tempfile)
                                    fstat_done = fstat_checkout_output(fd, state, &st);
                            close(fd);
                            free(new_blob);
                            if (wrote < 0)
                                    return error("unable to write file %s", path);
                            break;

                    case S_IFGITLINK:
                            if (to_tempfile)
                                    return error("cannot create temporary submodule %s", ce->name);
                            if (mkdir(path, 0777) < 0)
                                    return error("cannot create submodule directory %s", path);
                            sub = submodule_from_ce(ce);
                            if (sub)
                                    return submodule_move_head(ce->name, state->super_prefix,
                                            NULL, oid_to_hex(&ce->oid),
                                            state->force ? SUBMODULE_MOVE_HEAD_FORCE : 0);
                            break;

                    default:
                            return error("unknown file mode for %s in index", ce->name);
                    }

            finish:
                    if (state->refresh_cache) {
                            if (!fstat_done && lstat(ce->name, &st) < 0)
                                    return error_errno("unable to stat just-written file %s",
                                                    ce->name);
                            update_ce_after_write(state, ce , &st);
                    }
                    if (nr_checkouts)
                            (*nr_checkouts)++;
            delayed:
                    return 0;
            }

            /*
            * This is like 'lstat()', except it refuses to follow symlinks
            * in the path, after skipping "skiplen".
            */
            static int check_path(const char *path, int len, struct stat *st, int skiplen)
            {
                    const char *slash = path + len;

                    while (path < slash && *slash != '/')
                            slash--;
                    if (!has_dirs_only_path(path, slash - path, skiplen)) {
                            errno = ENOENT;
                            return -1;
                    }
                    return lstat(path, st);
            }

            static void mark_colliding_entries(const struct checkout *state,
                                            struct cache_entry *ce, struct stat *st)
            {
                    int trust_ino = check_stat;

            #if defined(GIT_WINDOWS_NATIVE) || defined(__CYGWIN__)
                    trust_ino = 0;
            #endif

                    ce->ce_flags |= CE_MATCHED;

                    /* TODO: audit for interaction with sparse-index. */
                    ensure_full_index(state->istate);
                    for (size_t i = 0; i < state->istate->cache_nr; i++) {
                            struct cache_entry *dup = state->istate->cache[i];

                            if (dup == ce) {
                                    /*
                                    * Parallel checkout doesn't create the files in index
                                    * order. So the other side of the collision may appear
                                    * after the given cache_entry in the array.
                                    */
                                    if (parallel_checkout_status() == PC_RUNNING)
                                            continue;
                                    else
                                            break;
                            }

                            if (dup->ce_flags & (CE_MATCHED | CE_VALID | CE_SKIP_WORKTREE))
                                    continue;

                            if ((trust_ino && !match_stat_data(&dup->ce_stat_data, st)) ||
                            paths_collide(ce->name, dup->name)) {
                                    dup->ce_flags |= CE_MATCHED;
                                    break;
                            }
                    }
            }

            int checkout_entry_ca(struct cache_entry *ce, struct conv_attrs *ca,
                            const struct checkout *state, char *topath,
                            int *nr_checkouts)
            {
                    static struct strbuf path = STRBUF_INIT;
                    struct stat st;
                    struct conv_attrs ca_buf;


            #ifdef __MVS__
            const char* git_utf8_ccsid_str = getenv("GIT_UTF8_CCSID");

            if (git_utf8_ccsid_str != NULL) {
            char* endptr;
            errno = 0;
            long conv = strtol(git_utf8_ccsid_str, &endptr, 10);

            if (!conv) {
                    perror("Error converting GIT_UTF8_CCSID to short");
            } else if (endptr == git_utf8_ccsid_str) {
                    fprintf(stderr, "No digits were found in GIT_UTF8_CCSID\n");
            } else {
                    utf8_ccsid = conv;
            }
            }
            #endif

                    if (ce->ce_flags & CE_WT_REMOVE) {
                            if (topath)
                                    /*
                                    * No content and thus no path to create, so we have
                                    * no pathname to return.
                                    */
                                    BUG("Can't remove entry to a path");
                            unlink_entry(ce, state->super_prefix);
                            return 0;
                    }

                    if (topath) {
                            if (S_ISREG(ce->ce_mode) && !ca) {
                                    convert_attrs(state->istate, &ca_buf, ce->name);
                                    ca = &ca_buf;
                            }
                            return write_entry(ce, topath, ca, state, 1, nr_checkouts);
                    }

                    strbuf_reset(&path);
                    strbuf_add(&path, state->base_dir, state->base_dir_len);
                    strbuf_add(&path, ce->name, ce_namelen(ce));

                    if (!check_path(path.buf, path.len, &st, state->base_dir_len)) {
                            const struct submodule *sub;
                            unsigned changed = ie_match_stat(state->istate, ce, &st,
                                                            CE_MATCH_IGNORE_VALID | CE_MATCH_IGNORE_SKIP_WORKTREE);
                            /*
                            * Needs to be checked before !changed returns early,
                            * as the possibly empty directory was not changed
                            */
                            sub = submodule_from_ce(ce);
                            if (sub) {
                                    int err;
                                    if (!is_submodule_populated_gently(ce->name, &err)) {
                                            struct stat sb;
                                            if (lstat(ce->name, &sb))
                                                    die(_("could not stat file '%s'"), ce->name);
                                            if (!(st.st_mode & S_IFDIR))
                                                    unlink_or_warn(ce->name);

                                            return submodule_move_head(ce->name, state->super_prefix,
                                                    NULL, oid_to_hex(&ce->oid), 0);
                                    } else
                                            return submodule_move_head(ce->name, state->super_prefix,
                                                    "HEAD", oid_to_hex(&ce->oid),
                                                    state->force ? SUBMODULE_MOVE_HEAD_FORCE : 0);
                            }

                            if (!changed)
                                    return 0;
                            if (!state->force) {
                                    if (!state->quiet)
                                            fprintf(stderr,
                                                    "%s already exists, no checkout\n",
                                                    path.buf);
                                    return -1;
                            }

                            if (state->clone)
                                    mark_colliding_entries(state, ce, &st);

                            /*
                            * We unlink the old file, to get the new one with the
                            * right permissions (including umask, which is nasty
                            * to emulate by hand - much easier to let the system
                            * just do the right thing)
                            */
                            if (S_ISDIR(st.st_mode)) {
                                    /* If it is a gitlink, leave it alone! */
                                    if (S_ISGITLINK(ce->ce_mode))
                                            return 0;
                                    /*
                                    * We must avoid replacing submodules' leading
                                    * directories with symbolic links, lest recursive
                                    * clones can write into arbitrary locations.
                                    *
                                    * Technically, this logic is not limited
                                    * to recursive clones, or for that matter to
                                    * submodules' paths colliding with symbolic links'
                                    * paths. Yet it strikes a balance in favor of
                                    * simplicity, and if paths are colliding, we might
                                    * just as well keep the directories during a clone.
                                    */
                                    if (state->clone && S_ISLNK(ce->ce_mode))
                                            return 0;
                                    remove_subtree(&path);
                            } else if (unlink(path.buf))
                                    return error_errno("unable to unlink old '%s'", path.buf);
                    } else if (state->not_new)
                            return 0;

                    create_directories(path.buf, path.len, state);

                    if (S_ISREG(ce->ce_mode) && !ca) {
                            convert_attrs(state->istate, &ca_buf, ce->name);
                            ca = &ca_buf;
                    }

                    if (!enqueue_checkout(ce, ca, nr_checkouts))
                            return 0;

                    return write_entry(ce, path.buf, ca, state, 0, nr_checkouts);
            }

            void unlink_entry(const struct cache_entry *ce, const char *super_prefix)
            {
                    const struct submodule *sub = submodule_from_ce(ce);
                    if (sub) {
                            /* state.force is set at the caller. */
                            submodule_move_head(ce->name, super_prefix, "HEAD", NULL,
                                            SUBMODULE_MOVE_HEAD_FORCE);
                    }
                    if (check_leading_path(ce->name, ce_namelen(ce), 1) >= 0)
                            return;
                    if (remove_or_warn(ce->ce_mode, ce->name))
                            return;
                    schedule_dir_for_removal(ce->name, ce_namelen(ce));
            }

            int remove_or_warn(unsigned int mode, const char *file)
            {
                    return S_ISGITLINK(mode) ? rmdir_or_warn(file) : unlink_or_warn(file);
            }
              """,

              "Patche":

              """
                            diff --git a/entry.c b/entry.c
            index 076e97e..5c19411 100644
            --- a/entry.c
            +++ b/entry.c
            @@ -126,6 +126,24 @@ int fstat_checkout_output(int fd, const struct checkout *state, struct stat *st)
                    return 0;
            }

            +#ifdef __MVS__
            +void tag_file_as_working_tree_encoding(struct index_state *istate, char* path, int fd) {
            +   struct conv_attrs ca;
            +   convert_attrs(istate, &ca, path);
            +  if (ca.attr_action != CRLF_BINARY) {
            +    if (ca.working_tree_encoding)
            +      __chgfdcodeset(fd, ca.working_tree_encoding);
            +    else
            +      __chgfdccsid(fd, utf8_ccsid);
            +  }
            +  else {
            +    __setfdbinary(fd);
            +  }
            +
            +  __disableautocvt(fd);
            +}
            +#endif
            +
            static int streaming_write_entry(const struct cache_entry *ce, char *path,
                                            struct stream_filter *filter,
                                            const struct checkout *state, int to_tempfile,
            @@ -138,6 +156,10 @@ static int streaming_write_entry(const struct cache_entry *ce, char *path,
                    if (fd < 0)
                            return -1;

            +#ifdef __MVS__
            +  tag_file_as_working_tree_encoding(state->istate, path, fd);
            +#endif
            +
                    result |= stream_blob_to_fd(fd, &ce->oid, filter, 1);
                    *fstat_done = fstat_checkout_output(fd, state, statbuf);
                    result |= close(fd);
            @@ -374,6 +396,10 @@ static int write_entry(struct cache_entry *ce, char *path, struct conv_attrs *ca
                                    return error_errno("unable to create file %s", path);
                            }

            +#ifdef __MVS__
            +    tag_file_as_working_tree_encoding(state->istate, path, fd);
            +#endif
            +
                            wrote = write_in_full(fd, new_blob, size);
                            if (!to_tempfile)
                                    fstat_done = fstat_checkout_output(fd, state, &st);
            @@ -476,6 +502,25 @@ int checkout_entry_ca(struct cache_entry *ce, struct conv_attrs *ca,
                    struct stat st;
                    struct conv_attrs ca_buf;

            +
            +#ifdef __MVS__
            +  const char* git_utf8_ccsid_str = getenv("GIT_UTF8_CCSID");
            +
            +  if (git_utf8_ccsid_str != NULL) {
            +      char* endptr;
            +      errno = 0;
            +      long conv = strtol(git_utf8_ccsid_str, &endptr, 10);
            +
            +      if (!conv) {
            +          perror("Error converting GIT_UTF8_CCSID to short");
            +      } else if (endptr == git_utf8_ccsid_str) {
            +          fprintf(stderr, "No digits were found in GIT_UTF8_CCSID\n");
            +      } else {
            +          utf8_ccsid = conv;
            +      }
            +  }
            +#endif
            +
                    if (ce->ce_flags & CE_WT_REMOVE) {
                            if (topath)
                                    /*


              """,
                },

       {
                "wrong code":

                """
                            /*
            * We put all the git config variables in this same object
            * file, so that programs can link against the config parser
            * without having to link against all the rest of git.
            *
            * In particular, no need to bring in libz etc unless needed,
            * even if you might want to know where the git directory etc
            * are.
            */

            #define USE_THE_REPOSITORY_VARIABLE

            #include "git-compat-util.h"
            #include "abspath.h"
            #include "branch.h"
            #include "convert.h"
            #include "environment.h"
            #include "gettext.h"
            #include "repository.h"
            #include "config.h"
            #include "refs.h"
            #include "fmt-merge-msg.h"
            #include "commit.h"
            #include "strvec.h"
            #include "path.h"
            #include "chdir-notify.h"
            #include "setup.h"
            #include "write-or-die.h"

            int trust_executable_bit = 1;
            int trust_ctime = 1;
            int check_stat = 1;
            int has_symlinks = 1;
            int minimum_abbrev = 4, default_abbrev = -1;
            int ignore_case;
            int assume_unchanged;
            int is_bare_repository_cfg = -1; /* unspecified */
            int warn_on_object_refname_ambiguity = 1;
            int repository_format_precious_objects;
            char *git_commit_encoding;
            char *git_log_output_encoding;
            char *apply_default_whitespace;
            char *apply_default_ignorewhitespace;
            char *git_attributes_file;
            char *git_hooks_path;
            int zlib_compression_level = Z_BEST_SPEED;
            int pack_compression_level = Z_DEFAULT_COMPRESSION;
            int fsync_object_files = -1;
            int use_fsync = -1;
            enum fsync_method fsync_method = FSYNC_METHOD_DEFAULT;
            enum fsync_component fsync_components = FSYNC_COMPONENTS_DEFAULT;
            unsigned long big_file_threshold = 512 * 1024 * 1024;
            char *editor_program;
            char *askpass_program;
            char *excludes_file;
            enum auto_crlf auto_crlf = AUTO_CRLF_FALSE;
            enum eol core_eol = EOL_UNSET;
            int global_conv_flags_eol = CONV_EOL_RNDTRP_WARN;
            char *check_roundtrip_encoding;
            enum branch_track git_branch_track = BRANCH_TRACK_REMOTE;
            enum rebase_setup_type autorebase = AUTOREBASE_NEVER;
            enum push_default_type push_default = PUSH_DEFAULT_UNSPECIFIED;
            #ifndef OBJECT_CREATION_MODE
            #define OBJECT_CREATION_MODE OBJECT_CREATION_USES_HARDLINKS
            #endif
            enum object_creation_mode object_creation_mode = OBJECT_CREATION_MODE;
            int grafts_keep_true_parents;
            int core_apply_sparse_checkout;
            int core_sparse_checkout_cone;
            int sparse_expect_files_outside_of_patterns;
            int merge_log_config = -1;
            int precomposed_unicode = -1; /* see probe_utf8_pathname_composition() */
            unsigned long pack_size_limit_cfg;
            int max_allowed_tree_depth =
            #ifdef _MSC_VER
                    /*
                    * When traversing into too-deep trees, Visual C-compiled Git seems to
                    * run into some internal stack overflow detection in the
                    * `RtlpAllocateHeap()` function that is called from within
                    * `git_inflate_init()`'s call tree. The following value seems to be
                    * low enough to avoid that by letting Git exit with an error before
                    * the stack overflow can occur.
                    */
                    512;
            #else
                    2048;
            #endif

            #ifndef PROTECT_HFS_DEFAULT
            #define PROTECT_HFS_DEFAULT 0
            #endif
            int protect_hfs = PROTECT_HFS_DEFAULT;

            #ifndef PROTECT_NTFS_DEFAULT
            #define PROTECT_NTFS_DEFAULT 1
            #endif
            int protect_ntfs = PROTECT_NTFS_DEFAULT;

            /*
            * The character that begins a commented line in user-editable file
            * that is subject to stripspace.
            */
            const char *comment_line_str = "#";
            char *comment_line_str_to_free;
            int auto_comment_line_char;

            /* Parallel index stat data preload? */
            int core_preload_index = 1;

            /* This is set by setup_git_dir_gently() and/or git_default_config() */
            char *git_work_tree_cfg;

            /*
            * Repository-local GIT_* environment variables; see environment.h for details.
            */
            const char * const local_repo_env[] = {
                    ALTERNATE_DB_ENVIRONMENT,
                    CONFIG_ENVIRONMENT,
                    CONFIG_DATA_ENVIRONMENT,
                    CONFIG_COUNT_ENVIRONMENT,
                    DB_ENVIRONMENT,
                    GIT_DIR_ENVIRONMENT,
                    GIT_WORK_TREE_ENVIRONMENT,
                    GIT_IMPLICIT_WORK_TREE_ENVIRONMENT,
                    GRAFT_ENVIRONMENT,
                    INDEX_ENVIRONMENT,
                    NO_REPLACE_OBJECTS_ENVIRONMENT,
                    GIT_REPLACE_REF_BASE_ENVIRONMENT,
                    GIT_PREFIX_ENVIRONMENT,
                    GIT_SHALLOW_FILE_ENVIRONMENT,
                    GIT_COMMON_DIR_ENVIRONMENT,
                    NULL
            };

            const char *getenv_safe(struct strvec *argv, const char *name)
            {
                    const char *value = getenv(name);

                    if (!value)
                            return NULL;

                    strvec_push(argv, value);
                    return argv->v[argv->nr - 1];
            }

            int is_bare_repository(void)
            {
                    /* if core.bare is not 'false', let's see if there is a work tree */
                    return is_bare_repository_cfg && !repo_get_work_tree(the_repository);
            }

            int have_git_dir(void)
            {
                    return startup_info->have_repository
                            || the_repository->gitdir;
            }

            const char *get_git_namespace(void)
            {
                    static const char *namespace;

                    struct strbuf buf = STRBUF_INIT;
                    struct strbuf **components, **c;
                    const char *raw_namespace;

                    if (namespace)
                            return namespace;

                    raw_namespace = getenv(GIT_NAMESPACE_ENVIRONMENT);
                    if (!raw_namespace || !*raw_namespace) {
                            namespace = "";
                            return namespace;
                    }

                    strbuf_addstr(&buf, raw_namespace);
                    components = strbuf_split(&buf, '/');
                    strbuf_reset(&buf);
                    for (c = components; *c; c++)
                            if (strcmp((*c)->buf, "/") != 0)
                                    strbuf_addf(&buf, "refs/namespaces/%s", (*c)->buf);
                    strbuf_list_free(components);
                    if (check_refname_format(buf.buf, 0))
                            die(_("bad git namespace path \"%s\""), raw_namespace);
                    strbuf_addch(&buf, '/');

                    namespace = strbuf_detach(&buf, NULL);

                    return namespace;
            }

            const char *strip_namespace(const char *namespaced_ref)
            {
                    const char *out;
                    if (skip_prefix(namespaced_ref, get_git_namespace(), &out))
                            return out;
                    return NULL;
            }

            const char *get_log_output_encoding(void)
            {
                    return git_log_output_encoding ? git_log_output_encoding
                            : get_commit_output_encoding();
            }

            const char *get_commit_output_encoding(void)
            {
                    return git_commit_encoding ? git_commit_encoding : "UTF-8";
            }

            static int the_shared_repository = PERM_UMASK;
            static int need_shared_repository_from_config = 1;

            void set_shared_repository(int value)
            {
                    the_shared_repository = value;
                    need_shared_repository_from_config = 0;
            }

            int get_shared_repository(void)
            {
                    if (need_shared_repository_from_config) {
                            const char *var = "core.sharedrepository";
                            const char *value;
                            if (!git_config_get_value(var, &value))
                                    the_shared_repository = git_config_perm(var, value);
                            need_shared_repository_from_config = 0;
                    }
                    return the_shared_repository;
            }

            void reset_shared_repository(void)
            {
                    need_shared_repository_from_config = 1;
            }

            int use_optional_locks(void)
            {
                    return git_env_bool(GIT_OPTIONAL_LOCKS_ENVIRONMENT, 1);
            }

            int print_sha1_ellipsis(void)
            {
                    /*
                    * Determine if the calling environment contains the variable
                    * GIT_PRINT_SHA1_ELLIPSIS set to "yes".
                    */
                    static int cached_result = -1; /* unknown */

                    if (cached_result < 0) {
                            const char *v = getenv("GIT_PRINT_SHA1_ELLIPSIS");
                            cached_result = (v && !strcasecmp(v, "yes"));
                    }
                    return cached_result;
            }


        """,
        "Error":" The patch ensures that Git on z/OS can handle character encodings properly and allows users to control
                  the handling of file tags. This improves Git's
                  compatibility with z/OS, preventing data corruption and ensuring correct file processing.",
        "Error Category":"Functionality Patch",

        "Corrceted Code":
        """
                    /*
            * We put all the git config variables in this same object
            * file, so that programs can link against the config parser
            * without having to link against all the rest of git.
            *
            * In particular, no need to bring in libz etc unless needed,
            * even if you might want to know where the git directory etc
            * are.
            */

            #define USE_THE_REPOSITORY_VARIABLE

            #include "git-compat-util.h"
            #include "abspath.h"
            #include "branch.h"
            #include "convert.h"
            #include "environment.h"
            #include "gettext.h"
            #include "repository.h"
            #include "config.h"
            #include "refs.h"
            #include "fmt-merge-msg.h"
            #include "commit.h"
            #include "strvec.h"
            #include "path.h"
            #include "chdir-notify.h"
            #include "setup.h"
            #include "write-or-die.h"

            int trust_executable_bit = 1;
            int trust_ctime = 1;
            int check_stat = 1;
            int has_symlinks = 1;
            int minimum_abbrev = 4, default_abbrev = -1;
            int ignore_case;
            int assume_unchanged;
            int is_bare_repository_cfg = -1; /* unspecified */
            int warn_on_object_refname_ambiguity = 1;
            int repository_format_precious_objects;
            char *git_commit_encoding;
            char *git_log_output_encoding;
            char *apply_default_whitespace;
            char *apply_default_ignorewhitespace;
            char *git_attributes_file;
            char *git_hooks_path;
            int zlib_compression_level = Z_BEST_SPEED;
            int pack_compression_level = Z_DEFAULT_COMPRESSION;
            int fsync_object_files = -1;
            #ifdef __MVS__
            int ignore_file_tags = 0;
            int utf8_ccsid = 1208;
            #endif
            int use_fsync = -1;
            enum fsync_method fsync_method = FSYNC_METHOD_DEFAULT;
            enum fsync_component fsync_components = FSYNC_COMPONENTS_DEFAULT;
            unsigned long big_file_threshold = 512 * 1024 * 1024;
            char *editor_program;
            char *askpass_program;
            char *excludes_file;
            enum auto_crlf auto_crlf = AUTO_CRLF_FALSE;
            enum eol core_eol = EOL_UNSET;
            int global_conv_flags_eol = CONV_EOL_RNDTRP_WARN;
            char *check_roundtrip_encoding;
            enum branch_track git_branch_track = BRANCH_TRACK_REMOTE;
            enum rebase_setup_type autorebase = AUTOREBASE_NEVER;
            enum push_default_type push_default = PUSH_DEFAULT_UNSPECIFIED;
            #ifndef OBJECT_CREATION_MODE
            #define OBJECT_CREATION_MODE OBJECT_CREATION_USES_HARDLINKS
            #endif
            enum object_creation_mode object_creation_mode = OBJECT_CREATION_MODE;
            int grafts_keep_true_parents;
            int core_apply_sparse_checkout;
            int core_sparse_checkout_cone;
            int sparse_expect_files_outside_of_patterns;
            int merge_log_config = -1;
            int precomposed_unicode = -1; /* see probe_utf8_pathname_composition() */
            unsigned long pack_size_limit_cfg;
            int max_allowed_tree_depth =
            #ifdef _MSC_VER
                    /*
                    * When traversing into too-deep trees, Visual C-compiled Git seems to
                    * run into some internal stack overflow detection in the
                    * `RtlpAllocateHeap()` function that is called from within
                    * `git_inflate_init()`'s call tree. The following value seems to be
                    * low enough to avoid that by letting Git exit with an error before
                    * the stack overflow can occur.
                    */
                    512;
            #else
                    2048;
            #endif

            #ifndef PROTECT_HFS_DEFAULT
            #define PROTECT_HFS_DEFAULT 0
            #endif
            int protect_hfs = PROTECT_HFS_DEFAULT;

            #ifndef PROTECT_NTFS_DEFAULT
            #define PROTECT_NTFS_DEFAULT 1
            #endif
            int protect_ntfs = PROTECT_NTFS_DEFAULT;

            /*
            * The character that begins a commented line in user-editable file
            * that is subject to stripspace.
            */
            const char *comment_line_str = "#";
            char *comment_line_str_to_free;
            int auto_comment_line_char;

            /* Parallel index stat data preload? */
            int core_preload_index = 1;

            /* This is set by setup_git_dir_gently() and/or git_default_config() */
            char *git_work_tree_cfg;

            /*
            * Repository-local GIT_* environment variables; see environment.h for details.
            */
            const char * const local_repo_env[] = {
                    ALTERNATE_DB_ENVIRONMENT,
                    CONFIG_ENVIRONMENT,
                    CONFIG_DATA_ENVIRONMENT,
                    CONFIG_COUNT_ENVIRONMENT,
                    DB_ENVIRONMENT,
                    GIT_DIR_ENVIRONMENT,
                    GIT_WORK_TREE_ENVIRONMENT,
                    GIT_IMPLICIT_WORK_TREE_ENVIRONMENT,
                    GRAFT_ENVIRONMENT,
                    INDEX_ENVIRONMENT,
                    NO_REPLACE_OBJECTS_ENVIRONMENT,
                    GIT_REPLACE_REF_BASE_ENVIRONMENT,
                    GIT_PREFIX_ENVIRONMENT,
                    GIT_SHALLOW_FILE_ENVIRONMENT,
                    GIT_COMMON_DIR_ENVIRONMENT,
                    NULL
            };

            const char *getenv_safe(struct strvec *argv, const char *name)
            {
                    const char *value = getenv(name);

                    if (!value)
                            return NULL;

                    strvec_push(argv, value);
                    return argv->v[argv->nr - 1];
            }

            int is_bare_repository(void)
            {
                    /* if core.bare is not 'false', let's see if there is a work tree */
                    return is_bare_repository_cfg && !repo_get_work_tree(the_repository);
            }

            int have_git_dir(void)
            {
                    return startup_info->have_repository
                            || the_repository->gitdir;
            }

            const char *get_git_namespace(void)
            {
                    static const char *namespace;

                    struct strbuf buf = STRBUF_INIT;
                    struct strbuf **components, **c;
                    const char *raw_namespace;

                    if (namespace)
                            return namespace;

                    raw_namespace = getenv(GIT_NAMESPACE_ENVIRONMENT);
                    if (!raw_namespace || !*raw_namespace) {
                            namespace = "";
                            return namespace;
                    }

                    strbuf_addstr(&buf, raw_namespace);
                    components = strbuf_split(&buf, '/');
                    strbuf_reset(&buf);
                    for (c = components; *c; c++)
                            if (strcmp((*c)->buf, "/") != 0)
                                    strbuf_addf(&buf, "refs/namespaces/%s", (*c)->buf);
                    strbuf_list_free(components);
                    if (check_refname_format(buf.buf, 0))
                            die(_("bad git namespace path \"%s\""), raw_namespace);
                    strbuf_addch(&buf, '/');

                    namespace = strbuf_detach(&buf, NULL);

                    return namespace;
            }

            const char *strip_namespace(const char *namespaced_ref)
            {
                    const char *out;
                    if (skip_prefix(namespaced_ref, get_git_namespace(), &out))
                            return out;
                    return NULL;
            }

            const char *get_log_output_encoding(void)
            {
                    return git_log_output_encoding ? git_log_output_encoding
                            : get_commit_output_encoding();
            }

            const char *get_commit_output_encoding(void)
            {
                    return git_commit_encoding ? git_commit_encoding : "UTF-8";
            }

            static int the_shared_repository = PERM_UMASK;
            static int need_shared_repository_from_config = 1;

            void set_shared_repository(int value)
            {
                    the_shared_repository = value;
                    need_shared_repository_from_config = 0;
            }

            int get_shared_repository(void)
            {
                    if (need_shared_repository_from_config) {
                            const char *var = "core.sharedrepository";
                            const char *value;
                            if (!git_config_get_value(var, &value))
                                    the_shared_repository = git_config_perm(var, value);
                            need_shared_repository_from_config = 0;
                    }
                    return the_shared_repository;
            }

            void reset_shared_repository(void)
            {
                    need_shared_repository_from_config = 1;
            }

            int use_optional_locks(void)
            {
                    return git_env_bool(GIT_OPTIONAL_LOCKS_ENVIRONMENT, 1);
            }

            int print_sha1_ellipsis(void)
            {
                    /*
                    * Determine if the calling environment contains the variable
                    * GIT_PRINT_SHA1_ELLIPSIS set to "yes".
                    */
                    static int cached_result = -1; /* unknown */

                    if (cached_result < 0) {
                            const char *v = getenv("GIT_PRINT_SHA1_ELLIPSIS");
                            cached_result = (v && !strcasecmp(v, "yes"));
                    }
                    return cached_result;

        """,
        "Patche":
        """
                    diff --git a/environment.c b/environment.c
            index 90632a39bc..b580112319 100644
            --- a/environment.c
            +++ b/environment.c
            @@ -51,6 +51,10 @@ const char *git_hooks_path;
            int zlib_compression_level = Z_BEST_SPEED;
            int pack_compression_level = Z_DEFAULT_COMPRESSION;
            int fsync_object_files = -1;
            +#ifdef __MVS__
            +int ignore_file_tags = 0;
            +int utf8_ccsid = 1208;
            +#endif
            int use_fsync = -1;
            enum fsync_method fsync_method = FSYNC_METHOD_DEFAULT;
            enum fsync_component fsync_components = FSYNC_COMPONENTS_DEFAULT;


        """,
    {
            "wrong code":

            """
                            #ifndef ENVIRONMENT_H
            #define ENVIRONMENT_H

            #include "repo-settings.h"

            /* Double-check local_repo_env below if you add to this list. */
            #define GIT_DIR_ENVIRONMENT "GIT_DIR"
            #define GIT_COMMON_DIR_ENVIRONMENT "GIT_COMMON_DIR"
            #define GIT_NAMESPACE_ENVIRONMENT "GIT_NAMESPACE"
            #define GIT_WORK_TREE_ENVIRONMENT "GIT_WORK_TREE"
            #define GIT_PREFIX_ENVIRONMENT "GIT_PREFIX"
            #define DEFAULT_GIT_DIR_ENVIRONMENT ".git"
            #define DB_ENVIRONMENT "GIT_OBJECT_DIRECTORY"
            #define INDEX_ENVIRONMENT "GIT_INDEX_FILE"
            #define GRAFT_ENVIRONMENT "GIT_GRAFT_FILE"
            #define GIT_SHALLOW_FILE_ENVIRONMENT "GIT_SHALLOW_FILE"
            #define TEMPLATE_DIR_ENVIRONMENT "GIT_TEMPLATE_DIR"
            #define CONFIG_ENVIRONMENT "GIT_CONFIG"
            #define CONFIG_DATA_ENVIRONMENT "GIT_CONFIG_PARAMETERS"
            #define CONFIG_COUNT_ENVIRONMENT "GIT_CONFIG_COUNT"
            #define EXEC_PATH_ENVIRONMENT "GIT_EXEC_PATH"
            #define CEILING_DIRECTORIES_ENVIRONMENT "GIT_CEILING_DIRECTORIES"
            #define NO_REPLACE_OBJECTS_ENVIRONMENT "GIT_NO_REPLACE_OBJECTS"
            #define GIT_REPLACE_REF_BASE_ENVIRONMENT "GIT_REPLACE_REF_BASE"
            #define NO_LAZY_FETCH_ENVIRONMENT "GIT_NO_LAZY_FETCH"
            #define GITATTRIBUTES_FILE ".gitattributes"
            #define INFOATTRIBUTES_FILE "info/attributes"
            #define ATTRIBUTE_MACRO_PREFIX "[attr]"
            #define GITMODULES_FILE ".gitmodules"
            #define GITMODULES_INDEX ":.gitmodules"
            #define GITMODULES_HEAD "HEAD:.gitmodules"
            #define GIT_NOTES_REF_ENVIRONMENT "GIT_NOTES_REF"
            #define GIT_NOTES_DEFAULT_REF "refs/notes/commits"
            #define GIT_NOTES_DISPLAY_REF_ENVIRONMENT "GIT_NOTES_DISPLAY_REF"
            #define GIT_NOTES_REWRITE_REF_ENVIRONMENT "GIT_NOTES_REWRITE_REF"
            #define GIT_NOTES_REWRITE_MODE_ENVIRONMENT "GIT_NOTES_REWRITE_MODE"
            #define GIT_LITERAL_PATHSPECS_ENVIRONMENT "GIT_LITERAL_PATHSPECS"
            #define GIT_GLOB_PATHSPECS_ENVIRONMENT "GIT_GLOB_PATHSPECS"
            #define GIT_NOGLOB_PATHSPECS_ENVIRONMENT "GIT_NOGLOB_PATHSPECS"
            #define GIT_ICASE_PATHSPECS_ENVIRONMENT "GIT_ICASE_PATHSPECS"
            #define GIT_QUARANTINE_ENVIRONMENT "GIT_QUARANTINE_PATH"
            #define GIT_OPTIONAL_LOCKS_ENVIRONMENT "GIT_OPTIONAL_LOCKS"
            #define GIT_TEXT_DOMAIN_DIR_ENVIRONMENT "GIT_TEXTDOMAINDIR"
            #define GIT_ATTR_SOURCE_ENVIRONMENT "GIT_ATTR_SOURCE"

            /*
            * Environment variable used to propagate the --no-advice global option to the
            * advice_enabled() helper, even when run in a subprocess.
            * This is an internal variable that should not be set by the user.
            */
            #define GIT_ADVICE_ENVIRONMENT "GIT_ADVICE"

            /*
            * Environment variable used in handshaking the wire protocol.
            * Contains a colon ':' separated list of keys with optional values
            * 'key[=value]'.  Presence of unknown keys and values must be
            * ignored.
            */
            #define GIT_PROTOCOL_ENVIRONMENT "GIT_PROTOCOL"
            /* HTTP header used to handshake the wire protocol */
            #define GIT_PROTOCOL_HEADER "Git-Protocol"

            /*
            * This environment variable is expected to contain a boolean indicating
            * whether we should or should not treat:
            *
            *   GIT_DIR=foo.git git ...
            *
            * as if GIT_WORK_TREE=. was given. It's not expected that users will make use
            * of this, but we use it internally to communicate to sub-processes that we
            * are in a bare repo. If not set, defaults to true.
            */
            #define GIT_IMPLICIT_WORK_TREE_ENVIRONMENT "GIT_IMPLICIT_WORK_TREE"

            #define ALTERNATE_DB_ENVIRONMENT "GIT_ALTERNATE_OBJECT_DIRECTORIES"

            /*
            * Repository-local GIT_* environment variables; these will be cleared
            * when git spawns a sub-process that runs inside another repository.
            * The array is NULL-terminated, which makes it easy to pass in the "env"
            * parameter of a run-command invocation, or to do a simple walk.
            */
            extern const char * const local_repo_env[];

            struct strvec;

            /*
            * Wrapper of getenv() that returns a strdup value. This value is kept
            * in argv to be freed later.
            */
            const char *getenv_safe(struct strvec *argv, const char *name);

            /*
            * Should we print an ellipsis after an abbreviated SHA-1 value
            * when doing diff-raw output or indicating a detached HEAD?
            */
            int print_sha1_ellipsis(void);

            /*
            * Returns the boolean value of $GIT_OPTIONAL_LOCKS (or the default value).
            */
            int use_optional_locks(void);

            const char *get_git_namespace(void);
            const char *strip_namespace(const char *namespaced_ref);

            /*
            * TODO: All the below state either explicitly or implicitly relies on
            * `the_repository`. We should eventually get rid of these and make the
            * dependency on a repository explicit:
            *
            *   - `setup_git_env()` ideally shouldn't exist as it modifies global state,
            *     namely the environment. The current process shouldn't ever access that
            *     state via envvars though, but should instead consult a `struct
            *     repository`. When spawning new processes, we would ideally also pass a
            *     `struct repository` and then set up the environment variables for the
            *     child process, only.
            *
            *   - `have_git_dir()` should not have to exist at all. Instead, we should
            *     decide on whether or not we have a `struct repository`.
            *
            *   - All the global config variables should become tied to a repository. Like
            *     this, we'd correctly honor repository-local configuration and be able to
            *     distinguish configuration values from different repositories.
            *
            * Please do not add new global config variables here.
            */
            # ifdef USE_THE_REPOSITORY_VARIABLE
            void setup_git_env(const char *git_dir);

            /*
            * Returns true iff we have a configured git repository (either via
            * setup_git_directory, or in the environment via $GIT_DIR).
            */
            int have_git_dir(void);

            /*
            * Accessors for the core.sharedrepository config which lazy-load the value
            * from the config (if not already set). The "reset" function can be
            * used to unset "set" or cached value, meaning that the value will be loaded
            * fresh from the config file on the next call to get_shared_repository().
            */
            void set_shared_repository(int value);
            int get_shared_repository(void);
            void reset_shared_repository(void);

            extern int is_bare_repository_cfg;
            int is_bare_repository(void);
            extern char *git_work_tree_cfg;

            /* Environment bits from configuration mechanism */
            extern int trust_executable_bit;
            extern int trust_ctime;
            extern int check_stat;
            extern int has_symlinks;
            extern int minimum_abbrev, default_abbrev;
            extern int ignore_case;
            extern int assume_unchanged;
            extern int warn_on_object_refname_ambiguity;
            extern char *apply_default_whitespace;
            extern char *apply_default_ignorewhitespace;
            extern char *git_attributes_file;
            extern char *git_hooks_path;
            extern int zlib_compression_level;
            extern int pack_compression_level;
            extern size_t packed_git_window_size;
            extern size_t packed_git_limit;
            extern unsigned long big_file_threshold;
            extern unsigned long pack_size_limit_cfg;
            extern int max_allowed_tree_depth;

            extern int core_preload_index;
            extern int precomposed_unicode;
            extern int protect_hfs;
            extern int protect_ntfs;

            extern int core_apply_sparse_checkout;
            extern int core_sparse_checkout_cone;
            extern int sparse_expect_files_outside_of_patterns;

            enum rebase_setup_type {
                    AUTOREBASE_NEVER = 0,
                    AUTOREBASE_LOCAL,
                    AUTOREBASE_REMOTE,
                    AUTOREBASE_ALWAYS
            };
            extern enum rebase_setup_type autorebase;

            enum push_default_type {
                    PUSH_DEFAULT_NOTHING = 0,
                    PUSH_DEFAULT_MATCHING,
                    PUSH_DEFAULT_SIMPLE,
                    PUSH_DEFAULT_UPSTREAM,
                    PUSH_DEFAULT_CURRENT,
                    PUSH_DEFAULT_UNSPECIFIED
            };
            extern enum push_default_type push_default;

            enum object_creation_mode {
                    OBJECT_CREATION_USES_HARDLINKS = 0,
                    OBJECT_CREATION_USES_RENAMES = 1
            };
            extern enum object_creation_mode object_creation_mode;

            extern int grafts_keep_true_parents;

            extern int repository_format_precious_objects;

            const char *get_log_output_encoding(void);
            const char *get_commit_output_encoding(void);

            extern char *git_commit_encoding;
            extern char *git_log_output_encoding;

            extern char *editor_program;
            extern char *askpass_program;
            extern char *excludes_file;

            /*
            * The character that begins a commented line in user-editable file
            * that is subject to stripspace.
            */
            extern const char *comment_line_str;
            extern char *comment_line_str_to_free;
            extern int auto_comment_line_char;

            # endif /* USE_THE_REPOSITORY_VARIABLE */
            #endif /* ENVIRONMENT_H */
       """,
       "Error":"The patch ensures that utf8_ccsid is properly declared for z/OS, making the character encoding
                    configuration available throughout the code. This improves Gits
                    compatibility with z/OS and ensures files are handled correctly with respect to their encoding.",
       "error category":"Functionality patch",
       "Corrected Code":
       """
                    #ifndef ENVIRONMENT_H
            #define ENVIRONMENT_H

            #include "repo-settings.h"

            /* Double-check local_repo_env below if you add to this list. */
            #define GIT_DIR_ENVIRONMENT "GIT_DIR"
            #define GIT_COMMON_DIR_ENVIRONMENT "GIT_COMMON_DIR"
            #define GIT_NAMESPACE_ENVIRONMENT "GIT_NAMESPACE"
            #define GIT_WORK_TREE_ENVIRONMENT "GIT_WORK_TREE"
            #define GIT_PREFIX_ENVIRONMENT "GIT_PREFIX"
            #define DEFAULT_GIT_DIR_ENVIRONMENT ".git"
            #define DB_ENVIRONMENT "GIT_OBJECT_DIRECTORY"
            #define INDEX_ENVIRONMENT "GIT_INDEX_FILE"
            #define GRAFT_ENVIRONMENT "GIT_GRAFT_FILE"
            #define GIT_SHALLOW_FILE_ENVIRONMENT "GIT_SHALLOW_FILE"
            #define TEMPLATE_DIR_ENVIRONMENT "GIT_TEMPLATE_DIR"
            #define CONFIG_ENVIRONMENT "GIT_CONFIG"
            #define CONFIG_DATA_ENVIRONMENT "GIT_CONFIG_PARAMETERS"
            #define CONFIG_COUNT_ENVIRONMENT "GIT_CONFIG_COUNT"
            #define EXEC_PATH_ENVIRONMENT "GIT_EXEC_PATH"
            #define CEILING_DIRECTORIES_ENVIRONMENT "GIT_CEILING_DIRECTORIES"
            #define NO_REPLACE_OBJECTS_ENVIRONMENT "GIT_NO_REPLACE_OBJECTS"
            #define GIT_REPLACE_REF_BASE_ENVIRONMENT "GIT_REPLACE_REF_BASE"
            #define NO_LAZY_FETCH_ENVIRONMENT "GIT_NO_LAZY_FETCH"
            #define GITATTRIBUTES_FILE ".gitattributes"
            #define INFOATTRIBUTES_FILE "info/attributes"
            #define ATTRIBUTE_MACRO_PREFIX "[attr]"
            #define GITMODULES_FILE ".gitmodules"
            #define GITMODULES_INDEX ":.gitmodules"
            #define GITMODULES_HEAD "HEAD:.gitmodules"
            #define GIT_NOTES_REF_ENVIRONMENT "GIT_NOTES_REF"
            #define GIT_NOTES_DEFAULT_REF "refs/notes/commits"
            #define GIT_NOTES_DISPLAY_REF_ENVIRONMENT "GIT_NOTES_DISPLAY_REF"
            #define GIT_NOTES_REWRITE_REF_ENVIRONMENT "GIT_NOTES_REWRITE_REF"
            #define GIT_NOTES_REWRITE_MODE_ENVIRONMENT "GIT_NOTES_REWRITE_MODE"
            #define GIT_LITERAL_PATHSPECS_ENVIRONMENT "GIT_LITERAL_PATHSPECS"
            #define GIT_GLOB_PATHSPECS_ENVIRONMENT "GIT_GLOB_PATHSPECS"
            #define GIT_NOGLOB_PATHSPECS_ENVIRONMENT "GIT_NOGLOB_PATHSPECS"
            #define GIT_ICASE_PATHSPECS_ENVIRONMENT "GIT_ICASE_PATHSPECS"
            #define GIT_QUARANTINE_ENVIRONMENT "GIT_QUARANTINE_PATH"
            #define GIT_OPTIONAL_LOCKS_ENVIRONMENT "GIT_OPTIONAL_LOCKS"
            #define GIT_TEXT_DOMAIN_DIR_ENVIRONMENT "GIT_TEXTDOMAINDIR"
            #define GIT_ATTR_SOURCE_ENVIRONMENT "GIT_ATTR_SOURCE"

            /*
            * Environment variable used to propagate the --no-advice global option to the
            * advice_enabled() helper, even when run in a subprocess.
            * This is an internal variable that should not be set by the user.
            */
            #define GIT_ADVICE_ENVIRONMENT "GIT_ADVICE"

            /*
            * Environment variable used in handshaking the wire protocol.
            * Contains a colon ':' separated list of keys with optional values
            * 'key[=value]'.  Presence of unknown keys and values must be
            * ignored.
            */
            #define GIT_PROTOCOL_ENVIRONMENT "GIT_PROTOCOL"
            /* HTTP header used to handshake the wire protocol */
            #define GIT_PROTOCOL_HEADER "Git-Protocol"

            /*
            * This environment variable is expected to contain a boolean indicating
            * whether we should or should not treat:
            *
            *   GIT_DIR=foo.git git ...
            *
            * as if GIT_WORK_TREE=. was given. It's not expected that users will make use
            * of this, but we use it internally to communicate to sub-processes that we
            * are in a bare repo. If not set, defaults to true.
            */
            #define GIT_IMPLICIT_WORK_TREE_ENVIRONMENT "GIT_IMPLICIT_WORK_TREE"

            #define ALTERNATE_DB_ENVIRONMENT "GIT_ALTERNATE_OBJECT_DIRECTORIES"

            /*
            * Repository-local GIT_* environment variables; these will be cleared
            * when git spawns a sub-process that runs inside another repository.
            * The array is NULL-terminated, which makes it easy to pass in the "env"
            * parameter of a run-command invocation, or to do a simple walk.
            */
            extern const char * const local_repo_env[];

            struct strvec;

            /*
            * Wrapper of getenv() that returns a strdup value. This value is kept
            * in argv to be freed later.
            */
            const char *getenv_safe(struct strvec *argv, const char *name);

            /*
            * Should we print an ellipsis after an abbreviated SHA-1 value
            * when doing diff-raw output or indicating a detached HEAD?
            */
            int print_sha1_ellipsis(void);

            /*
            * Returns the boolean value of $GIT_OPTIONAL_LOCKS (or the default value).
            */
            int use_optional_locks(void);

            const char *get_git_namespace(void);
            const char *strip_namespace(const char *namespaced_ref);

            /*
            * TODO: All the below state either explicitly or implicitly relies on
            * `the_repository`. We should eventually get rid of these and make the
            * dependency on a repository explicit:
            *
            *   - `setup_git_env()` ideally shouldn't exist as it modifies global state,
            *     namely the environment. The current process shouldn't ever access that
            *     state via envvars though, but should instead consult a `struct
            *     repository`. When spawning new processes, we would ideally also pass a
            *     `struct repository` and then set up the environment variables for the
            *     child process, only.
            *
            *   - `have_git_dir()` should not have to exist at all. Instead, we should
            *     decide on whether or not we have a `struct repository`.
            *
            *   - All the global config variables should become tied to a repository. Like
            *     this, we'd correctly honor repository-local configuration and be able to
            *     distinguish configuration values from different repositories.
            *
            * Please do not add new global config variables here.
            */
            # ifdef USE_THE_REPOSITORY_VARIABLE
            void setup_git_env(const char *git_dir);

            /*
            * Returns true iff we have a configured git repository (either via
            * setup_git_directory, or in the environment via $GIT_DIR).
            */
            int have_git_dir(void);

            /*
            * Accessors for the core.sharedrepository config which lazy-load the value
            * from the config (if not already set). The "reset" function can be
            * used to unset "set" or cached value, meaning that the value will be loaded
            * fresh from the config file on the next call to get_shared_repository().
            */
            void set_shared_repository(int value);
            int get_shared_repository(void);
            void reset_shared_repository(void);

            extern int is_bare_repository_cfg;
            int is_bare_repository(void);
            extern char *git_work_tree_cfg;

            /* Environment bits from configuration mechanism */
            extern int trust_executable_bit;
            extern int trust_ctime;
            extern int check_stat;
            extern int has_symlinks;
            extern int minimum_abbrev, default_abbrev;
            extern int ignore_case;
            extern int assume_unchanged;
            extern int warn_on_object_refname_ambiguity;
            extern char *apply_default_whitespace;
            extern char *apply_default_ignorewhitespace;
            extern char *git_attributes_file;
            extern char *git_hooks_path;
            extern int zlib_compression_level;
            extern int pack_compression_level;
            extern size_t packed_git_window_size;
            extern size_t packed_git_limit;
            extern unsigned long big_file_threshold;
            extern unsigned long pack_size_limit_cfg;
            extern int max_allowed_tree_depth;
            #ifdef __MVS__
            extern int utf8_ccsid;
            #endif
            extern int core_preload_index;
            extern int precomposed_unicode;
            extern int protect_hfs;
            extern int protect_ntfs;

            extern int core_apply_sparse_checkout;
            extern int core_sparse_checkout_cone;
            extern int sparse_expect_files_outside_of_patterns;

            enum rebase_setup_type {
                    AUTOREBASE_NEVER = 0,
                    AUTOREBASE_LOCAL,
                    AUTOREBASE_REMOTE,
                    AUTOREBASE_ALWAYS
            };
            extern enum rebase_setup_type autorebase;

            enum push_default_type {
                    PUSH_DEFAULT_NOTHING = 0,
                    PUSH_DEFAULT_MATCHING,
                    PUSH_DEFAULT_SIMPLE,
                    PUSH_DEFAULT_UPSTREAM,
                    PUSH_DEFAULT_CURRENT,
                    PUSH_DEFAULT_UNSPECIFIED
            };
            extern enum push_default_type push_default;

            enum object_creation_mode {
                    OBJECT_CREATION_USES_HARDLINKS = 0,
                    OBJECT_CREATION_USES_RENAMES = 1
            };
            extern enum object_creation_mode object_creation_mode;

            extern int grafts_keep_true_parents;

            extern int repository_format_precious_objects;

            const char *get_log_output_encoding(void);
            const char *get_commit_output_encoding(void);

            extern char *git_commit_encoding;
            extern char *git_log_output_encoding;

            extern char *editor_program;
            extern char *askpass_program;
            extern char *excludes_file;

            /*
            * The character that begins a commented line in user-editable file
            * that is subject to stripspace.
            */
            extern const char *comment_line_str;
            extern char *comment_line_str_to_free;
            extern int auto_comment_line_char;

            # endif /* USE_THE_REPOSITORY_VARIABLE */
            #endif /* ENVIRONMENT_H */

       """,
       "patches":
       """
                    diff --git a/environment.h b/environment.h
            index 923e12661e..ed3a77ae84 100644
            --- a/environment.h
            +++ b/environment.h
            @@ -169,7 +169,9 @@ extern size_t delta_base_cache_limit;
            extern unsigned long big_file_threshold;
            extern unsigned long pack_size_limit_cfg;
            extern int max_allowed_tree_depth;
            -
            +#ifdef __MVS__
            +extern int utf8_ccsid;
            +#endif
            extern int core_preload_index;
            extern int precomposed_unicode;
            extern int protect_hfs;

       """,
            },

       {
            "wrong code":
            """
                            #include "git-compat-util.h"
            #include "abspath.h"
            #include "environment.h"
            #include "exec-cmd.h"
            #include "gettext.h"
            #include "path.h"
            #include "run-command.h"
            #include "strvec.h"
            #include "trace.h"
            #include "trace2.h"

            #if defined(RUNTIME_PREFIX)

            #if defined(HAVE_NS_GET_EXECUTABLE_PATH)
            #include <mach-o/dyld.h>
            #endif

            #if defined(HAVE_BSD_KERN_PROC_SYSCTL)
            #include <sys/param.h>
            #include <sys/types.h>
            #include <sys/sysctl.h>
            #endif

            #endif /* RUNTIME_PREFIX */

            #define MAX_ARGS 32

            static const char *system_prefix(void);

            #ifdef RUNTIME_PREFIX

            /**
            * When using a runtime prefix, Git dynamically resolves paths relative to its
            * executable.
            *
            * The method for determining the path of the executable is highly
            * platform-specific.
            */

            /**
            * Path to the current Git executable. Resolved on startup by
            * 'git_resolve_executable_dir'.
            */
            static const char *executable_dirname;

            static const char *system_prefix(void)
            {
                    static const char *prefix;

                    assert(executable_dirname);
                    assert(is_absolute_path(executable_dirname));

                    if (!prefix &&
                    !(prefix = strip_path_suffix(executable_dirname, GIT_EXEC_PATH)) &&
                    !(prefix = strip_path_suffix(executable_dirname, BINDIR)) &&
                    !(prefix = strip_path_suffix(executable_dirname, "git"))) {
                            prefix = FALLBACK_RUNTIME_PREFIX;
                            trace_printf("RUNTIME_PREFIX requested, "
                                            "but prefix computation failed.  "
                                            "Using static fallback '%s'.\n", prefix);
                    }
                    return prefix;
            }

            /*
            * Resolves the executable path from argv[0], only if it is absolute.
            *
            * Returns 0 on success, -1 on failure.
            */
            static int git_get_exec_path_from_argv0(struct strbuf *buf, const char *argv0)
            {
                    const char *slash;

                    if (!argv0 || !*argv0)
                            return -1;

                    slash = find_last_dir_sep(argv0);
                    if (slash) {
                            trace_printf("trace: resolved executable path from argv0: %s\n",
                                    argv0);
                            strbuf_add_absolute_path(buf, argv0);
                            return 0;
                    }
                    return -1;
            }

            #ifdef PROCFS_EXECUTABLE_PATH
            /*
            * Resolves the executable path by examining a procfs symlink.
            *
            * Returns 0 on success, -1 on failure.
            */
            static int git_get_exec_path_procfs(struct strbuf *buf)
            {
                    if (strbuf_realpath(buf, PROCFS_EXECUTABLE_PATH, 0)) {
                            trace_printf(
                                    "trace: resolved executable path from procfs: %s\n",
                                    buf->buf);
                            return 0;
                    }
                    return -1;
            }
            #endif /* PROCFS_EXECUTABLE_PATH */

            #ifdef HAVE_BSD_KERN_PROC_SYSCTL
            /*
            * Resolves the executable path using KERN_PROC_PATHNAME BSD sysctl.
            *
            * Returns 0 on success, -1 on failure.
            */
            static int git_get_exec_path_bsd_sysctl(struct strbuf *buf)
            {
                    int mib[4];
                    char path[MAXPATHLEN];
                    size_t cb = sizeof(path);

                    mib[0] = CTL_KERN;
                    mib[1] = KERN_PROC;
                    mib[2] = KERN_PROC_PATHNAME;
                    mib[3] = -1;
                    if (!sysctl(mib, 4, path, &cb, NULL, 0)) {
                            trace_printf(
                                    "trace: resolved executable path from sysctl: %s\n",
                                    path);
                            strbuf_addstr(buf, path);
                            return 0;
                    }
                    return -1;
            }
            #endif /* HAVE_BSD_KERN_PROC_SYSCTL */

            #ifdef HAVE_NS_GET_EXECUTABLE_PATH
            /*
            * Resolves the executable path by querying Darwin application stack.
            *
            * Returns 0 on success, -1 on failure.
            */
            static int git_get_exec_path_darwin(struct strbuf *buf)
            {
                    char path[PATH_MAX];
                    uint32_t size = sizeof(path);
                    if (!_NSGetExecutablePath(path, &size)) {
                            trace_printf(
                                    "trace: resolved executable path from Darwin stack: %s\n",
                                    path);
                            strbuf_addstr(buf, path);
                            return 0;
                    }
                    return -1;
            }
            #endif /* HAVE_NS_GET_EXECUTABLE_PATH */

            #ifdef HAVE_ZOS_GET_EXECUTABLE_PATH
            /*
            * Resolves the executable path from current program's directory and name.
            *
            * Returns 0 on success, -1 on failure.
            */
            static int git_get_exec_path_zos(struct strbuf *buf)
            {
                    char *dir = __getprogramdir();
                    char *exe = getprogname();
                    if (dir && exe) {
                            strbuf_addf(buf, "%s/%s", dir, exe);
                            return 0;
                    }
                    return -1;
            }

            #endif /* HAVE_ZOS_GET_EXECUTABLE_PATH */

            #ifdef HAVE_WPGMPTR
            /*
            * Resolves the executable path by using the global variable _wpgmptr.
            *
            * Returns 0 on success, -1 on failure.
            */
            static int git_get_exec_path_wpgmptr(struct strbuf *buf)
            {
                    int len = wcslen(_wpgmptr) * 3 + 1;
                    strbuf_grow(buf, len);
                    len = xwcstoutf(buf->buf, _wpgmptr, len);
                    if (len < 0)
                            return -1;
                    buf->len += len;
                    return 0;
            }
            #endif /* HAVE_WPGMPTR */

            /*
            * Resolves the absolute path of the current executable.
            *
            * Returns 0 on success, -1 on failure.
            */
            static int git_get_exec_path(struct strbuf *buf, const char *argv0)
            {
                    /*
                    * Identifying the executable path is operating system specific.
                    * Selectively employ all available methods in order of preference,
                    * preferring highly-available authoritative methods over
                    * selectively-available or non-authoritative methods.
                    *
                    * All cases fall back on resolving against argv[0] if there isn't a
                    * better functional method. However, note that argv[0] can be
                    * used-supplied on many operating systems, and is not authoritative
                    * in those cases.
                    *
                    * Each of these functions returns 0 on success, so evaluation will stop
                    * after the first successful method.
                    */
                    if (
            #ifdef HAVE_BSD_KERN_PROC_SYSCTL
                            git_get_exec_path_bsd_sysctl(buf) &&
            #endif /* HAVE_BSD_KERN_PROC_SYSCTL */

            #ifdef HAVE_NS_GET_EXECUTABLE_PATH
                            git_get_exec_path_darwin(buf) &&
            #endif /* HAVE_NS_GET_EXECUTABLE_PATH */

            #ifdef PROCFS_EXECUTABLE_PATH
                            git_get_exec_path_procfs(buf) &&
            #endif /* PROCFS_EXECUTABLE_PATH */

            #ifdef HAVE_WPGMPTR
                            git_get_exec_path_wpgmptr(buf) &&
            #endif /* HAVE_WPGMPTR */

            #ifdef HAVE_ZOS_GET_EXECUTABLE_PATH
                            git_get_exec_path_zos(buf) &&
            #endif /*HAVE_ZOS_GET_EXECUTABLE_PATH */

                            git_get_exec_path_from_argv0(buf, argv0)) {
                            return -1;
                    }

                    if (strbuf_normalize_path(buf)) {
                            trace_printf("trace: could not normalize path: %s\n", buf->buf);
                            return -1;
                    }

                    trace2_cmd_path(buf->buf);

                    return 0;
            }

            void git_resolve_executable_dir(const char *argv0)
            {
                    struct strbuf buf = STRBUF_INIT;
                    char *resolved;
                    const char *slash;

                    if (git_get_exec_path(&buf, argv0)) {
                            trace_printf(
                                    "trace: could not determine executable path from: %s\n",
                                    argv0);
                            strbuf_release(&buf);
                            return;
                    }

                    resolved = strbuf_detach(&buf, NULL);
                    slash = find_last_dir_sep(resolved);
                    if (slash)
                            resolved[slash - resolved] = '\0';

                    executable_dirname = resolved;
                    trace_printf("trace: resolved executable dir: %s\n",
                            executable_dirname);
            }

            #else

            /*
            * When not using a runtime prefix, Git uses a hard-coded path.
            */
            static const char *system_prefix(void)
            {
                    return FALLBACK_RUNTIME_PREFIX;
            }

            /*
            * This is called during initialization, but No work needs to be done here when
            * runtime prefix is not being used.
            */
            void git_resolve_executable_dir(const char *argv0 UNUSED)
            {
            }

            #endif /* RUNTIME_PREFIX */

            char *system_path(const char *path)
            {
                    struct strbuf d = STRBUF_INIT;

                    if (is_absolute_path(path))
                            return xstrdup(path);

                    strbuf_addf(&d, "%s/%s", system_prefix(), path);
                    return strbuf_detach(&d, NULL);
            }

            static const char *exec_path_value;

            void git_set_exec_path(const char *exec_path)
            {
                    exec_path_value = exec_path;
                    /*
                    * Propagate this setting to external programs.
                    */
                    setenv(EXEC_PATH_ENVIRONMENT, exec_path, 1);
            }

            /* Returns the highest-priority location to look for git programs. */
            const char *git_exec_path(void)
            {
                    if (!exec_path_value) {
                            const char *env = getenv(EXEC_PATH_ENVIRONMENT);
                            if (env && *env)
                                    exec_path_value = xstrdup(env);
                            else
                                    exec_path_value = system_path(GIT_EXEC_PATH);
                    }
                    return exec_path_value;
            }

            static void add_path(struct strbuf *out, const char *path)
            {
                    if (path && *path) {
                            strbuf_add_absolute_path(out, path);
                            strbuf_addch(out, PATH_SEP);
                    }
            }

            void setup_path(void)
            {
                    const char *exec_path = git_exec_path();
                    const char *old_path = getenv("PATH");
                    struct strbuf new_path = STRBUF_INIT;

                    git_set_exec_path(exec_path);
                    add_path(&new_path, exec_path);

                    if (old_path)
                            strbuf_addstr(&new_path, old_path);
                    else
                            strbuf_addstr(&new_path, _PATH_DEFPATH);

                    setenv("PATH", new_path.buf, 1);

                    strbuf_release(&new_path);
            }

            const char **prepare_git_cmd(struct strvec *out, const char **argv)
            {
                    strvec_push(out, "git");
                    strvec_pushv(out, argv);
                    return out->v;
            }

            int execv_git_cmd(const char **argv)
            {
                    struct strvec nargv = STRVEC_INIT;

                    prepare_git_cmd(&nargv, argv);
                    trace_argv_printf(nargv.v, "trace: exec:");

                    /* execvp() can only ever return if it fails */
                    sane_execvp("git", (char **)nargv.v);

                    trace_printf("trace: exec failed: %s\n", strerror(errno));

                    strvec_clear(&nargv);
                    return -1;
            }

            int execl_git_cmd(const char *cmd, ...)
            {
                    int argc;
                    const char *argv[MAX_ARGS + 1];
                    const char *arg;
                    va_list param;

                    va_start(param, cmd);
                    argv[0] = cmd;
                    argc = 1;
                    while (argc < MAX_ARGS) {
                            arg = argv[argc++] = va_arg(param, char *);
                            if (!arg)
                                    break;
                    }
                    va_end(param);
                    if (MAX_ARGS <= argc)
                            return error(_("too many args to run %s"), cmd);

                    argv[argc] = NULL;
                    return execv_git_cmd(argv);
            }

            """,
            "Error":"The use of volatile ensures that the dir and exe variables are always correctly read from memory,
                     preventing optimization issues and ensuring that the executable path is constructed correctly on z/OS. ",
            "error category":"Functionality patch",
            "Corrected code":

            """
                            #include "git-compat-util.h"
            #include "abspath.h"
            #include "environment.h"
            #include "exec-cmd.h"
            #include "gettext.h"
            #include "path.h"
            #include "run-command.h"
            #include "strvec.h"
            #include "trace.h"
            #include "trace2.h"

            #if defined(RUNTIME_PREFIX)

            #if defined(HAVE_NS_GET_EXECUTABLE_PATH)
            #include <mach-o/dyld.h>
            #endif

            #if defined(HAVE_BSD_KERN_PROC_SYSCTL)
            #include <sys/param.h>
            #include <sys/types.h>
            #include <sys/sysctl.h>
            #endif

            #endif /* RUNTIME_PREFIX */

            #define MAX_ARGS 32

            static const char *system_prefix(void);

            #ifdef RUNTIME_PREFIX

            /**
            * When using a runtime prefix, Git dynamically resolves paths relative to its
            * executable.
            *
            * The method for determining the path of the executable is highly
            * platform-specific.
            */

            /**
            * Path to the current Git executable. Resolved on startup by
            * 'git_resolve_executable_dir'.
            */
            static const char *executable_dirname;

            static const char *system_prefix(void)
            {
                    static const char *prefix;

                    assert(executable_dirname);
                    assert(is_absolute_path(executable_dirname));

                    if (!prefix &&
                    !(prefix = strip_path_suffix(executable_dirname, GIT_EXEC_PATH)) &&
                    !(prefix = strip_path_suffix(executable_dirname, BINDIR)) &&
                    !(prefix = strip_path_suffix(executable_dirname, "git"))) {
                            prefix = FALLBACK_RUNTIME_PREFIX;
                            trace_printf("RUNTIME_PREFIX requested, "
                                            "but prefix computation failed.  "
                                            "Using static fallback '%s'.\n", prefix);
                    }
                    return prefix;
            }

            /*
            * Resolves the executable path from argv[0], only if it is absolute.
            *
            * Returns 0 on success, -1 on failure.
            */
            static int git_get_exec_path_from_argv0(struct strbuf *buf, const char *argv0)
            {
                    const char *slash;

                    if (!argv0 || !*argv0)
                            return -1;

                    slash = find_last_dir_sep(argv0);
                    if (slash) {
                            trace_printf("trace: resolved executable path from argv0: %s\n",
                                    argv0);
                            strbuf_add_absolute_path(buf, argv0);
                            return 0;
                    }
                    return -1;
            }

            #ifdef PROCFS_EXECUTABLE_PATH
            /*
            * Resolves the executable path by examining a procfs symlink.
            *
            * Returns 0 on success, -1 on failure.
            */
            static int git_get_exec_path_procfs(struct strbuf *buf)
            {
                    if (strbuf_realpath(buf, PROCFS_EXECUTABLE_PATH, 0)) {
                            trace_printf(
                                    "trace: resolved executable path from procfs: %s\n",
                                    buf->buf);
                            return 0;
                    }
                    return -1;
            }
            #endif /* PROCFS_EXECUTABLE_PATH */

            #ifdef HAVE_BSD_KERN_PROC_SYSCTL
            /*
            * Resolves the executable path using KERN_PROC_PATHNAME BSD sysctl.
            *
            * Returns 0 on success, -1 on failure.
            */
            static int git_get_exec_path_bsd_sysctl(struct strbuf *buf)
            {
                    int mib[4];
                    char path[MAXPATHLEN];
                    size_t cb = sizeof(path);

                    mib[0] = CTL_KERN;
                    mib[1] = KERN_PROC;
                    mib[2] = KERN_PROC_PATHNAME;
                    mib[3] = -1;
                    if (!sysctl(mib, 4, path, &cb, NULL, 0)) {
                            trace_printf(
                                    "trace: resolved executable path from sysctl: %s\n",
                                    path);
                            strbuf_addstr(buf, path);
                            return 0;
                    }
                    return -1;
            }
            #endif /* HAVE_BSD_KERN_PROC_SYSCTL */

            #ifdef HAVE_NS_GET_EXECUTABLE_PATH
            /*
            * Resolves the executable path by querying Darwin application stack.
            *
            * Returns 0 on success, -1 on failure.
            */
            static int git_get_exec_path_darwin(struct strbuf *buf)
            {
                    char path[PATH_MAX];
                    uint32_t size = sizeof(path);
                    if (!_NSGetExecutablePath(path, &size)) {
                            trace_printf(
                                    "trace: resolved executable path from Darwin stack: %s\n",
                                    path);
                            strbuf_addstr(buf, path);
                            return 0;
                    }
                    return -1;
            }
            #endif /* HAVE_NS_GET_EXECUTABLE_PATH */

            #ifdef HAVE_ZOS_GET_EXECUTABLE_PATH
            /*
            * Resolves the executable path from current program's directory and name.
            *
            * Returns 0 on success, -1 on failure.
            */
            static int git_get_exec_path_zos(struct strbuf *buf)
            {
                    volatile char * volatile dir = __getprogramdir();
                    volatile char * volatile exe = getprogname();
                    if (dir && exe) {
                            strbuf_addf(buf, "%s/%s", dir, exe);
                            return 0;
                    }
                    return -1;
            }

            #endif /* HAVE_ZOS_GET_EXECUTABLE_PATH */

            #ifdef HAVE_WPGMPTR
            /*
            * Resolves the executable path by using the global variable _wpgmptr.
            *
            * Returns 0 on success, -1 on failure.
            */
            static int git_get_exec_path_wpgmptr(struct strbuf *buf)
            {
                    int len = wcslen(_wpgmptr) * 3 + 1;
                    strbuf_grow(buf, len);
                    len = xwcstoutf(buf->buf, _wpgmptr, len);
                    if (len < 0)
                            return -1;
                    buf->len += len;
                    return 0;
            }
            #endif /* HAVE_WPGMPTR */

            /*
            * Resolves the absolute path of the current executable.
            *
            * Returns 0 on success, -1 on failure.
            */
            static int git_get_exec_path(struct strbuf *buf, const char *argv0)
            {
                    /*
                    * Identifying the executable path is operating system specific.
                    * Selectively employ all available methods in order of preference,
                    * preferring highly-available authoritative methods over
                    * selectively-available or non-authoritative methods.
                    *
                    * All cases fall back on resolving against argv[0] if there isn't a
                    * better functional method. However, note that argv[0] can be
                    * used-supplied on many operating systems, and is not authoritative
                    * in those cases.
                    *
                    * Each of these functions returns 0 on success, so evaluation will stop
                    * after the first successful method.
                    */
                    if (
            #ifdef HAVE_BSD_KERN_PROC_SYSCTL
                            git_get_exec_path_bsd_sysctl(buf) &&
            #endif /* HAVE_BSD_KERN_PROC_SYSCTL */

            #ifdef HAVE_NS_GET_EXECUTABLE_PATH
                            git_get_exec_path_darwin(buf) &&
            #endif /* HAVE_NS_GET_EXECUTABLE_PATH */

            #ifdef PROCFS_EXECUTABLE_PATH
                            git_get_exec_path_procfs(buf) &&
            #endif /* PROCFS_EXECUTABLE_PATH */

            #ifdef HAVE_WPGMPTR
                            git_get_exec_path_wpgmptr(buf) &&
            #endif /* HAVE_WPGMPTR */

            #ifdef HAVE_ZOS_GET_EXECUTABLE_PATH
                            git_get_exec_path_zos(buf) &&
            #endif /*HAVE_ZOS_GET_EXECUTABLE_PATH */

                            git_get_exec_path_from_argv0(buf, argv0)) {
                            return -1;
                    }

                    if (strbuf_normalize_path(buf)) {
                            trace_printf("trace: could not normalize path: %s\n", buf->buf);
                            return -1;
                    }

                    trace2_cmd_path(buf->buf);

                    return 0;
            }

            void git_resolve_executable_dir(const char *argv0)
            {
                    struct strbuf buf = STRBUF_INIT;
                    char *resolved;
                    const char *slash;

                    if (git_get_exec_path(&buf, argv0)) {
                            trace_printf(
                                    "trace: could not determine executable path from: %s\n",
                                    argv0);
                            strbuf_release(&buf);
                            return;
                    }

                    resolved = strbuf_detach(&buf, NULL);
                    slash = find_last_dir_sep(resolved);
                    if (slash)
                            resolved[slash - resolved] = '\0';

                    executable_dirname = resolved;
                    trace_printf("trace: resolved executable dir: %s\n",
                            executable_dirname);
            }

            #else

            /*
            * When not using a runtime prefix, Git uses a hard-coded path.
            */
            static const char *system_prefix(void)
            {
                    return FALLBACK_RUNTIME_PREFIX;
            }

            /*
            * This is called during initialization, but No work needs to be done here when
            * runtime prefix is not being used.
            */
            void git_resolve_executable_dir(const char *argv0 UNUSED)
            {
            }

            #endif /* RUNTIME_PREFIX */

            char *system_path(const char *path)
            {
                    struct strbuf d = STRBUF_INIT;

                    if (is_absolute_path(path))
                            return xstrdup(path);

                    strbuf_addf(&d, "%s/%s", system_prefix(), path);
                    return strbuf_detach(&d, NULL);
            }

            static const char *exec_path_value;

            void git_set_exec_path(const char *exec_path)
            {
                    exec_path_value = exec_path;
                    /*
                    * Propagate this setting to external programs.
                    */
                    setenv(EXEC_PATH_ENVIRONMENT, exec_path, 1);
            }

            /* Returns the highest-priority location to look for git programs. */
            const char *git_exec_path(void)
            {
                    if (!exec_path_value) {
                            const char *env = getenv(EXEC_PATH_ENVIRONMENT);
                            if (env && *env)
                                    exec_path_value = xstrdup(env);
                            else
                                    exec_path_value = system_path(GIT_EXEC_PATH);
                    }
                    return exec_path_value;
            }

            static void add_path(struct strbuf *out, const char *path)
            {
                    if (path && *path) {
                            strbuf_add_absolute_path(out, path);
                            strbuf_addch(out, PATH_SEP);
                    }
            }

            void setup_path(void)
            {
                    const char *exec_path = git_exec_path();
                    const char *old_path = getenv("PATH");
                    struct strbuf new_path = STRBUF_INIT;

                    git_set_exec_path(exec_path);
                    add_path(&new_path, exec_path);

                    if (old_path)
                            strbuf_addstr(&new_path, old_path);
                    else
                            strbuf_addstr(&new_path, _PATH_DEFPATH);

                    setenv("PATH", new_path.buf, 1);

                    strbuf_release(&new_path);
            }

            const char **prepare_git_cmd(struct strvec *out, const char **argv)
            {
                    strvec_push(out, "git");
                    strvec_pushv(out, argv);
                    return out->v;
            }

            int execv_git_cmd(const char **argv)
            {
                    struct strvec nargv = STRVEC_INIT;

                    prepare_git_cmd(&nargv, argv);
                    trace_argv_printf(nargv.v, "trace: exec:");

                    /* execvp() can only ever return if it fails */
                    sane_execvp("git", (char **)nargv.v);

                    trace_printf("trace: exec failed: %s\n", strerror(errno));

                    strvec_clear(&nargv);
                    return -1;
            }

            int execl_git_cmd(const char *cmd, ...)
            {
                    int argc;
                    const char *argv[MAX_ARGS + 1];
                    const char *arg;
                    va_list param;

                    va_start(param, cmd);
                    argv[0] = cmd;
                    argc = 1;
                    while (argc < MAX_ARGS) {
                            arg = argv[argc++] = va_arg(param, char *);
                            if (!arg)
                                    break;
                    }
                    va_end(param);
                    if (MAX_ARGS <= argc)
                            return error(_("too many args to run %s"), cmd);

                    argv[argc] = NULL;
                    return execv_git_cmd(argv);
            }

            """,

            "Patche":
            """
                            diff --git a/exec-cmd.c b/exec-cmd.c
            index 507e67d528..494abf8cc2 100644
            --- a/exec-cmd.c
            +++ b/exec-cmd.c
            @@ -158,8 +158,8 @@ static int git_get_exec_path_darwin(struct strbuf *buf)
            */
            static int git_get_exec_path_zos(struct strbuf *buf)
            {
            -   char *dir = __getprogramdir();
            -   char *exe = getprogname();
            +   volatile char * volatile dir = __getprogramdir();
            +   volatile char * volatile exe = getprogname();
                    if (dir && exe) {
                            strbuf_addf(buf, "%s/%s", dir, exe);
                            return 0;


            """,

              },

    {
              "wrongcode":

              """
             #!/bin/sh

            set -e

            if test $# -ne 5
            then
                    echo >&2 "USAGE: $0 <GIT_BUILD_OPTIONS> <GIT_VERSION_FILE> <PERL_HEADER> <INPUT> <OUTPUT>"
                    exit 1
            fi

            GIT_BUILD_OPTIONS="$1"
            GIT_VERSION_FILE="$2"
            PERL_HEADER="$3"
            INPUT="$4"
            OUTPUT="$5"

            . "$GIT_BUILD_OPTIONS"
            . "$GIT_VERSION_FILE"

            sed -e '1{' \
            -e "        /^#!.*perl/!b" \
            -e "        s|#!.*perl|#!$PERL_PATH|" \
            -e "        r $PERL_HEADER" \
            -e '        G' \
            -e '}' \
            -e "s|@GIT_VERSION@|$GIT_VERSION|g" \
            -e "s|@LOCALEDIR@|$PERL_LOCALEDIR|g" \
            -e "s|@NO_GETTEXT@|$NO_GETTEXT|g" \
            -e "s|@NO_PERL_CPAN_FALLBACKS@|$NO_PERL_CPAN_FALLBACKS|g" \
            "$INPUT" >"$OUTPUT"

            case "$INPUT" in
            *.perl)
                    chmod a+x "$OUTPUT";;
            *)
                    ;;
            esac

              """,

              "error":"The patch allows the Perl scripts to have a shebang line that works on platforms where the default $PERL_PATH is unsuitable.
                     This ensures that the scripts execute correctly and that the build process and other operations relying on these scripts function as expected."
              "error Category":"Functionality patch",
              "Corrected Code":
              """
                            #!/bin/sh

            set -e

            if test $# -ne 5
            then
                    echo >&2 "USAGE: $0 <GIT_BUILD_OPTIONS> <GIT_VERSION_FILE> <PERL_HEADER> <INPUT> <OUTPUT>"
                    exit 1
            fi

            GIT_BUILD_OPTIONS="$1"
            GIT_VERSION_FILE="$2"
            PERL_HEADER="$3"
            INPUT="$4"
            OUTPUT="$5"

            . "$GIT_BUILD_OPTIONS"
            . "$GIT_VERSION_FILE"

            sed -e '1{' \
            -e "        /^#!.*perl/!b" \
            -e "        s|#!.*perl|#!$PERL_PATH_FOR_SCRIPTS|" \
            -e "        r $PERL_HEADER" \
            -e '        G' \
            -e '}' \
            -e "s|@GIT_VERSION@|$GIT_VERSION|g" \
            -e "s|@LOCALEDIR@|$PERL_LOCALEDIR|g" \
            -e "s|@NO_GETTEXT@|$NO_GETTEXT|g" \
            -e "s|@NO_PERL_CPAN_FALLBACKS@|$NO_PERL_CPAN_FALLBACKS|g" \
            "$INPUT" >"$OUTPUT"

            case "$INPUT" in
            *.perl)
                    chmod a+x "$OUTPUT";;
            *)
                    ;;
            esac



              """,
              "patche":
              """
                            diff --git a/generate-perl.sh b/generate-perl.sh
            index 65f122ebfc..154ae533f8 100755
            --- a/generate-perl.sh
            +++ b/generate-perl.sh
            @@ -19,7 +19,7 @@ OUTPUT="$5"

            sed -e '1{' \
            -e "    /^#!.*perl/!b" \
            -    -e "   s|#!.*perl|#!$PERL_PATH|" \
            +    -e "   s|#!.*perl|#!$PERL_PATH_FOR_SCRIPTS|" \
            -e "    r $PERL_HEADER" \
            -e '    G' \
            -e '}' \


              """,
            },

    {
            "wrongcode":
            """
                            #ifndef GIT_COMPAT_UTIL_H
            #define GIT_COMPAT_UTIL_H

            #if __STDC_VERSION__ - 0 < 199901L
            /*
            * Git is in a testing period for mandatory C99 support in the compiler.  If
            * your compiler is reasonably recent, you can try to enable C99 support (or,
            * for MSVC, C11 support).  If you encounter a problem and can't enable C99
            * support with your compiler (such as with "-std=gnu99") and don't have access
            * to one with this support, such as GCC or Clang, you can remove this #if
            * directive, but please report the details of your system to
            * git@vger.kernel.org.
            */
            #error "Required C99 support is in a test phase.  Please see git-compat-util.h for more details."
            #endif

            #ifdef USE_MSVC_CRTDBG
            /*
            * For these to work they must appear very early in each
            * file -- before most of the standard header files.
            */
            #include <stdlib.h>
            #include <crtdbg.h>
            #endif

            struct strbuf;


            #define _FILE_OFFSET_BITS 64


            /* Derived from Linux "Features Test Macro" header
            * Convenience macros to test the versions of gcc (or
            * a compatible compiler).
            * Use them like this:
            *  #if GIT_GNUC_PREREQ (2,8)
            *   ... code requiring gcc 2.8 or later ...
            *  #endif
            */
            #if defined(__GNUC__) && defined(__GNUC_MINOR__)
            # define GIT_GNUC_PREREQ(maj, min) \
                    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((maj) << 16) + (min))
            #else
            #define GIT_GNUC_PREREQ(maj, min) 0
            #endif

            #if defined(__GNUC__) || defined(__clang__)
            #  define PRAGMA(pragma)           _Pragma(#pragma)
            #  define DISABLE_WARNING(warning) PRAGMA(GCC diagnostic ignored #warning)
            #else
            #  define DISABLE_WARNING(warning)
            #endif

            #ifdef DISABLE_SIGN_COMPARE_WARNINGS
            DISABLE_WARNING(-Wsign-compare)
            #endif

            #ifndef FLEX_ARRAY
            /*
            * See if our compiler is known to support flexible array members.
            */

            /*
            * Check vendor specific quirks first, before checking the
            * __STDC_VERSION__, as vendor compilers can lie and we need to be
            * able to work them around.  Note that by not defining FLEX_ARRAY
            * here, we can fall back to use the "safer but a bit wasteful" one
            * later.
            */
            #if defined(__SUNPRO_C) && (__SUNPRO_C <= 0x580)
            #elif defined(__GNUC__)
            # if (__GNUC__ >= 3)
            #  define FLEX_ARRAY /* empty */
            # else
            #  define FLEX_ARRAY 0 /* older GNU extension */
            # endif
            #elif defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
            # define FLEX_ARRAY /* empty */
            #endif

            /*
            * Otherwise, default to safer but a bit wasteful traditional style
            */
            #ifndef FLEX_ARRAY
            # define FLEX_ARRAY 1
            #endif
            #endif


            /*
            * BUILD_ASSERT_OR_ZERO - assert a build-time dependency, as an expression.
            * @cond: the compile-time condition which must be true.
            *
            * Your compile will fail if the condition isn't true, or can't be evaluated
            * by the compiler.  This can be used in an expression: its value is "0".
            *
            * Example:
            *      #define foo_to_char(foo)                                        \
            *               ((char *)(foo)                                         \
            *                + BUILD_ASSERT_OR_ZERO(offsetof(struct foo, string) == 0))
            */
            #define BUILD_ASSERT_OR_ZERO(cond) \
                    (sizeof(char [1 - 2*!(cond)]) - 1)

            #if GIT_GNUC_PREREQ(3, 1)
            /* &arr[0] degrades to a pointer: a different type from an array */
            # define BARF_UNLESS_AN_ARRAY(arr)                                              \
                    BUILD_ASSERT_OR_ZERO(!__builtin_types_compatible_p(__typeof__(arr), \
                                                                    __typeof__(&(arr)[0])))
            # define BARF_UNLESS_COPYABLE(dst, src) \
                    BUILD_ASSERT_OR_ZERO(__builtin_types_compatible_p(__typeof__(*(dst)), \
                                                                    __typeof__(*(src))))
            #else
            # define BARF_UNLESS_AN_ARRAY(arr) 0
            # define BARF_UNLESS_COPYABLE(dst, src) \
                    BUILD_ASSERT_OR_ZERO(0 ? ((*(dst) = *(src)), 0) : \
                                            sizeof(*(dst)) == sizeof(*(src)))
            #endif
            /*
            * ARRAY_SIZE - get the number of elements in a visible array
            * @x: the array whose size you want.
            *
            * This does not work on pointers, or arrays declared as [], or
            * function parameters.  With correct compiler support, such usage
            * will cause a build error (see the build_assert_or_zero macro).
            */
            #define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]) + BARF_UNLESS_AN_ARRAY(x))

            #define bitsizeof(x)  (CHAR_BIT * sizeof(x))

            #define maximum_signed_value_of_type(a) \
            (INTMAX_MAX >> (bitsizeof(intmax_t) - bitsizeof(a)))

            #define maximum_unsigned_value_of_type(a) \
            (UINTMAX_MAX >> (bitsizeof(uintmax_t) - bitsizeof(a)))

            /*
            * Signed integer overflow is undefined in C, so here's a helper macro
            * to detect if the sum of two integers will overflow.
            *
            * Requires: a >= 0, typeof(a) equals typeof(b)
            */
            #define signed_add_overflows(a, b) \
            ((b) > maximum_signed_value_of_type(a) - (a))

            #define unsigned_add_overflows(a, b) \
            ((b) > maximum_unsigned_value_of_type(a) - (a))

            /*
            * Returns true if the multiplication of "a" and "b" will
            * overflow. The types of "a" and "b" must match and must be unsigned.
            * Note that this macro evaluates "a" twice!
            */
            #define unsigned_mult_overflows(a, b) \
            ((a) && (b) > maximum_unsigned_value_of_type(a) / (a))

            /*
            * Returns true if the left shift of "a" by "shift" bits will
            * overflow. The type of "a" must be unsigned.
            */
            #define unsigned_left_shift_overflows(a, shift) \
            ((shift) < bitsizeof(a) && \
            (a) > maximum_unsigned_value_of_type(a) >> (shift))

            #ifdef __GNUC__
            #define TYPEOF(x) (__typeof__(x))
            #else
            #define TYPEOF(x)
            #endif

            #define MSB(x, bits) ((x) & TYPEOF(x)(~0ULL << (bitsizeof(x) - (bits))))
            #define HAS_MULTI_BITS(i)  ((i) & ((i) - 1))  /* checks if an integer has more than 1 bit set */

            #define DIV_ROUND_UP(n,d) (((n) + (d) - 1) / (d))

            /* Approximation of the length of the decimal representation of this type. */
            #define decimal_length(x)       ((int)(sizeof(x) * 2.56 + 0.5) + 1)

            #ifdef __MINGW64__
            #define _POSIX_C_SOURCE 1
            #elif defined(__sun__)
            /*
            * On Solaris, when _XOPEN_EXTENDED is set, its header file
            * forces the programs to be XPG4v2, defeating any _XOPEN_SOURCE
            * setting to say we are XPG5 or XPG6.  Also on Solaris,
            * XPG6 programs must be compiled with a c99 compiler, while
            * non XPG6 programs must be compiled with a pre-c99 compiler.
            */
            # if __STDC_VERSION__ - 0 >= 199901L
            # define _XOPEN_SOURCE 600
            # else
            # define _XOPEN_SOURCE 500
            # endif
            #elif !defined(__APPLE__) && !defined(__FreeBSD__) && !defined(__USLC__) && \
            !defined(_M_UNIX) && !defined(__sgi) && !defined(__DragonFly__) && \
            !defined(__TANDEM) && !defined(__QNX__) && !defined(__MirBSD__) && \
            !defined(__CYGWIN__)
            #define _XOPEN_SOURCE 600 /* glibc2 and AIX 5.3L need 500, OpenBSD needs 600 for S_ISLNK() */
            #define _XOPEN_SOURCE_EXTENDED 1 /* AIX 5.3L needs this */
            #endif
            #define _ALL_SOURCE 1
            #define _GNU_SOURCE 1
            #define _BSD_SOURCE 1
            #define _DEFAULT_SOURCE 1
            #define _NETBSD_SOURCE 1
            #define _SGI_SOURCE 1

            /*
            * UNUSED marks a function parameter that is always unused.  It also
            * can be used to annotate a function, a variable, or a type that is
            * always unused.
            *
            * A callback interface may dictate that a function accepts a
            * parameter at that position, but the implementation of the function
            * may not need to use the parameter.  In such a case, mark the parameter
            * with UNUSED.
            *
            * When a parameter may be used or unused, depending on conditional
            * compilation, consider using MAYBE_UNUSED instead.
            */
            #if GIT_GNUC_PREREQ(4, 5)
            #define UNUSED __attribute__((unused)) \
                    __attribute__((deprecated ("parameter declared as UNUSED")))
            #elif defined(__GNUC__)
            #define UNUSED __attribute__((unused)) \
                    __attribute__((deprecated))
            #else
            #define UNUSED
            #endif

            #if defined(WIN32) && !defined(__CYGWIN__) /* Both MinGW and MSVC */
            # if !defined(_WIN32_WINNT)
            #  define _WIN32_WINNT 0x0600
            # endif
            #define WIN32_LEAN_AND_MEAN  /* stops windows.h including winsock.h */
            #include <winsock2.h>
            #ifndef NO_UNIX_SOCKETS
            #include <afunix.h>
            #endif
            #include <windows.h>
            #define GIT_WINDOWS_NATIVE
            #endif

            #if defined(NO_UNIX_SOCKETS) || !defined(GIT_WINDOWS_NATIVE)
            static inline int _have_unix_sockets(void)
            {
            #if defined(NO_UNIX_SOCKETS)
                    return 0;
            #else
                    return 1;
            #endif
            }
            #define have_unix_sockets _have_unix_sockets
            #endif

            #include <unistd.h>
            #include <stdio.h>
            #include <sys/stat.h>
            #include <fcntl.h>
            #include <stddef.h>
            #include <stdlib.h>
            #include <stdarg.h>
            #include <stdbool.h>
            #include <string.h>
            #ifdef HAVE_STRINGS_H
            #include <strings.h> /* for strcasecmp() */
            #endif
            #include <errno.h>
            #include <limits.h>
            #include <locale.h>
            #ifdef NEEDS_SYS_PARAM_H
            #include <sys/param.h>
            #endif
            #include <sys/types.h>
            #include <dirent.h>
            #include <sys/time.h>
            #include <time.h>
            #include <signal.h>
            #include <assert.h>
            #include <regex.h>
            #include <utime.h>
            #include <syslog.h>
            #if !defined(NO_POLL_H)
            #include <poll.h>
            #elif !defined(NO_SYS_POLL_H)
            #include <sys/poll.h>
            #else
            /* Pull the compat stuff */
            #include <poll.h>
            #endif
            #ifdef HAVE_BSD_SYSCTL
            #include <sys/sysctl.h>
            #endif

            /* Used by compat/win32/path-utils.h, and more */
            static inline int is_xplatform_dir_sep(int c)
            {
                    return c == '/' || c == '\\';
            }

            #if defined(__CYGWIN__)
            #include "compat/win32/path-utils.h"
            #endif
            #if defined(__MINGW32__)
            /* pull in Windows compatibility stuff */
            #include "compat/win32/path-utils.h"
            #include "compat/mingw.h"
            #elif defined(_MSC_VER)
            #include "compat/win32/path-utils.h"
            #include "compat/msvc.h"
            #else
            #include <sys/utsname.h>
            #include <sys/wait.h>
            #include <sys/resource.h>
            #include <sys/socket.h>
            #include <sys/ioctl.h>
            #include <sys/statvfs.h>
            #include <termios.h>
            #ifndef NO_SYS_SELECT_H
            #include <sys/select.h>
            #endif
            #include <netinet/in.h>
            #include <netinet/tcp.h>
            #include <arpa/inet.h>
            #include <netdb.h>
            #include <pwd.h>
            #include <sys/un.h>
            #ifndef NO_INTTYPES_H
            #include <inttypes.h>
            #else
            #include <stdint.h>
            #endif
            #ifdef HAVE_ARC4RANDOM_LIBBSD
            #include <bsd/stdlib.h>
            #endif
            #ifdef HAVE_GETRANDOM
            #include <sys/random.h>
            #endif
            #ifdef NO_INTPTR_T
            /*
            * On I16LP32, ILP32 and LP64 "long" is the safe bet, however
            * on LLP86, IL33LLP64 and P64 it needs to be "long long",
            * while on IP16 and IP16L32 it is "int" (resp. "short")
            * Size needs to match (or exceed) 'sizeof(void *)'.
            * We can't take "long long" here as not everybody has it.
            */
            typedef long intptr_t;
            typedef unsigned long uintptr_t;
            #endif
            #undef _ALL_SOURCE /* AIX 5.3L defines a struct list with _ALL_SOURCE. */
            #include <grp.h>
            #define _ALL_SOURCE 1
            #endif

            /* used on Mac OS X */
            #ifdef PRECOMPOSE_UNICODE
            #include "compat/precompose_utf8.h"
            #else
            static inline const char *precompose_argv_prefix(int argc UNUSED,
                                                            const char **argv UNUSED,
                                                            const char *prefix)
            {
                    return prefix;
            }
            static inline const char *precompose_string_if_needed(const char *in)
            {
                    return in;
            }

            #define probe_utf8_pathname_composition()
            #endif

            #ifdef MKDIR_WO_TRAILING_SLASH
            #define mkdir(a,b) compat_mkdir_wo_trailing_slash((a),(b))
            int compat_mkdir_wo_trailing_slash(const char*, mode_t);
            #endif

            #ifdef time
            #undef time
            #endif
            static inline time_t git_time(time_t *tloc)
            {
                    struct timeval tv;

                    /*
                    * Avoid time(NULL), which can disagree with gettimeofday(2)
                    * and filesystem timestamps.
                    */
                    gettimeofday(&tv, NULL);

                    if (tloc)
                            *tloc = tv.tv_sec;
                    return tv.tv_sec;
            }
            #define time git_time

            #ifdef NO_STRUCT_ITIMERVAL
            struct itimerval {
                    struct timeval it_interval;
                    struct timeval it_value;
            };
            #endif

            #ifdef NO_SETITIMER
            static inline int git_setitimer(int which UNUSED,
                                            const struct itimerval *value UNUSED,
                                            struct itimerval *newvalue UNUSED) {
                    return 0; /* pretend success */
            }
            #undef setitimer
            #define setitimer(which,value,ovalue) git_setitimer(which,value,ovalue)
            #endif

            #ifndef NO_LIBGEN_H
            #include <libgen.h>
            #else
            #define basename gitbasename
            char *gitbasename(char *);
            #define dirname gitdirname
            char *gitdirname(char *);
            #endif

            #ifndef NO_ICONV
            #include <iconv.h>
            #endif

            #ifndef NO_OPENSSL
            #ifdef __APPLE__
            #undef __AVAILABILITY_MACROS_USES_AVAILABILITY
            #define __AVAILABILITY_MACROS_USES_AVAILABILITY 0
            #include <AvailabilityMacros.h>
            #undef DEPRECATED_ATTRIBUTE
            #define DEPRECATED_ATTRIBUTE
            #undef __AVAILABILITY_MACROS_USES_AVAILABILITY
            #endif
            #include <openssl/ssl.h>
            #include <openssl/err.h>
            #endif

            #ifdef HAVE_SYSINFO
            # include <sys/sysinfo.h>
            #endif

            /* On most systems <netdb.h> would have given us this, but
            * not on some systems (e.g. z/OS).
            */
            #ifndef NI_MAXHOST
            #define NI_MAXHOST 1025
            #endif

            #ifndef NI_MAXSERV
            #define NI_MAXSERV 32
            #endif

            /* On most systems <limits.h> would have given us this, but
            * not on some systems (e.g. GNU/Hurd).
            */
            #ifndef PATH_MAX
            #define PATH_MAX 4096
            #endif

            #ifndef NAME_MAX
            #define NAME_MAX 255
            #endif

            typedef uintmax_t timestamp_t;
            #define PRItime PRIuMAX
            #define parse_timestamp strtoumax
            #define TIME_MAX UINTMAX_MAX
            #define TIME_MIN 0

            #ifndef PATH_SEP
            #define PATH_SEP ':'
            #endif

            #ifdef HAVE_PATHS_H
            #include <paths.h>
            #endif
            #ifndef _PATH_DEFPATH
            #define _PATH_DEFPATH "/usr/local/bin:/usr/bin:/bin"
            #endif

            #ifndef platform_core_config
            struct config_context;
            static inline int noop_core_config(const char *var UNUSED,
                                            const char *value UNUSED,
                                            const struct config_context *ctx UNUSED,
                                            void *cb UNUSED)
            {
                    return 0;
            }
            #define platform_core_config noop_core_config
            #endif

            int lstat_cache_aware_rmdir(const char *path);
            #if !defined(__MINGW32__) && !defined(_MSC_VER)
            #define rmdir lstat_cache_aware_rmdir
            #endif

            #ifndef has_dos_drive_prefix
            static inline int git_has_dos_drive_prefix(const char *path UNUSED)
            {
                    return 0;
            }
            #define has_dos_drive_prefix git_has_dos_drive_prefix
            #endif

            #ifndef skip_dos_drive_prefix
            static inline int git_skip_dos_drive_prefix(char **path UNUSED)
            {
                    return 0;
            }
            #define skip_dos_drive_prefix git_skip_dos_drive_prefix
            #endif

            static inline int git_is_dir_sep(int c)
            {
                    return c == '/';
            }
            #ifndef is_dir_sep
            #define is_dir_sep git_is_dir_sep
            #endif

            #ifndef offset_1st_component
            static inline int git_offset_1st_component(const char *path)
            {
                    return is_dir_sep(path[0]);
            }
            #define offset_1st_component git_offset_1st_component
            #endif

            #ifndef fspathcmp
            #define fspathcmp git_fspathcmp
            #endif

            #ifndef fspathncmp
            #define fspathncmp git_fspathncmp
            #endif

            #ifndef is_valid_path
            #define is_valid_path(path) 1
            #endif

            #ifndef is_path_owned_by_current_user

            #ifdef __TANDEM
            #define ROOT_UID 65535
            #else
            #define ROOT_UID 0
            #endif

            /*
            * Do not use this function when
            * (1) geteuid() did not say we are running as 'root', or
            * (2) using this function will compromise the system.
            *
            * PORTABILITY WARNING:
            * This code assumes uid_t is unsigned because that is what sudo does.
            * If your uid_t type is signed and all your ids are positive then it
            * should all work fine.
            * If your version of sudo uses negative values for uid_t or it is
            * buggy and return an overflowed value in SUDO_UID, then git might
            * fail to grant access to your repository properly or even mistakenly
            * grant access to someone else.
            * In the unlikely scenario this happened to you, and that is how you
            * got to this message, we would like to know about it; so sent us an
            * email to git@vger.kernel.org indicating which platform you are
            * using and which version of sudo, so we can improve this logic and
            * maybe provide you with a patch that would prevent this issue again
            * in the future.
            */
            static inline void extract_id_from_env(const char *env, uid_t *id)
            {
                    const char *real_uid = getenv(env);

                    /* discard anything empty to avoid a more complex check below */
                    if (real_uid && *real_uid) {
                            char *endptr = NULL;
                            unsigned long env_id;

                            errno = 0;
                            /* silent overflow errors could trigger a bug here */
                            env_id = strtoul(real_uid, &endptr, 10);
                            if (!*endptr && !errno)
                                    *id = env_id;
                    }
            }

            static inline int is_path_owned_by_current_uid(const char *path,
                                                    struct strbuf *report UNUSED)
            {
                    struct stat st;
                    uid_t euid;

                    if (lstat(path, &st))
                            return 0;

                    euid = geteuid();
                    if (euid == ROOT_UID)
                    {
                            if (st.st_uid == ROOT_UID)
                                    return 1;
                            else
                                    extract_id_from_env("SUDO_UID", &euid);
                    }

                    return st.st_uid == euid;
            }

            #define is_path_owned_by_current_user is_path_owned_by_current_uid
            #endif

            #ifndef find_last_dir_sep
            static inline char *git_find_last_dir_sep(const char *path)
            {
                    return strrchr(path, '/');
            }
            #define find_last_dir_sep git_find_last_dir_sep
            #endif

            #ifndef has_dir_sep
            static inline int git_has_dir_sep(const char *path)
            {
                    return !!strchr(path, '/');
            }
            #define has_dir_sep(path) git_has_dir_sep(path)
            #endif

            #ifndef query_user_email
            #define query_user_email() NULL
            #endif

            #ifdef __TANDEM
            #include <floss.h(floss_execl,floss_execlp,floss_execv,floss_execvp)>
            #include <floss.h(floss_getpwuid)>
            #ifndef NSIG
            /*
            * NonStop NSE and NSX do not provide NSIG. SIGGUARDIAN(99) is the highest
            * known, by detective work using kill -l as a list is all signals
            * instead of signal.h where it should be.
            */
            # define NSIG 100
            #endif
            #endif

            #if defined(__HP_cc) && (__HP_cc >= 61000)
            #define NORETURN __attribute__((noreturn))
            #define NORETURN_PTR
            #elif defined(__GNUC__) && !defined(NO_NORETURN)
            #define NORETURN __attribute__((__noreturn__))
            #define NORETURN_PTR __attribute__((__noreturn__))
            #elif defined(_MSC_VER)
            #define NORETURN __declspec(noreturn)
            #define NORETURN_PTR
            #else
            #define NORETURN
            #define NORETURN_PTR
            #ifndef __GNUC__
            #ifndef __attribute__
            #define __attribute__(x)
            #endif
            #endif
            #endif

            /* The sentinel attribute is valid from gcc version 4.0 */
            #if defined(__GNUC__) && (__GNUC__ >= 4)
            #define LAST_ARG_MUST_BE_NULL __attribute__((sentinel))
            /* warn_unused_result exists as of gcc 3.4.0, but be lazy and check 4.0 */
            #define RESULT_MUST_BE_USED __attribute__ ((warn_unused_result))
            #else
            #define LAST_ARG_MUST_BE_NULL
            #define RESULT_MUST_BE_USED
            #endif

            /*
            * MAYBE_UNUSED marks a function parameter that may be unused, but
            * whose use is not an error.  It also can be used to annotate a
            * function, a variable, or a type that may be unused.
            *
            * Depending on a configuration, all uses of such a thing may become
            * #ifdef'ed away.  Marking it with UNUSED would give a warning in a
            * compilation where it is indeed used, and not marking it at all
            * would give a warning in a compilation where it is unused.  In such
            * a case, MAYBE_UNUSED is the appropriate annotation to use.
            */
            #define MAYBE_UNUSED __attribute__((__unused__))

            #include "compat/bswap.h"

            #include "wrapper.h"

            /* General helper functions */
            NORETURN void usage(const char *err);
            NORETURN void usagef(const char *err, ...) __attribute__((format (printf, 1, 2)));
            NORETURN void die(const char *err, ...) __attribute__((format (printf, 1, 2)));
            NORETURN void die_errno(const char *err, ...) __attribute__((format (printf, 1, 2)));
            int die_message(const char *err, ...) __attribute__((format (printf, 1, 2)));
            int die_message_errno(const char *err, ...) __attribute__((format (printf, 1, 2)));
            int error(const char *err, ...) __attribute__((format (printf, 1, 2)));
            int error_errno(const char *err, ...) __attribute__((format (printf, 1, 2)));
            void warning(const char *err, ...) __attribute__((format (printf, 1, 2)));
            void warning_errno(const char *err, ...) __attribute__((format (printf, 1, 2)));

            #ifndef NO_OPENSSL
            #ifdef APPLE_COMMON_CRYPTO
            #include "compat/apple-common-crypto.h"
            #else
            #include <openssl/evp.h>
            #include <openssl/hmac.h>
            #endif /* APPLE_COMMON_CRYPTO */
            #include <openssl/x509v3.h>
            #endif /* NO_OPENSSL */

            #ifdef HAVE_OPENSSL_CSPRNG
            #include <openssl/rand.h>
            #endif

            /*
            * Let callers be aware of the constant return value; this can help
            * gcc with -Wuninitialized analysis. We restrict this trick to gcc, though,
            * because other compilers may be confused by this.
            */
            #if defined(__GNUC__)
            static inline int const_error(void)
            {
                    return -1;
            }
            #define error(...) (error(__VA_ARGS__), const_error())
            #define error_errno(...) (error_errno(__VA_ARGS__), const_error())
            #endif

            typedef void (*report_fn)(const char *, va_list params);

            void set_die_routine(NORETURN_PTR report_fn routine);
            report_fn get_die_message_routine(void);
            void set_error_routine(report_fn routine);
            report_fn get_error_routine(void);
            void set_warn_routine(report_fn routine);
            report_fn get_warn_routine(void);
            void set_die_is_recursing_routine(int (*routine)(void));

            /*
            * If the string "str" begins with the string found in "prefix", return true.
            * The "out" parameter is set to "str + strlen(prefix)" (i.e., to the point in
            * the string right after the prefix).
            *
            * Otherwise, return false and leave "out" untouched.
            *
            * Examples:
            *
            *   [extract branch name, fail if not a branch]
            *   if (!skip_prefix(ref, "refs/heads/", &branch)
            *      return -1;
            *
            *   [skip prefix if present, otherwise use whole string]
            *   skip_prefix(name, "refs/heads/", &name);
            */
            static inline bool skip_prefix(const char *str, const char *prefix,
                                    const char **out)
            {
                    do {
                            if (!*prefix) {
                                    *out = str;
                                    return true;
                            }
                    } while (*str++ == *prefix++);
                    return false;
            }

            /*
            * Like skip_prefix, but promises never to read past "len" bytes of the input
            * buffer, and returns the remaining number of bytes in "out" via "outlen".
            */
            static inline bool skip_prefix_mem(const char *buf, size_t len,
                                            const char *prefix,
                                            const char **out, size_t *outlen)
            {
                    size_t prefix_len = strlen(prefix);
                    if (prefix_len <= len && !memcmp(buf, prefix, prefix_len)) {
                            *out = buf + prefix_len;
                            *outlen = len - prefix_len;
                            return true;
                    }
                    return false;
            }

            /*
            * If buf ends with suffix, return true and subtract the length of the suffix
            * from *len. Otherwise, return false and leave *len untouched.
            */
            static inline bool strip_suffix_mem(const char *buf, size_t *len,
                                            const char *suffix)
            {
                    size_t suflen = strlen(suffix);
                    if (*len < suflen || memcmp(buf + (*len - suflen), suffix, suflen))
                            return false;
                    *len -= suflen;
                    return true;
            }

            /*
            * If str ends with suffix, return true and set *len to the size of the string
            * without the suffix. Otherwise, return false and set *len to the size of the
            * string.
            *
            * Note that we do _not_ NUL-terminate str to the new length.
            */
            static inline bool strip_suffix(const char *str, const char *suffix,
                                            size_t *len)
            {
                    *len = strlen(str);
                    return strip_suffix_mem(str, len, suffix);
            }

            #define SWAP(a, b) do {                                         \
                    void *_swap_a_ptr = &(a);                               \
                    void *_swap_b_ptr = &(b);                               \
                    unsigned char _swap_buffer[sizeof(a)];                  \
                    memcpy(_swap_buffer, _swap_a_ptr, sizeof(a));           \
                    memcpy(_swap_a_ptr, _swap_b_ptr, sizeof(a) +            \
                    BUILD_ASSERT_OR_ZERO(sizeof(a) == sizeof(b)));   \
                    memcpy(_swap_b_ptr, _swap_buffer, sizeof(a));           \
            } while (0)

            #if defined(NO_MMAP) || defined(USE_WIN32_MMAP)

            #ifndef PROT_READ
            #define PROT_READ 1
            #define PROT_WRITE 2
            #define MAP_PRIVATE 1
            #endif

            #define mmap git_mmap
            #define munmap git_munmap
            void *git_mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);
            int git_munmap(void *start, size_t length);

            #else /* NO_MMAP || USE_WIN32_MMAP */

            #include <sys/mman.h>

            #endif /* NO_MMAP || USE_WIN32_MMAP */

            #ifdef NO_MMAP

            /* This value must be multiple of (pagesize * 2) */
            #define DEFAULT_PACKED_GIT_WINDOW_SIZE (1 * 1024 * 1024)

            #else /* NO_MMAP */

            /* This value must be multiple of (pagesize * 2) */
            #define DEFAULT_PACKED_GIT_WINDOW_SIZE \
                    (sizeof(void*) >= 8 \
                            ?  1 * 1024 * 1024 * 1024 \
                            : 32 * 1024 * 1024)

            #endif /* NO_MMAP */

            #ifndef MAP_FAILED
            #define MAP_FAILED ((void *)-1)
            #endif

            #ifdef NO_ST_BLOCKS_IN_STRUCT_STAT
            #define on_disk_bytes(st) ((st).st_size)
            #else
            #define on_disk_bytes(st) ((st).st_blocks * 512)
            #endif

            #ifdef NEEDS_MODE_TRANSLATION
            #undef S_IFMT
            #undef S_IFREG
            #undef S_IFDIR
            #undef S_IFLNK
            #undef S_IFBLK
            #undef S_IFCHR
            #undef S_IFIFO
            #undef S_IFSOCK
            #define S_IFMT   0170000
            #define S_IFREG  0100000
            #define S_IFDIR  0040000
            #define S_IFLNK  0120000
            #define S_IFBLK  0060000
            #define S_IFCHR  0020000
            #define S_IFIFO  0010000
            #define S_IFSOCK 0140000
            #ifdef stat
            #undef stat
            #endif
            #define stat(path, buf) git_stat(path, buf)
            int git_stat(const char *, struct stat *);
            #ifdef fstat
            #undef fstat
            #endif
            #define fstat(fd, buf) git_fstat(fd, buf)
            int git_fstat(int, struct stat *);
            #ifdef lstat
            #undef lstat
            #endif
            #define lstat(path, buf) git_lstat(path, buf)
            int git_lstat(const char *, struct stat *);
            #endif

            #define DEFAULT_PACKED_GIT_LIMIT \
                    ((1024L * 1024L) * (size_t)(sizeof(void*) >= 8 ? (32 * 1024L * 1024L) : 256))

            #ifdef NO_PREAD
            #define pread git_pread
            ssize_t git_pread(int fd, void *buf, size_t count, off_t offset);
            #endif

            #ifdef NO_SETENV
            #define setenv gitsetenv
            int gitsetenv(const char *, const char *, int);
            #endif

            #ifdef NO_MKDTEMP
            #define mkdtemp gitmkdtemp
            char *gitmkdtemp(char *);
            #endif

            #ifdef NO_UNSETENV
            #define unsetenv gitunsetenv
            int gitunsetenv(const char *);
            #endif

            #ifdef NO_STRCASESTR
            #define strcasestr gitstrcasestr
            char *gitstrcasestr(const char *haystack, const char *needle);
            #endif

            #ifdef NO_STRLCPY
            #define strlcpy gitstrlcpy
            size_t gitstrlcpy(char *, const char *, size_t);
            #endif

            #ifdef NO_STRTOUMAX
            #define strtoumax gitstrtoumax
            uintmax_t gitstrtoumax(const char *, char **, int);
            #define strtoimax gitstrtoimax
            intmax_t gitstrtoimax(const char *, char **, int);
            #endif

            #ifdef NO_HSTRERROR
            #define hstrerror githstrerror
            const char *githstrerror(int herror);
            #endif

            #ifdef NO_MEMMEM
            #define memmem gitmemmem
            void *gitmemmem(const void *haystack, size_t haystacklen,
                            const void *needle, size_t needlelen);
            #endif

            #ifdef OVERRIDE_STRDUP
            #ifdef strdup
            #undef strdup
            #endif
            #define strdup gitstrdup
            char *gitstrdup(const char *s);
            #endif

            #ifdef NO_GETPAGESIZE
            #define getpagesize() sysconf(_SC_PAGESIZE)
            #endif

            #ifndef O_CLOEXEC
            #define O_CLOEXEC 0
            #endif

            #ifdef FREAD_READS_DIRECTORIES
            # if !defined(SUPPRESS_FOPEN_REDEFINITION)
            #  ifdef fopen
            #   undef fopen
            #  endif
            #  define fopen(a,b) git_fopen(a,b)
            # endif
            FILE *git_fopen(const char*, const char*);
            #endif

            #ifdef SNPRINTF_RETURNS_BOGUS
            #ifdef snprintf
            #undef snprintf
            #endif
            #define snprintf git_snprintf
            int git_snprintf(char *str, size_t maxsize,
                            const char *format, ...);
            #ifdef vsnprintf
            #undef vsnprintf
            #endif
            #define vsnprintf git_vsnprintf
            int git_vsnprintf(char *str, size_t maxsize,
                            const char *format, va_list ap);
            #endif

            #ifdef OPEN_RETURNS_EINTR
            #undef open
            #define open git_open_with_retry
            int git_open_with_retry(const char *path, int flag, ...);
            #endif

            #ifdef __GLIBC_PREREQ
            #if __GLIBC_PREREQ(2, 1)
            #define HAVE_STRCHRNUL
            #endif
            #endif

            #ifndef HAVE_STRCHRNUL
            #define strchrnul gitstrchrnul
            static inline char *gitstrchrnul(const char *s, int c)
            {
                    while (*s && *s != c)
                            s++;
                    return (char *)s;
            }
            #endif

            #ifdef NO_INET_PTON
            int inet_pton(int af, const char *src, void *dst);
            #endif

            #ifdef NO_INET_NTOP
            const char *inet_ntop(int af, const void *src, char *dst, size_t size);
            #endif

            #ifdef NO_PTHREADS
            #define atexit git_atexit
            int git_atexit(void (*handler)(void));
            #endif

            static inline size_t st_add(size_t a, size_t b)
            {
                    if (unsigned_add_overflows(a, b))
                            die("size_t overflow: %"PRIuMAX" + %"PRIuMAX,
                            (uintmax_t)a, (uintmax_t)b);
                    return a + b;
            }
            #define st_add3(a,b,c)   st_add(st_add((a),(b)),(c))
            #define st_add4(a,b,c,d) st_add(st_add3((a),(b),(c)),(d))

            static inline size_t st_mult(size_t a, size_t b)
            {
                    if (unsigned_mult_overflows(a, b))
                            die("size_t overflow: %"PRIuMAX" * %"PRIuMAX,
                            (uintmax_t)a, (uintmax_t)b);
                    return a * b;
            }

            static inline size_t st_sub(size_t a, size_t b)
            {
                    if (a < b)
                            die("size_t underflow: %"PRIuMAX" - %"PRIuMAX,
                            (uintmax_t)a, (uintmax_t)b);
                    return a - b;
            }

            static inline size_t st_left_shift(size_t a, unsigned shift)
            {
                    if (unsigned_left_shift_overflows(a, shift))
                            die("size_t overflow: %"PRIuMAX" << %u",
                            (uintmax_t)a, shift);
                    return a << shift;
            }

            static inline unsigned long cast_size_t_to_ulong(size_t a)
            {
                    if (a != (unsigned long)a)
                            die("object too large to read on this platform: %"
                            PRIuMAX" is cut off to %lu",
                            (uintmax_t)a, (unsigned long)a);
                    return (unsigned long)a;
            }

            static inline uint32_t cast_size_t_to_uint32_t(size_t a)
            {
                    if (a != (uint32_t)a)
                            die("object too large to read on this platform: %"
                            PRIuMAX" is cut off to %u",
                            (uintmax_t)a, (uint32_t)a);
                    return (uint32_t)a;
            }

            static inline int cast_size_t_to_int(size_t a)
            {
                    if (a > INT_MAX)
                            die("number too large to represent as int on this platform: %"PRIuMAX,
                            (uintmax_t)a);
                    return (int)a;
            }

            /*
            * Limit size of IO chunks, because huge chunks only cause pain.  OS X
            * 64-bit is buggy, returning EINVAL if len >= INT_MAX; and even in
            * the absence of bugs, large chunks can result in bad latencies when
            * you decide to kill the process.
            *
            * We pick 8 MiB as our default, but if the platform defines SSIZE_MAX
            * that is smaller than that, clip it to SSIZE_MAX, as a call to
            * read(2) or write(2) larger than that is allowed to fail.  As the last
            * resort, we allow a port to pass via CFLAGS e.g. "-DMAX_IO_SIZE=value"
            * to override this, if the definition of SSIZE_MAX given by the platform
            * is broken.
            */
            #ifndef MAX_IO_SIZE
            # define MAX_IO_SIZE_DEFAULT (8*1024*1024)
            # if defined(SSIZE_MAX) && (SSIZE_MAX < MAX_IO_SIZE_DEFAULT)
            #  define MAX_IO_SIZE SSIZE_MAX
            # else
            #  define MAX_IO_SIZE MAX_IO_SIZE_DEFAULT
            # endif
            #endif

            #ifdef HAVE_ALLOCA_H
            # include <alloca.h>
            # define xalloca(size)      (alloca(size))
            # define xalloca_free(p)    do {} while (0)
            #else
            # define xalloca(size)      (xmalloc(size))
            # define xalloca_free(p)    (free(p))
            #endif

            /*
            * FREE_AND_NULL(ptr) is like free(ptr) followed by ptr = NULL. Note
            * that ptr is used twice, so don't pass e.g. ptr++.
            */
            #define FREE_AND_NULL(p) do { free(p); (p) = NULL; } while (0)

            #define ALLOC_ARRAY(x, alloc) (x) = xmalloc(st_mult(sizeof(*(x)), (alloc)))
            #define CALLOC_ARRAY(x, alloc) (x) = xcalloc((alloc), sizeof(*(x)))
            #define REALLOC_ARRAY(x, alloc) (x) = xrealloc((x), st_mult(sizeof(*(x)), (alloc)))

            #define COPY_ARRAY(dst, src, n) copy_array((dst), (src), (n), sizeof(*(dst)) + \
                    BARF_UNLESS_COPYABLE((dst), (src)))
            static inline void copy_array(void *dst, const void *src, size_t n, size_t size)
            {
                    if (n)
                            memcpy(dst, src, st_mult(size, n));
            }

            #define MOVE_ARRAY(dst, src, n) move_array((dst), (src), (n), sizeof(*(dst)) + \
                    BARF_UNLESS_COPYABLE((dst), (src)))
            static inline void move_array(void *dst, const void *src, size_t n, size_t size)
            {
                    if (n)
                            memmove(dst, src, st_mult(size, n));
            }

            #define DUP_ARRAY(dst, src, n) do { \
                    size_t dup_array_n_ = (n); \
                    COPY_ARRAY(ALLOC_ARRAY((dst), dup_array_n_), (src), dup_array_n_); \
            } while (0)

            /*
            * These functions help you allocate structs with flex arrays, and copy
            * the data directly into the array. For example, if you had:
            *
            *   struct foo {
            *     int bar;
            *     char name[FLEX_ARRAY];
            *   };
            *
            * you can do:
            *
            *   struct foo *f;
            *   FLEX_ALLOC_MEM(f, name, src, len);
            *
            * to allocate a "foo" with the contents of "src" in the "name" field.
            * The resulting struct is automatically zero'd, and the flex-array field
            * is NUL-terminated (whether the incoming src buffer was or not).
            *
            * The FLEXPTR_* variants operate on structs that don't use flex-arrays,
            * but do want to store a pointer to some extra data in the same allocated
            * block. For example, if you have:
            *
            *   struct foo {
            *     char *name;
            *     int bar;
            *   };
            *
            * you can do:
            *
            *   struct foo *f;
            *   FLEXPTR_ALLOC_STR(f, name, src);
            *
            * and "name" will point to a block of memory after the struct, which will be
            * freed along with the struct (but the pointer can be repointed anywhere).
            *
            * The *_STR variants accept a string parameter rather than a ptr/len
            * combination.
            *
            * Note that these macros will evaluate the first parameter multiple
            * times, and it must be assignable as an lvalue.
            */
            #define FLEX_ALLOC_MEM(x, flexname, buf, len) do { \
                    size_t flex_array_len_ = (len); \
                    (x) = xcalloc(1, st_add3(sizeof(*(x)), flex_array_len_, 1)); \
                    memcpy((void *)(x)->flexname, (buf), flex_array_len_); \
            } while (0)
            #define FLEXPTR_ALLOC_MEM(x, ptrname, buf, len) do { \
                    size_t flex_array_len_ = (len); \
                    (x) = xcalloc(1, st_add3(sizeof(*(x)), flex_array_len_, 1)); \
                    memcpy((x) + 1, (buf), flex_array_len_); \
                    (x)->ptrname = (void *)((x)+1); \
            } while(0)
            #define FLEX_ALLOC_STR(x, flexname, str) \
                    FLEX_ALLOC_MEM((x), flexname, (str), strlen(str))
            #define FLEXPTR_ALLOC_STR(x, ptrname, str) \
                    FLEXPTR_ALLOC_MEM((x), ptrname, (str), strlen(str))

            #define alloc_nr(x) (((x)+16)*3/2)

            /**
            * Dynamically growing an array using realloc() is error prone and boring.
            *
            * Define your array with:
            *
            * - a pointer (`item`) that points at the array, initialized to `NULL`
            *   (although please name the variable based on its contents, not on its
            *   type);
            *
            * - an integer variable (`alloc`) that keeps track of how big the current
            *   allocation is, initialized to `0`;
            *
            * - another integer variable (`nr`) to keep track of how many elements the
            *   array currently has, initialized to `0`.
            *
            * Then before adding `n`th element to the item, call `ALLOC_GROW(item, n,
            * alloc)`.  This ensures that the array can hold at least `n` elements by
            * calling `realloc(3)` and adjusting `alloc` variable.
            *
            * ------------
            * sometype *item;
            * size_t nr;
            * size_t alloc
            *
            * for (i = 0; i < nr; i++)
            *      if (we like item[i] already)
            *              return;
            *
            * // we did not like any existing one, so add one
            * ALLOC_GROW(item, nr + 1, alloc);
            * item[nr++] = value you like;
            * ------------
            *
            * You are responsible for updating the `nr` variable.
            *
            * If you need to specify the number of elements to allocate explicitly
            * then use the macro `REALLOC_ARRAY(item, alloc)` instead of `ALLOC_GROW`.
            *
            * Consider using ALLOC_GROW_BY instead of ALLOC_GROW as it has some
            * added niceties.
            *
            * DO NOT USE any expression with side-effect for 'x', 'nr', or 'alloc'.
            */
            #define ALLOC_GROW(x, nr, alloc) \
                    do { \
                            if ((nr) > alloc) { \
                                    if (alloc_nr(alloc) < (nr)) \
                                            alloc = (nr); \
                                    else \
                                            alloc = alloc_nr(alloc); \
                                    REALLOC_ARRAY(x, alloc); \
                            } \
                    } while (0)

            /*
            * Similar to ALLOC_GROW but handles updating of the nr value and
            * zeroing the bytes of the newly-grown array elements.
            *
            * DO NOT USE any expression with side-effect for any of the
            * arguments.
            */
            #define ALLOC_GROW_BY(x, nr, increase, alloc) \
                    do { \
                            if (increase) { \
                                    size_t new_nr = nr + (increase); \
                                    if (new_nr < nr) \
                                            BUG("negative growth in ALLOC_GROW_BY"); \
                                    ALLOC_GROW(x, new_nr, alloc); \
                                    memset((x) + nr, 0, sizeof(*(x)) * (increase)); \
                                    nr = new_nr; \
                            } \
                    } while (0)

            static inline char *xstrdup_or_null(const char *str)
            {
                    return str ? xstrdup(str) : NULL;
            }

            static inline size_t xsize_t(off_t len)
            {
                    if (len < 0 || (uintmax_t) len > SIZE_MAX)
                            die("Cannot handle files this big");
                    return (size_t) len;
            }

            #ifndef HOST_NAME_MAX
            #define HOST_NAME_MAX 256
            #endif

            #include "sane-ctype.h"

            /*
            * Like skip_prefix, but compare case-insensitively. Note that the comparison
            * is done via tolower(), so it is strictly ASCII (no multi-byte characters or
            * locale-specific conversions).
            */
            static inline int skip_iprefix(const char *str, const char *prefix,
                                    const char **out)
            {
                    do {
                            if (!*prefix) {
                                    *out = str;
                                    return 1;
                            }
                    } while (tolower(*str++) == tolower(*prefix++));
                    return 0;
            }

            /*
            * Like skip_prefix_mem, but compare case-insensitively. Note that the
            * comparison is done via tolower(), so it is strictly ASCII (no multi-byte
            * characters or locale-specific conversions).
            */
            static inline int skip_iprefix_mem(const char *buf, size_t len,
                                            const char *prefix,
                                            const char **out, size_t *outlen)
            {
                    do {
                            if (!*prefix) {
                                    *out = buf;
                                    *outlen = len;
                                    return 1;
                            }
                    } while (len-- > 0 && tolower(*buf++) == tolower(*prefix++));
                    return 0;
            }

            static inline int strtoul_ui(char const *s, int base, unsigned int *result)
            {
                    unsigned long ul;
                    char *p;

                    errno = 0;
                    /* negative values would be accepted by strtoul */
                    if (strchr(s, '-'))
                            return -1;
                    ul = strtoul(s, &p, base);
                    if (errno || *p || p == s || (unsigned int) ul != ul)
                            return -1;
                    *result = ul;
                    return 0;
            }

            static inline int strtol_i(char const *s, int base, int *result)
            {
                    long ul;
                    char *p;

                    errno = 0;
                    ul = strtol(s, &p, base);
                    if (errno || *p || p == s || (int) ul != ul)
                            return -1;
                    *result = ul;
                    return 0;
            }

            void git_stable_qsort(void *base, size_t nmemb, size_t size,
                            int(*compar)(const void *, const void *));
            #ifdef INTERNAL_QSORT
            #define qsort git_stable_qsort
            #endif

            #define QSORT(base, n, compar) sane_qsort((base), (n), sizeof(*(base)), compar)
            static inline void sane_qsort(void *base, size_t nmemb, size_t size,
                                    int(*compar)(const void *, const void *))
            {
                    if (nmemb > 1)
                            qsort(base, nmemb, size, compar);
            }

            #define STABLE_QSORT(base, n, compar) \
                    git_stable_qsort((base), (n), sizeof(*(base)), compar)

            #ifndef HAVE_ISO_QSORT_S
            int git_qsort_s(void *base, size_t nmemb, size_t size,
                            int (*compar)(const void *, const void *, void *), void *ctx);
            #define qsort_s git_qsort_s
            #endif

            #define QSORT_S(base, n, compar, ctx) do {                      \
                    if (qsort_s((base), (n), sizeof(*(base)), compar, ctx)) \
                            BUG("qsort_s() failed");                        \
            } while (0)

            #ifndef REG_STARTEND
            #error "Git requires REG_STARTEND support. Compile with NO_REGEX=NeedsStartEnd"
            #endif

            static inline int regexec_buf(const regex_t *preg, const char *buf, size_t size,
                                    size_t nmatch, regmatch_t pmatch[], int eflags)
            {
                    assert(nmatch > 0 && pmatch);
                    pmatch[0].rm_so = 0;
                    pmatch[0].rm_eo = size;
                    return regexec(preg, buf, nmatch, pmatch, eflags | REG_STARTEND);
            }

            #ifdef USE_ENHANCED_BASIC_REGULAR_EXPRESSIONS
            int git_regcomp(regex_t *preg, const char *pattern, int cflags);
            #define regcomp git_regcomp
            #endif

            #ifndef DIR_HAS_BSD_GROUP_SEMANTICS
            # define FORCE_DIR_SET_GID S_ISGID
            #else
            # define FORCE_DIR_SET_GID 0
            #endif

            #ifdef NO_NSEC
            #undef USE_NSEC
            #define ST_CTIME_NSEC(st) 0
            #define ST_MTIME_NSEC(st) 0
            #else
            #ifdef USE_ST_TIMESPEC
            #define ST_CTIME_NSEC(st) ((unsigned int)((st).st_ctimespec.tv_nsec))
            #define ST_MTIME_NSEC(st) ((unsigned int)((st).st_mtimespec.tv_nsec))
            #else
            #define ST_CTIME_NSEC(st) ((unsigned int)((st).st_ctim.tv_nsec))
            #define ST_MTIME_NSEC(st) ((unsigned int)((st).st_mtim.tv_nsec))
            #endif
            #endif

            #ifdef UNRELIABLE_FSTAT
            #define fstat_is_reliable() 0
            #else
            #define fstat_is_reliable() 1
            #endif

            #ifndef va_copy
            /*
            * Since an obvious implementation of va_list would be to make it a
            * pointer into the stack frame, a simple assignment will work on
            * many systems.  But let's try to be more portable.
            */
            #ifdef __va_copy
            #define va_copy(dst, src) __va_copy(dst, src)
            #else
            #define va_copy(dst, src) ((dst) = (src))
            #endif
            #endif

            /* usage.c: only to be used for testing BUG() implementation (see test-tool) */
            extern int BUG_exit_code;

            /* usage.c: if bug() is called we should have a BUG_if_bug() afterwards */
            extern int bug_called_must_BUG;

            __attribute__((format (printf, 3, 4))) NORETURN
            void BUG_fl(const char *file, int line, const char *fmt, ...);
            #define BUG(...) BUG_fl(__FILE__, __LINE__, __VA_ARGS__)
            __attribute__((format (printf, 3, 4)))
            void bug_fl(const char *file, int line, const char *fmt, ...);
            #define bug(...) bug_fl(__FILE__, __LINE__, __VA_ARGS__)
            #define BUG_if_bug(...) do { \
                    if (bug_called_must_BUG) \
                            BUG_fl(__FILE__, __LINE__, __VA_ARGS__); \
            } while (0)

            #ifndef FSYNC_METHOD_DEFAULT
            #ifdef __APPLE__
            #define FSYNC_METHOD_DEFAULT FSYNC_METHOD_WRITEOUT_ONLY
            #else
            #define FSYNC_METHOD_DEFAULT FSYNC_METHOD_FSYNC
            #endif
            #endif

            #ifndef SHELL_PATH
            # define SHELL_PATH "/bin/sh"
            #endif

            #ifndef _POSIX_THREAD_SAFE_FUNCTIONS
            static inline void git_flockfile(FILE *fh UNUSED)
            {
                    ; /* nothing */
            }
            static inline void git_funlockfile(FILE *fh UNUSED)
            {
                    ; /* nothing */
            }
            #undef flockfile
            #undef funlockfile
            #undef getc_unlocked
            #define flockfile(fh) git_flockfile(fh)
            #define funlockfile(fh) git_funlockfile(fh)
            #define getc_unlocked(fh) getc(fh)
            #endif

            #ifdef FILENO_IS_A_MACRO
            int git_fileno(FILE *stream);
            # ifndef COMPAT_CODE_FILENO
            #  undef fileno
            #  define fileno(p) git_fileno(p)
            # endif
            #endif

            #ifdef NEED_ACCESS_ROOT_HANDLER
            int git_access(const char *path, int mode);
            # ifndef COMPAT_CODE_ACCESS
            #  ifdef access
            #  undef access
            #  endif
            #  define access(path, mode) git_access(path, mode)
            # endif
            #endif

            /*
            * Our code often opens a path to an optional file, to work on its
            * contents when we can successfully open it.  We can ignore a failure
            * to open if such an optional file does not exist, but we do want to
            * report a failure in opening for other reasons (e.g. we got an I/O
            * error, or the file is there, but we lack the permission to open).
            *
            * Call this function after seeing an error from open() or fopen() to
            * see if the errno indicates a missing file that we can safely ignore.
            */
            static inline int is_missing_file_error(int errno_)
            {
                    return (errno_ == ENOENT || errno_ == ENOTDIR);
            }

            int cmd_main(int, const char **);

            /*
            * Intercept all calls to exit() and route them to trace2 to
            * optionally emit a message before calling the real exit().
            */
            int common_exit(const char *file, int line, int code);
            #define exit(code) exit(common_exit(__FILE__, __LINE__, (code)))

            #define z_const
            #include <zlib.h>

            #if ZLIB_VERNUM < 0x1290
            /*
            * This is uncompress2, which is only available in zlib >= 1.2.9
            * (released as of early 2017). See compat/zlib-uncompress2.c.
            */
            int uncompress2(Bytef *dest, uLongf *destLen, const Bytef *source,
                            uLong *sourceLen);
            #endif

            /*
            * This include must come after system headers, since it introduces macros that
            * replace system names.
            */
            #include "banned.h"

            /*
            * container_of - Get the address of an object containing a field.
            *
            * @ptr: pointer to the field.
            * @type: type of the object.
            * @member: name of the field within the object.
            */
            #define container_of(ptr, type, member) \
                    ((type *) ((char *)(ptr) - offsetof(type, member)))

            /*
            * helper function for `container_of_or_null' to avoid multiple
            * evaluation of @ptr
            */
            static inline void *container_of_or_null_offset(void *ptr, size_t offset)
            {
                    return ptr ? (char *)ptr - offset : NULL;
            }

            /*
            * like `container_of', but allows returned value to be NULL
            */
            #define container_of_or_null(ptr, type, member) \
                    (type *)container_of_or_null_offset(ptr, offsetof(type, member))

            /*
            * like offsetof(), but takes a pointer to a variable of type which
            * contains @member, instead of a specified type.
            * @ptr is subject to multiple evaluation since we can't rely on __typeof__
            * everywhere.
            */
            #if defined(__GNUC__) /* clang sets this, too */
            #define OFFSETOF_VAR(ptr, member) offsetof(__typeof__(*ptr), member)
            #else /* !__GNUC__ */
            #define OFFSETOF_VAR(ptr, member) \
                    ((uintptr_t)&(ptr)->member - (uintptr_t)(ptr))
            #endif /* !__GNUC__ */

            #endif

            """,
            "error":"The patch resolves these conflicts by redefining the terms temporarily, allowing Git to compile
                     successfully across all platforms, including those with special handling for release and fetch.
                     It ensures that Git's functionality remains intact while avoiding platform-specific issues.",
            "Error category":"Functionality Parche",

            "Corrected Code":
            """
                            #ifndef GIT_COMPAT_UTIL_H
            #define GIT_COMPAT_UTIL_H

            #if __STDC_VERSION__ - 0 < 199901L
            /*
            * Git is in a testing period for mandatory C99 support in the compiler.  If
            * your compiler is reasonably recent, you can try to enable C99 support (or,
            * for MSVC, C11 support).  If you encounter a problem and can't enable C99
            * support with your compiler (such as with "-std=gnu99") and don't have access
            * to one with this support, such as GCC or Clang, you can remove this #if
            * directive, but please report the details of your system to
            * git@vger.kernel.org.
            */
            #error "Required C99 support is in a test phase.  Please see git-compat-util.h for more details."
            #endif

            #ifdef USE_MSVC_CRTDBG
            /*
            * For these to work they must appear very early in each
            * file -- before most of the standard header files.
            */
            #include <stdlib.h>
            #include <crtdbg.h>
            #endif

            struct strbuf;


            #define _FILE_OFFSET_BITS 64


            /* Derived from Linux "Features Test Macro" header
            * Convenience macros to test the versions of gcc (or
            * a compatible compiler).
            * Use them like this:
            *  #if GIT_GNUC_PREREQ (2,8)
            *   ... code requiring gcc 2.8 or later ...
            *  #endif
            */
            #if defined(__GNUC__) && defined(__GNUC_MINOR__)
            # define GIT_GNUC_PREREQ(maj, min) \
                    ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((maj) << 16) + (min))
            #else
            #define GIT_GNUC_PREREQ(maj, min) 0
            #endif

            #if defined(__GNUC__) || defined(__clang__)
            #  define PRAGMA(pragma)           _Pragma(#pragma)
            #  define DISABLE_WARNING(warning) PRAGMA(GCC diagnostic ignored #warning)
            #else
            #  define DISABLE_WARNING(warning)
            #endif

            #ifdef DISABLE_SIGN_COMPARE_WARNINGS
            DISABLE_WARNING(-Wsign-compare)
            #endif

            #ifndef FLEX_ARRAY
            /*
            * See if our compiler is known to support flexible array members.
            */

            /*
            * Check vendor specific quirks first, before checking the
            * __STDC_VERSION__, as vendor compilers can lie and we need to be
            * able to work them around.  Note that by not defining FLEX_ARRAY
            * here, we can fall back to use the "safer but a bit wasteful" one
            * later.
            */
            #if defined(__SUNPRO_C) && (__SUNPRO_C <= 0x580)
            #elif defined(__GNUC__)
            # if (__GNUC__ >= 3)
            #  define FLEX_ARRAY /* empty */
            # else
            #  define FLEX_ARRAY 0 /* older GNU extension */
            # endif
            #elif defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
            # define FLEX_ARRAY /* empty */
            #endif

            /*
            * Otherwise, default to safer but a bit wasteful traditional style
            */
            #ifndef FLEX_ARRAY
            # define FLEX_ARRAY 1
            #endif
            #endif


            /*
            * BUILD_ASSERT_OR_ZERO - assert a build-time dependency, as an expression.
            * @cond: the compile-time condition which must be true.
            *
            * Your compile will fail if the condition isn't true, or can't be evaluated
            * by the compiler.  This can be used in an expression: its value is "0".
            *
            * Example:
            *      #define foo_to_char(foo)                                        \
            *               ((char *)(foo)                                         \
            *                + BUILD_ASSERT_OR_ZERO(offsetof(struct foo, string) == 0))
            */
            #define BUILD_ASSERT_OR_ZERO(cond) \
                    (sizeof(char [1 - 2*!(cond)]) - 1)

            #if GIT_GNUC_PREREQ(3, 1)
            /* &arr[0] degrades to a pointer: a different type from an array */
            # define BARF_UNLESS_AN_ARRAY(arr)                                              \
                    BUILD_ASSERT_OR_ZERO(!__builtin_types_compatible_p(__typeof__(arr), \
                                                                    __typeof__(&(arr)[0])))
            # define BARF_UNLESS_COPYABLE(dst, src) \
                    BUILD_ASSERT_OR_ZERO(__builtin_types_compatible_p(__typeof__(*(dst)), \
                                                                    __typeof__(*(src))))
            #else
            # define BARF_UNLESS_AN_ARRAY(arr) 0
            # define BARF_UNLESS_COPYABLE(dst, src) \
                    BUILD_ASSERT_OR_ZERO(0 ? ((*(dst) = *(src)), 0) : \
                                            sizeof(*(dst)) == sizeof(*(src)))
            #endif
            /*
            * ARRAY_SIZE - get the number of elements in a visible array
            * @x: the array whose size you want.
            *
            * This does not work on pointers, or arrays declared as [], or
            * function parameters.  With correct compiler support, such usage
            * will cause a build error (see the build_assert_or_zero macro).
            */
            #define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]) + BARF_UNLESS_AN_ARRAY(x))

            #define bitsizeof(x)  (CHAR_BIT * sizeof(x))

            #define maximum_signed_value_of_type(a) \
            (INTMAX_MAX >> (bitsizeof(intmax_t) - bitsizeof(a)))

            #define maximum_unsigned_value_of_type(a) \
            (UINTMAX_MAX >> (bitsizeof(uintmax_t) - bitsizeof(a)))

            /*
            * Signed integer overflow is undefined in C, so here's a helper macro
            * to detect if the sum of two integers will overflow.
            *
            * Requires: a >= 0, typeof(a) equals typeof(b)
            */
            #define signed_add_overflows(a, b) \
            ((b) > maximum_signed_value_of_type(a) - (a))

            #define unsigned_add_overflows(a, b) \
            ((b) > maximum_unsigned_value_of_type(a) - (a))

            /*
            * Returns true if the multiplication of "a" and "b" will
            * overflow. The types of "a" and "b" must match and must be unsigned.
            * Note that this macro evaluates "a" twice!
            */
            #define unsigned_mult_overflows(a, b) \
            ((a) && (b) > maximum_unsigned_value_of_type(a) / (a))

            /*
            * Returns true if the left shift of "a" by "shift" bits will
            * overflow. The type of "a" must be unsigned.
            */
            #define unsigned_left_shift_overflows(a, shift) \
            ((shift) < bitsizeof(a) && \
            (a) > maximum_unsigned_value_of_type(a) >> (shift))

            #ifdef __GNUC__
            #define TYPEOF(x) (__typeof__(x))
            #else
            #define TYPEOF(x)
            #endif

            #define MSB(x, bits) ((x) & TYPEOF(x)(~0ULL << (bitsizeof(x) - (bits))))
            #define HAS_MULTI_BITS(i)  ((i) & ((i) - 1))  /* checks if an integer has more than 1 bit set */

            #define DIV_ROUND_UP(n,d) (((n) + (d) - 1) / (d))

            /* Approximation of the length of the decimal representation of this type. */
            #define decimal_length(x)       ((int)(sizeof(x) * 2.56 + 0.5) + 1)

            #ifdef __MINGW64__
            #define _POSIX_C_SOURCE 1
            #elif defined(__sun__)
            /*
            * On Solaris, when _XOPEN_EXTENDED is set, its header file
            * forces the programs to be XPG4v2, defeating any _XOPEN_SOURCE
            * setting to say we are XPG5 or XPG6.  Also on Solaris,
            * XPG6 programs must be compiled with a c99 compiler, while
            * non XPG6 programs must be compiled with a pre-c99 compiler.
            */
            # if __STDC_VERSION__ - 0 >= 199901L
            # define _XOPEN_SOURCE 600
            # else
            # define _XOPEN_SOURCE 500
            # endif
            #elif !defined(__APPLE__) && !defined(__FreeBSD__) && !defined(__USLC__) && \
            !defined(_M_UNIX) && !defined(__sgi) && !defined(__DragonFly__) && \
            !defined(__TANDEM) && !defined(__QNX__) && !defined(__MirBSD__) && \
            !defined(__CYGWIN__)
            #define _XOPEN_SOURCE 600 /* glibc2 and AIX 5.3L need 500, OpenBSD needs 600 for S_ISLNK() */
            #define _XOPEN_SOURCE_EXTENDED 1 /* AIX 5.3L needs this */
            #endif
            #define _ALL_SOURCE 1
            #define _GNU_SOURCE 1
            #define _BSD_SOURCE 1
            #define _DEFAULT_SOURCE 1
            #define _NETBSD_SOURCE 1
            #define _SGI_SOURCE 1

            /*
            * UNUSED marks a function parameter that is always unused.  It also
            * can be used to annotate a function, a variable, or a type that is
            * always unused.
            *
            * A callback interface may dictate that a function accepts a
            * parameter at that position, but the implementation of the function
            * may not need to use the parameter.  In such a case, mark the parameter
            * with UNUSED.
            *
            * When a parameter may be used or unused, depending on conditional
            * compilation, consider using MAYBE_UNUSED instead.
            */
            #if GIT_GNUC_PREREQ(4, 5)
            #define UNUSED __attribute__((unused)) \
                    __attribute__((deprecated ("parameter declared as UNUSED")))
            #elif defined(__GNUC__)
            #define UNUSED __attribute__((unused)) \
                    __attribute__((deprecated))
            #else
            #define UNUSED
            #endif

            #if defined(WIN32) && !defined(__CYGWIN__) /* Both MinGW and MSVC */
            # if !defined(_WIN32_WINNT)
            #  define _WIN32_WINNT 0x0600
            # endif
            #define WIN32_LEAN_AND_MEAN  /* stops windows.h including winsock.h */
            #include <winsock2.h>
            #ifndef NO_UNIX_SOCKETS
            #include <afunix.h>
            #endif
            #include <windows.h>
            #define GIT_WINDOWS_NATIVE
            #endif

            #if defined(NO_UNIX_SOCKETS) || !defined(GIT_WINDOWS_NATIVE)
            static inline int _have_unix_sockets(void)
            {
            #if defined(NO_UNIX_SOCKETS)
                    return 0;
            #else
                    return 1;
            #endif
            }
            #define have_unix_sockets _have_unix_sockets
            #endif

            #include <unistd.h>
            #include <stdio.h>
            #include <sys/stat.h>
            #include <fcntl.h>
            #include <stddef.h>
            #define release stdlib_release
            #define fetch stdlib_fetch
            #include <stdlib.h>
            #undef fetch
            #undef release
            #include <stdarg.h>
            #include <stdbool.h>
            #include <string.h>
            #ifdef HAVE_STRINGS_H
            #include <strings.h> /* for strcasecmp() */
            #endif
            #include <errno.h>
            #include <limits.h>
            #include <locale.h>
            #ifdef NEEDS_SYS_PARAM_H
            #include <sys/param.h>
            #endif
            #include <sys/types.h>
            #include <dirent.h>
            #include <sys/time.h>
            #include <time.h>
            #include <signal.h>
            #include <assert.h>
            #include <regex.h>
            #include <utime.h>
            #include <syslog.h>
            #if !defined(NO_POLL_H)
            #include <poll.h>
            #elif !defined(NO_SYS_POLL_H)
            #include <sys/poll.h>
            #else
            /* Pull the compat stuff */
            #include <poll.h>
            #endif
            #ifdef HAVE_BSD_SYSCTL
            #include <sys/sysctl.h>
            #endif

            /* Used by compat/win32/path-utils.h, and more */
            static inline int is_xplatform_dir_sep(int c)
            {
                    return c == '/' || c == '\\';
            }

            #if defined(__CYGWIN__)
            #include "compat/win32/path-utils.h"
            #endif
            #if defined(__MINGW32__)
            /* pull in Windows compatibility stuff */
            #include "compat/win32/path-utils.h"
            #include "compat/mingw.h"
            #elif defined(_MSC_VER)
            #include "compat/win32/path-utils.h"
            #include "compat/msvc.h"
            #else
            #include <sys/utsname.h>
            #include <sys/wait.h>
            #include <sys/resource.h>
            #include <sys/socket.h>
            #include <sys/ioctl.h>
            #include <sys/statvfs.h>
            #include <termios.h>
            #ifndef NO_SYS_SELECT_H
            #include <sys/select.h>
            #endif
            #include <netinet/in.h>
            #include <netinet/tcp.h>
            #include <arpa/inet.h>
            #include <netdb.h>
            #include <pwd.h>
            #include <sys/un.h>
            #ifndef NO_INTTYPES_H
            #include <inttypes.h>
            #else
            #include <stdint.h>
            #endif
            #ifdef HAVE_ARC4RANDOM_LIBBSD
            #include <bsd/stdlib.h>
            #endif
            #ifdef HAVE_GETRANDOM
            #include <sys/random.h>
            #endif
            #ifdef NO_INTPTR_T
            /*
            * On I16LP32, ILP32 and LP64 "long" is the safe bet, however
            * on LLP86, IL33LLP64 and P64 it needs to be "long long",
            * while on IP16 and IP16L32 it is "int" (resp. "short")
            * Size needs to match (or exceed) 'sizeof(void *)'.
            * We can't take "long long" here as not everybody has it.
            */
            typedef long intptr_t;
            typedef unsigned long uintptr_t;
            #endif
            #undef _ALL_SOURCE /* AIX 5.3L defines a struct list with _ALL_SOURCE. */
            #include <grp.h>
            #define _ALL_SOURCE 1
            #endif

            /* used on Mac OS X */
            #ifdef PRECOMPOSE_UNICODE
            #include "compat/precompose_utf8.h"
            #else
            static inline const char *precompose_argv_prefix(int argc UNUSED,
                                                            const char **argv UNUSED,
                                                            const char *prefix)
            {
                    return prefix;
            }
            static inline const char *precompose_string_if_needed(const char *in)
            {
                    return in;
            }

            #define probe_utf8_pathname_composition()
            #endif

            #ifdef MKDIR_WO_TRAILING_SLASH
            #define mkdir(a,b) compat_mkdir_wo_trailing_slash((a),(b))
            int compat_mkdir_wo_trailing_slash(const char*, mode_t);
            #endif

            #ifdef time
            #undef time
            #endif
            static inline time_t git_time(time_t *tloc)
            {
                    struct timeval tv;

                    /*
                    * Avoid time(NULL), which can disagree with gettimeofday(2)
                    * and filesystem timestamps.
                    */
                    gettimeofday(&tv, NULL);

                    if (tloc)
                            *tloc = tv.tv_sec;
                    return tv.tv_sec;
            }
            #define time git_time

            #ifdef NO_STRUCT_ITIMERVAL
            struct itimerval {
                    struct timeval it_interval;
                    struct timeval it_value;
            };
            #endif

            #ifdef NO_SETITIMER
            static inline int git_setitimer(int which UNUSED,
                                            const struct itimerval *value UNUSED,
                                            struct itimerval *newvalue UNUSED) {
                    return 0; /* pretend success */
            }
            #undef setitimer
            #define setitimer(which,value,ovalue) git_setitimer(which,value,ovalue)
            #endif

            #ifndef NO_LIBGEN_H
            #include <libgen.h>
            #else
            #define basename gitbasename
            char *gitbasename(char *);
            #define dirname gitdirname
            char *gitdirname(char *);
            #endif

            #ifndef NO_ICONV
            #include <iconv.h>
            #endif

            #ifndef NO_OPENSSL
            #ifdef __APPLE__
            #undef __AVAILABILITY_MACROS_USES_AVAILABILITY
            #define __AVAILABILITY_MACROS_USES_AVAILABILITY 0
            #include <AvailabilityMacros.h>
            #undef DEPRECATED_ATTRIBUTE
            #define DEPRECATED_ATTRIBUTE
            #undef __AVAILABILITY_MACROS_USES_AVAILABILITY
            #endif
            #include <openssl/ssl.h>
            #include <openssl/err.h>
            #endif

            #ifdef HAVE_SYSINFO
            # include <sys/sysinfo.h>
            #endif

            /* On most systems <netdb.h> would have given us this, but
            * not on some systems (e.g. z/OS).
            */
            #ifndef NI_MAXHOST
            #define NI_MAXHOST 1025
            #endif

            #ifndef NI_MAXSERV
            #define NI_MAXSERV 32
            #endif

            /* On most systems <limits.h> would have given us this, but
            * not on some systems (e.g. GNU/Hurd).
            */
            #ifndef PATH_MAX
            #define PATH_MAX 4096
            #endif

            #ifndef NAME_MAX
            #define NAME_MAX 255
            #endif

            typedef uintmax_t timestamp_t;
            #define PRItime PRIuMAX
            #define parse_timestamp strtoumax
            #define TIME_MAX UINTMAX_MAX
            #define TIME_MIN 0

            #ifndef PATH_SEP
            #define PATH_SEP ':'
            #endif

            #ifdef HAVE_PATHS_H
            #include <paths.h>
            #endif
            #ifndef _PATH_DEFPATH
            #define _PATH_DEFPATH "/usr/local/bin:/usr/bin:/bin"
            #endif

            #ifndef platform_core_config
            struct config_context;
            static inline int noop_core_config(const char *var UNUSED,
                                            const char *value UNUSED,
                                            const struct config_context *ctx UNUSED,
                                            void *cb UNUSED)
            {
                    return 0;
            }
            #define platform_core_config noop_core_config
            #endif

            int lstat_cache_aware_rmdir(const char *path);
            #if !defined(__MINGW32__) && !defined(_MSC_VER)
            #define rmdir lstat_cache_aware_rmdir
            #endif

            #ifndef has_dos_drive_prefix
            static inline int git_has_dos_drive_prefix(const char *path UNUSED)
            {
                    return 0;
            }
            #define has_dos_drive_prefix git_has_dos_drive_prefix
            #endif

            #ifndef skip_dos_drive_prefix
            static inline int git_skip_dos_drive_prefix(char **path UNUSED)
            {
                    return 0;
            }
            #define skip_dos_drive_prefix git_skip_dos_drive_prefix
            #endif

            static inline int git_is_dir_sep(int c)
            {
                    return c == '/';
            }
            #ifndef is_dir_sep
            #define is_dir_sep git_is_dir_sep
            #endif

            #ifndef offset_1st_component
            static inline int git_offset_1st_component(const char *path)
            {
                    return is_dir_sep(path[0]);
            }
            #define offset_1st_component git_offset_1st_component
            #endif

            #ifndef fspathcmp
            #define fspathcmp git_fspathcmp
            #endif

            #ifndef fspathncmp
            #define fspathncmp git_fspathncmp
            #endif

            #ifndef is_valid_path
            #define is_valid_path(path) 1
            #endif

            #ifndef is_path_owned_by_current_user

            #ifdef __TANDEM
            #define ROOT_UID 65535
            #else
            #define ROOT_UID 0
            #endif

            /*
            * Do not use this function when
            * (1) geteuid() did not say we are running as 'root', or
            * (2) using this function will compromise the system.
            *
            * PORTABILITY WARNING:
            * This code assumes uid_t is unsigned because that is what sudo does.
            * If your uid_t type is signed and all your ids are positive then it
            * should all work fine.
            * If your version of sudo uses negative values for uid_t or it is
            * buggy and return an overflowed value in SUDO_UID, then git might
            * fail to grant access to your repository properly or even mistakenly
            * grant access to someone else.
            * In the unlikely scenario this happened to you, and that is how you
            * got to this message, we would like to know about it; so sent us an
            * email to git@vger.kernel.org indicating which platform you are
            * using and which version of sudo, so we can improve this logic and
            * maybe provide you with a patch that would prevent this issue again
            * in the future.
            */
            static inline void extract_id_from_env(const char *env, uid_t *id)
            {
                    const char *real_uid = getenv(env);

                    /* discard anything empty to avoid a more complex check below */
                    if (real_uid && *real_uid) {
                            char *endptr = NULL;
                            unsigned long env_id;

                            errno = 0;
                            /* silent overflow errors could trigger a bug here */
                            env_id = strtoul(real_uid, &endptr, 10);
                            if (!*endptr && !errno)
                                    *id = env_id;
                    }
            }

            static inline int is_path_owned_by_current_uid(const char *path,
                                                    struct strbuf *report UNUSED)
            {
                    struct stat st;
                    uid_t euid;

                    if (lstat(path, &st))
                            return 0;

                    euid = geteuid();
                    if (euid == ROOT_UID)
                    {
                            if (st.st_uid == ROOT_UID)
                                    return 1;
                            else
                                    extract_id_from_env("SUDO_UID", &euid);
                    }

                    return st.st_uid == euid;
            }

            #define is_path_owned_by_current_user is_path_owned_by_current_uid
            #endif

            #ifndef find_last_dir_sep
            static inline char *git_find_last_dir_sep(const char *path)
            {
                    return strrchr(path, '/');
            }
            #define find_last_dir_sep git_find_last_dir_sep
            #endif

            #ifndef has_dir_sep
            static inline int git_has_dir_sep(const char *path)
            {
                    return !!strchr(path, '/');
            }
            #define has_dir_sep(path) git_has_dir_sep(path)
            #endif

            #ifndef query_user_email
            #define query_user_email() NULL
            #endif

            #ifdef __TANDEM
            #include <floss.h(floss_execl,floss_execlp,floss_execv,floss_execvp)>
            #include <floss.h(floss_getpwuid)>
            #ifndef NSIG
            /*
            * NonStop NSE and NSX do not provide NSIG. SIGGUARDIAN(99) is the highest
            * known, by detective work using kill -l as a list is all signals
            * instead of signal.h where it should be.
            */
            # define NSIG 100
            #endif
            #endif

            #if defined(__HP_cc) && (__HP_cc >= 61000)
            #define NORETURN __attribute__((noreturn))
            #define NORETURN_PTR
            #elif defined(__GNUC__) && !defined(NO_NORETURN)
            #define NORETURN __attribute__((__noreturn__))
            #define NORETURN_PTR __attribute__((__noreturn__))
            #elif defined(_MSC_VER)
            #define NORETURN __declspec(noreturn)
            #define NORETURN_PTR
            #else
            #define NORETURN
            #define NORETURN_PTR
            #ifndef __GNUC__
            #ifndef __attribute__
            #define __attribute__(x)
            #endif
            #endif
            #endif

            /* The sentinel attribute is valid from gcc version 4.0 */
            #if defined(__GNUC__) && (__GNUC__ >= 4)
            #define LAST_ARG_MUST_BE_NULL __attribute__((sentinel))
            /* warn_unused_result exists as of gcc 3.4.0, but be lazy and check 4.0 */
            #define RESULT_MUST_BE_USED __attribute__ ((warn_unused_result))
            #else
            #define LAST_ARG_MUST_BE_NULL
            #define RESULT_MUST_BE_USED
            #endif

            /*
            * MAYBE_UNUSED marks a function parameter that may be unused, but
            * whose use is not an error.  It also can be used to annotate a
            * function, a variable, or a type that may be unused.
            *
            * Depending on a configuration, all uses of such a thing may become
            * #ifdef'ed away.  Marking it with UNUSED would give a warning in a
            * compilation where it is indeed used, and not marking it at all
            * would give a warning in a compilation where it is unused.  In such
            * a case, MAYBE_UNUSED is the appropriate annotation to use.
            */
            #define MAYBE_UNUSED __attribute__((__unused__))

            #include "compat/bswap.h"

            #include "wrapper.h"

            /* General helper functions */
            NORETURN void usage(const char *err);
            NORETURN void usagef(const char *err, ...) __attribute__((format (printf, 1, 2)));
            NORETURN void die(const char *err, ...) __attribute__((format (printf, 1, 2)));
            NORETURN void die_errno(const char *err, ...) __attribute__((format (printf, 1, 2)));
            int die_message(const char *err, ...) __attribute__((format (printf, 1, 2)));
            int die_message_errno(const char *err, ...) __attribute__((format (printf, 1, 2)));
            int error(const char *err, ...) __attribute__((format (printf, 1, 2)));
            int error_errno(const char *err, ...) __attribute__((format (printf, 1, 2)));
            void warning(const char *err, ...) __attribute__((format (printf, 1, 2)));
            void warning_errno(const char *err, ...) __attribute__((format (printf, 1, 2)));

            #ifndef NO_OPENSSL
            #ifdef APPLE_COMMON_CRYPTO
            #include "compat/apple-common-crypto.h"
            #else
            #include <openssl/evp.h>
            #include <openssl/hmac.h>
            #endif /* APPLE_COMMON_CRYPTO */
            #include <openssl/x509v3.h>
            #endif /* NO_OPENSSL */

            #ifdef HAVE_OPENSSL_CSPRNG
            #include <openssl/rand.h>
            #endif

            /*
            * Let callers be aware of the constant return value; this can help
            * gcc with -Wuninitialized analysis. We restrict this trick to gcc, though,
            * because other compilers may be confused by this.
            */
            #if defined(__GNUC__)
            static inline int const_error(void)
            {
                    return -1;
            }
            #define error(...) (error(__VA_ARGS__), const_error())
            #define error_errno(...) (error_errno(__VA_ARGS__), const_error())
            #endif

            typedef void (*report_fn)(const char *, va_list params);

            void set_die_routine(NORETURN_PTR report_fn routine);
            report_fn get_die_message_routine(void);
            void set_error_routine(report_fn routine);
            report_fn get_error_routine(void);
            void set_warn_routine(report_fn routine);
            report_fn get_warn_routine(void);
            void set_die_is_recursing_routine(int (*routine)(void));

            /*
            * If the string "str" begins with the string found in "prefix", return true.
            * The "out" parameter is set to "str + strlen(prefix)" (i.e., to the point in
            * the string right after the prefix).
            *
            * Otherwise, return false and leave "out" untouched.
            *
            * Examples:
            *
            *   [extract branch name, fail if not a branch]
            *   if (!skip_prefix(ref, "refs/heads/", &branch)
            *      return -1;
            *
            *   [skip prefix if present, otherwise use whole string]
            *   skip_prefix(name, "refs/heads/", &name);
            */
            static inline bool skip_prefix(const char *str, const char *prefix,
                                    const char **out)
            {
                    do {
                            if (!*prefix) {
                                    *out = str;
                                    return true;
                            }
                    } while (*str++ == *prefix++);
                    return false;
            }

            /*
            * Like skip_prefix, but promises never to read past "len" bytes of the input
            * buffer, and returns the remaining number of bytes in "out" via "outlen".
            */
            static inline bool skip_prefix_mem(const char *buf, size_t len,
                                            const char *prefix,
                                            const char **out, size_t *outlen)
            {
                    size_t prefix_len = strlen(prefix);
                    if (prefix_len <= len && !memcmp(buf, prefix, prefix_len)) {
                            *out = buf + prefix_len;
                            *outlen = len - prefix_len;
                            return true;
                    }
                    return false;
            }

            /*
            * If buf ends with suffix, return true and subtract the length of the suffix
            * from *len. Otherwise, return false and leave *len untouched.
            */
            static inline bool strip_suffix_mem(const char *buf, size_t *len,
                                            const char *suffix)
            {
                    size_t suflen = strlen(suffix);
                    if (*len < suflen || memcmp(buf + (*len - suflen), suffix, suflen))
                            return false;
                    *len -= suflen;
                    return true;
            }

            /*
            * If str ends with suffix, return true and set *len to the size of the string
            * without the suffix. Otherwise, return false and set *len to the size of the
            * string.
            *
            * Note that we do _not_ NUL-terminate str to the new length.
            */
            static inline bool strip_suffix(const char *str, const char *suffix,
                                            size_t *len)
            {
                    *len = strlen(str);
                    return strip_suffix_mem(str, len, suffix);
            }

            #define SWAP(a, b) do {                                         \
                    void *_swap_a_ptr = &(a);                               \
                    void *_swap_b_ptr = &(b);                               \
                    unsigned char _swap_buffer[sizeof(a)];                  \
                    memcpy(_swap_buffer, _swap_a_ptr, sizeof(a));           \
                    memcpy(_swap_a_ptr, _swap_b_ptr, sizeof(a) +            \
                    BUILD_ASSERT_OR_ZERO(sizeof(a) == sizeof(b)));   \
                    memcpy(_swap_b_ptr, _swap_buffer, sizeof(a));           \
            } while (0)

            #if defined(NO_MMAP) || defined(USE_WIN32_MMAP)

            #ifndef PROT_READ
            #define PROT_READ 1
            #define PROT_WRITE 2
            #define MAP_PRIVATE 1
            #endif

            #define mmap git_mmap
            #define munmap git_munmap
            void *git_mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);
            int git_munmap(void *start, size_t length);

            #else /* NO_MMAP || USE_WIN32_MMAP */

            #include <sys/mman.h>

            #endif /* NO_MMAP || USE_WIN32_MMAP */

            #ifdef NO_MMAP

            /* This value must be multiple of (pagesize * 2) */
            #define DEFAULT_PACKED_GIT_WINDOW_SIZE (1 * 1024 * 1024)

            #else /* NO_MMAP */

            /* This value must be multiple of (pagesize * 2) */
            #define DEFAULT_PACKED_GIT_WINDOW_SIZE \
                    (sizeof(void*) >= 8 \
                            ?  1 * 1024 * 1024 * 1024 \
                            : 32 * 1024 * 1024)

            #endif /* NO_MMAP */

            #ifndef MAP_FAILED
            #define MAP_FAILED ((void *)-1)
            #endif

            #ifdef NO_ST_BLOCKS_IN_STRUCT_STAT
            #define on_disk_bytes(st) ((st).st_size)
            #else
            #define on_disk_bytes(st) ((st).st_blocks * 512)
            #endif

            #ifdef NEEDS_MODE_TRANSLATION
            #undef S_IFMT
            #undef S_IFREG
            #undef S_IFDIR
            #undef S_IFLNK
            #undef S_IFBLK
            #undef S_IFCHR
            #undef S_IFIFO
            #undef S_IFSOCK
            #define S_IFMT   0170000
            #define S_IFREG  0100000
            #define S_IFDIR  0040000
            #define S_IFLNK  0120000
            #define S_IFBLK  0060000
            #define S_IFCHR  0020000
            #define S_IFIFO  0010000
            #define S_IFSOCK 0140000
            #ifdef stat
            #undef stat
            #endif
            #define stat(path, buf) git_stat(path, buf)
            int git_stat(const char *, struct stat *);
            #ifdef fstat
            #undef fstat
            #endif
            #define fstat(fd, buf) git_fstat(fd, buf)
            int git_fstat(int, struct stat *);
            #ifdef lstat
            #undef lstat
            #endif
            #define lstat(path, buf) git_lstat(path, buf)
            int git_lstat(const char *, struct stat *);
            #endif

            #define DEFAULT_PACKED_GIT_LIMIT \
                    ((1024L * 1024L) * (size_t)(sizeof(void*) >= 8 ? (32 * 1024L * 1024L) : 256))

            #ifdef NO_PREAD
            #define pread git_pread
            ssize_t git_pread(int fd, void *buf, size_t count, off_t offset);
            #endif

            #ifdef NO_SETENV
            #define setenv gitsetenv
            int gitsetenv(const char *, const char *, int);
            #endif

            #ifdef NO_MKDTEMP
            #define mkdtemp gitmkdtemp
            char *gitmkdtemp(char *);
            #endif

            #ifdef NO_UNSETENV
            #define unsetenv gitunsetenv
            int gitunsetenv(const char *);
            #endif

            #ifdef NO_STRCASESTR
            #define strcasestr gitstrcasestr
            char *gitstrcasestr(const char *haystack, const char *needle);
            #endif

            #ifdef NO_STRLCPY
            #define strlcpy gitstrlcpy
            size_t gitstrlcpy(char *, const char *, size_t);
            #endif

            #ifdef NO_STRTOUMAX
            #define strtoumax gitstrtoumax
            uintmax_t gitstrtoumax(const char *, char **, int);
            #define strtoimax gitstrtoimax
            intmax_t gitstrtoimax(const char *, char **, int);
            #endif

            #ifdef NO_HSTRERROR
            #define hstrerror githstrerror
            const char *githstrerror(int herror);
            #endif

            #ifdef NO_MEMMEM
            #define memmem gitmemmem
            void *gitmemmem(const void *haystack, size_t haystacklen,
                            const void *needle, size_t needlelen);
            #endif

            #ifdef OVERRIDE_STRDUP
            #ifdef strdup
            #undef strdup
            #endif
            #define strdup gitstrdup
            char *gitstrdup(const char *s);
            #endif

            #ifdef NO_GETPAGESIZE
            #define getpagesize() sysconf(_SC_PAGESIZE)
            #endif

            #ifndef O_CLOEXEC
            #define O_CLOEXEC 0
            #endif

            #ifdef FREAD_READS_DIRECTORIES
            # if !defined(SUPPRESS_FOPEN_REDEFINITION)
            #  ifdef fopen
            #   undef fopen
            #  endif
            #  define fopen(a,b) git_fopen(a,b)
            # endif
            FILE *git_fopen(const char*, const char*);
            #endif

            #ifdef SNPRINTF_RETURNS_BOGUS
            #ifdef snprintf
            #undef snprintf
            #endif
            #define snprintf git_snprintf
            int git_snprintf(char *str, size_t maxsize,
                            const char *format, ...);
            #ifdef vsnprintf
            #undef vsnprintf
            #endif
            #define vsnprintf git_vsnprintf
            int git_vsnprintf(char *str, size_t maxsize,
                            const char *format, va_list ap);
            #endif

            #ifdef OPEN_RETURNS_EINTR
            #undef open
            #define open git_open_with_retry
            int git_open_with_retry(const char *path, int flag, ...);
            #endif

            #ifdef __GLIBC_PREREQ
            #if __GLIBC_PREREQ(2, 1)
            #define HAVE_STRCHRNUL
            #endif
            #endif

            #ifndef HAVE_STRCHRNUL
            #define strchrnul gitstrchrnul
            static inline char *gitstrchrnul(const char *s, int c)
            {
                    while (*s && *s != c)
                            s++;
                    return (char *)s;
            }
            #endif

            #ifdef NO_INET_PTON
            int inet_pton(int af, const char *src, void *dst);
            #endif

            #ifdef NO_INET_NTOP
            const char *inet_ntop(int af, const void *src, char *dst, size_t size);
            #endif

            #ifdef NO_PTHREADS
            #define atexit git_atexit
            int git_atexit(void (*handler)(void));
            #endif

            static inline size_t st_add(size_t a, size_t b)
            {
                    if (unsigned_add_overflows(a, b))
                            die("size_t overflow: %"PRIuMAX" + %"PRIuMAX,
                            (uintmax_t)a, (uintmax_t)b);
                    return a + b;
            }
            #define st_add3(a,b,c)   st_add(st_add((a),(b)),(c))
            #define st_add4(a,b,c,d) st_add(st_add3((a),(b),(c)),(d))

            static inline size_t st_mult(size_t a, size_t b)
            {
                    if (unsigned_mult_overflows(a, b))
                            die("size_t overflow: %"PRIuMAX" * %"PRIuMAX,
                            (uintmax_t)a, (uintmax_t)b);
                    return a * b;
            }

            static inline size_t st_sub(size_t a, size_t b)
            {
                    if (a < b)
                            die("size_t underflow: %"PRIuMAX" - %"PRIuMAX,
                            (uintmax_t)a, (uintmax_t)b);
                    return a - b;
            }

            static inline size_t st_left_shift(size_t a, unsigned shift)
            {
                    if (unsigned_left_shift_overflows(a, shift))
                            die("size_t overflow: %"PRIuMAX" << %u",
                            (uintmax_t)a, shift);
                    return a << shift;
            }

            static inline unsigned long cast_size_t_to_ulong(size_t a)
            {
                    if (a != (unsigned long)a)
                            die("object too large to read on this platform: %"
                            PRIuMAX" is cut off to %lu",
                            (uintmax_t)a, (unsigned long)a);
                    return (unsigned long)a;
            }

            static inline uint32_t cast_size_t_to_uint32_t(size_t a)
            {
                    if (a != (uint32_t)a)
                            die("object too large to read on this platform: %"
                            PRIuMAX" is cut off to %u",
                            (uintmax_t)a, (uint32_t)a);
                    return (uint32_t)a;
            }

            static inline int cast_size_t_to_int(size_t a)
            {
                    if (a > INT_MAX)
                            die("number too large to represent as int on this platform: %"PRIuMAX,
                            (uintmax_t)a);
                    return (int)a;
            }

            /*
            * Limit size of IO chunks, because huge chunks only cause pain.  OS X
            * 64-bit is buggy, returning EINVAL if len >= INT_MAX; and even in
            * the absence of bugs, large chunks can result in bad latencies when
            * you decide to kill the process.
            *
            * We pick 8 MiB as our default, but if the platform defines SSIZE_MAX
            * that is smaller than that, clip it to SSIZE_MAX, as a call to
            * read(2) or write(2) larger than that is allowed to fail.  As the last
            * resort, we allow a port to pass via CFLAGS e.g. "-DMAX_IO_SIZE=value"
            * to override this, if the definition of SSIZE_MAX given by the platform
            * is broken.
            */
            #ifndef MAX_IO_SIZE
            # define MAX_IO_SIZE_DEFAULT (8*1024*1024)
            # if defined(SSIZE_MAX) && (SSIZE_MAX < MAX_IO_SIZE_DEFAULT)
            #  define MAX_IO_SIZE SSIZE_MAX
            # else
            #  define MAX_IO_SIZE MAX_IO_SIZE_DEFAULT
            # endif
            #endif

            #ifdef HAVE_ALLOCA_H
            # include <alloca.h>
            # define xalloca(size)      (alloca(size))
            # define xalloca_free(p)    do {} while (0)
            #else
            # define xalloca(size)      (xmalloc(size))
            # define xalloca_free(p)    (free(p))
            #endif

            /*
            * FREE_AND_NULL(ptr) is like free(ptr) followed by ptr = NULL. Note
            * that ptr is used twice, so don't pass e.g. ptr++.
            */
            #define FREE_AND_NULL(p) do { free(p); (p) = NULL; } while (0)

            #define ALLOC_ARRAY(x, alloc) (x) = xmalloc(st_mult(sizeof(*(x)), (alloc)))
            #define CALLOC_ARRAY(x, alloc) (x) = xcalloc((alloc), sizeof(*(x)))
            #define REALLOC_ARRAY(x, alloc) (x) = xrealloc((x), st_mult(sizeof(*(x)), (alloc)))

            #define COPY_ARRAY(dst, src, n) copy_array((dst), (src), (n), sizeof(*(dst)) + \
                    BARF_UNLESS_COPYABLE((dst), (src)))
            static inline void copy_array(void *dst, const void *src, size_t n, size_t size)
            {
                    if (n)
                            memcpy(dst, src, st_mult(size, n));
            }

            #define MOVE_ARRAY(dst, src, n) move_array((dst), (src), (n), sizeof(*(dst)) + \
                    BARF_UNLESS_COPYABLE((dst), (src)))
            static inline void move_array(void *dst, const void *src, size_t n, size_t size)
            {
                    if (n)
                            memmove(dst, src, st_mult(size, n));
            }

            #define DUP_ARRAY(dst, src, n) do { \
                    size_t dup_array_n_ = (n); \
                    COPY_ARRAY(ALLOC_ARRAY((dst), dup_array_n_), (src), dup_array_n_); \
            } while (0)

            /*
            * These functions help you allocate structs with flex arrays, and copy
            * the data directly into the array. For example, if you had:
            *
            *   struct foo {
            *     int bar;
            *     char name[FLEX_ARRAY];
            *   };
            *
            * you can do:
            *
            *   struct foo *f;
            *   FLEX_ALLOC_MEM(f, name, src, len);
            *
            * to allocate a "foo" with the contents of "src" in the "name" field.
            * The resulting struct is automatically zero'd, and the flex-array field
            * is NUL-terminated (whether the incoming src buffer was or not).
            *
            * The FLEXPTR_* variants operate on structs that don't use flex-arrays,
            * but do want to store a pointer to some extra data in the same allocated
            * block. For example, if you have:
            *
            *   struct foo {
            *     char *name;
            *     int bar;
            *   };
            *
            * you can do:
            *
            *   struct foo *f;
            *   FLEXPTR_ALLOC_STR(f, name, src);
            *
            * and "name" will point to a block of memory after the struct, which will be
            * freed along with the struct (but the pointer can be repointed anywhere).
            *
            * The *_STR variants accept a string parameter rather than a ptr/len
            * combination.
            *
            * Note that these macros will evaluate the first parameter multiple
            * times, and it must be assignable as an lvalue.
            */
            #define FLEX_ALLOC_MEM(x, flexname, buf, len) do { \
                    size_t flex_array_len_ = (len); \
                    (x) = xcalloc(1, st_add3(sizeof(*(x)), flex_array_len_, 1)); \
                    memcpy((void *)(x)->flexname, (buf), flex_array_len_); \
            } while (0)
            #define FLEXPTR_ALLOC_MEM(x, ptrname, buf, len) do { \
                    size_t flex_array_len_ = (len); \
                    (x) = xcalloc(1, st_add3(sizeof(*(x)), flex_array_len_, 1)); \
                    memcpy((x) + 1, (buf), flex_array_len_); \
                    (x)->ptrname = (void *)((x)+1); \
            } while(0)
            #define FLEX_ALLOC_STR(x, flexname, str) \
                    FLEX_ALLOC_MEM((x), flexname, (str), strlen(str))
            #define FLEXPTR_ALLOC_STR(x, ptrname, str) \
                    FLEXPTR_ALLOC_MEM((x), ptrname, (str), strlen(str))

            #define alloc_nr(x) (((x)+16)*3/2)

            /**
            * Dynamically growing an array using realloc() is error prone and boring.
            *
            * Define your array with:
            *
            * - a pointer (`item`) that points at the array, initialized to `NULL`
            *   (although please name the variable based on its contents, not on its
            *   type);
            *
            * - an integer variable (`alloc`) that keeps track of how big the current
            *   allocation is, initialized to `0`;
            *
            * - another integer variable (`nr`) to keep track of how many elements the
            *   array currently has, initialized to `0`.
            *
            * Then before adding `n`th element to the item, call `ALLOC_GROW(item, n,
            * alloc)`.  This ensures that the array can hold at least `n` elements by
            * calling `realloc(3)` and adjusting `alloc` variable.
            *
            * ------------
            * sometype *item;
            * size_t nr;
            * size_t alloc
            *
            * for (i = 0; i < nr; i++)
            *      if (we like item[i] already)
            *              return;
            *
            * // we did not like any existing one, so add one
            * ALLOC_GROW(item, nr + 1, alloc);
            * item[nr++] = value you like;
            * ------------
            *
            * You are responsible for updating the `nr` variable.
            *
            * If you need to specify the number of elements to allocate explicitly
            * then use the macro `REALLOC_ARRAY(item, alloc)` instead of `ALLOC_GROW`.
            *
            * Consider using ALLOC_GROW_BY instead of ALLOC_GROW as it has some
            * added niceties.
            *
            * DO NOT USE any expression with side-effect for 'x', 'nr', or 'alloc'.
            */
            #define ALLOC_GROW(x, nr, alloc) \
                    do { \
                            if ((nr) > alloc) { \
                                    if (alloc_nr(alloc) < (nr)) \
                                            alloc = (nr); \
                                    else \
                                            alloc = alloc_nr(alloc); \
                                    REALLOC_ARRAY(x, alloc); \
                            } \
                    } while (0)

            /*
            * Similar to ALLOC_GROW but handles updating of the nr value and
            * zeroing the bytes of the newly-grown array elements.
            *
            * DO NOT USE any expression with side-effect for any of the
            * arguments.
            */
            #define ALLOC_GROW_BY(x, nr, increase, alloc) \
                    do { \
                            if (increase) { \
                                    size_t new_nr = nr + (increase); \
                                    if (new_nr < nr) \
                                            BUG("negative growth in ALLOC_GROW_BY"); \
                                    ALLOC_GROW(x, new_nr, alloc); \
                                    memset((x) + nr, 0, sizeof(*(x)) * (increase)); \
                                    nr = new_nr; \
                            } \
                    } while (0)

            static inline char *xstrdup_or_null(const char *str)
            {
                    return str ? xstrdup(str) : NULL;
            }

            static inline size_t xsize_t(off_t len)
            {
                    if (len < 0 || (uintmax_t) len > SIZE_MAX)
                            die("Cannot handle files this big");
                    return (size_t) len;
            }

            #ifndef HOST_NAME_MAX
            #define HOST_NAME_MAX 256
            #endif

            #include "sane-ctype.h"

            /*
            * Like skip_prefix, but compare case-insensitively. Note that the comparison
            * is done via tolower(), so it is strictly ASCII (no multi-byte characters or
            * locale-specific conversions).
            */
            static inline int skip_iprefix(const char *str, const char *prefix,
                                    const char **out)
            {
                    do {
                            if (!*prefix) {
                                    *out = str;
                                    return 1;
                            }
                    } while (tolower(*str++) == tolower(*prefix++));
                    return 0;
            }

            /*
            * Like skip_prefix_mem, but compare case-insensitively. Note that the
            * comparison is done via tolower(), so it is strictly ASCII (no multi-byte
            * characters or locale-specific conversions).
            */
            static inline int skip_iprefix_mem(const char *buf, size_t len,
                                            const char *prefix,
                                            const char **out, size_t *outlen)
            {
                    do {
                            if (!*prefix) {
                                    *out = buf;
                                    *outlen = len;
                                    return 1;
                            }
                    } while (len-- > 0 && tolower(*buf++) == tolower(*prefix++));
                    return 0;
            }

            static inline int strtoul_ui(char const *s, int base, unsigned int *result)
            {
                    unsigned long ul;
                    char *p;

                    errno = 0;
                    /* negative values would be accepted by strtoul */
                    if (strchr(s, '-'))
                            return -1;
                    ul = strtoul(s, &p, base);
                    if (errno || *p || p == s || (unsigned int) ul != ul)
                            return -1;
                    *result = ul;
                    return 0;
            }

            static inline int strtol_i(char const *s, int base, int *result)
            {
                    long ul;
                    char *p;

                    errno = 0;
                    ul = strtol(s, &p, base);
                    if (errno || *p || p == s || (int) ul != ul)
                            return -1;
                    *result = ul;
                    return 0;
            }

            void git_stable_qsort(void *base, size_t nmemb, size_t size,
                            int(*compar)(const void *, const void *));
            #ifdef INTERNAL_QSORT
            #define qsort git_stable_qsort
            #endif

            #define QSORT(base, n, compar) sane_qsort((base), (n), sizeof(*(base)), compar)
            static inline void sane_qsort(void *base, size_t nmemb, size_t size,
                                    int(*compar)(const void *, const void *))
            {
                    if (nmemb > 1)
                            qsort(base, nmemb, size, compar);
            }

            #define STABLE_QSORT(base, n, compar) \
                    git_stable_qsort((base), (n), sizeof(*(base)), compar)

            #ifndef HAVE_ISO_QSORT_S
            int git_qsort_s(void *base, size_t nmemb, size_t size,
                            int (*compar)(const void *, const void *, void *), void *ctx);
            #define qsort_s git_qsort_s
            #endif

            #define QSORT_S(base, n, compar, ctx) do {                      \
                    if (qsort_s((base), (n), sizeof(*(base)), compar, ctx)) \
                            BUG("qsort_s() failed");                        \
            } while (0)

            #ifndef REG_STARTEND
            #error "Git requires REG_STARTEND support. Compile with NO_REGEX=NeedsStartEnd"
            #endif

            static inline int regexec_buf(const regex_t *preg, const char *buf, size_t size,
                                    size_t nmatch, regmatch_t pmatch[], int eflags)
            {
                    assert(nmatch > 0 && pmatch);
                    pmatch[0].rm_so = 0;
                    pmatch[0].rm_eo = size;
                    return regexec(preg, buf, nmatch, pmatch, eflags | REG_STARTEND);
            }

            #ifdef USE_ENHANCED_BASIC_REGULAR_EXPRESSIONS
            int git_regcomp(regex_t *preg, const char *pattern, int cflags);
            #define regcomp git_regcomp
            #endif

            #ifndef DIR_HAS_BSD_GROUP_SEMANTICS
            # define FORCE_DIR_SET_GID S_ISGID
            #else
            # define FORCE_DIR_SET_GID 0
            #endif

            #ifdef NO_NSEC
            #undef USE_NSEC
            #define ST_CTIME_NSEC(st) 0
            #define ST_MTIME_NSEC(st) 0
            #else
            #ifdef USE_ST_TIMESPEC
            #define ST_CTIME_NSEC(st) ((unsigned int)((st).st_ctimespec.tv_nsec))
            #define ST_MTIME_NSEC(st) ((unsigned int)((st).st_mtimespec.tv_nsec))
            #else
            #define ST_CTIME_NSEC(st) ((unsigned int)((st).st_ctim.tv_nsec))
            #define ST_MTIME_NSEC(st) ((unsigned int)((st).st_mtim.tv_nsec))
            #endif
            #endif

            #ifdef UNRELIABLE_FSTAT
            #define fstat_is_reliable() 0
            #else
            #define fstat_is_reliable() 1
            #endif

            #ifndef va_copy
            /*
            * Since an obvious implementation of va_list would be to make it a
            * pointer into the stack frame, a simple assignment will work on
            * many systems.  But let's try to be more portable.
            */
            #ifdef __va_copy
            #define va_copy(dst, src) __va_copy(dst, src)
            #else
            #define va_copy(dst, src) ((dst) = (src))
            #endif
            #endif

            /* usage.c: only to be used for testing BUG() implementation (see test-tool) */
            extern int BUG_exit_code;

            /* usage.c: if bug() is called we should have a BUG_if_bug() afterwards */
            extern int bug_called_must_BUG;

            __attribute__((format (printf, 3, 4))) NORETURN
            void BUG_fl(const char *file, int line, const char *fmt, ...);
            #define BUG(...) BUG_fl(__FILE__, __LINE__, __VA_ARGS__)
            __attribute__((format (printf, 3, 4)))
            void bug_fl(const char *file, int line, const char *fmt, ...);
            #define bug(...) bug_fl(__FILE__, __LINE__, __VA_ARGS__)
            #define BUG_if_bug(...) do { \
                    if (bug_called_must_BUG) \
                            BUG_fl(__FILE__, __LINE__, __VA_ARGS__); \
            } while (0)

            #ifndef FSYNC_METHOD_DEFAULT
            #ifdef __APPLE__
            #define FSYNC_METHOD_DEFAULT FSYNC_METHOD_WRITEOUT_ONLY
            #else
            #define FSYNC_METHOD_DEFAULT FSYNC_METHOD_FSYNC
            #endif
            #endif

            #ifndef SHELL_PATH
            # define SHELL_PATH "/bin/sh"
            #endif

            #ifndef _POSIX_THREAD_SAFE_FUNCTIONS
            static inline void git_flockfile(FILE *fh UNUSED)
            {
                    ; /* nothing */
            }
            static inline void git_funlockfile(FILE *fh UNUSED)
            {
                    ; /* nothing */
            }
            #undef flockfile
            #undef funlockfile
            #undef getc_unlocked
            #define flockfile(fh) git_flockfile(fh)
            #define funlockfile(fh) git_funlockfile(fh)
            #define getc_unlocked(fh) getc(fh)
            #endif

            #ifdef FILENO_IS_A_MACRO
            int git_fileno(FILE *stream);
            # ifndef COMPAT_CODE_FILENO
            #  undef fileno
            #  define fileno(p) git_fileno(p)
            # endif
            #endif

            #ifdef NEED_ACCESS_ROOT_HANDLER
            int git_access(const char *path, int mode);
            # ifndef COMPAT_CODE_ACCESS
            #  ifdef access
            #  undef access
            #  endif
            #  define access(path, mode) git_access(path, mode)
            # endif
            #endif

            /*
            * Our code often opens a path to an optional file, to work on its
            * contents when we can successfully open it.  We can ignore a failure
            * to open if such an optional file does not exist, but we do want to
            * report a failure in opening for other reasons (e.g. we got an I/O
            * error, or the file is there, but we lack the permission to open).
            *
            * Call this function after seeing an error from open() or fopen() to
            * see if the errno indicates a missing file that we can safely ignore.
            */
            static inline int is_missing_file_error(int errno_)
            {
                    return (errno_ == ENOENT || errno_ == ENOTDIR);
            }

            int cmd_main(int, const char **);

            /*
            * Intercept all calls to exit() and route them to trace2 to
            * optionally emit a message before calling the real exit().
            */
            int common_exit(const char *file, int line, int code);
            #define exit(code) exit(common_exit(__FILE__, __LINE__, (code)))

            #define z_const
            #include <zlib.h>

            #if ZLIB_VERNUM < 0x1290
            /*
            * This is uncompress2, which is only available in zlib >= 1.2.9
            * (released as of early 2017). See compat/zlib-uncompress2.c.
            */
            int uncompress2(Bytef *dest, uLongf *destLen, const Bytef *source,
                            uLong *sourceLen);
            #endif

            /*
            * This include must come after system headers, since it introduces macros that
            * replace system names.
            */
            #include "banned.h"

            /*
            * container_of - Get the address of an object containing a field.
            *
            * @ptr: pointer to the field.
            * @type: type of the object.
            * @member: name of the field within the object.
            */
            #define container_of(ptr, type, member) \
                    ((type *) ((char *)(ptr) - offsetof(type, member)))

            /*
            * helper function for `container_of_or_null' to avoid multiple
            * evaluation of @ptr
            */
            static inline void *container_of_or_null_offset(void *ptr, size_t offset)
            {
                    return ptr ? (char *)ptr - offset : NULL;
            }

            /*
            * like `container_of', but allows returned value to be NULL
            */
            #define container_of_or_null(ptr, type, member) \
                    (type *)container_of_or_null_offset(ptr, offsetof(type, member))

            /*
            * like offsetof(), but takes a pointer to a variable of type which
            * contains @member, instead of a specified type.
            * @ptr is subject to multiple evaluation since we can't rely on __typeof__
            * everywhere.
            */
            #if defined(__GNUC__) /* clang sets this, too */
            #define OFFSETOF_VAR(ptr, member) offsetof(__typeof__(*ptr), member)
            #else /* !__GNUC__ */
            #define OFFSETOF_VAR(ptr, member) \
                    ((uintptr_t)&(ptr)->member - (uintptr_t)(ptr))
            #endif /* !__GNUC__ */

            #endif

            """,
            "Patch":
            """
            diff --git a/git-compat-util.h b/git-compat-util.h
            index 7c2a6538e5..1d9713a421 100644
            --- a/git-compat-util.h
            +++ b/git-compat-util.h
            @@ -223,7 +223,11 @@ struct strbuf;
            #include <sys/stat.h>
            #include <fcntl.h>
            #include <stddef.h>
            +#define release stdlib_release
            +#define fetch stdlib_fetch
            #include <stdlib.h>
            +#undef fetch
            +#undef release
            #include <stdarg.h>
            #include <stdbool.h>
            #include <string.h>

            """,

    },
    {
            "Wrong code":
            """
                            /*
            * GIT - The information manager from hell
            *
            * Copyright (C) Linus Torvalds, 2005
            * Copyright (C) Junio C Hamano, 2005
            */
            #define USE_THE_REPOSITORY_VARIABLE
            #include "builtin.h"
            #include "abspath.h"
            #include "config.h"
            #include "gettext.h"
            #include "hex.h"
            #include "object-file.h"
            #include "object-store-ll.h"
            #include "blob.h"
            #include "quote.h"
            #include "parse-options.h"
            #include "setup.h"
            #include "strbuf.h"
            #include "write-or-die.h"

            /*
            * This is to create corrupt objects for debugging and as such it
            * needs to bypass the data conversion performed by, and the type
            * limitation imposed by, index_fd() and its callees.
            */
            static int hash_literally(struct object_id *oid, int fd, const char *type, unsigned flags)
            {
                    struct strbuf buf = STRBUF_INIT;
                    int ret;

                    if (strbuf_read(&buf, fd, 4096) < 0)
                            ret = -1;
                    else
                            ret = write_object_file_literally(buf.buf, buf.len, type, oid,
                                                            flags);
                    close(fd);
                    strbuf_release(&buf);
                    return ret;
            }

            static void hash_fd(int fd, const char *type, const char *path, unsigned flags,
                            int literally)
            {
                    struct stat st;
                    struct object_id oid;

                    if (fstat(fd, &st) < 0 ||
                    (literally
                    ? hash_literally(&oid, fd, type, flags)
                    : index_fd(the_repository->index, &oid, fd, &st,
                                    type_from_string(type), path, flags)))
                            die((flags & HASH_WRITE_OBJECT)
                            ? "Unable to add %s to database"
                            : "Unable to hash %s", path);
                    printf("%s\n", oid_to_hex(&oid));
                    maybe_flush_or_die(stdout, "hash to stdout");
            }

            static void hash_object(const char *path, const char *type, const char *vpath,
                                    unsigned flags, int literally)
            {
                    int fd;
                    fd = xopen(path, O_RDONLY);
                    hash_fd(fd, type, vpath, flags, literally);
            }

            static void hash_stdin_paths(const char *type, int no_filters, unsigned flags,
                                    int literally)
            {
                    struct strbuf buf = STRBUF_INIT;
                    struct strbuf unquoted = STRBUF_INIT;

                    while (strbuf_getline(&buf, stdin) != EOF) {
                            if (buf.buf[0] == '"') {
                                    strbuf_reset(&unquoted);
                                    if (unquote_c_style(&unquoted, buf.buf, NULL))
                                            die("line is badly quoted");
                                    strbuf_swap(&buf, &unquoted);
                            }
                            hash_object(buf.buf, type, no_filters ? NULL : buf.buf, flags,
                                    literally);
                    }
                    strbuf_release(&buf);
                    strbuf_release(&unquoted);
            }

            int cmd_hash_object(int argc,
                            const char **argv,
                            const char *prefix,
                            struct repository *repo UNUSED)
            {
                    static const char * const hash_object_usage[] = {
                            N_("git hash-object [-t <type>] [-w] [--path=<file> | --no-filters]\n"
                            "                [--stdin [--literally]] [--] <file>..."),
                            N_("git hash-object [-t <type>] [-w] --stdin-paths [--no-filters]"),
                            NULL
                    };
                    const char *type = blob_type;
                    int hashstdin = 0;
                    int stdin_paths = 0;
                    int no_filters = 0;
                    int literally = 0;
                    int nongit = 0;
                    unsigned flags = HASH_FORMAT_CHECK;
                    const char *vpath = NULL;
                    char *vpath_free = NULL;
                    const struct option hash_object_options[] = {
                            OPT_STRING('t', NULL, &type, N_("type"), N_("object type")),
                            OPT_BIT('w', NULL, &flags, N_("write the object into the object database"),
                                    HASH_WRITE_OBJECT),
                            OPT_COUNTUP( 0 , "stdin", &hashstdin, N_("read the object from stdin")),
                            OPT_BOOL( 0 , "stdin-paths", &stdin_paths, N_("read file names from stdin")),
                            OPT_BOOL( 0 , "no-filters", &no_filters, N_("store file as is without filters")),
                            OPT_BOOL( 0, "literally", &literally, N_("just hash any random garbage to create corrupt objects for debugging Git")),
                            OPT_STRING( 0 , "path", &vpath, N_("file"), N_("process file as it were from this path")),
                            OPT_END()
                    };
                    int i;
                    const char *errstr = NULL;

                    argc = parse_options(argc, argv, prefix, hash_object_options,
                                    hash_object_usage, 0);

                    if (flags & HASH_WRITE_OBJECT)
                            prefix = setup_git_directory();
                    else
                            prefix = setup_git_directory_gently(&nongit);

                    if (nongit && !the_hash_algo)
                            repo_set_hash_algo(the_repository, GIT_HASH_SHA1);

                    if (vpath && prefix) {
                            vpath_free = prefix_filename(prefix, vpath);
                            vpath = vpath_free;
                    }

                    git_config(git_default_config, NULL);

                    if (stdin_paths) {
                            if (hashstdin)
                                    errstr = "Can't use --stdin-paths with --stdin";
                            else if (argc)
                                    errstr = "Can't specify files with --stdin-paths";
                            else if (vpath)
                                    errstr = "Can't use --stdin-paths with --path";
                    }
                    else {
                            if (hashstdin > 1)
                                    errstr = "Multiple --stdin arguments are not supported";
                            if (vpath && no_filters)
                                    errstr = "Can't use --path with --no-filters";
                    }

                    if (errstr) {
                            error("%s", errstr);
                            usage_with_options(hash_object_usage, hash_object_options);
                    }

                    if (hashstdin)
                            hash_fd(0, type, vpath, flags, literally);

                    for (i = 0 ; i < argc; i++) {
                            const char *arg = argv[i];
                            char *to_free = NULL;

                            if (prefix)
                                    arg = to_free = prefix_filename(prefix, arg);
                            hash_object(arg, type, no_filters ? NULL : vpath ? vpath : arg,
                                    flags, literally);
                            free(to_free);
                    }

                    if (stdin_paths)
                            hash_stdin_paths(type, no_filters, flags, literally);

                    free(vpath_free);

                    return 0;
            }


            """,
            "Error":"The patch ensures that files are treated as binary on z/OS, preventing unintended encoding conversions and ensuring accurate hashing.
                     This improves Git's compatibility with z/OS and ensures reliable behavior across platforms.",
            "error Category":"Functionality Patche",
            "Corrected Code":
            """
                            /*
            * GIT - The information manager from hell
            *
            * Copyright (C) Linus Torvalds, 2005
            * Copyright (C) Junio C Hamano, 2005
            */
            #define USE_THE_REPOSITORY_VARIABLE
            #include "builtin.h"
            #include "abspath.h"
            #include "config.h"
            #include "gettext.h"
            #include "hex.h"
            #include "object-file.h"
            #include "object-store-ll.h"
            #include "blob.h"
            #include "quote.h"
            #include "parse-options.h"
            #include "setup.h"
            #include "strbuf.h"
            #include "write-or-die.h"

            /*
            * This is to create corrupt objects for debugging and as such it
            * needs to bypass the data conversion performed by, and the type
            * limitation imposed by, index_fd() and its callees.
            */
            static int hash_literally(struct object_id *oid, int fd, const char *type, unsigned flags)
            {
                    struct strbuf buf = STRBUF_INIT;
                    int ret;

                    if (strbuf_read(&buf, fd, 4096) < 0)
                            ret = -1;
                    else
                            ret = write_object_file_literally(buf.buf, buf.len, type, oid,
                                                            flags);
                    close(fd);
                    strbuf_release(&buf);
                    return ret;
            }

            static void hash_fd(int fd, const char *type, const char *path, unsigned flags,
                            int literally)
            {
                    struct stat st;
                    struct object_id oid;

                    if (fstat(fd, &st) < 0 ||
                    (literally
                    ? hash_literally(&oid, fd, type, flags)
                    : index_fd(the_repository->index, &oid, fd, &st,
                                    type_from_string(type), path, flags)))
                            die((flags & HASH_WRITE_OBJECT)
                            ? "Unable to add %s to database"
                            : "Unable to hash %s", path);
                    printf("%s\n", oid_to_hex(&oid));
                    maybe_flush_or_die(stdout, "hash to stdout");
            }

            #ifdef __MVS__
            #  if (__CHARSET_LIB == 1)
            #  include <stdio.h>
            #  include <stdlib.h>

            int setbinaryfd(int fd)
            {
            attrib_t attr;
            int rc;

            memset(&attr, 0, sizeof(attr));
            attr.att_filetagchg = 1;
            attr.att_filetag.ft_ccsid = FT_BINARY;
            attr.att_filetag.ft_txtflag = 0;

            rc = __fchattr(fd, &attr, sizeof(attr));
            return rc;
            }
            #  endif
            #endif


            static void hash_object(const char *path, const char *type, const char *vpath,
                                    unsigned flags, int literally)
            {
                    int fd;
                    fd = xopen(path, O_RDONLY);
            #ifdef __MVS__
            #  if (__CHARSET_LIB == 1)
            if (setbinaryfd(fd))
                            die_errno("Cannot set to binary '%s'", path);
            #  endif
            #endif
                    hash_fd(fd, type, vpath, flags, literally);
            }

            static void hash_stdin_paths(const char *type, int no_filters, unsigned flags,
                                    int literally)
            {
                    struct strbuf buf = STRBUF_INIT;
                    struct strbuf unquoted = STRBUF_INIT;

                    while (strbuf_getline(&buf, stdin) != EOF) {
                            if (buf.buf[0] == '"') {
                                    strbuf_reset(&unquoted);
                                    if (unquote_c_style(&unquoted, buf.buf, NULL))
                                            die("line is badly quoted");
                                    strbuf_swap(&buf, &unquoted);
                            }
                            hash_object(buf.buf, type, no_filters ? NULL : buf.buf, flags,
                                    literally);
                    }
                    strbuf_release(&buf);
                    strbuf_release(&unquoted);
            }

            int cmd_hash_object(int argc,
                            const char **argv,
                            const char *prefix,
                            struct repository *repo UNUSED)
            {
                    static const char * const hash_object_usage[] = {
                            N_("git hash-object [-t <type>] [-w] [--path=<file> | --no-filters]\n"
                            "                [--stdin [--literally]] [--] <file>..."),
                            N_("git hash-object [-t <type>] [-w] --stdin-paths [--no-filters]"),
                            NULL
                    };
                    const char *type = blob_type;
                    int hashstdin = 0;
                    int stdin_paths = 0;
                    int no_filters = 0;
                    int literally = 0;
                    int nongit = 0;
                    unsigned flags = HASH_FORMAT_CHECK;
                    const char *vpath = NULL;
                    char *vpath_free = NULL;
                    const struct option hash_object_options[] = {
                            OPT_STRING('t', NULL, &type, N_("type"), N_("object type")),
                            OPT_BIT('w', NULL, &flags, N_("write the object into the object database"),
                                    HASH_WRITE_OBJECT),
                            OPT_COUNTUP( 0 , "stdin", &hashstdin, N_("read the object from stdin")),
                            OPT_BOOL( 0 , "stdin-paths", &stdin_paths, N_("read file names from stdin")),
                            OPT_BOOL( 0 , "no-filters", &no_filters, N_("store file as is without filters")),
                            OPT_BOOL( 0, "literally", &literally, N_("just hash any random garbage to create corrupt objects for debugging Git")),
                            OPT_STRING( 0 , "path", &vpath, N_("file"), N_("process file as it were from this path")),
                            OPT_END()
                    };
                    int i;
                    const char *errstr = NULL;

                    argc = parse_options(argc, argv, prefix, hash_object_options,
                                    hash_object_usage, 0);

                    if (flags & HASH_WRITE_OBJECT)
                            prefix = setup_git_directory();
                    else
                            prefix = setup_git_directory_gently(&nongit);

                    if (nongit && !the_hash_algo)
                            repo_set_hash_algo(the_repository, GIT_HASH_SHA1);

                    if (vpath && prefix) {
                            vpath_free = prefix_filename(prefix, vpath);
                            vpath = vpath_free;
                    }

                    git_config(git_default_config, NULL);

                    if (stdin_paths) {
                            if (hashstdin)
                                    errstr = "Can't use --stdin-paths with --stdin";
                            else if (argc)
                                    errstr = "Can't specify files with --stdin-paths";
                            else if (vpath)
                                    errstr = "Can't use --stdin-paths with --path";
                    }
                    else {
                            if (hashstdin > 1)
                                    errstr = "Multiple --stdin arguments are not supported";
                            if (vpath && no_filters)
                                    errstr = "Can't use --path with --no-filters";
                    }

                    if (errstr) {
                            error("%s", errstr);
                            usage_with_options(hash_object_usage, hash_object_options);
                    }

                    if (hashstdin)
                            hash_fd(0, type, vpath, flags, literally);

                    for (i = 0 ; i < argc; i++) {
                            const char *arg = argv[i];
                            char *to_free = NULL;

                            if (prefix)
                                    arg = to_free = prefix_filename(prefix, arg);
                            hash_object(arg, type, no_filters ? NULL : vpath ? vpath : arg,
                                    flags, literally);
                            free(to_free);
                    }

                    if (stdin_paths)
                            hash_stdin_paths(type, no_filters, flags, literally);

                    free(vpath_free);

                    return 0;
            }



            """,
            "Patche":
            """
                            diff --git a/builtin/hash-object.c b/builtin/hash-object.c
            index fbae878..4c9c973 100644
            --- a/builtin/hash-object.c
            +++ b/builtin/hash-object.c
            @@ -49,11 +49,39 @@ static void hash_fd(int fd, const char *type, const char *path, unsigned flags,
                    maybe_flush_or_die(stdout, "hash to stdout");
            }

            +#ifdef __MVS__
            +#  if (__CHARSET_LIB == 1)
            +#  include <stdio.h>
            +#  include <stdlib.h>
            +
            +   int setbinaryfd(int fd)
            +   {
            +     attrib_t attr;
            +     int rc;
            +
            +     memset(&attr, 0, sizeof(attr));
            +     attr.att_filetagchg = 1;
            +     attr.att_filetag.ft_ccsid = FT_BINARY;
            +     attr.att_filetag.ft_txtflag = 0;
            +
            +     rc = __fchattr(fd, &attr, sizeof(attr));
            +     return rc;
            +   }
            +#  endif
            +#endif
            +
            +
            static void hash_object(const char *path, const char *type, const char *vpath,
                                    unsigned flags, int literally)
            {
                    int fd;
                    fd = xopen(path, O_RDONLY);
            +#ifdef __MVS__
            +#  if (__CHARSET_LIB == 1)
            +  if (setbinaryfd(fd))
            +       die_errno("Cannot set to binary '%s'", path);
            +#  endif
            +#endif
                    hash_fd(fd, type, vpath, flags, literally);
            }



            """,
    },

    {

            "Wrong code":
            """
                            #define USE_THE_REPOSITORY_VARIABLE
            #define DISABLE_SIGN_COMPARE_WARNINGS

            #include "git-compat-util.h"
            #include "git-curl-compat.h"
            #include "hex.h"
            #include "http.h"
            #include "config.h"
            #include "pack.h"
            #include "run-command.h"
            #include "url.h"
            #include "urlmatch.h"
            #include "credential.h"
            #include "version.h"
            #include "pkt-line.h"
            #include "gettext.h"
            #include "trace.h"
            #include "transport.h"
            #include "packfile.h"
            #include "string-list.h"
            #include "object-file.h"
            #include "object-store-ll.h"
            #include "tempfile.h"

            static struct trace_key trace_curl = TRACE_KEY_INIT(CURL);
            static int trace_curl_data = 1;
            static int trace_curl_redact = 1;
            long int git_curl_ipresolve = CURL_IPRESOLVE_WHATEVER;
            int active_requests;
            int http_is_verbose;
            ssize_t http_post_buffer = 16 * LARGE_PACKET_MAX;

            static int min_curl_sessions = 1;
            static int curl_session_count;
            static int max_requests = -1;
            static CURLM *curlm;
            static CURL *curl_default;

            #define PREV_BUF_SIZE 4096

            char curl_errorstr[CURL_ERROR_SIZE];

            static int curl_ssl_verify = -1;
            static int curl_ssl_try;
            static char *curl_http_version;
            static char *ssl_cert;
            static char *ssl_cert_type;
            static char *ssl_cipherlist;
            static char *ssl_version;
            static struct {
                    const char *name;
                    long ssl_version;
            } sslversions[] = {
                    { "sslv2", CURL_SSLVERSION_SSLv2 },
                    { "sslv3", CURL_SSLVERSION_SSLv3 },
                    { "tlsv1", CURL_SSLVERSION_TLSv1 },
                    { "tlsv1.0", CURL_SSLVERSION_TLSv1_0 },
                    { "tlsv1.1", CURL_SSLVERSION_TLSv1_1 },
                    { "tlsv1.2", CURL_SSLVERSION_TLSv1_2 },
                    { "tlsv1.3", CURL_SSLVERSION_TLSv1_3 },
            };
            static char *ssl_key;
            static char *ssl_key_type;
            static char *ssl_capath;
            static char *curl_no_proxy;
            static char *ssl_pinnedkey;
            static char *ssl_cainfo;
            static long curl_low_speed_limit = -1;
            static long curl_low_speed_time = -1;
            static int curl_ftp_no_epsv;
            static char *curl_http_proxy;
            static char *http_proxy_authmethod;

            static char *http_proxy_ssl_cert;
            static char *http_proxy_ssl_key;
            static char *http_proxy_ssl_ca_info;
            static struct credential proxy_cert_auth = CREDENTIAL_INIT;
            static int proxy_ssl_cert_password_required;

            static struct {
                    const char *name;
                    long curlauth_param;
            } proxy_authmethods[] = {
                    { "basic", CURLAUTH_BASIC },
                    { "digest", CURLAUTH_DIGEST },
                    { "negotiate", CURLAUTH_GSSNEGOTIATE },
                    { "ntlm", CURLAUTH_NTLM },
                    { "anyauth", CURLAUTH_ANY },
                    /*
                    * CURLAUTH_DIGEST_IE has no corresponding command-line option in
                    * curl(1) and is not included in CURLAUTH_ANY, so we leave it out
                    * here, too
                    */
            };
            #ifdef CURLGSSAPI_DELEGATION_FLAG
            static char *curl_deleg;
            static struct {
                    const char *name;
                    long curl_deleg_param;
            } curl_deleg_levels[] = {
                    { "none", CURLGSSAPI_DELEGATION_NONE },
                    { "policy", CURLGSSAPI_DELEGATION_POLICY_FLAG },
                    { "always", CURLGSSAPI_DELEGATION_FLAG },
            };
            #endif

            enum proactive_auth {
                    PROACTIVE_AUTH_NONE = 0,
                    PROACTIVE_AUTH_IF_CREDENTIALS,
                    PROACTIVE_AUTH_AUTO,
                    PROACTIVE_AUTH_BASIC,
            };

            static struct credential proxy_auth = CREDENTIAL_INIT;
            static const char *curl_proxyuserpwd;
            static char *curl_cookie_file;
            static int curl_save_cookies;
            struct credential http_auth = CREDENTIAL_INIT;
            static enum proactive_auth http_proactive_auth;
            static char *user_agent;
            static int curl_empty_auth = -1;

            enum http_follow_config http_follow_config = HTTP_FOLLOW_INITIAL;

            static struct credential cert_auth = CREDENTIAL_INIT;
            static int ssl_cert_password_required;
            static unsigned long http_auth_methods = CURLAUTH_ANY;
            static int http_auth_methods_restricted;
            /* Modes for which empty_auth cannot actually help us. */
            static unsigned long empty_auth_useless =
                    CURLAUTH_BASIC
                    | CURLAUTH_DIGEST_IE
                    | CURLAUTH_DIGEST;

            static struct curl_slist *pragma_header;
            static struct string_list extra_http_headers = STRING_LIST_INIT_DUP;

            static struct curl_slist *host_resolutions;

            static struct active_request_slot *active_queue_head;

            static char *cached_accept_language;

            static char *http_ssl_backend;

            static int http_schannel_check_revoke = 1;
            /*
            * With the backend being set to `schannel`, setting sslCAinfo would override
            * the Certificate Store in cURL v7.60.0 and later, which is not what we want
            * by default.
            */
            static int http_schannel_use_ssl_cainfo;

            static int always_auth_proactively(void)
            {
                    return http_proactive_auth != PROACTIVE_AUTH_NONE &&
                    http_proactive_auth != PROACTIVE_AUTH_IF_CREDENTIALS;
            }

            size_t fread_buffer(char *ptr, size_t eltsize, size_t nmemb, void *buffer_)
            {
                    size_t size = eltsize * nmemb;
                    struct buffer *buffer = buffer_;

                    if (size > buffer->buf.len - buffer->posn)
                            size = buffer->buf.len - buffer->posn;
                    memcpy(ptr, buffer->buf.buf + buffer->posn, size);
                    buffer->posn += size;

                    return size / eltsize;
            }

            int seek_buffer(void *clientp, curl_off_t offset, int origin)
            {
                    struct buffer *buffer = clientp;

                    if (origin != SEEK_SET)
                            BUG("seek_buffer only handles SEEK_SET");
                    if (offset < 0 || offset >= buffer->buf.len) {
                            error("curl seek would be outside of buffer");
                            return CURL_SEEKFUNC_FAIL;
                    }

                    buffer->posn = offset;
                    return CURL_SEEKFUNC_OK;
            }

            size_t fwrite_buffer(char *ptr, size_t eltsize, size_t nmemb, void *buffer_)
            {
                    size_t size = eltsize * nmemb;
                    struct strbuf *buffer = buffer_;

                    strbuf_add(buffer, ptr, size);
                    return nmemb;
            }

            /*
            * A folded header continuation line starts with any number of spaces or
            * horizontal tab characters (SP or HTAB) as per RFC 7230 section 3.2.
            * It is not a continuation line if the line starts with any other character.
            */
            static inline int is_hdr_continuation(const char *ptr, const size_t size)
            {
                    return size && (*ptr == ' ' || *ptr == '\t');
            }

            static size_t fwrite_wwwauth(char *ptr, size_t eltsize, size_t nmemb, void *p UNUSED)
            {
                    size_t size = eltsize * nmemb;
                    struct strvec *values = &http_auth.wwwauth_headers;
                    struct strbuf buf = STRBUF_INIT;
                    const char *val;
                    size_t val_len;

                    /*
                    * Header lines may not come NULL-terminated from libcurl so we must
                    * limit all scans to the maximum length of the header line, or leverage
                    * strbufs for all operations.
                    *
                    * In addition, it is possible that header values can be split over
                    * multiple lines as per RFC 7230. 'Line folding' has been deprecated
                    * but older servers may still emit them. A continuation header field
                    * value is identified as starting with a space or horizontal tab.
                    *
                    * The formal definition of a header field as given in RFC 7230 is:
                    *
                    * header-field   = field-name ":" OWS field-value OWS
                    *
                    * field-name     = token
                    * field-value    = *( field-content / obs-fold )
                    * field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
                    * field-vchar    = VCHAR / obs-text
                    *
                    * obs-fold       = CRLF 1*( SP / HTAB )
                    *                ; obsolete line folding
                    *                ; see Section 3.2.4
                    */

                    /* Start of a new WWW-Authenticate header */
                    if (skip_iprefix_mem(ptr, size, "www-authenticate:", &val, &val_len)) {
                            strbuf_add(&buf, val, val_len);

                            /*
                            * Strip the CRLF that should be present at the end of each
                            * field as well as any trailing or leading whitespace from the
                            * value.
                            */
                            strbuf_trim(&buf);

                            strvec_push(values, buf.buf);
                            http_auth.header_is_last_match = 1;
                            goto exit;
                    }

                    /*
                    * This line could be a continuation of the previously matched header
                    * field. If this is the case then we should append this value to the
                    * end of the previously consumed value.
                    */
                    if (http_auth.header_is_last_match && is_hdr_continuation(ptr, size)) {
                            /*
                            * Trim the CRLF and any leading or trailing from this line.
                            */
                            strbuf_add(&buf, ptr, size);
                            strbuf_trim(&buf);

                            /*
                            * At this point we should always have at least one existing
                            * value, even if it is empty. Do not bother appending the new
                            * value if this continuation header is itself empty.
                            */
                            if (!values->nr) {
                                    BUG("should have at least one existing header value");
                            } else if (buf.len) {
                                    char *prev = xstrdup(values->v[values->nr - 1]);

                                    /* Join two non-empty values with a single space. */
                                    const char *const sp = *prev ? " " : "";

                                    strvec_pop(values);
                                    strvec_pushf(values, "%s%s%s", prev, sp, buf.buf);
                                    free(prev);
                            }

                            goto exit;
                    }

                    /* Not a continuation of a previously matched auth header line. */
                    http_auth.header_is_last_match = 0;

                    /*
                    * If this is a HTTP status line and not a header field, this signals
                    * a different HTTP response. libcurl writes all the output of all
                    * response headers of all responses, including redirects.
                    * We only care about the last HTTP request response's headers so clear
                    * the existing array.
                    */
                    if (skip_iprefix_mem(ptr, size, "http/", &val, &val_len))
                            strvec_clear(values);

            exit:
                    strbuf_release(&buf);
                    return size;
            }

            size_t fwrite_null(char *ptr UNUSED, size_t eltsize UNUSED, size_t nmemb,
                            void *data UNUSED)
            {
                    return nmemb;
            }

            static struct curl_slist *object_request_headers(void)
            {
                    return curl_slist_append(http_copy_default_headers(), "Pragma:");
            }

            static void closedown_active_slot(struct active_request_slot *slot)
            {
                    active_requests--;
                    slot->in_use = 0;
            }

            static void finish_active_slot(struct active_request_slot *slot)
            {
                    closedown_active_slot(slot);
                    curl_easy_getinfo(slot->curl, CURLINFO_HTTP_CODE, &slot->http_code);

                    if (slot->finished)
                            (*slot->finished) = 1;

                    /* Store slot results so they can be read after the slot is reused */
                    if (slot->results) {
                            slot->results->curl_result = slot->curl_result;
                            slot->results->http_code = slot->http_code;
                            curl_easy_getinfo(slot->curl, CURLINFO_HTTPAUTH_AVAIL,
                                            &slot->results->auth_avail);

                            curl_easy_getinfo(slot->curl, CURLINFO_HTTP_CONNECTCODE,
                                    &slot->results->http_connectcode);
                    }

                    /* Run callback if appropriate */
                    if (slot->callback_func)
                            slot->callback_func(slot->callback_data);
            }

            static void xmulti_remove_handle(struct active_request_slot *slot)
            {
                    curl_multi_remove_handle(curlm, slot->curl);
            }

            static void process_curl_messages(void)
            {
                    int num_messages;
                    struct active_request_slot *slot;
                    CURLMsg *curl_message = curl_multi_info_read(curlm, &num_messages);

                    while (curl_message != NULL) {
                            if (curl_message->msg == CURLMSG_DONE) {
                                    int curl_result = curl_message->data.result;
                                    slot = active_queue_head;
                                    while (slot != NULL &&
                                    slot->curl != curl_message->easy_handle)
                                            slot = slot->next;
                                    if (slot) {
                                            xmulti_remove_handle(slot);
                                            slot->curl_result = curl_result;
                                            finish_active_slot(slot);
                                    } else {
                                            fprintf(stderr, "Received DONE message for unknown request!\n");
                                    }
                            } else {
                                    fprintf(stderr, "Unknown CURL message received: %d\n",
                                            (int)curl_message->msg);
                            }
                            curl_message = curl_multi_info_read(curlm, &num_messages);
                    }
            }

            static int http_options(const char *var, const char *value,
                                    const struct config_context *ctx, void *data)
            {
                    if (!strcmp("http.version", var)) {
                            return git_config_string(&curl_http_version, var, value);
                    }
                    if (!strcmp("http.sslverify", var)) {
                            curl_ssl_verify = git_config_bool(var, value);
                            return 0;
                    }
                    if (!strcmp("http.sslcipherlist", var))
                            return git_config_string(&ssl_cipherlist, var, value);
                    if (!strcmp("http.sslversion", var))
                            return git_config_string(&ssl_version, var, value);
                    if (!strcmp("http.sslcert", var))
                            return git_config_pathname(&ssl_cert, var, value);
                    if (!strcmp("http.sslcerttype", var))
                            return git_config_string(&ssl_cert_type, var, value);
                    if (!strcmp("http.sslkey", var))
                            return git_config_pathname(&ssl_key, var, value);
                    if (!strcmp("http.sslkeytype", var))
                            return git_config_string(&ssl_key_type, var, value);
                    if (!strcmp("http.sslcapath", var))
                            return git_config_pathname(&ssl_capath, var, value);
                    if (!strcmp("http.sslcainfo", var))
                            return git_config_pathname(&ssl_cainfo, var, value);
                    if (!strcmp("http.sslcertpasswordprotected", var)) {
                            ssl_cert_password_required = git_config_bool(var, value);
                            return 0;
                    }
                    if (!strcmp("http.ssltry", var)) {
                            curl_ssl_try = git_config_bool(var, value);
                            return 0;
                    }
                    if (!strcmp("http.sslbackend", var)) {
                            free(http_ssl_backend);
                            http_ssl_backend = xstrdup_or_null(value);
                            return 0;
                    }

                    if (!strcmp("http.schannelcheckrevoke", var)) {
                            http_schannel_check_revoke = git_config_bool(var, value);
                            return 0;
                    }

                    if (!strcmp("http.schannelusesslcainfo", var)) {
                            http_schannel_use_ssl_cainfo = git_config_bool(var, value);
                            return 0;
                    }

                    if (!strcmp("http.minsessions", var)) {
                            min_curl_sessions = git_config_int(var, value, ctx->kvi);
                            if (min_curl_sessions > 1)
                                    min_curl_sessions = 1;
                            return 0;
                    }
                    if (!strcmp("http.maxrequests", var)) {
                            max_requests = git_config_int(var, value, ctx->kvi);
                            return 0;
                    }
                    if (!strcmp("http.lowspeedlimit", var)) {
                            curl_low_speed_limit = (long)git_config_int(var, value, ctx->kvi);
                            return 0;
                    }
                    if (!strcmp("http.lowspeedtime", var)) {
                            curl_low_speed_time = (long)git_config_int(var, value, ctx->kvi);
                            return 0;
                    }

                    if (!strcmp("http.noepsv", var)) {
                            curl_ftp_no_epsv = git_config_bool(var, value);
                            return 0;
                    }
                    if (!strcmp("http.proxy", var))
                            return git_config_string(&curl_http_proxy, var, value);

                    if (!strcmp("http.proxyauthmethod", var))
                            return git_config_string(&http_proxy_authmethod, var, value);

                    if (!strcmp("http.proxysslcert", var))
                            return git_config_string(&http_proxy_ssl_cert, var, value);

                    if (!strcmp("http.proxysslkey", var))
                            return git_config_string(&http_proxy_ssl_key, var, value);

                    if (!strcmp("http.proxysslcainfo", var))
                            return git_config_string(&http_proxy_ssl_ca_info, var, value);

                    if (!strcmp("http.proxysslcertpasswordprotected", var)) {
                            proxy_ssl_cert_password_required = git_config_bool(var, value);
                            return 0;
                    }

                    if (!strcmp("http.cookiefile", var))
                            return git_config_pathname(&curl_cookie_file, var, value);
                    if (!strcmp("http.savecookies", var)) {
                            curl_save_cookies = git_config_bool(var, value);
                            return 0;
                    }

                    if (!strcmp("http.postbuffer", var)) {
                            http_post_buffer = git_config_ssize_t(var, value, ctx->kvi);
                            if (http_post_buffer < 0)
                                    warning(_("negative value for http.postBuffer; defaulting to %d"), LARGE_PACKET_MAX);
                            if (http_post_buffer < LARGE_PACKET_MAX)
                                    http_post_buffer = LARGE_PACKET_MAX;
                            return 0;
                    }

                    if (!strcmp("http.useragent", var))
                            return git_config_string(&user_agent, var, value);

                    if (!strcmp("http.emptyauth", var)) {
                            if (value && !strcmp("auto", value))
                                    curl_empty_auth = -1;
                            else
                                    curl_empty_auth = git_config_bool(var, value);
                            return 0;
                    }

                    if (!strcmp("http.delegation", var)) {
            #ifdef CURLGSSAPI_DELEGATION_FLAG
                            return git_config_string(&curl_deleg, var, value);
            #else
                            warning(_("Delegation control is not supported with cURL < 7.22.0"));
                            return 0;
            #endif
                    }

                    if (!strcmp("http.pinnedpubkey", var)) {
                            return git_config_pathname(&ssl_pinnedkey, var, value);
                    }

                    if (!strcmp("http.extraheader", var)) {
                            if (!value) {
                                    return config_error_nonbool(var);
                            } else if (!*value) {
                                    string_list_clear(&extra_http_headers, 0);
                            } else {
                                    string_list_append(&extra_http_headers, value);
                            }
                            return 0;
                    }

                    if (!strcmp("http.curloptresolve", var)) {
                            if (!value) {
                                    return config_error_nonbool(var);
                            } else if (!*value) {
                                    curl_slist_free_all(host_resolutions);
                                    host_resolutions = NULL;
                            } else {
                                    host_resolutions = curl_slist_append(host_resolutions, value);
                            }
                            return 0;
                    }

                    if (!strcmp("http.followredirects", var)) {
                            if (value && !strcmp(value, "initial"))
                                    http_follow_config = HTTP_FOLLOW_INITIAL;
                            else if (git_config_bool(var, value))
                                    http_follow_config = HTTP_FOLLOW_ALWAYS;
                            else
                                    http_follow_config = HTTP_FOLLOW_NONE;
                            return 0;
                    }

                    if (!strcmp("http.proactiveauth", var)) {
                            if (!value)
                                    return config_error_nonbool(var);
                            if (!strcmp(value, "auto"))
                                    http_proactive_auth = PROACTIVE_AUTH_AUTO;
                            else if (!strcmp(value, "basic"))
                                    http_proactive_auth = PROACTIVE_AUTH_BASIC;
                            else if (!strcmp(value, "none"))
                                    http_proactive_auth = PROACTIVE_AUTH_NONE;
                            else
                                    warning(_("Unknown value for http.proactiveauth"));
                            return 0;
                    }

                    /* Fall back on the default ones */
                    return git_default_config(var, value, ctx, data);
            }

            static int curl_empty_auth_enabled(void)
            {
                    if (curl_empty_auth >= 0)
                            return curl_empty_auth;

                    /*
                    * In the automatic case, kick in the empty-auth
                    * hack as long as we would potentially try some
                    * method more exotic than "Basic" or "Digest".
                    *
                    * But only do this when this is our second or
                    * subsequent request, as by then we know what
                    * methods are available.
                    */
                    if (http_auth_methods_restricted &&
                    (http_auth_methods & ~empty_auth_useless))
                            return 1;
                    return 0;
            }

            struct curl_slist *http_append_auth_header(const struct credential *c,
                                                    struct curl_slist *headers)
            {
                    if (c->authtype && c->credential) {
                            struct strbuf auth = STRBUF_INIT;
                            strbuf_addf(&auth, "Authorization: %s %s",
                                    c->authtype, c->credential);
                            headers = curl_slist_append(headers, auth.buf);
                            strbuf_release(&auth);
                    }
                    return headers;
            }

            static void init_curl_http_auth(CURL *result)
            {
                    if ((!http_auth.username || !*http_auth.username) &&
                    (!http_auth.credential || !*http_auth.credential)) {
                            int empty_auth = curl_empty_auth_enabled();
                            if ((empty_auth != -1 && !always_auth_proactively()) || empty_auth == 1) {
                                    curl_easy_setopt(result, CURLOPT_USERPWD, ":");
                                    return;
                            } else if (!always_auth_proactively()) {
                                    return;
                            } else if (http_proactive_auth == PROACTIVE_AUTH_BASIC) {
                                    strvec_push(&http_auth.wwwauth_headers, "Basic");
                            }
                    }

                    credential_fill(&http_auth, 1);

                    if (http_auth.password) {
                            if (always_auth_proactively()) {
                                    /*
                                    * We got a credential without an authtype and we don't
                                    * know what's available.  Since our only two options at
                                    * the moment are auto (which defaults to basic) and
                                    * basic, use basic for now.
                                    */
                                    curl_easy_setopt(result, CURLOPT_HTTPAUTH, CURLAUTH_BASIC);
                            }
                            curl_easy_setopt(result, CURLOPT_USERNAME, http_auth.username);
                            curl_easy_setopt(result, CURLOPT_PASSWORD, http_auth.password);
                    }
            }

            /* *var must be free-able */
            static void var_override(char **var, char *value)
            {
                    if (value) {
                            free(*var);
                            *var = xstrdup(value);
                    }
            }

            static void set_proxyauth_name_password(CURL *result)
            {
                    if (proxy_auth.password) {
                            curl_easy_setopt(result, CURLOPT_PROXYUSERNAME,
                                    proxy_auth.username);
                            curl_easy_setopt(result, CURLOPT_PROXYPASSWORD,
                                    proxy_auth.password);
                    } else if (proxy_auth.authtype && proxy_auth.credential) {
                            curl_easy_setopt(result, CURLOPT_PROXYHEADER,
                                            http_append_auth_header(&proxy_auth, NULL));
                    }
            }

            static void init_curl_proxy_auth(CURL *result)
            {
                    if (proxy_auth.username) {
                            if (!proxy_auth.password && !proxy_auth.credential)
                                    credential_fill(&proxy_auth, 1);
                            set_proxyauth_name_password(result);
                    }

                    var_override(&http_proxy_authmethod, getenv("GIT_HTTP_PROXY_AUTHMETHOD"));

                    if (http_proxy_authmethod) {
                            int i;
                            for (i = 0; i < ARRAY_SIZE(proxy_authmethods); i++) {
                                    if (!strcmp(http_proxy_authmethod, proxy_authmethods[i].name)) {
                                            curl_easy_setopt(result, CURLOPT_PROXYAUTH,
                                                            proxy_authmethods[i].curlauth_param);
                                            break;
                                    }
                            }
                            if (i == ARRAY_SIZE(proxy_authmethods)) {
                                    warning("unsupported proxy authentication method %s: using anyauth",
                                                    http_proxy_authmethod);
                                    curl_easy_setopt(result, CURLOPT_PROXYAUTH, CURLAUTH_ANY);
                            }
                    }
                    else
                            curl_easy_setopt(result, CURLOPT_PROXYAUTH, CURLAUTH_ANY);
            }

            static int has_cert_password(void)
            {
                    if (ssl_cert == NULL || ssl_cert_password_required != 1)
                            return 0;
                    if (!cert_auth.password) {
                            cert_auth.protocol = xstrdup("cert");
                            cert_auth.host = xstrdup("");
                            cert_auth.username = xstrdup("");
                            cert_auth.path = xstrdup(ssl_cert);
                            credential_fill(&cert_auth, 0);
                    }
                    return 1;
            }

            static int has_proxy_cert_password(void)
            {
                    if (http_proxy_ssl_cert == NULL || proxy_ssl_cert_password_required != 1)
                            return 0;
                    if (!proxy_cert_auth.password) {
                            proxy_cert_auth.protocol = xstrdup("cert");
                            proxy_cert_auth.host = xstrdup("");
                            proxy_cert_auth.username = xstrdup("");
                            proxy_cert_auth.path = xstrdup(http_proxy_ssl_cert);
                            credential_fill(&proxy_cert_auth, 0);
                    }
                    return 1;
            }

            static void set_curl_keepalive(CURL *c)
            {
                    curl_easy_setopt(c, CURLOPT_TCP_KEEPALIVE, 1);
            }

            /* Return 1 if redactions have been made, 0 otherwise. */
            static int redact_sensitive_header(struct strbuf *header, size_t offset)
            {
                    int ret = 0;
                    const char *sensitive_header;

                    if (trace_curl_redact &&
                    (skip_iprefix(header->buf + offset, "Authorization:", &sensitive_header) ||
                    skip_iprefix(header->buf + offset, "Proxy-Authorization:", &sensitive_header))) {
                            /* The first token is the type, which is OK to log */
                            while (isspace(*sensitive_header))
                                    sensitive_header++;
                            while (*sensitive_header && !isspace(*sensitive_header))
                                    sensitive_header++;
                            /* Everything else is opaque and possibly sensitive */
                            strbuf_setlen(header,  sensitive_header - header->buf);
                            strbuf_addstr(header, " <redacted>");
                            ret = 1;
                    } else if (trace_curl_redact &&
                            skip_iprefix(header->buf + offset, "Cookie:", &sensitive_header)) {
                            struct strbuf redacted_header = STRBUF_INIT;
                            const char *cookie;

                            while (isspace(*sensitive_header))
                                    sensitive_header++;

                            cookie = sensitive_header;

                            while (cookie) {
                                    char *equals;
                                    char *semicolon = strstr(cookie, "; ");
                                    if (semicolon)
                                            *semicolon = 0;
                                    equals = strchrnul(cookie, '=');
                                    if (!equals) {
                                            /* invalid cookie, just append and continue */
                                            strbuf_addstr(&redacted_header, cookie);
                                            continue;
                                    }
                                    strbuf_add(&redacted_header, cookie, equals - cookie);
                                    strbuf_addstr(&redacted_header, "=<redacted>");
                                    if (semicolon) {
                                            /*
                                            * There are more cookies. (Or, for some
                                            * reason, the input string ends in "; ".)
                                            */
                                            strbuf_addstr(&redacted_header, "; ");
                                            cookie = semicolon + strlen("; ");
                                    } else {
                                            cookie = NULL;
                                    }
                            }

                            strbuf_setlen(header, sensitive_header - header->buf);
                            strbuf_addbuf(header, &redacted_header);
                            strbuf_release(&redacted_header);
                            ret = 1;
                    }
                    return ret;
            }

            static int match_curl_h2_trace(const char *line, const char **out)
            {
                    const char *p;

                    /*
                    * curl prior to 8.1.0 gives us:
                    *
                    *     h2h3 [<header-name>: <header-val>]
                    *
                    * Starting in 8.1.0, the first token became just "h2".
                    */
                    if (skip_iprefix(line, "h2h3 [", out) ||
                    skip_iprefix(line, "h2 [", out))
                            return 1;

                    /*
                    * curl 8.3.0 uses:
                    *   [HTTP/2] [<stream-id>] [<header-name>: <header-val>]
                    * where <stream-id> is numeric.
                    */
                    if (skip_iprefix(line, "[HTTP/2] [", &p)) {
                            while (isdigit(*p))
                                    p++;
                            if (skip_prefix(p, "] [", out))
                                    return 1;
                    }

                    return 0;
            }

            /* Redact headers in info */
            static void redact_sensitive_info_header(struct strbuf *header)
            {
                    const char *sensitive_header;

                    if (trace_curl_redact &&
                    match_curl_h2_trace(header->buf, &sensitive_header)) {
                            if (redact_sensitive_header(header, sensitive_header - header->buf)) {
                                    /* redaction ate our closing bracket */
                                    strbuf_addch(header, ']');
                            }
                    }
            }

            static void curl_dump_header(const char *text, unsigned char *ptr, size_t size, int hide_sensitive_header)
            {
                    struct strbuf out = STRBUF_INIT;
                    struct strbuf **headers, **header;

                    strbuf_addf(&out, "%s, %10.10ld bytes (0x%8.8lx)\n",
                            text, (long)size, (long)size);
                    trace_strbuf(&trace_curl, &out);
                    strbuf_reset(&out);
                    strbuf_add(&out, ptr, size);
                    headers = strbuf_split_max(&out, '\n', 0);

                    for (header = headers; *header; header++) {
                            if (hide_sensitive_header)
                                    redact_sensitive_header(*header, 0);
                            strbuf_insertstr((*header), 0, text);
                            strbuf_insertstr((*header), strlen(text), ": ");
                            strbuf_rtrim((*header));
                            strbuf_addch((*header), '\n');
                            trace_strbuf(&trace_curl, (*header));
                    }
                    strbuf_list_free(headers);
                    strbuf_release(&out);
            }

            static void curl_dump_data(const char *text, unsigned char *ptr, size_t size)
            {
                    size_t i;
                    struct strbuf out = STRBUF_INIT;
                    unsigned int width = 60;

                    strbuf_addf(&out, "%s, %10.10ld bytes (0x%8.8lx)\n",
                            text, (long)size, (long)size);
                    trace_strbuf(&trace_curl, &out);

                    for (i = 0; i < size; i += width) {
                            size_t w;

                            strbuf_reset(&out);
                            strbuf_addf(&out, "%s: ", text);
                            for (w = 0; (w < width) && (i + w < size); w++) {
                                    unsigned char ch = ptr[i + w];

                                    strbuf_addch(&out,
                                            (ch >= 0x20) && (ch < 0x80)
                                            ? ch : '.');
                            }
                            strbuf_addch(&out, '\n');
                            trace_strbuf(&trace_curl, &out);
                    }
                    strbuf_release(&out);
            }

            static void curl_dump_info(char *data, size_t size)
            {
                    struct strbuf buf = STRBUF_INIT;

                    strbuf_add(&buf, data, size);

                    redact_sensitive_info_header(&buf);
                    trace_printf_key(&trace_curl, "== Info: %s", buf.buf);

                    strbuf_release(&buf);
            }

            static int curl_trace(CURL *handle UNUSED, curl_infotype type,
                            char *data, size_t size,
                            void *userp UNUSED)
            {
                    const char *text;
                    enum { NO_FILTER = 0, DO_FILTER = 1 };

                    switch (type) {
                    case CURLINFO_TEXT:
                            curl_dump_info(data, size);
                            break;
                    case CURLINFO_HEADER_OUT:
                            text = "=> Send header";
                            curl_dump_header(text, (unsigned char *)data, size, DO_FILTER);
                            break;
                    case CURLINFO_DATA_OUT:
                            if (trace_curl_data) {
                                    text = "=> Send data";
                                    curl_dump_data(text, (unsigned char *)data, size);
                            }
                            break;
                    case CURLINFO_SSL_DATA_OUT:
                            if (trace_curl_data) {
                                    text = "=> Send SSL data";
                                    curl_dump_data(text, (unsigned char *)data, size);
                            }
                            break;
                    case CURLINFO_HEADER_IN:
                            text = "<= Recv header";
                            curl_dump_header(text, (unsigned char *)data, size, NO_FILTER);
                            break;
                    case CURLINFO_DATA_IN:
                            if (trace_curl_data) {
                                    text = "<= Recv data";
                                    curl_dump_data(text, (unsigned char *)data, size);
                            }
                            break;
                    case CURLINFO_SSL_DATA_IN:
                            if (trace_curl_data) {
                                    text = "<= Recv SSL data";
                                    curl_dump_data(text, (unsigned char *)data, size);
                            }
                            break;

                    default:                /* we ignore unknown types by default */
                            return 0;
                    }
                    return 0;
            }

            void http_trace_curl_no_data(void)
            {
                    trace_override_envvar(&trace_curl, "1");
                    trace_curl_data = 0;
            }

            void setup_curl_trace(CURL *handle)
            {
                    if (!trace_want(&trace_curl))
                            return;
                    curl_easy_setopt(handle, CURLOPT_VERBOSE, 1L);
                    curl_easy_setopt(handle, CURLOPT_DEBUGFUNCTION, curl_trace);
                    curl_easy_setopt(handle, CURLOPT_DEBUGDATA, NULL);
            }

            static void proto_list_append(struct strbuf *list, const char *proto)
            {
                    if (!list)
                            return;
                    if (list->len)
                            strbuf_addch(list, ',');
                    strbuf_addstr(list, proto);
            }

            static long get_curl_allowed_protocols(int from_user, struct strbuf *list)
            {
                    long bits = 0;

                    if (is_transport_allowed("http", from_user)) {
                            bits |= CURLPROTO_HTTP;
                            proto_list_append(list, "http");
                    }
                    if (is_transport_allowed("https", from_user)) {
                            bits |= CURLPROTO_HTTPS;
                            proto_list_append(list, "https");
                    }
                    if (is_transport_allowed("ftp", from_user)) {
                            bits |= CURLPROTO_FTP;
                            proto_list_append(list, "ftp");
                    }
                    if (is_transport_allowed("ftps", from_user)) {
                            bits |= CURLPROTO_FTPS;
                            proto_list_append(list, "ftps");
                    }

                    return bits;
            }

            static int get_curl_http_version_opt(const char *version_string, long *opt)
            {
                    int i;
                    static struct {
                            const char *name;
                            long opt_token;
                    } choice[] = {
                            { "HTTP/1.1", CURL_HTTP_VERSION_1_1 },
                            { "HTTP/2", CURL_HTTP_VERSION_2 }
                    };

                    for (i = 0; i < ARRAY_SIZE(choice); i++) {
                            if (!strcmp(version_string, choice[i].name)) {
                                    *opt = choice[i].opt_token;
                                    return 0;
                            }
                    }

                    warning("unknown value given to http.version: '%s'", version_string);
                    return -1; /* not found */
            }

            static CURL *get_curl_handle(void)
            {
                    CURL *result = curl_easy_init();

                    if (!result)
                            die("curl_easy_init failed");

                    if (!curl_ssl_verify) {
                            curl_easy_setopt(result, CURLOPT_SSL_VERIFYPEER, 0);
                            curl_easy_setopt(result, CURLOPT_SSL_VERIFYHOST, 0);
                    } else {
                            /* Verify authenticity of the peer's certificate */
                            curl_easy_setopt(result, CURLOPT_SSL_VERIFYPEER, 1);
                            /* The name in the cert must match whom we tried to connect */
                            curl_easy_setopt(result, CURLOPT_SSL_VERIFYHOST, 2);
                    }

            if (curl_http_version) {
                            long opt;
                            if (!get_curl_http_version_opt(curl_http_version, &opt)) {
                                    /* Set request use http version */
                                    curl_easy_setopt(result, CURLOPT_HTTP_VERSION, opt);
                            }
            }

                    curl_easy_setopt(result, CURLOPT_NETRC, CURL_NETRC_OPTIONAL);
                    curl_easy_setopt(result, CURLOPT_HTTPAUTH, CURLAUTH_ANY);

            #ifdef CURLGSSAPI_DELEGATION_FLAG
                    if (curl_deleg) {
                            int i;
                            for (i = 0; i < ARRAY_SIZE(curl_deleg_levels); i++) {
                                    if (!strcmp(curl_deleg, curl_deleg_levels[i].name)) {
                                            curl_easy_setopt(result, CURLOPT_GSSAPI_DELEGATION,
                                                            curl_deleg_levels[i].curl_deleg_param);
                                            break;
                                    }
                            }
                            if (i == ARRAY_SIZE(curl_deleg_levels))
                                    warning("Unknown delegation method '%s': using default",
                                            curl_deleg);
                    }
            #endif

                    if (http_ssl_backend && !strcmp("schannel", http_ssl_backend) &&
                    !http_schannel_check_revoke) {
                            curl_easy_setopt(result, CURLOPT_SSL_OPTIONS, CURLSSLOPT_NO_REVOKE);
                    }

                    if (http_proactive_auth != PROACTIVE_AUTH_NONE)
                            init_curl_http_auth(result);

                    if (getenv("GIT_SSL_VERSION"))
                            ssl_version = getenv("GIT_SSL_VERSION");
                    if (ssl_version && *ssl_version) {
                            int i;
                            for (i = 0; i < ARRAY_SIZE(sslversions); i++) {
                                    if (!strcmp(ssl_version, sslversions[i].name)) {
                                            curl_easy_setopt(result, CURLOPT_SSLVERSION,
                                                            sslversions[i].ssl_version);
                                            break;
                                    }
                            }
                            if (i == ARRAY_SIZE(sslversions))
                                    warning("unsupported ssl version %s: using default",
                                            ssl_version);
                    }

                    if (getenv("GIT_SSL_CIPHER_LIST"))
                            ssl_cipherlist = getenv("GIT_SSL_CIPHER_LIST");
                    if (ssl_cipherlist != NULL && *ssl_cipherlist)
                            curl_easy_setopt(result, CURLOPT_SSL_CIPHER_LIST,
                                            ssl_cipherlist);

                    if (ssl_cert)
                            curl_easy_setopt(result, CURLOPT_SSLCERT, ssl_cert);
                    if (ssl_cert_type)
                            curl_easy_setopt(result, CURLOPT_SSLCERTTYPE, ssl_cert_type);
                    if (has_cert_password())
                            curl_easy_setopt(result, CURLOPT_KEYPASSWD, cert_auth.password);
                    if (ssl_key)
                            curl_easy_setopt(result, CURLOPT_SSLKEY, ssl_key);
                    if (ssl_key_type)
                            curl_easy_setopt(result, CURLOPT_SSLKEYTYPE, ssl_key_type);
                    if (ssl_capath)
                            curl_easy_setopt(result, CURLOPT_CAPATH, ssl_capath);
                    if (ssl_pinnedkey)
                            curl_easy_setopt(result, CURLOPT_PINNEDPUBLICKEY, ssl_pinnedkey);
                    if (http_ssl_backend && !strcmp("schannel", http_ssl_backend) &&
                    !http_schannel_use_ssl_cainfo) {
                            curl_easy_setopt(result, CURLOPT_CAINFO, NULL);
                            curl_easy_setopt(result, CURLOPT_PROXY_CAINFO, NULL);
                    } else if (ssl_cainfo != NULL || http_proxy_ssl_ca_info != NULL) {
                            if (ssl_cainfo)
                                    curl_easy_setopt(result, CURLOPT_CAINFO, ssl_cainfo);
                            if (http_proxy_ssl_ca_info)
                                    curl_easy_setopt(result, CURLOPT_PROXY_CAINFO, http_proxy_ssl_ca_info);
                    }

                    if (curl_low_speed_limit > 0 && curl_low_speed_time > 0) {
                            curl_easy_setopt(result, CURLOPT_LOW_SPEED_LIMIT,
                                            curl_low_speed_limit);
                            curl_easy_setopt(result, CURLOPT_LOW_SPEED_TIME,
                                            curl_low_speed_time);
                    }

                    curl_easy_setopt(result, CURLOPT_MAXREDIRS, 20);
                    curl_easy_setopt(result, CURLOPT_POSTREDIR, CURL_REDIR_POST_ALL);

            #ifdef GIT_CURL_HAVE_CURLOPT_PROTOCOLS_STR
                    {
                            struct strbuf buf = STRBUF_INIT;

                            get_curl_allowed_protocols(0, &buf);
                            curl_easy_setopt(result, CURLOPT_REDIR_PROTOCOLS_STR, buf.buf);
                            strbuf_reset(&buf);

                            get_curl_allowed_protocols(-1, &buf);
                            curl_easy_setopt(result, CURLOPT_PROTOCOLS_STR, buf.buf);
                            strbuf_release(&buf);
                    }
            #else
                    curl_easy_setopt(result, CURLOPT_REDIR_PROTOCOLS,
                                    get_curl_allowed_protocols(0, NULL));
                    curl_easy_setopt(result, CURLOPT_PROTOCOLS,
                                    get_curl_allowed_protocols(-1, NULL));
            #endif

                    if (getenv("GIT_CURL_VERBOSE"))
                            http_trace_curl_no_data();
                    setup_curl_trace(result);
                    if (getenv("GIT_TRACE_CURL_NO_DATA"))
                            trace_curl_data = 0;
                    if (!git_env_bool("GIT_TRACE_REDACT", 1))
                            trace_curl_redact = 0;

                    curl_easy_setopt(result, CURLOPT_USERAGENT,
                            user_agent ? user_agent : git_user_agent());

                    if (curl_ftp_no_epsv)
                            curl_easy_setopt(result, CURLOPT_FTP_USE_EPSV, 0);

                    if (curl_ssl_try)
                            curl_easy_setopt(result, CURLOPT_USE_SSL, CURLUSESSL_TRY);

                    /*
                    * CURL also examines these variables as a fallback; but we need to query
                    * them here in order to decide whether to prompt for missing password (cf.
                    * init_curl_proxy_auth()).
                    *
                    * Unlike many other common environment variables, these are historically
                    * lowercase only. It appears that CURL did not know this and implemented
                    * only uppercase variants, which was later corrected to take both - with
                    * the exception of http_proxy, which is lowercase only also in CURL. As
                    * the lowercase versions are the historical quasi-standard, they take
                    * precedence here, as in CURL.
                    */
                    if (!curl_http_proxy) {
                            if (http_auth.protocol && !strcmp(http_auth.protocol, "https")) {
                                    var_override(&curl_http_proxy, getenv("HTTPS_PROXY"));
                                    var_override(&curl_http_proxy, getenv("https_proxy"));
                            } else {
                                    var_override(&curl_http_proxy, getenv("http_proxy"));
                            }
                            if (!curl_http_proxy) {
                                    var_override(&curl_http_proxy, getenv("ALL_PROXY"));
                                    var_override(&curl_http_proxy, getenv("all_proxy"));
                            }
                    }

                    if (curl_http_proxy && curl_http_proxy[0] == '\0') {
                            /*
                            * Handle case with the empty http.proxy value here to keep
                            * common code clean.
                            * NB: empty option disables proxying at all.
                            */
                            curl_easy_setopt(result, CURLOPT_PROXY, "");
                    } else if (curl_http_proxy) {
                            struct strbuf proxy = STRBUF_INIT;

                            if (starts_with(curl_http_proxy, "socks5h"))
                                    curl_easy_setopt(result,
                                            CURLOPT_PROXYTYPE, CURLPROXY_SOCKS5_HOSTNAME);
                            else if (starts_with(curl_http_proxy, "socks5"))
                                    curl_easy_setopt(result,
                                            CURLOPT_PROXYTYPE, CURLPROXY_SOCKS5);
                            else if (starts_with(curl_http_proxy, "socks4a"))
                                    curl_easy_setopt(result,
                                            CURLOPT_PROXYTYPE, CURLPROXY_SOCKS4A);
                            else if (starts_with(curl_http_proxy, "socks"))
                                    curl_easy_setopt(result,
                                            CURLOPT_PROXYTYPE, CURLPROXY_SOCKS4);
                            else if (starts_with(curl_http_proxy, "https")) {
                                    curl_easy_setopt(result, CURLOPT_PROXYTYPE, CURLPROXY_HTTPS);

                                    if (http_proxy_ssl_cert)
                                            curl_easy_setopt(result, CURLOPT_PROXY_SSLCERT, http_proxy_ssl_cert);

                                    if (http_proxy_ssl_key)
                                            curl_easy_setopt(result, CURLOPT_PROXY_SSLKEY, http_proxy_ssl_key);

                                    if (has_proxy_cert_password())
                                            curl_easy_setopt(result, CURLOPT_PROXY_KEYPASSWD, proxy_cert_auth.password);
                            }
                            if (strstr(curl_http_proxy, "://"))
                                    credential_from_url(&proxy_auth, curl_http_proxy);
                            else {
                                    struct strbuf url = STRBUF_INIT;
                                    strbuf_addf(&url, "http://%s", curl_http_proxy);
                                    credential_from_url(&proxy_auth, url.buf);
                                    strbuf_release(&url);
                            }

                            if (!proxy_auth.host)
                                    die("Invalid proxy URL '%s'", curl_http_proxy);

                            strbuf_addstr(&proxy, proxy_auth.host);
                            if (proxy_auth.path) {
                                    curl_version_info_data *ver = curl_version_info(CURLVERSION_NOW);

                                    if (ver->version_num < 0x075400)
                                            die("libcurl 7.84 or later is required to support paths in proxy URLs");

                                    if (!starts_with(proxy_auth.protocol, "socks"))
                                            die("Invalid proxy URL '%s': only SOCKS proxies support paths",
                                            curl_http_proxy);

                                    if (strcasecmp(proxy_auth.host, "localhost"))
                                            die("Invalid proxy URL '%s': host must be localhost if a path is present",
                                            curl_http_proxy);

                                    strbuf_addch(&proxy, '/');
                                    strbuf_add_percentencode(&proxy, proxy_auth.path, 0);
                            }
                            curl_easy_setopt(result, CURLOPT_PROXY, proxy.buf);
                            strbuf_release(&proxy);

                            var_override(&curl_no_proxy, getenv("NO_PROXY"));
                            var_override(&curl_no_proxy, getenv("no_proxy"));
                            curl_easy_setopt(result, CURLOPT_NOPROXY, curl_no_proxy);
                    }
                    init_curl_proxy_auth(result);

                    set_curl_keepalive(result);

                    return result;
            }

            static void set_from_env(char **var, const char *envname)
            {
                    const char *val = getenv(envname);
                    if (val) {
                            FREE_AND_NULL(*var);
                            *var = xstrdup(val);
                    }
            }

            void http_init(struct remote *remote, const char *url, int proactive_auth)
            {
                    char *low_speed_limit;
                    char *low_speed_time;
                    char *normalized_url;
                    struct urlmatch_config config = URLMATCH_CONFIG_INIT;

                    config.section = "http";
                    config.key = NULL;
                    config.collect_fn = http_options;
                    config.cascade_fn = git_default_config;
                    config.cb = NULL;

                    http_is_verbose = 0;
                    normalized_url = url_normalize(url, &config.url);

                    git_config(urlmatch_config_entry, &config);
                    free(normalized_url);
                    string_list_clear(&config.vars, 1);

                    if (http_ssl_backend) {
                            const curl_ssl_backend **backends;
                            struct strbuf buf = STRBUF_INIT;
                            int i;

                            switch (curl_global_sslset(-1, http_ssl_backend, &backends)) {
                            case CURLSSLSET_UNKNOWN_BACKEND:
                                    strbuf_addf(&buf, _("Unsupported SSL backend '%s'. "
                                                    "Supported SSL backends:"),
                                                    http_ssl_backend);
                                    for (i = 0; backends[i]; i++)
                                            strbuf_addf(&buf, "\n\t%s", backends[i]->name);
                                    die("%s", buf.buf);
                            case CURLSSLSET_NO_BACKENDS:
                                    die(_("Could not set SSL backend to '%s': "
                                    "cURL was built without SSL backends"),
                                    http_ssl_backend);
                            case CURLSSLSET_TOO_LATE:
                                    die(_("Could not set SSL backend to '%s': already set"),
                                    http_ssl_backend);
                            case CURLSSLSET_OK:
                                    break; /* Okay! */
                            }
                    }

                    if (curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK)
                            die("curl_global_init failed");

                    if (proactive_auth && http_proactive_auth == PROACTIVE_AUTH_NONE)
                            http_proactive_auth = PROACTIVE_AUTH_IF_CREDENTIALS;

                    if (remote && remote->http_proxy)
                            curl_http_proxy = xstrdup(remote->http_proxy);

                    if (remote)
                            var_override(&http_proxy_authmethod, remote->http_proxy_authmethod);

                    pragma_header = curl_slist_append(http_copy_default_headers(),
                            "Pragma: no-cache");

                    {
                            char *http_max_requests = getenv("GIT_HTTP_MAX_REQUESTS");
                            if (http_max_requests)
                                    max_requests = atoi(http_max_requests);
                    }

                    curlm = curl_multi_init();
                    if (!curlm)
                            die("curl_multi_init failed");

                    if (getenv("GIT_SSL_NO_VERIFY"))
                            curl_ssl_verify = 0;

                    set_from_env(&ssl_cert, "GIT_SSL_CERT");
                    set_from_env(&ssl_cert_type, "GIT_SSL_CERT_TYPE");
                    set_from_env(&ssl_key, "GIT_SSL_KEY");
                    set_from_env(&ssl_key_type, "GIT_SSL_KEY_TYPE");
                    set_from_env(&ssl_capath, "GIT_SSL_CAPATH");
                    set_from_env(&ssl_cainfo, "GIT_SSL_CAINFO");

                    set_from_env(&user_agent, "GIT_HTTP_USER_AGENT");

                    low_speed_limit = getenv("GIT_HTTP_LOW_SPEED_LIMIT");
                    if (low_speed_limit)
                            curl_low_speed_limit = strtol(low_speed_limit, NULL, 10);
                    low_speed_time = getenv("GIT_HTTP_LOW_SPEED_TIME");
                    if (low_speed_time)
                            curl_low_speed_time = strtol(low_speed_time, NULL, 10);

                    if (curl_ssl_verify == -1)
                            curl_ssl_verify = 1;

                    curl_session_count = 0;
                    if (max_requests < 1)
                            max_requests = DEFAULT_MAX_REQUESTS;

                    set_from_env(&http_proxy_ssl_cert, "GIT_PROXY_SSL_CERT");
                    set_from_env(&http_proxy_ssl_key, "GIT_PROXY_SSL_KEY");
                    set_from_env(&http_proxy_ssl_ca_info, "GIT_PROXY_SSL_CAINFO");

                    if (getenv("GIT_PROXY_SSL_CERT_PASSWORD_PROTECTED"))
                            proxy_ssl_cert_password_required = 1;

                    if (getenv("GIT_CURL_FTP_NO_EPSV"))
                            curl_ftp_no_epsv = 1;

                    if (url) {
                            credential_from_url(&http_auth, url);
                            if (!ssl_cert_password_required &&
                            getenv("GIT_SSL_CERT_PASSWORD_PROTECTED") &&
                            starts_with(url, "https://"))
                                    ssl_cert_password_required = 1;
                    }

                    curl_default = get_curl_handle();
            }

            void http_cleanup(void)
            {
                    struct active_request_slot *slot = active_queue_head;

                    while (slot != NULL) {
                            struct active_request_slot *next = slot->next;
                            if (slot->curl) {
                                    xmulti_remove_handle(slot);
                                    curl_easy_cleanup(slot->curl);
                            }
                            free(slot);
                            slot = next;
                    }
                    active_queue_head = NULL;

                    curl_easy_cleanup(curl_default);

                    curl_multi_cleanup(curlm);
                    curl_global_cleanup();

                    string_list_clear(&extra_http_headers, 0);

                    curl_slist_free_all(pragma_header);
                    pragma_header = NULL;

                    curl_slist_free_all(host_resolutions);
                    host_resolutions = NULL;

                    if (curl_http_proxy) {
                            free((void *)curl_http_proxy);
                            curl_http_proxy = NULL;
                    }

                    if (proxy_auth.password) {
                            memset(proxy_auth.password, 0, strlen(proxy_auth.password));
                            FREE_AND_NULL(proxy_auth.password);
                    }

                    free((void *)curl_proxyuserpwd);
                    curl_proxyuserpwd = NULL;

                    free((void *)http_proxy_authmethod);
                    http_proxy_authmethod = NULL;

                    if (cert_auth.password) {
                            memset(cert_auth.password, 0, strlen(cert_auth.password));
                            FREE_AND_NULL(cert_auth.password);
                    }
                    ssl_cert_password_required = 0;

                    if (proxy_cert_auth.password) {
                            memset(proxy_cert_auth.password, 0, strlen(proxy_cert_auth.password));
                            FREE_AND_NULL(proxy_cert_auth.password);
                    }
                    proxy_ssl_cert_password_required = 0;

                    FREE_AND_NULL(cached_accept_language);
            }

            struct active_request_slot *get_active_slot(void)
            {
                    struct active_request_slot *slot = active_queue_head;
                    struct active_request_slot *newslot;

                    int num_transfers;

                    /* Wait for a slot to open up if the queue is full */
                    while (active_requests >= max_requests) {
                            curl_multi_perform(curlm, &num_transfers);
                            if (num_transfers < active_requests)
                                    process_curl_messages();
                    }

                    while (slot != NULL && slot->in_use)
                            slot = slot->next;

                    if (!slot) {
                            newslot = xmalloc(sizeof(*newslot));
                            newslot->curl = NULL;
                            newslot->in_use = 0;
                            newslot->next = NULL;

                            slot = active_queue_head;
                            if (!slot) {
                                    active_queue_head = newslot;
                            } else {
                                    while (slot->next != NULL)
                                            slot = slot->next;
                                    slot->next = newslot;
                            }
                            slot = newslot;
                    }

                    if (!slot->curl) {
                            slot->curl = curl_easy_duphandle(curl_default);
                            curl_session_count++;
                    }

                    active_requests++;
                    slot->in_use = 1;
                    slot->results = NULL;
                    slot->finished = NULL;
                    slot->callback_data = NULL;
                    slot->callback_func = NULL;

                    if (curl_cookie_file && !strcmp(curl_cookie_file, "-")) {
                            warning(_("refusing to read cookies from http.cookiefile '-'"));
                            FREE_AND_NULL(curl_cookie_file);
                    }
                    curl_easy_setopt(slot->curl, CURLOPT_COOKIEFILE, curl_cookie_file);
                    if (curl_save_cookies && (!curl_cookie_file || !curl_cookie_file[0])) {
                            curl_save_cookies = 0;
                            warning(_("ignoring http.savecookies for empty http.cookiefile"));
                    }
                    if (curl_save_cookies)
                            curl_easy_setopt(slot->curl, CURLOPT_COOKIEJAR, curl_cookie_file);
                    curl_easy_setopt(slot->curl, CURLOPT_HTTPHEADER, pragma_header);
                    curl_easy_setopt(slot->curl, CURLOPT_RESOLVE, host_resolutions);
                    curl_easy_setopt(slot->curl, CURLOPT_ERRORBUFFER, curl_errorstr);
                    curl_easy_setopt(slot->curl, CURLOPT_CUSTOMREQUEST, NULL);
                    curl_easy_setopt(slot->curl, CURLOPT_READFUNCTION, NULL);
                    curl_easy_setopt(slot->curl, CURLOPT_WRITEFUNCTION, NULL);
                    curl_easy_setopt(slot->curl, CURLOPT_POSTFIELDS, NULL);
                    curl_easy_setopt(slot->curl, CURLOPT_POSTFIELDSIZE, -1L);
                    curl_easy_setopt(slot->curl, CURLOPT_UPLOAD, 0);
                    curl_easy_setopt(slot->curl, CURLOPT_HTTPGET, 1);
                    curl_easy_setopt(slot->curl, CURLOPT_FAILONERROR, 1);
                    curl_easy_setopt(slot->curl, CURLOPT_RANGE, NULL);

                    /*
                    * Default following to off unless "ALWAYS" is configured; this gives
                    * callers a sane starting point, and they can tweak for individual
                    * HTTP_FOLLOW_* cases themselves.
                    */
                    if (http_follow_config == HTTP_FOLLOW_ALWAYS)
                            curl_easy_setopt(slot->curl, CURLOPT_FOLLOWLOCATION, 1);
                    else
                            curl_easy_setopt(slot->curl, CURLOPT_FOLLOWLOCATION, 0);

                    curl_easy_setopt(slot->curl, CURLOPT_IPRESOLVE, git_curl_ipresolve);
                    curl_easy_setopt(slot->curl, CURLOPT_HTTPAUTH, http_auth_methods);
                    if (http_auth.password || http_auth.credential || curl_empty_auth_enabled())
                            init_curl_http_auth(slot->curl);

                    return slot;
            }

            int start_active_slot(struct active_request_slot *slot)
            {
                    CURLMcode curlm_result = curl_multi_add_handle(curlm, slot->curl);
                    int num_transfers;

                    if (curlm_result != CURLM_OK &&
                    curlm_result != CURLM_CALL_MULTI_PERFORM) {
                            warning("curl_multi_add_handle failed: %s",
                                    curl_multi_strerror(curlm_result));
                            active_requests--;
                            slot->in_use = 0;
                            return 0;
                    }

                    /*
                    * We know there must be something to do, since we just added
                    * something.
                    */
                    curl_multi_perform(curlm, &num_transfers);
                    return 1;
            }

            struct fill_chain {
                    void *data;
                    int (*fill)(void *);
                    struct fill_chain *next;
            };

            static struct fill_chain *fill_cfg;

            void add_fill_function(void *data, int (*fill)(void *))
            {
                    struct fill_chain *new_fill = xmalloc(sizeof(*new_fill));
                    struct fill_chain **linkp = &fill_cfg;
                    new_fill->data = data;
                    new_fill->fill = fill;
                    new_fill->next = NULL;
                    while (*linkp)
                            linkp = &(*linkp)->next;
                    *linkp = new_fill;
            }

            void fill_active_slots(void)
            {
                    struct active_request_slot *slot = active_queue_head;

                    while (active_requests < max_requests) {
                            struct fill_chain *fill;
                            for (fill = fill_cfg; fill; fill = fill->next)
                                    if (fill->fill(fill->data))
                                            break;

                            if (!fill)
                                    break;
                    }

                    while (slot != NULL) {
                            if (!slot->in_use && slot->curl != NULL
                                    && curl_session_count > min_curl_sessions) {
                                    curl_easy_cleanup(slot->curl);
                                    slot->curl = NULL;
                                    curl_session_count--;
                            }
                            slot = slot->next;
                    }
            }

            void step_active_slots(void)
            {
                    int num_transfers;
                    CURLMcode curlm_result;

                    do {
                            curlm_result = curl_multi_perform(curlm, &num_transfers);
                    } while (curlm_result == CURLM_CALL_MULTI_PERFORM);
                    if (num_transfers < active_requests) {
                            process_curl_messages();
                            fill_active_slots();
                    }
            }

            void run_active_slot(struct active_request_slot *slot)
            {
                    fd_set readfds;
                    fd_set writefds;
                    fd_set excfds;
                    int max_fd;
                    struct timeval select_timeout;
                    int finished = 0;

                    slot->finished = &finished;
                    while (!finished) {
                            step_active_slots();

                            if (slot->in_use) {
                                    long curl_timeout;
                                    curl_multi_timeout(curlm, &curl_timeout);
                                    if (curl_timeout == 0) {
                                            continue;
                                    } else if (curl_timeout == -1) {
                                            select_timeout.tv_sec  = 0;
                                            select_timeout.tv_usec = 50000;
                                    } else {
                                            select_timeout.tv_sec  =  curl_timeout / 1000;
                                            select_timeout.tv_usec = (curl_timeout % 1000) * 1000;
                                    }

                                    max_fd = -1;
                                    FD_ZERO(&readfds);
                                    FD_ZERO(&writefds);
                                    FD_ZERO(&excfds);
                                    curl_multi_fdset(curlm, &readfds, &writefds, &excfds, &max_fd);

                                    /*
                                    * It can happen that curl_multi_timeout returns a pathologically
                                    * long timeout when curl_multi_fdset returns no file descriptors
                                    * to read.  See commit message for more details.
                                    */
                                    if (max_fd < 0 &&
                                    (select_timeout.tv_sec > 0 ||
                                    select_timeout.tv_usec > 50000)) {
                                            select_timeout.tv_sec  = 0;
                                            select_timeout.tv_usec = 50000;
                                    }

                                    select(max_fd+1, &readfds, &writefds, &excfds, &select_timeout);
                            }
                    }

                    /*
                    * The value of slot->finished we set before the loop was used
                    * to set our "finished" variable when our request completed.
                    *
                    * 1. The slot may not have been reused for another request
                    *    yet, in which case it still has &finished.
                    *
                    * 2. The slot may already be in-use to serve another request,
                    *    which can further be divided into two cases:
                    *
                    * (a) If call run_active_slot() hasn't been called for that
                    *     other request, slot->finished would have been cleared
                    *     by get_active_slot() and has NULL.
                    *
                    * (b) If the request did call run_active_slot(), then the
                    *     call would have updated slot->finished at the beginning
                    *     of this function, and with the clearing of the member
                    *     below, we would find that slot->finished is now NULL.
                    *
                    * In all cases, slot->finished has no useful information to
                    * anybody at this point.  Some compilers warn us for
                    * attempting to smuggle a pointer that is about to become
                    * invalid, i.e. &finished.  We clear it here to assure them.
                    */
                    slot->finished = NULL;
            }

            static void release_active_slot(struct active_request_slot *slot)
            {
                    closedown_active_slot(slot);
                    if (slot->curl) {
                            xmulti_remove_handle(slot);
                            if (curl_session_count > min_curl_sessions) {
                                    curl_easy_cleanup(slot->curl);
                                    slot->curl = NULL;
                                    curl_session_count--;
                            }
                    }
                    fill_active_slots();
            }

            void finish_all_active_slots(void)
            {
                    struct active_request_slot *slot = active_queue_head;

                    while (slot != NULL)
                            if (slot->in_use) {
                                    run_active_slot(slot);
                                    slot = active_queue_head;
                            } else {
                                    slot = slot->next;
                            }
            }

            /* Helpers for modifying and creating URLs */
            static inline int needs_quote(int ch)
            {
                    if (((ch >= 'A') && (ch <= 'Z'))
                                    || ((ch >= 'a') && (ch <= 'z'))
                                    || ((ch >= '0') && (ch <= '9'))
                                    || (ch == '/')
                                    || (ch == '-')
                                    || (ch == '.'))
                            return 0;
                    return 1;
            }

            static char *quote_ref_url(const char *base, const char *ref)
            {
                    struct strbuf buf = STRBUF_INIT;
                    const char *cp;
                    int ch;

                    end_url_with_slash(&buf, base);

                    for (cp = ref; (ch = *cp) != 0; cp++)
                            if (needs_quote(ch))
                                    strbuf_addf(&buf, "%%%02x", ch);
                            else
                                    strbuf_addch(&buf, *cp);

                    return strbuf_detach(&buf, NULL);
            }

            void append_remote_object_url(struct strbuf *buf, const char *url,
                                    const char *hex,
                                    int only_two_digit_prefix)
            {
                    end_url_with_slash(buf, url);

                    strbuf_addf(buf, "objects/%.*s/", 2, hex);
                    if (!only_two_digit_prefix)
                            strbuf_addstr(buf, hex + 2);
            }

            char *get_remote_object_url(const char *url, const char *hex,
                                    int only_two_digit_prefix)
            {
                    struct strbuf buf = STRBUF_INIT;
                    append_remote_object_url(&buf, url, hex, only_two_digit_prefix);
                    return strbuf_detach(&buf, NULL);
            }

            void normalize_curl_result(CURLcode *result, long http_code,
                                    char *errorstr, size_t errorlen)
            {
                    /*
                    * If we see a failing http code with CURLE_OK, we have turned off
                    * FAILONERROR (to keep the server's custom error response), and should
                    * translate the code into failure here.
                    *
                    * Likewise, if we see a redirect (30x code), that means we turned off
                    * redirect-following, and we should treat the result as an error.
                    */
                    if (*result == CURLE_OK && http_code >= 300) {
                            *result = CURLE_HTTP_RETURNED_ERROR;
                            /*
                            * Normally curl will already have put the "reason phrase"
                            * from the server into curl_errorstr; unfortunately without
                            * FAILONERROR it is lost, so we can give only the numeric
                            * status code.
                            */
                            xsnprintf(errorstr, errorlen,
                                    "The requested URL returned error: %ld",
                                    http_code);
                    }
            }

            static int handle_curl_result(struct slot_results *results)
            {
                    normalize_curl_result(&results->curl_result, results->http_code,
                                    curl_errorstr, sizeof(curl_errorstr));

                    if (results->curl_result == CURLE_OK) {
                            credential_approve(&http_auth);
                            credential_approve(&proxy_auth);
                            credential_approve(&cert_auth);
                            return HTTP_OK;
                    } else if (results->curl_result == CURLE_SSL_CERTPROBLEM) {
                            /*
                            * We can't tell from here whether it's a bad path, bad
                            * certificate, bad password, or something else wrong
                            * with the certificate.  So we reject the credential to
                            * avoid caching or saving a bad password.
                            */
                            credential_reject(&cert_auth);
                            return HTTP_NOAUTH;
                    } else if (results->curl_result == CURLE_SSL_PINNEDPUBKEYNOTMATCH) {
                            return HTTP_NOMATCHPUBLICKEY;
                    } else if (missing_target(results))
                            return HTTP_MISSING_TARGET;
                    else if (results->http_code == 401) {
                            if ((http_auth.username && http_auth.password) ||\
                            (http_auth.authtype && http_auth.credential)) {
                                    if (http_auth.multistage) {
                                            credential_clear_secrets(&http_auth);
                                            return HTTP_REAUTH;
                                    }
                                    credential_reject(&http_auth);
                                    if (always_auth_proactively())
                                            http_proactive_auth = PROACTIVE_AUTH_NONE;
                                    return HTTP_NOAUTH;
                            } else {
                                    http_auth_methods &= ~CURLAUTH_GSSNEGOTIATE;
                                    if (results->auth_avail) {
                                            http_auth_methods &= results->auth_avail;
                                            http_auth_methods_restricted = 1;
                                    }
                                    return HTTP_REAUTH;
                            }
                    } else {
                            if (results->http_connectcode == 407)
                                    credential_reject(&proxy_auth);
                            if (!curl_errorstr[0])
                                    strlcpy(curl_errorstr,
                                            curl_easy_strerror(results->curl_result),
                                            sizeof(curl_errorstr));
                            return HTTP_ERROR;
                    }
            }

            int run_one_slot(struct active_request_slot *slot,
                            struct slot_results *results)
            {
                    slot->results = results;
                    if (!start_active_slot(slot)) {
                            xsnprintf(curl_errorstr, sizeof(curl_errorstr),
                                    "failed to start HTTP request");
                            return HTTP_START_FAILED;
                    }

                    run_active_slot(slot);
                    return handle_curl_result(results);
            }

            struct curl_slist *http_copy_default_headers(void)
            {
                    struct curl_slist *headers = NULL;
                    const struct string_list_item *item;

                    for_each_string_list_item(item, &extra_http_headers)
                            headers = curl_slist_append(headers, item->string);

                    return headers;
            }

            static CURLcode curlinfo_strbuf(CURL *curl, CURLINFO info, struct strbuf *buf)
            {
                    char *ptr;
                    CURLcode ret;

                    strbuf_reset(buf);
                    ret = curl_easy_getinfo(curl, info, &ptr);
                    if (!ret && ptr)
                            strbuf_addstr(buf, ptr);
                    return ret;
            }

            /*
            * Check for and extract a content-type parameter. "raw"
            * should be positioned at the start of the potential
            * parameter, with any whitespace already removed.
            *
            * "name" is the name of the parameter. The value is appended
            * to "out".
            */
            static int extract_param(const char *raw, const char *name,
                                    struct strbuf *out)
            {
                    size_t len = strlen(name);

                    if (strncasecmp(raw, name, len))
                            return -1;
                    raw += len;

                    if (*raw != '=')
                            return -1;
                    raw++;

                    while (*raw && !isspace(*raw) && *raw != ';')
                            strbuf_addch(out, *raw++);
                    return 0;
            }

            /*
            * Extract a normalized version of the content type, with any
            * spaces suppressed, all letters lowercased, and no trailing ";"
            * or parameters.
            *
            * Note that we will silently remove even invalid whitespace. For
            * example, "text / plain" is specifically forbidden by RFC 2616,
            * but "text/plain" is the only reasonable output, and this keeps
            * our code simple.
            *
            * If the "charset" argument is not NULL, store the value of any
            * charset parameter there.
            *
            * Example:
            *   "TEXT/PLAIN; charset=utf-8" -> "text/plain", "utf-8"
            *   "text / plain" -> "text/plain"
            */
            static void extract_content_type(struct strbuf *raw, struct strbuf *type,
                                            struct strbuf *charset)
            {
                    const char *p;

                    strbuf_reset(type);
                    strbuf_grow(type, raw->len);
                    for (p = raw->buf; *p; p++) {
                            if (isspace(*p))
                                    continue;
                            if (*p == ';') {
                                    p++;
                                    break;
                            }
                            strbuf_addch(type, tolower(*p));
                    }

                    if (!charset)
                            return;

                    strbuf_reset(charset);
                    while (*p) {
                            while (isspace(*p) || *p == ';')
                                    p++;
                            if (!extract_param(p, "charset", charset))
                                    return;
                            while (*p && !isspace(*p))
                                    p++;
                    }

                    if (!charset->len && starts_with(type->buf, "text/"))
                            strbuf_addstr(charset, "ISO-8859-1");
            }

            static void write_accept_language(struct strbuf *buf)
            {
                    /*
                    * MAX_DECIMAL_PLACES must not be larger than 3. If it is larger than
                    * that, q-value will be smaller than 0.001, the minimum q-value the
                    * HTTP specification allows. See
                    * https://datatracker.ietf.org/doc/html/rfc7231#section-5.3.1 for q-value.
                    */
                    const int MAX_DECIMAL_PLACES = 3;
                    const int MAX_LANGUAGE_TAGS = 1000;
                    const int MAX_ACCEPT_LANGUAGE_HEADER_SIZE = 4000;
                    char **language_tags = NULL;
                    int num_langs = 0;
                    const char *s = get_preferred_languages();
                    int i;
                    struct strbuf tag = STRBUF_INIT;

                    /* Don't add Accept-Language header if no language is preferred. */
                    if (!s)
                            return;

                    /*
                    * Split the colon-separated string of preferred languages into
                    * language_tags array.
                    */
                    do {
                            /* collect language tag */
                            for (; *s && (isalnum(*s) || *s == '_'); s++)
                                    strbuf_addch(&tag, *s == '_' ? '-' : *s);

                            /* skip .codeset, @modifier and any other unnecessary parts */
                            while (*s && *s != ':')
                                    s++;

                            if (tag.len) {
                                    num_langs++;
                                    REALLOC_ARRAY(language_tags, num_langs);
                                    language_tags[num_langs - 1] = strbuf_detach(&tag, NULL);
                                    if (num_langs >= MAX_LANGUAGE_TAGS - 1) /* -1 for '*' */
                                            break;
                            }
                    } while (*s++);

                    /* write Accept-Language header into buf */
                    if (num_langs) {
                            int last_buf_len = 0;
                            int max_q;
                            int decimal_places;
                            char q_format[32];

                            /* add '*' */
                            REALLOC_ARRAY(language_tags, num_langs + 1);
                            language_tags[num_langs++] = xstrdup("*");

                            /* compute decimal_places */
                            for (max_q = 1, decimal_places = 0;
                            max_q < num_langs && decimal_places <= MAX_DECIMAL_PLACES;
                            decimal_places++, max_q *= 10)
                                    ;

                            xsnprintf(q_format, sizeof(q_format), ";q=0.%%0%dd", decimal_places);

                            strbuf_addstr(buf, "Accept-Language: ");

                            for (i = 0; i < num_langs; i++) {
                                    if (i > 0)
                                            strbuf_addstr(buf, ", ");

                                    strbuf_addstr(buf, language_tags[i]);

                                    if (i > 0)
                                            strbuf_addf(buf, q_format, max_q - i);

                                    if (buf->len > MAX_ACCEPT_LANGUAGE_HEADER_SIZE) {
                                            strbuf_remove(buf, last_buf_len, buf->len - last_buf_len);
                                            break;
                                    }

                                    last_buf_len = buf->len;
                            }
                    }

                    for (i = 0; i < num_langs; i++)
                            free(language_tags[i]);
                    free(language_tags);
            }

            /*
            * Get an Accept-Language header which indicates user's preferred languages.
            *
            * Examples:
            *   LANGUAGE= -> ""
            *   LANGUAGE=ko:en -> "Accept-Language: ko, en; q=0.9, *; q=0.1"
            *   LANGUAGE=ko_KR.UTF-8:sr@latin -> "Accept-Language: ko-KR, sr; q=0.9, *; q=0.1"
            *   LANGUAGE=ko LANG=en_US.UTF-8 -> "Accept-Language: ko, *; q=0.1"
            *   LANGUAGE= LANG=en_US.UTF-8 -> "Accept-Language: en-US, *; q=0.1"
            *   LANGUAGE= LANG=C -> ""
            */
            const char *http_get_accept_language_header(void)
            {
                    if (!cached_accept_language) {
                            struct strbuf buf = STRBUF_INIT;
                            write_accept_language(&buf);
                            if (buf.len > 0)
                                    cached_accept_language = strbuf_detach(&buf, NULL);
                    }

                    return cached_accept_language;
            }

            static void http_opt_request_remainder(CURL *curl, off_t pos)
            {
                    char buf[128];
                    xsnprintf(buf, sizeof(buf), "%"PRIuMAX"-", (uintmax_t)pos);
                    curl_easy_setopt(curl, CURLOPT_RANGE, buf);
            }

            /* http_request() targets */
            #define HTTP_REQUEST_STRBUF     0
            #define HTTP_REQUEST_FILE       1

            static int http_request(const char *url,
                                    void *result, int target,
                                    const struct http_get_options *options)
            {
                    struct active_request_slot *slot;
                    struct slot_results results;
                    struct curl_slist *headers = http_copy_default_headers();
                    struct strbuf buf = STRBUF_INIT;
                    const char *accept_language;
                    int ret;

                    slot = get_active_slot();
                    curl_easy_setopt(slot->curl, CURLOPT_HTTPGET, 1);

                    if (!result) {
                            curl_easy_setopt(slot->curl, CURLOPT_NOBODY, 1);
                    } else {
                            curl_easy_setopt(slot->curl, CURLOPT_NOBODY, 0);
                            curl_easy_setopt(slot->curl, CURLOPT_WRITEDATA, result);

                            if (target == HTTP_REQUEST_FILE) {
                                    off_t posn = ftello(result);
                                    curl_easy_setopt(slot->curl, CURLOPT_WRITEFUNCTION,
                                                    fwrite);
                                    if (posn > 0)
                                            http_opt_request_remainder(slot->curl, posn);
                            } else
                                    curl_easy_setopt(slot->curl, CURLOPT_WRITEFUNCTION,
                                                    fwrite_buffer);
                    }

                    curl_easy_setopt(slot->curl, CURLOPT_HEADERFUNCTION, fwrite_wwwauth);

                    accept_language = http_get_accept_language_header();

                    if (accept_language)
                            headers = curl_slist_append(headers, accept_language);

                    strbuf_addstr(&buf, "Pragma:");
                    if (options && options->no_cache)
                            strbuf_addstr(&buf, " no-cache");
                    if (options && options->initial_request &&
                    http_follow_config == HTTP_FOLLOW_INITIAL)
                            curl_easy_setopt(slot->curl, CURLOPT_FOLLOWLOCATION, 1);

                    headers = curl_slist_append(headers, buf.buf);

                    /* Add additional headers here */
                    if (options && options->extra_headers) {
                            const struct string_list_item *item;
                            if (options && options->extra_headers) {
                                    for_each_string_list_item(item, options->extra_headers) {
                                            headers = curl_slist_append(headers, item->string);
                                    }
                            }
                    }

                    headers = http_append_auth_header(&http_auth, headers);

                    curl_easy_setopt(slot->curl, CURLOPT_URL, url);
                    curl_easy_setopt(slot->curl, CURLOPT_HTTPHEADER, headers);
                    curl_easy_setopt(slot->curl, CURLOPT_ENCODING, "");
                    curl_easy_setopt(slot->curl, CURLOPT_FAILONERROR, 0);

                    ret = run_one_slot(slot, &results);

                    if (options && options->content_type) {
                            struct strbuf raw = STRBUF_INIT;
                            curlinfo_strbuf(slot->curl, CURLINFO_CONTENT_TYPE, &raw);
                            extract_content_type(&raw, options->content_type,
                                            options->charset);
                            strbuf_release(&raw);
                    }

                    if (options && options->effective_url)
                            curlinfo_strbuf(slot->curl, CURLINFO_EFFECTIVE_URL,
                                            options->effective_url);

                    curl_slist_free_all(headers);
                    strbuf_release(&buf);

                    return ret;
            }

            /*
            * Update the "base" url to a more appropriate value, as deduced by
            * redirects seen when requesting a URL starting with "url".
            *
            * The "asked" parameter is a URL that we asked curl to access, and must begin
            * with "base".
            *
            * The "got" parameter is the URL that curl reported to us as where we ended
            * up.
            *
            * Returns 1 if we updated the base url, 0 otherwise.
            *
            * Our basic strategy is to compare "base" and "asked" to find the bits
            * specific to our request. We then strip those bits off of "got" to yield the
            * new base. So for example, if our base is "http://example.com/foo.git",
            * and we ask for "http://example.com/foo.git/info/refs", we might end up
            * with "https://other.example.com/foo.git/info/refs". We would want the
            * new URL to become "https://other.example.com/foo.git".
            *
            * Note that this assumes a sane redirect scheme. It's entirely possible
            * in the example above to end up at a URL that does not even end in
            * "info/refs".  In such a case we die. There's not much we can do, such a
            * scheme is unlikely to represent a real git repository, and failing to
            * rewrite the base opens options for malicious redirects to do funny things.
            */
            static int update_url_from_redirect(struct strbuf *base,
                                            const char *asked,
                                            const struct strbuf *got)
            {
                    const char *tail;
                    size_t new_len;

                    if (!strcmp(asked, got->buf))
                            return 0;

                    if (!skip_prefix(asked, base->buf, &tail))
                            BUG("update_url_from_redirect: %s is not a superset of %s",
                            asked, base->buf);

                    new_len = got->len;
                    if (!strip_suffix_mem(got->buf, &new_len, tail))
                            die(_("unable to update url base from redirection:\n"
                            "  asked for: %s\n"
                            "   redirect: %s"),
                            asked, got->buf);

                    strbuf_reset(base);
                    strbuf_add(base, got->buf, new_len);

                    return 1;
            }

            static int http_request_reauth(const char *url,
                                    void *result, int target,
                                    struct http_get_options *options)
            {
                    int i = 3;
                    int ret;

                    if (always_auth_proactively())
                            credential_fill(&http_auth, 1);

                    ret = http_request(url, result, target, options);

                    if (ret != HTTP_OK && ret != HTTP_REAUTH)
                            return ret;

                    if (options && options->effective_url && options->base_url) {
                            if (update_url_from_redirect(options->base_url,
                                                    url, options->effective_url)) {
                                    credential_from_url(&http_auth, options->base_url->buf);
                                    url = options->effective_url->buf;
                            }
                    }

                    while (ret == HTTP_REAUTH && --i) {
                            /*
                            * The previous request may have put cruft into our output stream; we
                            * should clear it out before making our next request.
                            */
                            switch (target) {
                            case HTTP_REQUEST_STRBUF:
                                    strbuf_reset(result);
                                    break;
                            case HTTP_REQUEST_FILE: {
                                    FILE *f = result;
                                    if (fflush(f)) {
                                            error_errno("unable to flush a file");
                                            return HTTP_START_FAILED;
                                    }
                                    rewind(f);
                                    if (ftruncate(fileno(f), 0) < 0) {
                                            error_errno("unable to truncate a file");
                                            return HTTP_START_FAILED;
                                    }
                                    break;
                            }
                            default:
                                    BUG("Unknown http_request target");
                            }

                            credential_fill(&http_auth, 1);

                            ret = http_request(url, result, target, options);
                    }
                    return ret;
            }

            int http_get_strbuf(const char *url,
                            struct strbuf *result,
                            struct http_get_options *options)
            {
                    return http_request_reauth(url, result, HTTP_REQUEST_STRBUF, options);
            }

            /*
            * Downloads a URL and stores the result in the given file.
            *
            * If a previous interrupted download is detected (i.e. a previous temporary
            * file is still around) the download is resumed.
            */
            int http_get_file(const char *url, const char *filename,
                            struct http_get_options *options)
            {
                    int ret;
                    struct strbuf tmpfile = STRBUF_INIT;
                    FILE *result;

                    strbuf_addf(&tmpfile, "%s.temp", filename);
                    result = fopen(tmpfile.buf, "a");
                    if (!result) {
                            error("Unable to open local file %s", tmpfile.buf);
                            ret = HTTP_ERROR;
                            goto cleanup;
                    }

                    ret = http_request_reauth(url, result, HTTP_REQUEST_FILE, options);
                    fclose(result);

                    if (ret == HTTP_OK && finalize_object_file(tmpfile.buf, filename))
                            ret = HTTP_ERROR;
            cleanup:
                    strbuf_release(&tmpfile);
                    return ret;
            }

            int http_fetch_ref(const char *base, struct ref *ref)
            {
                    struct http_get_options options = {0};
                    char *url;
                    struct strbuf buffer = STRBUF_INIT;
                    int ret = -1;

                    options.no_cache = 1;

                    url = quote_ref_url(base, ref->name);
                    if (http_get_strbuf(url, &buffer, &options) == HTTP_OK) {
                            strbuf_rtrim(&buffer);
                            if (buffer.len == the_hash_algo->hexsz)
                                    ret = get_oid_hex(buffer.buf, &ref->old_oid);
                            else if (starts_with(buffer.buf, "ref: ")) {
                                    ref->symref = xstrdup(buffer.buf + 5);
                                    ret = 0;
                            }
                    }

                    strbuf_release(&buffer);
                    free(url);
                    return ret;
            }

            /* Helpers for fetching packs */
            static char *fetch_pack_index(unsigned char *hash, const char *base_url)
            {
                    char *url, *tmp;
                    struct strbuf buf = STRBUF_INIT;

                    if (http_is_verbose)
                            fprintf(stderr, "Getting index for pack %s\n", hash_to_hex(hash));

                    end_url_with_slash(&buf, base_url);
                    strbuf_addf(&buf, "objects/pack/pack-%s.idx", hash_to_hex(hash));
                    url = strbuf_detach(&buf, NULL);

                    /*
                    * Don't put this into packs/, since it's just temporary and we don't
                    * want to confuse it with our local .idx files.  We'll generate our
                    * own index if we choose to download the matching packfile.
                    *
                    * It's tempting to use xmks_tempfile() here, but it's important that
                    * the file not exist, otherwise http_get_file() complains. So we
                    * create a filename that should be unique, and then just register it
                    * as a tempfile so that it will get cleaned up on exit.
                    *
                    * In theory we could hold on to the tempfile and delete these as soon
                    * as we download the matching pack, but it would take a bit of
                    * refactoring. Leaving them until the process ends is probably OK.
                    */
                    tmp = xstrfmt("%s/tmp_pack_%s.idx",
                            repo_get_object_directory(the_repository),
                            hash_to_hex(hash));
                    register_tempfile(tmp);

                    if (http_get_file(url, tmp, NULL) != HTTP_OK) {
                            error("Unable to get pack index %s", url);
                            FREE_AND_NULL(tmp);
                    }

                    free(url);
                    return tmp;
            }

            static int fetch_and_setup_pack_index(struct packed_git **packs_head,
                    unsigned char *sha1, const char *base_url)
            {
                    struct packed_git *new_pack, *p;
                    char *tmp_idx = NULL;
                    int ret;

                    /*
                    * If we already have the pack locally, no need to fetch its index or
                    * even add it to list; we already have all of its objects.
                    */
                    for (p = get_all_packs(the_repository); p; p = p->next) {
                            if (hasheq(p->hash, sha1, the_repository->hash_algo))
                                    return 0;
                    }

                    tmp_idx = fetch_pack_index(sha1, base_url);
                    if (!tmp_idx)
                            return -1;

                    new_pack = parse_pack_index(the_repository, sha1, tmp_idx);
                    if (!new_pack) {
                            unlink(tmp_idx);
                            free(tmp_idx);

                            return -1; /* parse_pack_index() already issued error message */
                    }

                    ret = verify_pack_index(new_pack);
                    if (!ret)
                            close_pack_index(new_pack);
                    free(tmp_idx);
                    if (ret)
                            return -1;

                    new_pack->next = *packs_head;
                    *packs_head = new_pack;
                    return 0;
            }

            int http_get_info_packs(const char *base_url, struct packed_git **packs_head)
            {
                    struct http_get_options options = {0};
                    int ret = 0;
                    char *url;
                    const char *data;
                    struct strbuf buf = STRBUF_INIT;
                    struct object_id oid;

                    end_url_with_slash(&buf, base_url);
                    strbuf_addstr(&buf, "objects/info/packs");
                    url = strbuf_detach(&buf, NULL);

                    options.no_cache = 1;
                    ret = http_get_strbuf(url, &buf, &options);
                    if (ret != HTTP_OK)
                            goto cleanup;

                    data = buf.buf;
                    while (*data) {
                            if (skip_prefix(data, "P pack-", &data) &&
                            !parse_oid_hex(data, &oid, &data) &&
                            skip_prefix(data, ".pack", &data) &&
                            (*data == '\n' || *data == '\0')) {
                                    fetch_and_setup_pack_index(packs_head, oid.hash, base_url);
                            } else {
                                    data = strchrnul(data, '\n');
                            }
                            if (*data)
                                    data++; /* skip past newline */
                    }

            cleanup:
                    free(url);
                    strbuf_release(&buf);
                    return ret;
            }

            void release_http_pack_request(struct http_pack_request *preq)
            {
                    if (preq->packfile) {
                            fclose(preq->packfile);
                            preq->packfile = NULL;
                    }
                    preq->slot = NULL;
                    strbuf_release(&preq->tmpfile);
                    curl_slist_free_all(preq->headers);
                    free(preq->url);
                    free(preq);
            }

            static const char *default_index_pack_args[] =
                    {"index-pack", "--stdin", NULL};

            int finish_http_pack_request(struct http_pack_request *preq)
            {
                    struct child_process ip = CHILD_PROCESS_INIT;
                    int tmpfile_fd;
                    int ret = 0;

                    fclose(preq->packfile);
                    preq->packfile = NULL;

                    tmpfile_fd = xopen(preq->tmpfile.buf, O_RDONLY);

                    ip.git_cmd = 1;
                    ip.in = tmpfile_fd;
                    strvec_pushv(&ip.args, preq->index_pack_args ?
                            preq->index_pack_args :
                            default_index_pack_args);

                    if (preq->preserve_index_pack_stdout)
                            ip.out = 0;
                    else
                            ip.no_stdout = 1;

                    if (run_command(&ip)) {
                            ret = -1;
                            goto cleanup;
                    }

            cleanup:
                    close(tmpfile_fd);
                    unlink(preq->tmpfile.buf);
                    return ret;
            }

            void http_install_packfile(struct packed_git *p,
                                    struct packed_git **list_to_remove_from)
            {
                    struct packed_git **lst = list_to_remove_from;

                    while (*lst != p)
                            lst = &((*lst)->next);
                    *lst = (*lst)->next;

                    install_packed_git(the_repository, p);
            }

            struct http_pack_request *new_http_pack_request(
                    const unsigned char *packed_git_hash, const char *base_url) {

                    struct strbuf buf = STRBUF_INIT;

                    end_url_with_slash(&buf, base_url);
                    strbuf_addf(&buf, "objects/pack/pack-%s.pack",
                            hash_to_hex(packed_git_hash));
                    return new_direct_http_pack_request(packed_git_hash,
                                                    strbuf_detach(&buf, NULL));
            }

            struct http_pack_request *new_direct_http_pack_request(
                    const unsigned char *packed_git_hash, char *url)
            {
                    off_t prev_posn = 0;
                    struct http_pack_request *preq;

                    CALLOC_ARRAY(preq, 1);
                    strbuf_init(&preq->tmpfile, 0);

                    preq->url = url;

                    odb_pack_name(the_repository, &preq->tmpfile, packed_git_hash, "pack");
                    strbuf_addstr(&preq->tmpfile, ".temp");
                    preq->packfile = fopen(preq->tmpfile.buf, "a");
                    if (!preq->packfile) {
                            error("Unable to open local file %s for pack",
                            preq->tmpfile.buf);
                            goto abort;
                    }

                    preq->slot = get_active_slot();
                    preq->headers = object_request_headers();
                    curl_easy_setopt(preq->slot->curl, CURLOPT_WRITEDATA, preq->packfile);
                    curl_easy_setopt(preq->slot->curl, CURLOPT_WRITEFUNCTION, fwrite);
                    curl_easy_setopt(preq->slot->curl, CURLOPT_URL, preq->url);
                    curl_easy_setopt(preq->slot->curl, CURLOPT_HTTPHEADER, preq->headers);

                    /*
                    * If there is data present from a previous transfer attempt,
                    * resume where it left off
                    */
                    prev_posn = ftello(preq->packfile);
                    if (prev_posn>0) {
                            if (http_is_verbose)
                                    fprintf(stderr,
                                            "Resuming fetch of pack %s at byte %"PRIuMAX"\n",
                                            hash_to_hex(packed_git_hash),
                                            (uintmax_t)prev_posn);
                            http_opt_request_remainder(preq->slot->curl, prev_posn);
                    }

                    return preq;

            abort:
                    strbuf_release(&preq->tmpfile);
                    free(preq->url);
                    free(preq);
                    return NULL;
            }

            /* Helpers for fetching objects (loose) */
            static size_t fwrite_sha1_file(char *ptr, size_t eltsize, size_t nmemb,
                                    void *data)
            {
                    unsigned char expn[4096];
                    size_t size = eltsize * nmemb;
                    int posn = 0;
                    struct http_object_request *freq = data;
                    struct active_request_slot *slot = freq->slot;

                    if (slot) {
                            CURLcode c = curl_easy_getinfo(slot->curl, CURLINFO_HTTP_CODE,
                                                            &slot->http_code);
                            if (c != CURLE_OK)
                                    BUG("curl_easy_getinfo for HTTP code failed: %s",
                                            curl_easy_strerror(c));
                            if (slot->http_code >= 300)
                                    return nmemb;
                    }

                    do {
                            ssize_t retval = xwrite(freq->localfile,
                                                    (char *) ptr + posn, size - posn);
                            if (retval < 0)
                                    return posn / eltsize;
                            posn += retval;
                    } while (posn < size);

                    freq->stream.avail_in = size;
                    freq->stream.next_in = (void *)ptr;
                    do {
                            freq->stream.next_out = expn;
                            freq->stream.avail_out = sizeof(expn);
                            freq->zret = git_inflate(&freq->stream, Z_SYNC_FLUSH);
                            the_hash_algo->update_fn(&freq->c, expn,
                                                    sizeof(expn) - freq->stream.avail_out);
                    } while (freq->stream.avail_in && freq->zret == Z_OK);
                    return nmemb;
            }

            struct http_object_request *new_http_object_request(const char *base_url,
                                                            const struct object_id *oid)
            {
                    char *hex = oid_to_hex(oid);
                    struct strbuf filename = STRBUF_INIT;
                    struct strbuf prevfile = STRBUF_INIT;
                    int prevlocal;
                    char prev_buf[PREV_BUF_SIZE];
                    ssize_t prev_read = 0;
                    off_t prev_posn = 0;
                    struct http_object_request *freq;

                    CALLOC_ARRAY(freq, 1);
                    strbuf_init(&freq->tmpfile, 0);
                    oidcpy(&freq->oid, oid);
                    freq->localfile = -1;

                    loose_object_path(the_repository, &filename, oid);
                    strbuf_addf(&freq->tmpfile, "%s.temp", filename.buf);

                    strbuf_addf(&prevfile, "%s.prev", filename.buf);
                    unlink_or_warn(prevfile.buf);
                    rename(freq->tmpfile.buf, prevfile.buf);
                    unlink_or_warn(freq->tmpfile.buf);
                    strbuf_release(&filename);

                    if (freq->localfile != -1)
                            error("fd leakage in start: %d", freq->localfile);
                    freq->localfile = open(freq->tmpfile.buf,
                                    O_WRONLY | O_CREAT | O_EXCL, 0666);
                    /*
                    * This could have failed due to the "lazy directory creation";
                    * try to mkdir the last path component.
                    */
                    if (freq->localfile < 0 && errno == ENOENT) {
                            char *dir = strrchr(freq->tmpfile.buf, '/');
                            if (dir) {
                                    *dir = 0;
                                    mkdir(freq->tmpfile.buf, 0777);
                                    *dir = '/';
                            }
                            freq->localfile = open(freq->tmpfile.buf,
                                            O_WRONLY | O_CREAT | O_EXCL, 0666);
                    }

                    if (freq->localfile < 0) {
                            error_errno("Couldn't create temporary file %s",
                                    freq->tmpfile.buf);
                            goto abort;
                    }

                    git_inflate_init(&freq->stream);

                    the_hash_algo->init_fn(&freq->c);

                    freq->url = get_remote_object_url(base_url, hex, 0);

                    /*
                    * If a previous temp file is present, process what was already
                    * fetched.
                    */
                    prevlocal = open(prevfile.buf, O_RDONLY);
                    if (prevlocal != -1) {
                            do {
                                    prev_read = xread(prevlocal, prev_buf, PREV_BUF_SIZE);
                                    if (prev_read>0) {
                                            if (fwrite_sha1_file(prev_buf,
                                                            1,
                                                            prev_read,
                                                            freq) == prev_read) {
                                                    prev_posn += prev_read;
                                            } else {
                                                    prev_read = -1;
                                            }
                                    }
                            } while (prev_read > 0);
                            close(prevlocal);
                    }
                    unlink_or_warn(prevfile.buf);
                    strbuf_release(&prevfile);

                    /*
                    * Reset inflate/SHA1 if there was an error reading the previous temp
                    * file; also rewind to the beginning of the local file.
                    */
                    if (prev_read == -1) {
                            git_inflate_end(&freq->stream);
                            memset(&freq->stream, 0, sizeof(freq->stream));
                            git_inflate_init(&freq->stream);
                            the_hash_algo->init_fn(&freq->c);
                            if (prev_posn>0) {
                                    prev_posn = 0;
                                    lseek(freq->localfile, 0, SEEK_SET);
                                    if (ftruncate(freq->localfile, 0) < 0) {
                                            error_errno("Couldn't truncate temporary file %s",
                                                    freq->tmpfile.buf);
                                            goto abort;
                                    }
                            }
                    }

                    freq->slot = get_active_slot();
                    freq->headers = object_request_headers();

                    curl_easy_setopt(freq->slot->curl, CURLOPT_WRITEDATA, freq);
                    curl_easy_setopt(freq->slot->curl, CURLOPT_FAILONERROR, 0);
                    curl_easy_setopt(freq->slot->curl, CURLOPT_WRITEFUNCTION, fwrite_sha1_file);
                    curl_easy_setopt(freq->slot->curl, CURLOPT_ERRORBUFFER, freq->errorstr);
                    curl_easy_setopt(freq->slot->curl, CURLOPT_URL, freq->url);
                    curl_easy_setopt(freq->slot->curl, CURLOPT_HTTPHEADER, freq->headers);

                    /*
                    * If we have successfully processed data from a previous fetch
                    * attempt, only fetch the data we don't already have.
                    */
                    if (prev_posn>0) {
                            if (http_is_verbose)
                                    fprintf(stderr,
                                            "Resuming fetch of object %s at byte %"PRIuMAX"\n",
                                            hex, (uintmax_t)prev_posn);
                            http_opt_request_remainder(freq->slot->curl, prev_posn);
                    }

                    return freq;

            abort:
                    strbuf_release(&prevfile);
                    free(freq->url);
                    free(freq);
                    return NULL;
            }

            void process_http_object_request(struct http_object_request *freq)
            {
                    if (!freq->slot)
                            return;
                    freq->curl_result = freq->slot->curl_result;
                    freq->http_code = freq->slot->http_code;
                    freq->slot = NULL;
            }

            int finish_http_object_request(struct http_object_request *freq)
            {
                    struct stat st;
                    struct strbuf filename = STRBUF_INIT;

                    close(freq->localfile);
                    freq->localfile = -1;

                    process_http_object_request(freq);

                    if (freq->http_code == 416) {
                            warning("requested range invalid; we may already have all the data.");
                    } else if (freq->curl_result != CURLE_OK) {
                            if (stat(freq->tmpfile.buf, &st) == 0)
                                    if (st.st_size == 0)
                                            unlink_or_warn(freq->tmpfile.buf);
                            return -1;
                    }

                    the_hash_algo->final_oid_fn(&freq->real_oid, &freq->c);
                    if (freq->zret != Z_STREAM_END) {
                            unlink_or_warn(freq->tmpfile.buf);
                            return -1;
                    }
                    if (!oideq(&freq->oid, &freq->real_oid)) {
                            unlink_or_warn(freq->tmpfile.buf);
                            return -1;
                    }
                    loose_object_path(the_repository, &filename, &freq->oid);
                    freq->rename = finalize_object_file(freq->tmpfile.buf, filename.buf);
                    strbuf_release(&filename);

                    return freq->rename;
            }

            void abort_http_object_request(struct http_object_request **freq_p)
            {
                    struct http_object_request *freq = *freq_p;
                    unlink_or_warn(freq->tmpfile.buf);

                    release_http_object_request(freq_p);
            }

            void release_http_object_request(struct http_object_request **freq_p)
            {
                    struct http_object_request *freq = *freq_p;
                    if (freq->localfile != -1) {
                            close(freq->localfile);
                            freq->localfile = -1;
                    }
                    FREE_AND_NULL(freq->url);
                    if (freq->slot) {
                            freq->slot->callback_func = NULL;
                            freq->slot->callback_data = NULL;
                            release_active_slot(freq->slot);
                            freq->slot = NULL;
                    }
                    curl_slist_free_all(freq->headers);
                    strbuf_release(&freq->tmpfile);
                    git_inflate_end(&freq->stream);

                    free(freq);
                    *freq_p = NULL;
            }


            """,
            "Error":"The patch ensures that Git can fall back to using ZOPEN_GIT_SSL_CAINFO on z/OS, providing an
                     alternative path to configure the CA file for SSL connections.This improves the user experience
                     and ensures that Git works out of the box in z/OS environments, even when GIT_SSL_CAINFO is not configured.",

            "Error Category":"Functionality Patches",
            "Corrected Code":
                            """
            #define USE_THE_REPOSITORY_VARIABLE
            #define DISABLE_SIGN_COMPARE_WARNINGS

            #include "git-compat-util.h"
            #include "git-curl-compat.h"
            #include "hex.h"
            #include "http.h"
            #include "config.h"
            #include "pack.h"
            #include "run-command.h"
            #include "url.h"
            #include "urlmatch.h"
            #include "credential.h"
            #include "version.h"
            #include "pkt-line.h"
            #include "gettext.h"
            #include "trace.h"
            #include "transport.h"
            #include "packfile.h"
            #include "string-list.h"
            #include "object-file.h"
            #include "object-store-ll.h"
            #include "tempfile.h"

            static struct trace_key trace_curl = TRACE_KEY_INIT(CURL);
            static int trace_curl_data = 1;
            static int trace_curl_redact = 1;
            long int git_curl_ipresolve = CURL_IPRESOLVE_WHATEVER;
            int active_requests;
            int http_is_verbose;
            ssize_t http_post_buffer = 16 * LARGE_PACKET_MAX;

            static int min_curl_sessions = 1;
            static int curl_session_count;
            static int max_requests = -1;
            static CURLM *curlm;
            static CURL *curl_default;

            #define PREV_BUF_SIZE 4096

            char curl_errorstr[CURL_ERROR_SIZE];

            static int curl_ssl_verify = -1;
            static int curl_ssl_try;
            static char *curl_http_version;
            static char *ssl_cert;
            static char *ssl_cert_type;
            static char *ssl_cipherlist;
            static char *ssl_version;
            static struct {
                    const char *name;
                    long ssl_version;
            } sslversions[] = {
                    { "sslv2", CURL_SSLVERSION_SSLv2 },
                    { "sslv3", CURL_SSLVERSION_SSLv3 },
                    { "tlsv1", CURL_SSLVERSION_TLSv1 },
                    { "tlsv1.0", CURL_SSLVERSION_TLSv1_0 },
                    { "tlsv1.1", CURL_SSLVERSION_TLSv1_1 },
                    { "tlsv1.2", CURL_SSLVERSION_TLSv1_2 },
                    { "tlsv1.3", CURL_SSLVERSION_TLSv1_3 },
            };
            static char *ssl_key;
            static char *ssl_key_type;
            static char *ssl_capath;
            static char *curl_no_proxy;
            static char *ssl_pinnedkey;
            static char *ssl_cainfo;
            static long curl_low_speed_limit = -1;
            static long curl_low_speed_time = -1;
            static int curl_ftp_no_epsv;
            static char *curl_http_proxy;
            static char *http_proxy_authmethod;

            static char *http_proxy_ssl_cert;
            static char *http_proxy_ssl_key;
            static char *http_proxy_ssl_ca_info;
            static struct credential proxy_cert_auth = CREDENTIAL_INIT;
            static int proxy_ssl_cert_password_required;

            static struct {
                    const char *name;
                    long curlauth_param;
            } proxy_authmethods[] = {
                    { "basic", CURLAUTH_BASIC },
                    { "digest", CURLAUTH_DIGEST },
                    { "negotiate", CURLAUTH_GSSNEGOTIATE },
                    { "ntlm", CURLAUTH_NTLM },
                    { "anyauth", CURLAUTH_ANY },
                    /*
                    * CURLAUTH_DIGEST_IE has no corresponding command-line option in
                    * curl(1) and is not included in CURLAUTH_ANY, so we leave it out
                    * here, too
                    */
            };
            #ifdef CURLGSSAPI_DELEGATION_FLAG
            static char *curl_deleg;
            static struct {
                    const char *name;
                    long curl_deleg_param;
            } curl_deleg_levels[] = {
                    { "none", CURLGSSAPI_DELEGATION_NONE },
                    { "policy", CURLGSSAPI_DELEGATION_POLICY_FLAG },
                    { "always", CURLGSSAPI_DELEGATION_FLAG },
            };
            #endif

            enum proactive_auth {
                    PROACTIVE_AUTH_NONE = 0,
                    PROACTIVE_AUTH_IF_CREDENTIALS,
                    PROACTIVE_AUTH_AUTO,
                    PROACTIVE_AUTH_BASIC,
            };

            static struct credential proxy_auth = CREDENTIAL_INIT;
            static const char *curl_proxyuserpwd;
            static char *curl_cookie_file;
            static int curl_save_cookies;
            struct credential http_auth = CREDENTIAL_INIT;
            static enum proactive_auth http_proactive_auth;
            static char *user_agent;
            static int curl_empty_auth = -1;

            enum http_follow_config http_follow_config = HTTP_FOLLOW_INITIAL;

            static struct credential cert_auth = CREDENTIAL_INIT;
            static int ssl_cert_password_required;
            static unsigned long http_auth_methods = CURLAUTH_ANY;
            static int http_auth_methods_restricted;
            /* Modes for which empty_auth cannot actually help us. */
            static unsigned long empty_auth_useless =
                    CURLAUTH_BASIC
                    | CURLAUTH_DIGEST_IE
                    | CURLAUTH_DIGEST;

            static struct curl_slist *pragma_header;
            static struct string_list extra_http_headers = STRING_LIST_INIT_DUP;

            static struct curl_slist *host_resolutions;

            static struct active_request_slot *active_queue_head;

            static char *cached_accept_language;

            static char *http_ssl_backend;

            static int http_schannel_check_revoke = 1;
            /*
            * With the backend being set to `schannel`, setting sslCAinfo would override
            * the Certificate Store in cURL v7.60.0 and later, which is not what we want
            * by default.
            */
            static int http_schannel_use_ssl_cainfo;

            static int always_auth_proactively(void)
            {
                    return http_proactive_auth != PROACTIVE_AUTH_NONE &&
                    http_proactive_auth != PROACTIVE_AUTH_IF_CREDENTIALS;
            }

            size_t fread_buffer(char *ptr, size_t eltsize, size_t nmemb, void *buffer_)
            {
                    size_t size = eltsize * nmemb;
                    struct buffer *buffer = buffer_;

                    if (size > buffer->buf.len - buffer->posn)
                            size = buffer->buf.len - buffer->posn;
                    memcpy(ptr, buffer->buf.buf + buffer->posn, size);
                    buffer->posn += size;

                    return size / eltsize;
            }

            int seek_buffer(void *clientp, curl_off_t offset, int origin)
            {
                    struct buffer *buffer = clientp;

                    if (origin != SEEK_SET)
                            BUG("seek_buffer only handles SEEK_SET");
                    if (offset < 0 || offset >= buffer->buf.len) {
                            error("curl seek would be outside of buffer");
                            return CURL_SEEKFUNC_FAIL;
                    }

                    buffer->posn = offset;
                    return CURL_SEEKFUNC_OK;
            }

            size_t fwrite_buffer(char *ptr, size_t eltsize, size_t nmemb, void *buffer_)
            {
                    size_t size = eltsize * nmemb;
                    struct strbuf *buffer = buffer_;

                    strbuf_add(buffer, ptr, size);
                    return nmemb;
            }

            /*
            * A folded header continuation line starts with any number of spaces or
            * horizontal tab characters (SP or HTAB) as per RFC 7230 section 3.2.
            * It is not a continuation line if the line starts with any other character.
            */
            static inline int is_hdr_continuation(const char *ptr, const size_t size)
            {
                    return size && (*ptr == ' ' || *ptr == '\t');
            }

            static size_t fwrite_wwwauth(char *ptr, size_t eltsize, size_t nmemb, void *p UNUSED)
            {
                    size_t size = eltsize * nmemb;
                    struct strvec *values = &http_auth.wwwauth_headers;
                    struct strbuf buf = STRBUF_INIT;
                    const char *val;
                    size_t val_len;

                    /*
                    * Header lines may not come NULL-terminated from libcurl so we must
                    * limit all scans to the maximum length of the header line, or leverage
                    * strbufs for all operations.
                    *
                    * In addition, it is possible that header values can be split over
                    * multiple lines as per RFC 7230. 'Line folding' has been deprecated
                    * but older servers may still emit them. A continuation header field
                    * value is identified as starting with a space or horizontal tab.
                    *
                    * The formal definition of a header field as given in RFC 7230 is:
                    *
                    * header-field   = field-name ":" OWS field-value OWS
                    *
                    * field-name     = token
                    * field-value    = *( field-content / obs-fold )
                    * field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
                    * field-vchar    = VCHAR / obs-text
                    *
                    * obs-fold       = CRLF 1*( SP / HTAB )
                    *                ; obsolete line folding
                    *                ; see Section 3.2.4
                    */

                    /* Start of a new WWW-Authenticate header */
                    if (skip_iprefix_mem(ptr, size, "www-authenticate:", &val, &val_len)) {
                            strbuf_add(&buf, val, val_len);

                            /*
                            * Strip the CRLF that should be present at the end of each
                            * field as well as any trailing or leading whitespace from the
                            * value.
                            */
                            strbuf_trim(&buf);

                            strvec_push(values, buf.buf);
                            http_auth.header_is_last_match = 1;
                            goto exit;
                    }

                    /*
                    * This line could be a continuation of the previously matched header
                    * field. If this is the case then we should append this value to the
                    * end of the previously consumed value.
                    */
                    if (http_auth.header_is_last_match && is_hdr_continuation(ptr, size)) {
                            /*
                            * Trim the CRLF and any leading or trailing from this line.
                            */
                            strbuf_add(&buf, ptr, size);
                            strbuf_trim(&buf);

                            /*
                            * At this point we should always have at least one existing
                            * value, even if it is empty. Do not bother appending the new
                            * value if this continuation header is itself empty.
                            */
                            if (!values->nr) {
                                    BUG("should have at least one existing header value");
                            } else if (buf.len) {
                                    char *prev = xstrdup(values->v[values->nr - 1]);

                                    /* Join two non-empty values with a single space. */
                                    const char *const sp = *prev ? " " : "";

                                    strvec_pop(values);
                                    strvec_pushf(values, "%s%s%s", prev, sp, buf.buf);
                                    free(prev);
                            }

                            goto exit;
                    }

                    /* Not a continuation of a previously matched auth header line. */
                    http_auth.header_is_last_match = 0;

                    /*
                    * If this is a HTTP status line and not a header field, this signals
                    * a different HTTP response. libcurl writes all the output of all
                    * response headers of all responses, including redirects.
                    * We only care about the last HTTP request response's headers so clear
                    * the existing array.
                    */
                    if (skip_iprefix_mem(ptr, size, "http/", &val, &val_len))
                            strvec_clear(values);

            exit:
                    strbuf_release(&buf);
                    return size;
            }

            size_t fwrite_null(char *ptr UNUSED, size_t eltsize UNUSED, size_t nmemb,
                            void *data UNUSED)
            {
                    return nmemb;
            }

            static struct curl_slist *object_request_headers(void)
            {
                    return curl_slist_append(http_copy_default_headers(), "Pragma:");
            }

            static void closedown_active_slot(struct active_request_slot *slot)
            {
                    active_requests--;
                    slot->in_use = 0;
            }

            static void finish_active_slot(struct active_request_slot *slot)
            {
                    closedown_active_slot(slot);
                    curl_easy_getinfo(slot->curl, CURLINFO_HTTP_CODE, &slot->http_code);

                    if (slot->finished)
                            (*slot->finished) = 1;

                    /* Store slot results so they can be read after the slot is reused */
                    if (slot->results) {
                            slot->results->curl_result = slot->curl_result;
                            slot->results->http_code = slot->http_code;
                            curl_easy_getinfo(slot->curl, CURLINFO_HTTPAUTH_AVAIL,
                                            &slot->results->auth_avail);

                            curl_easy_getinfo(slot->curl, CURLINFO_HTTP_CONNECTCODE,
                                    &slot->results->http_connectcode);
                    }

                    /* Run callback if appropriate */
                    if (slot->callback_func)
                            slot->callback_func(slot->callback_data);
            }

            static void xmulti_remove_handle(struct active_request_slot *slot)
            {
                    curl_multi_remove_handle(curlm, slot->curl);
            }

            static void process_curl_messages(void)
            {
                    int num_messages;
                    struct active_request_slot *slot;
                    CURLMsg *curl_message = curl_multi_info_read(curlm, &num_messages);

                    while (curl_message != NULL) {
                            if (curl_message->msg == CURLMSG_DONE) {
                                    int curl_result = curl_message->data.result;
                                    slot = active_queue_head;
                                    while (slot != NULL &&
                                    slot->curl != curl_message->easy_handle)
                                            slot = slot->next;
                                    if (slot) {
                                            xmulti_remove_handle(slot);
                                            slot->curl_result = curl_result;
                                            finish_active_slot(slot);
                                    } else {
                                            fprintf(stderr, "Received DONE message for unknown request!\n");
                                    }
                            } else {
                                    fprintf(stderr, "Unknown CURL message received: %d\n",
                                            (int)curl_message->msg);
                            }
                            curl_message = curl_multi_info_read(curlm, &num_messages);
                    }
            }

            static int http_options(const char *var, const char *value,
                                    const struct config_context *ctx, void *data)
            {
                    if (!strcmp("http.version", var)) {
                            return git_config_string(&curl_http_version, var, value);
                    }
                    if (!strcmp("http.sslverify", var)) {
                            curl_ssl_verify = git_config_bool(var, value);
                            return 0;
                    }
                    if (!strcmp("http.sslcipherlist", var))
                            return git_config_string(&ssl_cipherlist, var, value);
                    if (!strcmp("http.sslversion", var))
                            return git_config_string(&ssl_version, var, value);
                    if (!strcmp("http.sslcert", var))
                            return git_config_pathname(&ssl_cert, var, value);
                    if (!strcmp("http.sslcerttype", var))
                            return git_config_string(&ssl_cert_type, var, value);
                    if (!strcmp("http.sslkey", var))
                            return git_config_pathname(&ssl_key, var, value);
                    if (!strcmp("http.sslkeytype", var))
                            return git_config_string(&ssl_key_type, var, value);
                    if (!strcmp("http.sslcapath", var))
                            return git_config_pathname(&ssl_capath, var, value);
                    if (!strcmp("http.sslcainfo", var))
                            return git_config_pathname(&ssl_cainfo, var, value);
                    if (!strcmp("http.sslcertpasswordprotected", var)) {
                            ssl_cert_password_required = git_config_bool(var, value);
                            return 0;
                    }
                    if (!strcmp("http.ssltry", var)) {
                            curl_ssl_try = git_config_bool(var, value);
                            return 0;
                    }
                    if (!strcmp("http.sslbackend", var)) {
                            free(http_ssl_backend);
                            http_ssl_backend = xstrdup_or_null(value);
                            return 0;
                    }

                    if (!strcmp("http.schannelcheckrevoke", var)) {
                            http_schannel_check_revoke = git_config_bool(var, value);
                            return 0;
                    }

                    if (!strcmp("http.schannelusesslcainfo", var)) {
                            http_schannel_use_ssl_cainfo = git_config_bool(var, value);
                            return 0;
                    }

                    if (!strcmp("http.minsessions", var)) {
                            min_curl_sessions = git_config_int(var, value, ctx->kvi);
                            if (min_curl_sessions > 1)
                                    min_curl_sessions = 1;
                            return 0;
                    }
                    if (!strcmp("http.maxrequests", var)) {
                            max_requests = git_config_int(var, value, ctx->kvi);
                            return 0;
                    }
                    if (!strcmp("http.lowspeedlimit", var)) {
                            curl_low_speed_limit = (long)git_config_int(var, value, ctx->kvi);
                            return 0;
                    }
                    if (!strcmp("http.lowspeedtime", var)) {
                            curl_low_speed_time = (long)git_config_int(var, value, ctx->kvi);
                            return 0;
                    }

                    if (!strcmp("http.noepsv", var)) {
                            curl_ftp_no_epsv = git_config_bool(var, value);
                            return 0;
                    }
                    if (!strcmp("http.proxy", var))
                            return git_config_string(&curl_http_proxy, var, value);

                    if (!strcmp("http.proxyauthmethod", var))
                            return git_config_string(&http_proxy_authmethod, var, value);

                    if (!strcmp("http.proxysslcert", var))
                            return git_config_string(&http_proxy_ssl_cert, var, value);

                    if (!strcmp("http.proxysslkey", var))
                            return git_config_string(&http_proxy_ssl_key, var, value);

                    if (!strcmp("http.proxysslcainfo", var))
                            return git_config_string(&http_proxy_ssl_ca_info, var, value);

                    if (!strcmp("http.proxysslcertpasswordprotected", var)) {
                            proxy_ssl_cert_password_required = git_config_bool(var, value);
                            return 0;
                    }

                    if (!strcmp("http.cookiefile", var))
                            return git_config_pathname(&curl_cookie_file, var, value);
                    if (!strcmp("http.savecookies", var)) {
                            curl_save_cookies = git_config_bool(var, value);
                            return 0;
                    }

                    if (!strcmp("http.postbuffer", var)) {
                            http_post_buffer = git_config_ssize_t(var, value, ctx->kvi);
                            if (http_post_buffer < 0)
                                    warning(_("negative value for http.postBuffer; defaulting to %d"), LARGE_PACKET_MAX);
                            if (http_post_buffer < LARGE_PACKET_MAX)
                                    http_post_buffer = LARGE_PACKET_MAX;
                            return 0;
                    }

                    if (!strcmp("http.useragent", var))
                            return git_config_string(&user_agent, var, value);

                    if (!strcmp("http.emptyauth", var)) {
                            if (value && !strcmp("auto", value))
                                    curl_empty_auth = -1;
                            else
                                    curl_empty_auth = git_config_bool(var, value);
                            return 0;
                    }

                    if (!strcmp("http.delegation", var)) {
            #ifdef CURLGSSAPI_DELEGATION_FLAG
                            return git_config_string(&curl_deleg, var, value);
            #else
                            warning(_("Delegation control is not supported with cURL < 7.22.0"));
                            return 0;
            #endif
                    }

                    if (!strcmp("http.pinnedpubkey", var)) {
                            return git_config_pathname(&ssl_pinnedkey, var, value);
                    }

                    if (!strcmp("http.extraheader", var)) {
                            if (!value) {
                                    return config_error_nonbool(var);
                            } else if (!*value) {
                                    string_list_clear(&extra_http_headers, 0);
                            } else {
                                    string_list_append(&extra_http_headers, value);
                            }
                            return 0;
                    }

                    if (!strcmp("http.curloptresolve", var)) {
                            if (!value) {
                                    return config_error_nonbool(var);
                            } else if (!*value) {
                                    curl_slist_free_all(host_resolutions);
                                    host_resolutions = NULL;
                            } else {
                                    host_resolutions = curl_slist_append(host_resolutions, value);
                            }
                            return 0;
                    }

                    if (!strcmp("http.followredirects", var)) {
                            if (value && !strcmp(value, "initial"))
                                    http_follow_config = HTTP_FOLLOW_INITIAL;
                            else if (git_config_bool(var, value))
                                    http_follow_config = HTTP_FOLLOW_ALWAYS;
                            else
                                    http_follow_config = HTTP_FOLLOW_NONE;
                            return 0;
                    }

                    if (!strcmp("http.proactiveauth", var)) {
                            if (!value)
                                    return config_error_nonbool(var);
                            if (!strcmp(value, "auto"))
                                    http_proactive_auth = PROACTIVE_AUTH_AUTO;
                            else if (!strcmp(value, "basic"))
                                    http_proactive_auth = PROACTIVE_AUTH_BASIC;
                            else if (!strcmp(value, "none"))
                                    http_proactive_auth = PROACTIVE_AUTH_NONE;
                            else
                                    warning(_("Unknown value for http.proactiveauth"));
                            return 0;
                    }

                    /* Fall back on the default ones */
                    return git_default_config(var, value, ctx, data);
            }

            static int curl_empty_auth_enabled(void)
            {
                    if (curl_empty_auth >= 0)
                            return curl_empty_auth;

                    /*
                    * In the automatic case, kick in the empty-auth
                    * hack as long as we would potentially try some
                    * method more exotic than "Basic" or "Digest".
                    *
                    * But only do this when this is our second or
                    * subsequent request, as by then we know what
                    * methods are available.
                    */
                    if (http_auth_methods_restricted &&
                    (http_auth_methods & ~empty_auth_useless))
                            return 1;
                    return 0;
            }

            struct curl_slist *http_append_auth_header(const struct credential *c,
                                                    struct curl_slist *headers)
            {
                    if (c->authtype && c->credential) {
                            struct strbuf auth = STRBUF_INIT;
                            strbuf_addf(&auth, "Authorization: %s %s",
                                    c->authtype, c->credential);
                            headers = curl_slist_append(headers, auth.buf);
                            strbuf_release(&auth);
                    }
                    return headers;
            }

            static void init_curl_http_auth(CURL *result)
            {
                    if ((!http_auth.username || !*http_auth.username) &&
                    (!http_auth.credential || !*http_auth.credential)) {
                            int empty_auth = curl_empty_auth_enabled();
                            if ((empty_auth != -1 && !always_auth_proactively()) || empty_auth == 1) {
                                    curl_easy_setopt(result, CURLOPT_USERPWD, ":");
                                    return;
                            } else if (!always_auth_proactively()) {
                                    return;
                            } else if (http_proactive_auth == PROACTIVE_AUTH_BASIC) {
                                    strvec_push(&http_auth.wwwauth_headers, "Basic");
                            }
                    }

                    credential_fill(&http_auth, 1);

                    if (http_auth.password) {
                            if (always_auth_proactively()) {
                                    /*
                                    * We got a credential without an authtype and we don't
                                    * know what's available.  Since our only two options at
                                    * the moment are auto (which defaults to basic) and
                                    * basic, use basic for now.
                                    */
                                    curl_easy_setopt(result, CURLOPT_HTTPAUTH, CURLAUTH_BASIC);
                            }
                            curl_easy_setopt(result, CURLOPT_USERNAME, http_auth.username);
                            curl_easy_setopt(result, CURLOPT_PASSWORD, http_auth.password);
                    }
            }

            /* *var must be free-able */
            static void var_override(char **var, char *value)
            {
                    if (value) {
                            free(*var);
                            *var = xstrdup(value);
                    }
            }

            static void set_proxyauth_name_password(CURL *result)
            {
                    if (proxy_auth.password) {
                            curl_easy_setopt(result, CURLOPT_PROXYUSERNAME,
                                    proxy_auth.username);
                            curl_easy_setopt(result, CURLOPT_PROXYPASSWORD,
                                    proxy_auth.password);
                    } else if (proxy_auth.authtype && proxy_auth.credential) {
                            curl_easy_setopt(result, CURLOPT_PROXYHEADER,
                                            http_append_auth_header(&proxy_auth, NULL));
                    }
            }

            static void init_curl_proxy_auth(CURL *result)
            {
                    if (proxy_auth.username) {
                            if (!proxy_auth.password && !proxy_auth.credential)
                                    credential_fill(&proxy_auth, 1);
                            set_proxyauth_name_password(result);
                    }

                    var_override(&http_proxy_authmethod, getenv("GIT_HTTP_PROXY_AUTHMETHOD"));

                    if (http_proxy_authmethod) {
                            int i;
                            for (i = 0; i < ARRAY_SIZE(proxy_authmethods); i++) {
                                    if (!strcmp(http_proxy_authmethod, proxy_authmethods[i].name)) {
                                            curl_easy_setopt(result, CURLOPT_PROXYAUTH,
                                                            proxy_authmethods[i].curlauth_param);
                                            break;
                                    }
                            }
                            if (i == ARRAY_SIZE(proxy_authmethods)) {
                                    warning("unsupported proxy authentication method %s: using anyauth",
                                                    http_proxy_authmethod);
                                    curl_easy_setopt(result, CURLOPT_PROXYAUTH, CURLAUTH_ANY);
                            }
                    }
                    else
                            curl_easy_setopt(result, CURLOPT_PROXYAUTH, CURLAUTH_ANY);
            }

            static int has_cert_password(void)
            {
                    if (ssl_cert == NULL || ssl_cert_password_required != 1)
                            return 0;
                    if (!cert_auth.password) {
                            cert_auth.protocol = xstrdup("cert");
                            cert_auth.host = xstrdup("");
                            cert_auth.username = xstrdup("");
                            cert_auth.path = xstrdup(ssl_cert);
                            credential_fill(&cert_auth, 0);
                    }
                    return 1;
            }

            static int has_proxy_cert_password(void)
            {
                    if (http_proxy_ssl_cert == NULL || proxy_ssl_cert_password_required != 1)
                            return 0;
                    if (!proxy_cert_auth.password) {
                            proxy_cert_auth.protocol = xstrdup("cert");
                            proxy_cert_auth.host = xstrdup("");
                            proxy_cert_auth.username = xstrdup("");
                            proxy_cert_auth.path = xstrdup(http_proxy_ssl_cert);
                            credential_fill(&proxy_cert_auth, 0);
                    }
                    return 1;
            }

            static void set_curl_keepalive(CURL *c)
            {
                    curl_easy_setopt(c, CURLOPT_TCP_KEEPALIVE, 1);
            }

            /* Return 1 if redactions have been made, 0 otherwise. */
            static int redact_sensitive_header(struct strbuf *header, size_t offset)
            {
                    int ret = 0;
                    const char *sensitive_header;

                    if (trace_curl_redact &&
                    (skip_iprefix(header->buf + offset, "Authorization:", &sensitive_header) ||
                    skip_iprefix(header->buf + offset, "Proxy-Authorization:", &sensitive_header))) {
                            /* The first token is the type, which is OK to log */
                            while (isspace(*sensitive_header))
                                    sensitive_header++;
                            while (*sensitive_header && !isspace(*sensitive_header))
                                    sensitive_header++;
                            /* Everything else is opaque and possibly sensitive */
                            strbuf_setlen(header,  sensitive_header - header->buf);
                            strbuf_addstr(header, " <redacted>");
                            ret = 1;
                    } else if (trace_curl_redact &&
                            skip_iprefix(header->buf + offset, "Cookie:", &sensitive_header)) {
                            struct strbuf redacted_header = STRBUF_INIT;
                            const char *cookie;

                            while (isspace(*sensitive_header))
                                    sensitive_header++;

                            cookie = sensitive_header;

                            while (cookie) {
                                    char *equals;
                                    char *semicolon = strstr(cookie, "; ");
                                    if (semicolon)
                                            *semicolon = 0;
                                    equals = strchrnul(cookie, '=');
                                    if (!equals) {
                                            /* invalid cookie, just append and continue */
                                            strbuf_addstr(&redacted_header, cookie);
                                            continue;
                                    }
                                    strbuf_add(&redacted_header, cookie, equals - cookie);
                                    strbuf_addstr(&redacted_header, "=<redacted>");
                                    if (semicolon) {
                                            /*
                                            * There are more cookies. (Or, for some
                                            * reason, the input string ends in "; ".)
                                            */
                                            strbuf_addstr(&redacted_header, "; ");
                                            cookie = semicolon + strlen("; ");
                                    } else {
                                            cookie = NULL;
                                    }
                            }

                            strbuf_setlen(header, sensitive_header - header->buf);
                            strbuf_addbuf(header, &redacted_header);
                            strbuf_release(&redacted_header);
                            ret = 1;
                    }
                    return ret;
            }

            static int match_curl_h2_trace(const char *line, const char **out)
            {
                    const char *p;

                    /*
                    * curl prior to 8.1.0 gives us:
                    *
                    *     h2h3 [<header-name>: <header-val>]
                    *
                    * Starting in 8.1.0, the first token became just "h2".
                    */
                    if (skip_iprefix(line, "h2h3 [", out) ||
                    skip_iprefix(line, "h2 [", out))
                            return 1;

                    /*
                    * curl 8.3.0 uses:
                    *   [HTTP/2] [<stream-id>] [<header-name>: <header-val>]
                    * where <stream-id> is numeric.
                    */
                    if (skip_iprefix(line, "[HTTP/2] [", &p)) {
                            while (isdigit(*p))
                                    p++;
                            if (skip_prefix(p, "] [", out))
                                    return 1;
                    }

                    return 0;
            }

            /* Redact headers in info */
            static void redact_sensitive_info_header(struct strbuf *header)
            {
                    const char *sensitive_header;

                    if (trace_curl_redact &&
                    match_curl_h2_trace(header->buf, &sensitive_header)) {
                            if (redact_sensitive_header(header, sensitive_header - header->buf)) {
                                    /* redaction ate our closing bracket */
                                    strbuf_addch(header, ']');
                            }
                    }
            }

            static void curl_dump_header(const char *text, unsigned char *ptr, size_t size, int hide_sensitive_header)
            {
                    struct strbuf out = STRBUF_INIT;
                    struct strbuf **headers, **header;

                    strbuf_addf(&out, "%s, %10.10ld bytes (0x%8.8lx)\n",
                            text, (long)size, (long)size);
                    trace_strbuf(&trace_curl, &out);
                    strbuf_reset(&out);
                    strbuf_add(&out, ptr, size);
                    headers = strbuf_split_max(&out, '\n', 0);

                    for (header = headers; *header; header++) {
                            if (hide_sensitive_header)
                                    redact_sensitive_header(*header, 0);
                            strbuf_insertstr((*header), 0, text);
                            strbuf_insertstr((*header), strlen(text), ": ");
                            strbuf_rtrim((*header));
                            strbuf_addch((*header), '\n');
                            trace_strbuf(&trace_curl, (*header));
                    }
                    strbuf_list_free(headers);
                    strbuf_release(&out);
            }

            static void curl_dump_data(const char *text, unsigned char *ptr, size_t size)
            {
                    size_t i;
                    struct strbuf out = STRBUF_INIT;
                    unsigned int width = 60;

                    strbuf_addf(&out, "%s, %10.10ld bytes (0x%8.8lx)\n",
                            text, (long)size, (long)size);
                    trace_strbuf(&trace_curl, &out);

                    for (i = 0; i < size; i += width) {
                            size_t w;

                            strbuf_reset(&out);
                            strbuf_addf(&out, "%s: ", text);
                            for (w = 0; (w < width) && (i + w < size); w++) {
                                    unsigned char ch = ptr[i + w];

                                    strbuf_addch(&out,
                                            (ch >= 0x20) && (ch < 0x80)
                                            ? ch : '.');
                            }
                            strbuf_addch(&out, '\n');
                            trace_strbuf(&trace_curl, &out);
                    }
                    strbuf_release(&out);
            }

            static void curl_dump_info(char *data, size_t size)
            {
                    struct strbuf buf = STRBUF_INIT;

                    strbuf_add(&buf, data, size);

                    redact_sensitive_info_header(&buf);
                    trace_printf_key(&trace_curl, "== Info: %s", buf.buf);

                    strbuf_release(&buf);
            }

            static int curl_trace(CURL *handle UNUSED, curl_infotype type,
                            char *data, size_t size,
                            void *userp UNUSED)
            {
                    const char *text;
                    enum { NO_FILTER = 0, DO_FILTER = 1 };

                    switch (type) {
                    case CURLINFO_TEXT:
                            curl_dump_info(data, size);
                            break;
                    case CURLINFO_HEADER_OUT:
                            text = "=> Send header";
                            curl_dump_header(text, (unsigned char *)data, size, DO_FILTER);
                            break;
                    case CURLINFO_DATA_OUT:
                            if (trace_curl_data) {
                                    text = "=> Send data";
                                    curl_dump_data(text, (unsigned char *)data, size);
                            }
                            break;
                    case CURLINFO_SSL_DATA_OUT:
                            if (trace_curl_data) {
                                    text = "=> Send SSL data";
                                    curl_dump_data(text, (unsigned char *)data, size);
                            }
                            break;
                    case CURLINFO_HEADER_IN:
                            text = "<= Recv header";
                            curl_dump_header(text, (unsigned char *)data, size, NO_FILTER);
                            break;
                    case CURLINFO_DATA_IN:
                            if (trace_curl_data) {
                                    text = "<= Recv data";
                                    curl_dump_data(text, (unsigned char *)data, size);
                            }
                            break;
                    case CURLINFO_SSL_DATA_IN:
                            if (trace_curl_data) {
                                    text = "<= Recv SSL data";
                                    curl_dump_data(text, (unsigned char *)data, size);
                            }
                            break;

                    default:                /* we ignore unknown types by default */
                            return 0;
                    }
                    return 0;
            }

            void http_trace_curl_no_data(void)
            {
                    trace_override_envvar(&trace_curl, "1");
                    trace_curl_data = 0;
            }

            void setup_curl_trace(CURL *handle)
            {
                    if (!trace_want(&trace_curl))
                            return;
                    curl_easy_setopt(handle, CURLOPT_VERBOSE, 1L);
                    curl_easy_setopt(handle, CURLOPT_DEBUGFUNCTION, curl_trace);
                    curl_easy_setopt(handle, CURLOPT_DEBUGDATA, NULL);
            }

            static void proto_list_append(struct strbuf *list, const char *proto)
            {
                    if (!list)
                            return;
                    if (list->len)
                            strbuf_addch(list, ',');
                    strbuf_addstr(list, proto);
            }

            static long get_curl_allowed_protocols(int from_user, struct strbuf *list)
            {
                    long bits = 0;

                    if (is_transport_allowed("http", from_user)) {
                            bits |= CURLPROTO_HTTP;
                            proto_list_append(list, "http");
                    }
                    if (is_transport_allowed("https", from_user)) {
                            bits |= CURLPROTO_HTTPS;
                            proto_list_append(list, "https");
                    }
                    if (is_transport_allowed("ftp", from_user)) {
                            bits |= CURLPROTO_FTP;
                            proto_list_append(list, "ftp");
                    }
                    if (is_transport_allowed("ftps", from_user)) {
                            bits |= CURLPROTO_FTPS;
                            proto_list_append(list, "ftps");
                    }

                    return bits;
            }

            static int get_curl_http_version_opt(const char *version_string, long *opt)
            {
                    int i;
                    static struct {
                            const char *name;
                            long opt_token;
                    } choice[] = {
                            { "HTTP/1.1", CURL_HTTP_VERSION_1_1 },
                            { "HTTP/2", CURL_HTTP_VERSION_2 }
                    };

                    for (i = 0; i < ARRAY_SIZE(choice); i++) {
                            if (!strcmp(version_string, choice[i].name)) {
                                    *opt = choice[i].opt_token;
                                    return 0;
                            }
                    }

                    warning("unknown value given to http.version: '%s'", version_string);
                    return -1; /* not found */
            }

            static CURL *get_curl_handle(void)
            {
                    CURL *result = curl_easy_init();

                    if (!result)
                            die("curl_easy_init failed");

                    if (!curl_ssl_verify) {
                            curl_easy_setopt(result, CURLOPT_SSL_VERIFYPEER, 0);
                            curl_easy_setopt(result, CURLOPT_SSL_VERIFYHOST, 0);
                    } else {
                            /* Verify authenticity of the peer's certificate */
                            curl_easy_setopt(result, CURLOPT_SSL_VERIFYPEER, 1);
                            /* The name in the cert must match whom we tried to connect */
                            curl_easy_setopt(result, CURLOPT_SSL_VERIFYHOST, 2);
                    }

            if (curl_http_version) {
                            long opt;
                            if (!get_curl_http_version_opt(curl_http_version, &opt)) {
                                    /* Set request use http version */
                                    curl_easy_setopt(result, CURLOPT_HTTP_VERSION, opt);
                            }
            }

                    curl_easy_setopt(result, CURLOPT_NETRC, CURL_NETRC_OPTIONAL);
                    curl_easy_setopt(result, CURLOPT_HTTPAUTH, CURLAUTH_ANY);

            #ifdef CURLGSSAPI_DELEGATION_FLAG
                    if (curl_deleg) {
                            int i;
                            for (i = 0; i < ARRAY_SIZE(curl_deleg_levels); i++) {
                                    if (!strcmp(curl_deleg, curl_deleg_levels[i].name)) {
                                            curl_easy_setopt(result, CURLOPT_GSSAPI_DELEGATION,
                                                            curl_deleg_levels[i].curl_deleg_param);
                                            break;
                                    }
                            }
                            if (i == ARRAY_SIZE(curl_deleg_levels))
                                    warning("Unknown delegation method '%s': using default",
                                            curl_deleg);
                    }
            #endif

                    if (http_ssl_backend && !strcmp("schannel", http_ssl_backend) &&
                    !http_schannel_check_revoke) {
                            curl_easy_setopt(result, CURLOPT_SSL_OPTIONS, CURLSSLOPT_NO_REVOKE);
                    }

                    if (http_proactive_auth != PROACTIVE_AUTH_NONE)
                            init_curl_http_auth(result);

                    if (getenv("GIT_SSL_VERSION"))
                            ssl_version = getenv("GIT_SSL_VERSION");
                    if (ssl_version && *ssl_version) {
                            int i;
                            for (i = 0; i < ARRAY_SIZE(sslversions); i++) {
                                    if (!strcmp(ssl_version, sslversions[i].name)) {
                                            curl_easy_setopt(result, CURLOPT_SSLVERSION,
                                                            sslversions[i].ssl_version);
                                            break;
                                    }
                            }
                            if (i == ARRAY_SIZE(sslversions))
                                    warning("unsupported ssl version %s: using default",
                                            ssl_version);
                    }

                    if (getenv("GIT_SSL_CIPHER_LIST"))
                            ssl_cipherlist = getenv("GIT_SSL_CIPHER_LIST");
                    if (ssl_cipherlist != NULL && *ssl_cipherlist)
                            curl_easy_setopt(result, CURLOPT_SSL_CIPHER_LIST,
                                            ssl_cipherlist);
                    if (ssl_cert)
                            curl_easy_setopt(result, CURLOPT_SSLCERT, ssl_cert);
                    if (ssl_cert_type)
                            curl_easy_setopt(result, CURLOPT_SSLCERTTYPE, ssl_cert_type);
                    if (has_cert_password())
                            curl_easy_setopt(result, CURLOPT_KEYPASSWD, cert_auth.password);
                    if (ssl_key)
                            curl_easy_setopt(result, CURLOPT_SSLKEY, ssl_key);
                    if (ssl_key_type)
                            curl_easy_setopt(result, CURLOPT_SSLKEYTYPE, ssl_key_type);
                    if (ssl_capath)
                            curl_easy_setopt(result, CURLOPT_CAPATH, ssl_capath);
                    if (ssl_pinnedkey)
                            curl_easy_setopt(result, CURLOPT_PINNEDPUBLICKEY, ssl_pinnedkey);
                    if (http_ssl_backend && !strcmp("schannel", http_ssl_backend) &&
                    !http_schannel_use_ssl_cainfo) {
                            curl_easy_setopt(result, CURLOPT_CAINFO, NULL);
                            curl_easy_setopt(result, CURLOPT_PROXY_CAINFO, NULL);
                    } else if (ssl_cainfo != NULL || http_proxy_ssl_ca_info != NULL) {
                            if (ssl_cainfo)
                                    curl_easy_setopt(result, CURLOPT_CAINFO, ssl_cainfo);
                            if (http_proxy_ssl_ca_info)
                                    curl_easy_setopt(result, CURLOPT_PROXY_CAINFO, http_proxy_ssl_ca_info);
                    }

                    if (curl_low_speed_limit > 0 && curl_low_speed_time > 0) {
                            curl_easy_setopt(result, CURLOPT_LOW_SPEED_LIMIT,
                                            curl_low_speed_limit);
                            curl_easy_setopt(result, CURLOPT_LOW_SPEED_TIME,
                                            curl_low_speed_time);
                    }

                    curl_easy_setopt(result, CURLOPT_MAXREDIRS, 20);
                    curl_easy_setopt(result, CURLOPT_POSTREDIR, CURL_REDIR_POST_ALL);

            #ifdef GIT_CURL_HAVE_CURLOPT_PROTOCOLS_STR
                    {
                            struct strbuf buf = STRBUF_INIT;

                            get_curl_allowed_protocols(0, &buf);
                            curl_easy_setopt(result, CURLOPT_REDIR_PROTOCOLS_STR, buf.buf);
                            strbuf_reset(&buf);

                            get_curl_allowed_protocols(-1, &buf);
                            curl_easy_setopt(result, CURLOPT_PROTOCOLS_STR, buf.buf);
                            strbuf_release(&buf);
                    }
            #else
                    curl_easy_setopt(result, CURLOPT_REDIR_PROTOCOLS,
                                    get_curl_allowed_protocols(0, NULL));
                    curl_easy_setopt(result, CURLOPT_PROTOCOLS,
                                    get_curl_allowed_protocols(-1, NULL));
            #endif

                    if (getenv("GIT_CURL_VERBOSE"))
                            http_trace_curl_no_data();
                    setup_curl_trace(result);
                    if (getenv("GIT_TRACE_CURL_NO_DATA"))
                            trace_curl_data = 0;
                    if (!git_env_bool("GIT_TRACE_REDACT", 1))
                            trace_curl_redact = 0;

                    curl_easy_setopt(result, CURLOPT_USERAGENT,
                            user_agent ? user_agent : git_user_agent());

                    if (curl_ftp_no_epsv)
                            curl_easy_setopt(result, CURLOPT_FTP_USE_EPSV, 0);

                    if (curl_ssl_try)
                            curl_easy_setopt(result, CURLOPT_USE_SSL, CURLUSESSL_TRY);

                    /*
                    * CURL also examines these variables as a fallback; but we need to query
                    * them here in order to decide whether to prompt for missing password (cf.
                    * init_curl_proxy_auth()).
                    *
                    * Unlike many other common environment variables, these are historically
                    * lowercase only. It appears that CURL did not know this and implemented
                    * only uppercase variants, which was later corrected to take both - with
                    * the exception of http_proxy, which is lowercase only also in CURL. As
                    * the lowercase versions are the historical quasi-standard, they take
                    * precedence here, as in CURL.
                    */
                    if (!curl_http_proxy) {
                            if (http_auth.protocol && !strcmp(http_auth.protocol, "https")) {
                                    var_override(&curl_http_proxy, getenv("HTTPS_PROXY"));
                                    var_override(&curl_http_proxy, getenv("https_proxy"));
                            } else {
                                    var_override(&curl_http_proxy, getenv("http_proxy"));
                            }
                            if (!curl_http_proxy) {
                                    var_override(&curl_http_proxy, getenv("ALL_PROXY"));
                                    var_override(&curl_http_proxy, getenv("all_proxy"));
                            }
                    }

                    if (curl_http_proxy && curl_http_proxy[0] == '\0') {
                            /*
                            * Handle case with the empty http.proxy value here to keep
                            * common code clean.
                            * NB: empty option disables proxying at all.
                            */
                            curl_easy_setopt(result, CURLOPT_PROXY, "");
                    } else if (curl_http_proxy) {
                            struct strbuf proxy = STRBUF_INIT;

                            if (starts_with(curl_http_proxy, "socks5h"))
                                    curl_easy_setopt(result,
                                            CURLOPT_PROXYTYPE, CURLPROXY_SOCKS5_HOSTNAME);
                            else if (starts_with(curl_http_proxy, "socks5"))
                                    curl_easy_setopt(result,
                                            CURLOPT_PROXYTYPE, CURLPROXY_SOCKS5);
                            else if (starts_with(curl_http_proxy, "socks4a"))
                                    curl_easy_setopt(result,
                                            CURLOPT_PROXYTYPE, CURLPROXY_SOCKS4A);
                            else if (starts_with(curl_http_proxy, "socks"))
                                    curl_easy_setopt(result,
                                            CURLOPT_PROXYTYPE, CURLPROXY_SOCKS4);
                            else if (starts_with(curl_http_proxy, "https")) {
                                    curl_easy_setopt(result, CURLOPT_PROXYTYPE, CURLPROXY_HTTPS);

                                    if (http_proxy_ssl_cert)
                                            curl_easy_setopt(result, CURLOPT_PROXY_SSLCERT, http_proxy_ssl_cert);

                                    if (http_proxy_ssl_key)
                                            curl_easy_setopt(result, CURLOPT_PROXY_SSLKEY, http_proxy_ssl_key);

                                    if (has_proxy_cert_password())
                                            curl_easy_setopt(result, CURLOPT_PROXY_KEYPASSWD, proxy_cert_auth.password);
                            }
                            if (strstr(curl_http_proxy, "://"))
                                    credential_from_url(&proxy_auth, curl_http_proxy);
                            else {
                                    struct strbuf url = STRBUF_INIT;
                                    strbuf_addf(&url, "http://%s", curl_http_proxy);
                                    credential_from_url(&proxy_auth, url.buf);
                                    strbuf_release(&url);
                            }

                            if (!proxy_auth.host)
                                    die("Invalid proxy URL '%s'", curl_http_proxy);

                            strbuf_addstr(&proxy, proxy_auth.host);
                            if (proxy_auth.path) {
                                    curl_version_info_data *ver = curl_version_info(CURLVERSION_NOW);

                                    if (ver->version_num < 0x075400)
                                            die("libcurl 7.84 or later is required to support paths in proxy URLs");

                                    if (!starts_with(proxy_auth.protocol, "socks"))
                                            die("Invalid proxy URL '%s': only SOCKS proxies support paths",
                                            curl_http_proxy);

                                    if (strcasecmp(proxy_auth.host, "localhost"))
                                            die("Invalid proxy URL '%s': host must be localhost if a path is present",
                                            curl_http_proxy);

                                    strbuf_addch(&proxy, '/');
                                    strbuf_add_percentencode(&proxy, proxy_auth.path, 0);
                            }
                            curl_easy_setopt(result, CURLOPT_PROXY, proxy.buf);
                            strbuf_release(&proxy);

                            var_override(&curl_no_proxy, getenv("NO_PROXY"));
                            var_override(&curl_no_proxy, getenv("no_proxy"));
                            curl_easy_setopt(result, CURLOPT_NOPROXY, curl_no_proxy);
                    }
                    init_curl_proxy_auth(result);

                    set_curl_keepalive(result);

                    return result;
            }

            static void set_from_env(char **var, const char *envname)
            {
                    const char *val = getenv(envname);
                    if (val) {
                            FREE_AND_NULL(*var);
                            *var = xstrdup(val);
                    }
            }

            void http_init(struct remote *remote, const char *url, int proactive_auth)
            {
                    char *low_speed_limit;
                    char *low_speed_time;
                    char *normalized_url;
                    struct urlmatch_config config = URLMATCH_CONFIG_INIT;

                    config.section = "http";
                    config.key = NULL;
                    config.collect_fn = http_options;
                    config.cascade_fn = git_default_config;
                    config.cb = NULL;

                    http_is_verbose = 0;
                    normalized_url = url_normalize(url, &config.url);

                    git_config(urlmatch_config_entry, &config);
                    free(normalized_url);
                    string_list_clear(&config.vars, 1);

                    if (http_ssl_backend) {
                            const curl_ssl_backend **backends;
                            struct strbuf buf = STRBUF_INIT;
                            int i;

                            switch (curl_global_sslset(-1, http_ssl_backend, &backends)) {
                            case CURLSSLSET_UNKNOWN_BACKEND:
                                    strbuf_addf(&buf, _("Unsupported SSL backend '%s'. "
                                                    "Supported SSL backends:"),
                                                    http_ssl_backend);
                                    for (i = 0; backends[i]; i++)
                                            strbuf_addf(&buf, "\n\t%s", backends[i]->name);
                                    die("%s", buf.buf);
                            case CURLSSLSET_NO_BACKENDS:
                                    die(_("Could not set SSL backend to '%s': "
                                    "cURL was built without SSL backends"),
                                    http_ssl_backend);
                            case CURLSSLSET_TOO_LATE:
                                    die(_("Could not set SSL backend to '%s': already set"),
                                    http_ssl_backend);
                            case CURLSSLSET_OK:
                                    break; /* Okay! */
                            }
                    }

                    if (curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK)
                            die("curl_global_init failed");

                    if (proactive_auth && http_proactive_auth == PROACTIVE_AUTH_NONE)
                            http_proactive_auth = PROACTIVE_AUTH_IF_CREDENTIALS;

                    if (remote && remote->http_proxy)
                            curl_http_proxy = xstrdup(remote->http_proxy);

                    if (remote)
                            var_override(&http_proxy_authmethod, remote->http_proxy_authmethod);

                    pragma_header = curl_slist_append(http_copy_default_headers(),
                            "Pragma: no-cache");

                    {
                            char *http_max_requests = getenv("GIT_HTTP_MAX_REQUESTS");
                            if (http_max_requests)
                                    max_requests = atoi(http_max_requests);
                    }

                    curlm = curl_multi_init();
                    if (!curlm)
                            die("curl_multi_init failed");

                    if (getenv("GIT_SSL_NO_VERIFY"))
                            curl_ssl_verify = 0;

                    set_from_env(&ssl_cert, "GIT_SSL_CERT");
                    set_from_env(&ssl_cert_type, "GIT_SSL_CERT_TYPE");
                    set_from_env(&ssl_key, "GIT_SSL_KEY");
                    set_from_env(&ssl_key_type, "GIT_SSL_KEY_TYPE");
                    set_from_env(&ssl_capath, "GIT_SSL_CAPATH");
                    set_from_env(&ssl_cainfo, "GIT_SSL_CAINFO");
            #ifdef __MVS__
            if (!ssl_cainfo)
                    set_from_env(&ssl_cainfo, "ZOPEN_GIT_SSL_CAINFO");
            #endif

                    set_from_env(&user_agent, "GIT_HTTP_USER_AGENT");

                    low_speed_limit = getenv("GIT_HTTP_LOW_SPEED_LIMIT");
                    if (low_speed_limit)
                            curl_low_speed_limit = strtol(low_speed_limit, NULL, 10);
                    low_speed_time = getenv("GIT_HTTP_LOW_SPEED_TIME");
                    if (low_speed_time)
                            curl_low_speed_time = strtol(low_speed_time, NULL, 10);

                    if (curl_ssl_verify == -1)
                            curl_ssl_verify = 1;

                    curl_session_count = 0;
                    if (max_requests < 1)
                            max_requests = DEFAULT_MAX_REQUESTS;

                    set_from_env(&http_proxy_ssl_cert, "GIT_PROXY_SSL_CERT");
                    set_from_env(&http_proxy_ssl_key, "GIT_PROXY_SSL_KEY");
                    set_from_env(&http_proxy_ssl_ca_info, "GIT_PROXY_SSL_CAINFO");

                    if (getenv("GIT_PROXY_SSL_CERT_PASSWORD_PROTECTED"))
                            proxy_ssl_cert_password_required = 1;

                    if (getenv("GIT_CURL_FTP_NO_EPSV"))
                            curl_ftp_no_epsv = 1;

                    if (url) {
                            credential_from_url(&http_auth, url);
                            if (!ssl_cert_password_required &&
                            getenv("GIT_SSL_CERT_PASSWORD_PROTECTED") &&
                            starts_with(url, "https://"))
                                    ssl_cert_password_required = 1;
                    }

                    curl_default = get_curl_handle();
            }

            void http_cleanup(void)
            {
                    struct active_request_slot *slot = active_queue_head;

                    while (slot != NULL) {
                            struct active_request_slot *next = slot->next;
                            if (slot->curl) {
                                    xmulti_remove_handle(slot);
                                    curl_easy_cleanup(slot->curl);
                            }
                            free(slot);
                            slot = next;
                    }
                    active_queue_head = NULL;

                    curl_easy_cleanup(curl_default);

                    curl_multi_cleanup(curlm);
                    curl_global_cleanup();

                    string_list_clear(&extra_http_headers, 0);

                    curl_slist_free_all(pragma_header);
                    pragma_header = NULL;

                    curl_slist_free_all(host_resolutions);
                    host_resolutions = NULL;

                    if (curl_http_proxy) {
                            free((void *)curl_http_proxy);
                            curl_http_proxy = NULL;
                    }

                    if (proxy_auth.password) {
                            memset(proxy_auth.password, 0, strlen(proxy_auth.password));
                            FREE_AND_NULL(proxy_auth.password);
                    }

                    free((void *)curl_proxyuserpwd);
                    curl_proxyuserpwd = NULL;

                    free((void *)http_proxy_authmethod);
                    http_proxy_authmethod = NULL;

                    if (cert_auth.password) {
                            memset(cert_auth.password, 0, strlen(cert_auth.password));
                            FREE_AND_NULL(cert_auth.password);
                    }
                    ssl_cert_password_required = 0;

                    if (proxy_cert_auth.password) {
                            memset(proxy_cert_auth.password, 0, strlen(proxy_cert_auth.password));
                            FREE_AND_NULL(proxy_cert_auth.password);
                    }
                    proxy_ssl_cert_password_required = 0;

                    FREE_AND_NULL(cached_accept_language);
            }

            struct active_request_slot *get_active_slot(void)
            {
                    struct active_request_slot *slot = active_queue_head;
                    struct active_request_slot *newslot;

                    int num_transfers;

                    /* Wait for a slot to open up if the queue is full */
                    while (active_requests >= max_requests) {
                            curl_multi_perform(curlm, &num_transfers);
                            if (num_transfers < active_requests)
                                    process_curl_messages();
                    }

                    while (slot != NULL && slot->in_use)
                            slot = slot->next;

                    if (!slot) {
                            newslot = xmalloc(sizeof(*newslot));
                            newslot->curl = NULL;
                            newslot->in_use = 0;
                            newslot->next = NULL;

                            slot = active_queue_head;
                            if (!slot) {
                                    active_queue_head = newslot;
                            } else {
                                    while (slot->next != NULL)
                                            slot = slot->next;
                                    slot->next = newslot;
                            }
                            slot = newslot;
                    }

                    if (!slot->curl) {
                            slot->curl = curl_easy_duphandle(curl_default);
                            curl_session_count++;
                    }

                    active_requests++;
                    slot->in_use = 1;
                    slot->results = NULL;
                    slot->finished = NULL;
                    slot->callback_data = NULL;
                    slot->callback_func = NULL;

                    if (curl_cookie_file && !strcmp(curl_cookie_file, "-")) {
                            warning(_("refusing to read cookies from http.cookiefile '-'"));
                            FREE_AND_NULL(curl_cookie_file);
                    }
                    curl_easy_setopt(slot->curl, CURLOPT_COOKIEFILE, curl_cookie_file);
                    if (curl_save_cookies && (!curl_cookie_file || !curl_cookie_file[0])) {
                            curl_save_cookies = 0;
                            warning(_("ignoring http.savecookies for empty http.cookiefile"));
                    }
                    if (curl_save_cookies)
                            curl_easy_setopt(slot->curl, CURLOPT_COOKIEJAR, curl_cookie_file);
                    curl_easy_setopt(slot->curl, CURLOPT_HTTPHEADER, pragma_header);
                    curl_easy_setopt(slot->curl, CURLOPT_RESOLVE, host_resolutions);
                    curl_easy_setopt(slot->curl, CURLOPT_ERRORBUFFER, curl_errorstr);
                    curl_easy_setopt(slot->curl, CURLOPT_CUSTOMREQUEST, NULL);
                    curl_easy_setopt(slot->curl, CURLOPT_READFUNCTION, NULL);
                    curl_easy_setopt(slot->curl, CURLOPT_WRITEFUNCTION, NULL);
                    curl_easy_setopt(slot->curl, CURLOPT_POSTFIELDS, NULL);
                    curl_easy_setopt(slot->curl, CURLOPT_POSTFIELDSIZE, -1L);
                    curl_easy_setopt(slot->curl, CURLOPT_UPLOAD, 0);
                    curl_easy_setopt(slot->curl, CURLOPT_HTTPGET, 1);
                    curl_easy_setopt(slot->curl, CURLOPT_FAILONERROR, 1);
                    curl_easy_setopt(slot->curl, CURLOPT_RANGE, NULL);

                    /*
                    * Default following to off unless "ALWAYS" is configured; this gives
                    * callers a sane starting point, and they can tweak for individual
                    * HTTP_FOLLOW_* cases themselves.
                    */
                    if (http_follow_config == HTTP_FOLLOW_ALWAYS)
                            curl_easy_setopt(slot->curl, CURLOPT_FOLLOWLOCATION, 1);
                    else
                            curl_easy_setopt(slot->curl, CURLOPT_FOLLOWLOCATION, 0);

                    curl_easy_setopt(slot->curl, CURLOPT_IPRESOLVE, git_curl_ipresolve);
                    curl_easy_setopt(slot->curl, CURLOPT_HTTPAUTH, http_auth_methods);
                    if (http_auth.password || http_auth.credential || curl_empty_auth_enabled())
                            init_curl_http_auth(slot->curl);

                    return slot;
            }

            int start_active_slot(struct active_request_slot *slot)
            {
                    CURLMcode curlm_result = curl_multi_add_handle(curlm, slot->curl);
                    int num_transfers;

                    if (curlm_result != CURLM_OK &&
                    curlm_result != CURLM_CALL_MULTI_PERFORM) {
                            warning("curl_multi_add_handle failed: %s",
                                    curl_multi_strerror(curlm_result));
                            active_requests--;
                            slot->in_use = 0;
                            return 0;
                    }

                    /*
                    * We know there must be something to do, since we just added
                    * something.
                    */
                    curl_multi_perform(curlm, &num_transfers);
                    return 1;
            }

            struct fill_chain {
                    void *data;
                    int (*fill)(void *);
                    struct fill_chain *next;
            };

            static struct fill_chain *fill_cfg;

            void add_fill_function(void *data, int (*fill)(void *))
            {
                    struct fill_chain *new_fill = xmalloc(sizeof(*new_fill));
                    struct fill_chain **linkp = &fill_cfg;
                    new_fill->data = data;
                    new_fill->fill = fill;
                    new_fill->next = NULL;
                    while (*linkp)
                            linkp = &(*linkp)->next;
                    *linkp = new_fill;
            }

            void fill_active_slots(void)
            {
                    struct active_request_slot *slot = active_queue_head;

                    while (active_requests < max_requests) {
                            struct fill_chain *fill;
                            for (fill = fill_cfg; fill; fill = fill->next)
                                    if (fill->fill(fill->data))
                                            break;

                            if (!fill)
                                    break;
                    }

                    while (slot != NULL) {
                            if (!slot->in_use && slot->curl != NULL
                                    && curl_session_count > min_curl_sessions) {
                                    curl_easy_cleanup(slot->curl);
                                    slot->curl = NULL;
                                    curl_session_count--;
                            }
                            slot = slot->next;
                    }
            }

            void step_active_slots(void)
            {
                    int num_transfers;
                    CURLMcode curlm_result;

                    do {
                            curlm_result = curl_multi_perform(curlm, &num_transfers);
                    } while (curlm_result == CURLM_CALL_MULTI_PERFORM);
                    if (num_transfers < active_requests) {
                            process_curl_messages();
                            fill_active_slots();
                    }
            }

            void run_active_slot(struct active_request_slot *slot)
            {
                    fd_set readfds;
                    fd_set writefds;
                    fd_set excfds;
                    int max_fd;
                    struct timeval select_timeout;
                    int finished = 0;

                    slot->finished = &finished;
                    while (!finished) {
                            step_active_slots();

                            if (slot->in_use) {
                                    long curl_timeout;
                                    curl_multi_timeout(curlm, &curl_timeout);
                                    if (curl_timeout == 0) {
                                            continue;
                                    } else if (curl_timeout == -1) {
                                            select_timeout.tv_sec  = 0;
                                            select_timeout.tv_usec = 50000;
                                    } else {
                                            select_timeout.tv_sec  =  curl_timeout / 1000;
                                            select_timeout.tv_usec = (curl_timeout % 1000) * 1000;
                                    }

                                    max_fd = -1;
                                    FD_ZERO(&readfds);
                                    FD_ZERO(&writefds);
                                    FD_ZERO(&excfds);
                                    curl_multi_fdset(curlm, &readfds, &writefds, &excfds, &max_fd);

                                    /*
                                    * It can happen that curl_multi_timeout returns a pathologically
                                    * long timeout when curl_multi_fdset returns no file descriptors
                                    * to read.  See commit message for more details.
                                    */
                                    if (max_fd < 0 &&
                                    (select_timeout.tv_sec > 0 ||
                                    select_timeout.tv_usec > 50000)) {
                                            select_timeout.tv_sec  = 0;
                                            select_timeout.tv_usec = 50000;
                                    }

                                    select(max_fd+1, &readfds, &writefds, &excfds, &select_timeout);
                            }
                    }

                    /*
                    * The value of slot->finished we set before the loop was used
                    * to set our "finished" variable when our request completed.
                    *
                    * 1. The slot may not have been reused for another request
                    *    yet, in which case it still has &finished.
                    *
                    * 2. The slot may already be in-use to serve another request,
                    *    which can further be divided into two cases:
                    *
                    * (a) If call run_active_slot() hasn't been called for that
                    *     other request, slot->finished would have been cleared
                    *     by get_active_slot() and has NULL.
                    *
                    * (b) If the request did call run_active_slot(), then the
                    *     call would have updated slot->finished at the beginning
                    *     of this function, and with the clearing of the member
                    *     below, we would find that slot->finished is now NULL.
                    *
                    * In all cases, slot->finished has no useful information to
                    * anybody at this point.  Some compilers warn us for
                    * attempting to smuggle a pointer that is about to become
                    * invalid, i.e. &finished.  We clear it here to assure them.
                    */
                    slot->finished = NULL;
            }

            static void release_active_slot(struct active_request_slot *slot)
            {
                    closedown_active_slot(slot);
                    if (slot->curl) {
                            xmulti_remove_handle(slot);
                            if (curl_session_count > min_curl_sessions) {
                                    curl_easy_cleanup(slot->curl);
                                    slot->curl = NULL;
                                    curl_session_count--;
                            }
                    }
                    fill_active_slots();
            }

            void finish_all_active_slots(void)
            {
                    struct active_request_slot *slot = active_queue_head;

                    while (slot != NULL)
                            if (slot->in_use) {
                                    run_active_slot(slot);
                                    slot = active_queue_head;
                            } else {
                                    slot = slot->next;
                            }
            }

            /* Helpers for modifying and creating URLs */
            static inline int needs_quote(int ch)
            {
                    if (((ch >= 'A') && (ch <= 'Z'))
                                    || ((ch >= 'a') && (ch <= 'z'))
                                    || ((ch >= '0') && (ch <= '9'))
                                    || (ch == '/')
                                    || (ch == '-')
                                    || (ch == '.'))
                            return 0;
                    return 1;
            }

            static char *quote_ref_url(const char *base, const char *ref)
            {
                    struct strbuf buf = STRBUF_INIT;
                    const char *cp;
                    int ch;

                    end_url_with_slash(&buf, base);

                    for (cp = ref; (ch = *cp) != 0; cp++)
                            if (needs_quote(ch))
                                    strbuf_addf(&buf, "%%%02x", ch);
                            else
                                    strbuf_addch(&buf, *cp);

                    return strbuf_detach(&buf, NULL);
            }

            void append_remote_object_url(struct strbuf *buf, const char *url,
                                    const char *hex,
                                    int only_two_digit_prefix)
            {
                    end_url_with_slash(buf, url);

                    strbuf_addf(buf, "objects/%.*s/", 2, hex);
                    if (!only_two_digit_prefix)
                            strbuf_addstr(buf, hex + 2);
            }

            char *get_remote_object_url(const char *url, const char *hex,
                                    int only_two_digit_prefix)
            {
                    struct strbuf buf = STRBUF_INIT;
                    append_remote_object_url(&buf, url, hex, only_two_digit_prefix);
                    return strbuf_detach(&buf, NULL);
            }

            void normalize_curl_result(CURLcode *result, long http_code,
                                    char *errorstr, size_t errorlen)
            {
                    /*
                    * If we see a failing http code with CURLE_OK, we have turned off
                    * FAILONERROR (to keep the server's custom error response), and should
                    * translate the code into failure here.
                    *
                    * Likewise, if we see a redirect (30x code), that means we turned off
                    * redirect-following, and we should treat the result as an error.
                    */
                    if (*result == CURLE_OK && http_code >= 300) {
                            *result = CURLE_HTTP_RETURNED_ERROR;
                            /*
                            * Normally curl will already have put the "reason phrase"
                            * from the server into curl_errorstr; unfortunately without
                            * FAILONERROR it is lost, so we can give only the numeric
                            * status code.
                            */
                            xsnprintf(errorstr, errorlen,
                                    "The requested URL returned error: %ld",
                                    http_code);
                    }
            }

            static int handle_curl_result(struct slot_results *results)
            {
                    normalize_curl_result(&results->curl_result, results->http_code,
                                    curl_errorstr, sizeof(curl_errorstr));

                    if (results->curl_result == CURLE_OK) {
                            credential_approve(&http_auth);
                            credential_approve(&proxy_auth);
                            credential_approve(&cert_auth);
                            return HTTP_OK;
                    } else if (results->curl_result == CURLE_SSL_CERTPROBLEM) {
                            /*
                            * We can't tell from here whether it's a bad path, bad
                            * certificate, bad password, or something else wrong
                            * with the certificate.  So we reject the credential to
                            * avoid caching or saving a bad password.
                            */
                            credential_reject(&cert_auth);
                            return HTTP_NOAUTH;
                    } else if (results->curl_result == CURLE_SSL_PINNEDPUBKEYNOTMATCH) {
                            return HTTP_NOMATCHPUBLICKEY;
                    } else if (missing_target(results))
                            return HTTP_MISSING_TARGET;
                    else if (results->http_code == 401) {
                            if ((http_auth.username && http_auth.password) ||\
                            (http_auth.authtype && http_auth.credential)) {
                                    if (http_auth.multistage) {
                                            credential_clear_secrets(&http_auth);
                                            return HTTP_REAUTH;
                                    }
                                    credential_reject(&http_auth);
                                    if (always_auth_proactively())
                                            http_proactive_auth = PROACTIVE_AUTH_NONE;
                                    return HTTP_NOAUTH;
                            } else {
                                    http_auth_methods &= ~CURLAUTH_GSSNEGOTIATE;
                                    if (results->auth_avail) {
                                            http_auth_methods &= results->auth_avail;
                                            http_auth_methods_restricted = 1;
                                    }
                                    return HTTP_REAUTH;
                            }
                    } else {
                            if (results->http_connectcode == 407)
                                    credential_reject(&proxy_auth);
                            if (!curl_errorstr[0])
                                    strlcpy(curl_errorstr,
                                            curl_easy_strerror(results->curl_result),
                                            sizeof(curl_errorstr));
                            return HTTP_ERROR;
                    }
            }

            int run_one_slot(struct active_request_slot *slot,
                            struct slot_results *results)
            {
                    slot->results = results;
                    if (!start_active_slot(slot)) {
                            xsnprintf(curl_errorstr, sizeof(curl_errorstr),
                                    "failed to start HTTP request");
                            return HTTP_START_FAILED;
                    }

                    run_active_slot(slot);
                    return handle_curl_result(results);
            }

            struct curl_slist *http_copy_default_headers(void)
            {
                    struct curl_slist *headers = NULL;
                    const struct string_list_item *item;

                    for_each_string_list_item(item, &extra_http_headers)
                            headers = curl_slist_append(headers, item->string);

                    return headers;
            }

            static CURLcode curlinfo_strbuf(CURL *curl, CURLINFO info, struct strbuf *buf)
            {
                    char *ptr;
                    CURLcode ret;

                    strbuf_reset(buf);
                    ret = curl_easy_getinfo(curl, info, &ptr);
                    if (!ret && ptr)
                            strbuf_addstr(buf, ptr);
                    return ret;
            }

            /*
            * Check for and extract a content-type parameter. "raw"
            * should be positioned at the start of the potential
            * parameter, with any whitespace already removed.
            *
            * "name" is the name of the parameter. The value is appended
            * to "out".
            */
            static int extract_param(const char *raw, const char *name,
                                    struct strbuf *out)
            {
                    size_t len = strlen(name);

                    if (strncasecmp(raw, name, len))
                            return -1;
                    raw += len;

                    if (*raw != '=')
                            return -1;
                    raw++;

                    while (*raw && !isspace(*raw) && *raw != ';')
                            strbuf_addch(out, *raw++);
                    return 0;
            }

            /*
            * Extract a normalized version of the content type, with any
            * spaces suppressed, all letters lowercased, and no trailing ";"
            * or parameters.
            *
            * Note that we will silently remove even invalid whitespace. For
            * example, "text / plain" is specifically forbidden by RFC 2616,
            * but "text/plain" is the only reasonable output, and this keeps
            * our code simple.
            *
            * If the "charset" argument is not NULL, store the value of any
            * charset parameter there.
            *
            * Example:
            *   "TEXT/PLAIN; charset=utf-8" -> "text/plain", "utf-8"
            *   "text / plain" -> "text/plain"
            */
            static void extract_content_type(struct strbuf *raw, struct strbuf *type,
                                            struct strbuf *charset)
            {
                    const char *p;

                    strbuf_reset(type);
                    strbuf_grow(type, raw->len);
                    for (p = raw->buf; *p; p++) {
                            if (isspace(*p))
                                    continue;
                            if (*p == ';') {
                                    p++;
                                    break;
                            }
                            strbuf_addch(type, tolower(*p));
                    }

                    if (!charset)
                            return;

                    strbuf_reset(charset);
                    while (*p) {
                            while (isspace(*p) || *p == ';')
                                    p++;
                            if (!extract_param(p, "charset", charset))
                                    return;
                            while (*p && !isspace(*p))
                                    p++;
                    }

                    if (!charset->len && starts_with(type->buf, "text/"))
                            strbuf_addstr(charset, "ISO-8859-1");
            }

            static void write_accept_language(struct strbuf *buf)
            {
                    /*
                    * MAX_DECIMAL_PLACES must not be larger than 3. If it is larger than
                    * that, q-value will be smaller than 0.001, the minimum q-value the
                    * HTTP specification allows. See
                    * https://datatracker.ietf.org/doc/html/rfc7231#section-5.3.1 for q-value.
                    */
                    const int MAX_DECIMAL_PLACES = 3;
                    const int MAX_LANGUAGE_TAGS = 1000;
                    const int MAX_ACCEPT_LANGUAGE_HEADER_SIZE = 4000;
                    char **language_tags = NULL;
                    int num_langs = 0;
                    const char *s = get_preferred_languages();
                    int i;
                    struct strbuf tag = STRBUF_INIT;

                    /* Don't add Accept-Language header if no language is preferred. */
                    if (!s)
                            return;

                    /*
                    * Split the colon-separated string of preferred languages into
                    * language_tags array.
                    */
                    do {
                            /* collect language tag */
                            for (; *s && (isalnum(*s) || *s == '_'); s++)
                                    strbuf_addch(&tag, *s == '_' ? '-' : *s);

                            /* skip .codeset, @modifier and any other unnecessary parts */
                            while (*s && *s != ':')
                                    s++;

                            if (tag.len) {
                                    num_langs++;
                                    REALLOC_ARRAY(language_tags, num_langs);
                                    language_tags[num_langs - 1] = strbuf_detach(&tag, NULL);
                                    if (num_langs >= MAX_LANGUAGE_TAGS - 1) /* -1 for '*' */
                                            break;
                            }
                    } while (*s++);

                    /* write Accept-Language header into buf */
                    if (num_langs) {
                            int last_buf_len = 0;
                            int max_q;
                            int decimal_places;
                            char q_format[32];

                            /* add '*' */
                            REALLOC_ARRAY(language_tags, num_langs + 1);
                            language_tags[num_langs++] = xstrdup("*");

                            /* compute decimal_places */
                            for (max_q = 1, decimal_places = 0;
                            max_q < num_langs && decimal_places <= MAX_DECIMAL_PLACES;
                            decimal_places++, max_q *= 10)
                                    ;

                            xsnprintf(q_format, sizeof(q_format), ";q=0.%%0%dd", decimal_places);

                            strbuf_addstr(buf, "Accept-Language: ");

                            for (i = 0; i < num_langs; i++) {
                                    if (i > 0)
                                            strbuf_addstr(buf, ", ");

                                    strbuf_addstr(buf, language_tags[i]);

                                    if (i > 0)
                                            strbuf_addf(buf, q_format, max_q - i);

                                    if (buf->len > MAX_ACCEPT_LANGUAGE_HEADER_SIZE) {
                                            strbuf_remove(buf, last_buf_len, buf->len - last_buf_len);
                                            break;
                                    }

                                    last_buf_len = buf->len;
                            }
                    }

                    for (i = 0; i < num_langs; i++)
                            free(language_tags[i]);
                    free(language_tags);
            }

            /*
            * Get an Accept-Language header which indicates user's preferred languages.
            *
            * Examples:
            *   LANGUAGE= -> ""
            *   LANGUAGE=ko:en -> "Accept-Language: ko, en; q=0.9, *; q=0.1"
            *   LANGUAGE=ko_KR.UTF-8:sr@latin -> "Accept-Language: ko-KR, sr; q=0.9, *; q=0.1"
            *   LANGUAGE=ko LANG=en_US.UTF-8 -> "Accept-Language: ko, *; q=0.1"
            *   LANGUAGE= LANG=en_US.UTF-8 -> "Accept-Language: en-US, *; q=0.1"
            *   LANGUAGE= LANG=C -> ""
            */
            const char *http_get_accept_language_header(void)
            {
                    if (!cached_accept_language) {
                            struct strbuf buf = STRBUF_INIT;
                            write_accept_language(&buf);
                            if (buf.len > 0)
                                    cached_accept_language = strbuf_detach(&buf, NULL);
                    }

                    return cached_accept_language;
            }

            static void http_opt_request_remainder(CURL *curl, off_t pos)
            {
                    char buf[128];
                    xsnprintf(buf, sizeof(buf), "%"PRIuMAX"-", (uintmax_t)pos);
                    curl_easy_setopt(curl, CURLOPT_RANGE, buf);
            }

            /* http_request() targets */
            #define HTTP_REQUEST_STRBUF     0
            #define HTTP_REQUEST_FILE       1

            static int http_request(const char *url,
                                    void *result, int target,
                                    const struct http_get_options *options)
            {
                    struct active_request_slot *slot;
                    struct slot_results results;
                    struct curl_slist *headers = http_copy_default_headers();
                    struct strbuf buf = STRBUF_INIT;
                    const char *accept_language;
                    int ret;

                    slot = get_active_slot();
                    curl_easy_setopt(slot->curl, CURLOPT_HTTPGET, 1);

                    if (!result) {
                            curl_easy_setopt(slot->curl, CURLOPT_NOBODY, 1);
                    } else {
                            curl_easy_setopt(slot->curl, CURLOPT_NOBODY, 0);
                            curl_easy_setopt(slot->curl, CURLOPT_WRITEDATA, result);

                            if (target == HTTP_REQUEST_FILE) {
                                    off_t posn = ftello(result);
                                    curl_easy_setopt(slot->curl, CURLOPT_WRITEFUNCTION,
                                                    fwrite);
                                    if (posn > 0)
                                            http_opt_request_remainder(slot->curl, posn);
                            } else
                                    curl_easy_setopt(slot->curl, CURLOPT_WRITEFUNCTION,
                                                    fwrite_buffer);
                    }

                    curl_easy_setopt(slot->curl, CURLOPT_HEADERFUNCTION, fwrite_wwwauth);

                    accept_language = http_get_accept_language_header();

                    if (accept_language)
                            headers = curl_slist_append(headers, accept_language);

                    strbuf_addstr(&buf, "Pragma:");
                    if (options && options->no_cache)
                            strbuf_addstr(&buf, " no-cache");
                    if (options && options->initial_request &&
                    http_follow_config == HTTP_FOLLOW_INITIAL)
                            curl_easy_setopt(slot->curl, CURLOPT_FOLLOWLOCATION, 1);

                    headers = curl_slist_append(headers, buf.buf);

                    /* Add additional headers here */
                    if (options && options->extra_headers) {
                            const struct string_list_item *item;
                            if (options && options->extra_headers) {
                                    for_each_string_list_item(item, options->extra_headers) {
                                            headers = curl_slist_append(headers, item->string);
                                    }
                            }
                    }

                    headers = http_append_auth_header(&http_auth, headers);

                    curl_easy_setopt(slot->curl, CURLOPT_URL, url);
                    curl_easy_setopt(slot->curl, CURLOPT_HTTPHEADER, headers);
                    curl_easy_setopt(slot->curl, CURLOPT_ENCODING, "");
                    curl_easy_setopt(slot->curl, CURLOPT_FAILONERROR, 0);

                    ret = run_one_slot(slot, &results);

                    if (options && options->content_type) {
                            struct strbuf raw = STRBUF_INIT;
                            curlinfo_strbuf(slot->curl, CURLINFO_CONTENT_TYPE, &raw);
                            extract_content_type(&raw, options->content_type,
                                            options->charset);
                            strbuf_release(&raw);
                    }

                    if (options && options->effective_url)
                            curlinfo_strbuf(slot->curl, CURLINFO_EFFECTIVE_URL,
                                            options->effective_url);

                    curl_slist_free_all(headers);
                    strbuf_release(&buf);

                    return ret;
            }

            /*
            * Update the "base" url to a more appropriate value, as deduced by
            * redirects seen when requesting a URL starting with "url".
            *
            * The "asked" parameter is a URL that we asked curl to access, and must begin
            * with "base".
            *
            * The "got" parameter is the URL that curl reported to us as where we ended
            * up.
            *
            * Returns 1 if we updated the base url, 0 otherwise.
            *
            * Our basic strategy is to compare "base" and "asked" to find the bits
            * specific to our request. We then strip those bits off of "got" to yield the
            * new base. So for example, if our base is "http://example.com/foo.git",
            * and we ask for "http://example.com/foo.git/info/refs", we might end up
            * with "https://other.example.com/foo.git/info/refs". We would want the
            * new URL to become "https://other.example.com/foo.git".
            *
            * Note that this assumes a sane redirect scheme. It's entirely possible
            * in the example above to end up at a URL that does not even end in
            * "info/refs".  In such a case we die. There's not much we can do, such a
            * scheme is unlikely to represent a real git repository, and failing to
            * rewrite the base opens options for malicious redirects to do funny things.
            */
            static int update_url_from_redirect(struct strbuf *base,
                                            const char *asked,
                                            const struct strbuf *got)
            {
                    const char *tail;
                    size_t new_len;

                    if (!strcmp(asked, got->buf))
                            return 0;

                    if (!skip_prefix(asked, base->buf, &tail))
                            BUG("update_url_from_redirect: %s is not a superset of %s",
                            asked, base->buf);

                    new_len = got->len;
                    if (!strip_suffix_mem(got->buf, &new_len, tail))
                            die(_("unable to update url base from redirection:\n"
                            "  asked for: %s\n"
                            "   redirect: %s"),
                            asked, got->buf);

                    strbuf_reset(base);
                    strbuf_add(base, got->buf, new_len);

                    return 1;
            }

            static int http_request_reauth(const char *url,
                                    void *result, int target,
                                    struct http_get_options *options)
            {
                    int i = 3;
                    int ret;

                    if (always_auth_proactively())
                            credential_fill(&http_auth, 1);

                    ret = http_request(url, result, target, options);

                    if (ret != HTTP_OK && ret != HTTP_REAUTH)
                            return ret;

                    if (options && options->effective_url && options->base_url) {
                            if (update_url_from_redirect(options->base_url,
                                                    url, options->effective_url)) {
                                    credential_from_url(&http_auth, options->base_url->buf);
                                    url = options->effective_url->buf;
                            }
                    }

                    while (ret == HTTP_REAUTH && --i) {
                            /*
                            * The previous request may have put cruft into our output stream; we
                            * should clear it out before making our next request.
                            */
                            switch (target) {
                            case HTTP_REQUEST_STRBUF:
                                    strbuf_reset(result);
                                    break;
                            case HTTP_REQUEST_FILE: {
                                    FILE *f = result;
                                    if (fflush(f)) {
                                            error_errno("unable to flush a file");
                                            return HTTP_START_FAILED;
                                    }
                                    rewind(f);
                                    if (ftruncate(fileno(f), 0) < 0) {
                                            error_errno("unable to truncate a file");
                                            return HTTP_START_FAILED;
                                    }
                                    break;
                            }
                            default:
                                    BUG("Unknown http_request target");
                            }

                            credential_fill(&http_auth, 1);

                            ret = http_request(url, result, target, options);
                    }
                    return ret;
            }

            int http_get_strbuf(const char *url,
                            struct strbuf *result,
                            struct http_get_options *options)
            {
                    return http_request_reauth(url, result, HTTP_REQUEST_STRBUF, options);
            }

            /*
            * Downloads a URL and stores the result in the given file.
            *
            * If a previous interrupted download is detected (i.e. a previous temporary
            * file is still around) the download is resumed.
            */
            int http_get_file(const char *url, const char *filename,
                            struct http_get_options *options)
            {
                    int ret;
                    struct strbuf tmpfile = STRBUF_INIT;
                    FILE *result;

                    strbuf_addf(&tmpfile, "%s.temp", filename);
                    result = fopen(tmpfile.buf, "a");
                    if (!result) {
                            error("Unable to open local file %s", tmpfile.buf);
                            ret = HTTP_ERROR;
                            goto cleanup;
                    }

                    ret = http_request_reauth(url, result, HTTP_REQUEST_FILE, options);
                    fclose(result);

                    if (ret == HTTP_OK && finalize_object_file(tmpfile.buf, filename))
                            ret = HTTP_ERROR;
            cleanup:
                    strbuf_release(&tmpfile);
                    return ret;
            }

            int http_fetch_ref(const char *base, struct ref *ref)
            {
                    struct http_get_options options = {0};
                    char *url;
                    struct strbuf buffer = STRBUF_INIT;
                    int ret = -1;

                    options.no_cache = 1;

                    url = quote_ref_url(base, ref->name);
                    if (http_get_strbuf(url, &buffer, &options) == HTTP_OK) {
                            strbuf_rtrim(&buffer);
                            if (buffer.len == the_hash_algo->hexsz)
                                    ret = get_oid_hex(buffer.buf, &ref->old_oid);
                            else if (starts_with(buffer.buf, "ref: ")) {
                                    ref->symref = xstrdup(buffer.buf + 5);
                                    ret = 0;
                            }
                    }

                    strbuf_release(&buffer);
                    free(url);
                    return ret;
            }

            /* Helpers for fetching packs */
            static char *fetch_pack_index(unsigned char *hash, const char *base_url)
            {
                    char *url, *tmp;
                    struct strbuf buf = STRBUF_INIT;

                    if (http_is_verbose)
                            fprintf(stderr, "Getting index for pack %s\n", hash_to_hex(hash));

                    end_url_with_slash(&buf, base_url);
                    strbuf_addf(&buf, "objects/pack/pack-%s.idx", hash_to_hex(hash));
                    url = strbuf_detach(&buf, NULL);

                    /*
                    * Don't put this into packs/, since it's just temporary and we don't
                    * want to confuse it with our local .idx files.  We'll generate our
                    * own index if we choose to download the matching packfile.
                    *
                    * It's tempting to use xmks_tempfile() here, but it's important that
                    * the file not exist, otherwise http_get_file() complains. So we
                    * create a filename that should be unique, and then just register it
                    * as a tempfile so that it will get cleaned up on exit.
                    *
                    * In theory we could hold on to the tempfile and delete these as soon
                    * as we download the matching pack, but it would take a bit of
                    * refactoring. Leaving them until the process ends is probably OK.
                    */
                    tmp = xstrfmt("%s/tmp_pack_%s.idx",
                            repo_get_object_directory(the_repository),
                            hash_to_hex(hash));
                    register_tempfile(tmp);

                    if (http_get_file(url, tmp, NULL) != HTTP_OK) {
                            error("Unable to get pack index %s", url);
                            FREE_AND_NULL(tmp);
                    }

                    free(url);
                    return tmp;
            }

            static int fetch_and_setup_pack_index(struct packed_git **packs_head,
                    unsigned char *sha1, const char *base_url)
            {
                    struct packed_git *new_pack, *p;
                    char *tmp_idx = NULL;
                    int ret;

                    /*
                    * If we already have the pack locally, no need to fetch its index or
                    * even add it to list; we already have all of its objects.
                    */
                    for (p = get_all_packs(the_repository); p; p = p->next) {
                            if (hasheq(p->hash, sha1, the_repository->hash_algo))
                                    return 0;
                    }

                    tmp_idx = fetch_pack_index(sha1, base_url);
                    if (!tmp_idx)
                            return -1;

                    new_pack = parse_pack_index(the_repository, sha1, tmp_idx);
                    if (!new_pack) {
                            unlink(tmp_idx);
                            free(tmp_idx);

                            return -1; /* parse_pack_index() already issued error message */
                    }

                    ret = verify_pack_index(new_pack);
                    if (!ret)
                            close_pack_index(new_pack);
                    free(tmp_idx);
                    if (ret)
                            return -1;

                    new_pack->next = *packs_head;
                    *packs_head = new_pack;
                    return 0;
            }

            int http_get_info_packs(const char *base_url, struct packed_git **packs_head)
            {
                    struct http_get_options options = {0};
                    int ret = 0;
                    char *url;
                    const char *data;
                    struct strbuf buf = STRBUF_INIT;
                    struct object_id oid;

                    end_url_with_slash(&buf, base_url);
                    strbuf_addstr(&buf, "objects/info/packs");
                    url = strbuf_detach(&buf, NULL);

                    options.no_cache = 1;
                    ret = http_get_strbuf(url, &buf, &options);
                    if (ret != HTTP_OK)
                            goto cleanup;

                    data = buf.buf;
                    while (*data) {
                            if (skip_prefix(data, "P pack-", &data) &&
                            !parse_oid_hex(data, &oid, &data) &&
                            skip_prefix(data, ".pack", &data) &&
                            (*data == '\n' || *data == '\0')) {
                                    fetch_and_setup_pack_index(packs_head, oid.hash, base_url);
                            } else {
                                    data = strchrnul(data, '\n');
                            }
                            if (*data)
                                    data++; /* skip past newline */
                    }

            cleanup:
                    free(url);
                    strbuf_release(&buf);
                    return ret;
            }

            void release_http_pack_request(struct http_pack_request *preq)
            {
                    if (preq->packfile) {
                            fclose(preq->packfile);
                            preq->packfile = NULL;
                    }
                    preq->slot = NULL;
                    strbuf_release(&preq->tmpfile);
                    curl_slist_free_all(preq->headers);
                    free(preq->url);
                    free(preq);
            }

            static const char *default_index_pack_args[] =
                    {"index-pack", "--stdin", NULL};

            int finish_http_pack_request(struct http_pack_request *preq)
            {
                    struct child_process ip = CHILD_PROCESS_INIT;
                    int tmpfile_fd;
                    int ret = 0;

                    fclose(preq->packfile);
                    preq->packfile = NULL;

                    tmpfile_fd = xopen(preq->tmpfile.buf, O_RDONLY);

                    ip.git_cmd = 1;
                    ip.in = tmpfile_fd;
                    strvec_pushv(&ip.args, preq->index_pack_args ?
                            preq->index_pack_args :
                            default_index_pack_args);

                    if (preq->preserve_index_pack_stdout)
                            ip.out = 0;
                    else
                            ip.no_stdout = 1;

                    if (run_command(&ip)) {
                            ret = -1;
                            goto cleanup;
                    }

            cleanup:
                    close(tmpfile_fd);
                    unlink(preq->tmpfile.buf);
                    return ret;
            }

            void http_install_packfile(struct packed_git *p,
                                    struct packed_git **list_to_remove_from)
            {
                    struct packed_git **lst = list_to_remove_from;

                    while (*lst != p)
                            lst = &((*lst)->next);
                    *lst = (*lst)->next;

                    install_packed_git(the_repository, p);
            }

            struct http_pack_request *new_http_pack_request(
                    const unsigned char *packed_git_hash, const char *base_url) {

                    struct strbuf buf = STRBUF_INIT;

                    end_url_with_slash(&buf, base_url);
                    strbuf_addf(&buf, "objects/pack/pack-%s.pack",
                            hash_to_hex(packed_git_hash));
                    return new_direct_http_pack_request(packed_git_hash,
                                                    strbuf_detach(&buf, NULL));
            }

            struct http_pack_request *new_direct_http_pack_request(
                    const unsigned char *packed_git_hash, char *url)
            {
                    off_t prev_posn = 0;
                    struct http_pack_request *preq;

                    CALLOC_ARRAY(preq, 1);
                    strbuf_init(&preq->tmpfile, 0);

                    preq->url = url;

                    odb_pack_name(the_repository, &preq->tmpfile, packed_git_hash, "pack");
                    strbuf_addstr(&preq->tmpfile, ".temp");
                    preq->packfile = fopen(preq->tmpfile.buf, "a");
                    if (!preq->packfile) {
                            error("Unable to open local file %s for pack",
                            preq->tmpfile.buf);
                            goto abort;
                    }

                    preq->slot = get_active_slot();
                    preq->headers = object_request_headers();
                    curl_easy_setopt(preq->slot->curl, CURLOPT_WRITEDATA, preq->packfile);
                    curl_easy_setopt(preq->slot->curl, CURLOPT_WRITEFUNCTION, fwrite);
                    curl_easy_setopt(preq->slot->curl, CURLOPT_URL, preq->url);
                    curl_easy_setopt(preq->slot->curl, CURLOPT_HTTPHEADER, preq->headers);

                    /*
                    * If there is data present from a previous transfer attempt,
                    * resume where it left off
                    */
                    prev_posn = ftello(preq->packfile);
                    if (prev_posn>0) {
                            if (http_is_verbose)
                                    fprintf(stderr,
                                            "Resuming fetch of pack %s at byte %"PRIuMAX"\n",
                                            hash_to_hex(packed_git_hash),
                                            (uintmax_t)prev_posn);
                            http_opt_request_remainder(preq->slot->curl, prev_posn);
                    }

                    return preq;

            abort:
                    strbuf_release(&preq->tmpfile);
                    free(preq->url);
                    free(preq);
                    return NULL;
            }

            /* Helpers for fetching objects (loose) */
            static size_t fwrite_sha1_file(char *ptr, size_t eltsize, size_t nmemb,
                                    void *data)
            {
                    unsigned char expn[4096];
                    size_t size = eltsize * nmemb;
                    int posn = 0;
                    struct http_object_request *freq = data;
                    struct active_request_slot *slot = freq->slot;

                    if (slot) {
                            CURLcode c = curl_easy_getinfo(slot->curl, CURLINFO_HTTP_CODE,
                                                            &slot->http_code);
                            if (c != CURLE_OK)
                                    BUG("curl_easy_getinfo for HTTP code failed: %s",
                                            curl_easy_strerror(c));
                            if (slot->http_code >= 300)
                                    return nmemb;
                    }

                    do {
                            ssize_t retval = xwrite(freq->localfile,
                                                    (char *) ptr + posn, size - posn);
                            if (retval < 0)
                                    return posn / eltsize;
                            posn += retval;
                    } while (posn < size);

                    freq->stream.avail_in = size;
                    freq->stream.next_in = (void *)ptr;
                    do {
                            freq->stream.next_out = expn;
                            freq->stream.avail_out = sizeof(expn);
                            freq->zret = git_inflate(&freq->stream, Z_SYNC_FLUSH);
                            the_hash_algo->update_fn(&freq->c, expn,
                                                    sizeof(expn) - freq->stream.avail_out);
                    } while (freq->stream.avail_in && freq->zret == Z_OK);
                    return nmemb;
            }

            struct http_object_request *new_http_object_request(const char *base_url,
                                                            const struct object_id *oid)
            {
                    char *hex = oid_to_hex(oid);
                    struct strbuf filename = STRBUF_INIT;
                    struct strbuf prevfile = STRBUF_INIT;
                    int prevlocal;
                    char prev_buf[PREV_BUF_SIZE];
                    ssize_t prev_read = 0;
                    off_t prev_posn = 0;
                    struct http_object_request *freq;

                    CALLOC_ARRAY(freq, 1);
                    strbuf_init(&freq->tmpfile, 0);
                    oidcpy(&freq->oid, oid);
                    freq->localfile = -1;

                    loose_object_path(the_repository, &filename, oid);
                    strbuf_addf(&freq->tmpfile, "%s.temp", filename.buf);

                    strbuf_addf(&prevfile, "%s.prev", filename.buf);
                    unlink_or_warn(prevfile.buf);
                    rename(freq->tmpfile.buf, prevfile.buf);
                    unlink_or_warn(freq->tmpfile.buf);
                    strbuf_release(&filename);

                    if (freq->localfile != -1)
                            error("fd leakage in start: %d", freq->localfile);
                    freq->localfile = open(freq->tmpfile.buf,
                                    O_WRONLY | O_CREAT | O_EXCL, 0666);
                    /*
                    * This could have failed due to the "lazy directory creation";
                    * try to mkdir the last path component.
                    */
                    if (freq->localfile < 0 && errno == ENOENT) {
                            char *dir = strrchr(freq->tmpfile.buf, '/');
                            if (dir) {
                                    *dir = 0;
                                    mkdir(freq->tmpfile.buf, 0777);
                                    *dir = '/';
                            }
                            freq->localfile = open(freq->tmpfile.buf,
                                            O_WRONLY | O_CREAT | O_EXCL, 0666);
                    }

                    if (freq->localfile < 0) {
                            error_errno("Couldn't create temporary file %s",
                                    freq->tmpfile.buf);
                            goto abort;
                    }

                    git_inflate_init(&freq->stream);

                    the_hash_algo->init_fn(&freq->c);

                    freq->url = get_remote_object_url(base_url, hex, 0);

                    /*
                    * If a previous temp file is present, process what was already
                    * fetched.
                    */
                    prevlocal = open(prevfile.buf, O_RDONLY);
                    if (prevlocal != -1) {
                            do {
                                    prev_read = xread(prevlocal, prev_buf, PREV_BUF_SIZE);
                                    if (prev_read>0) {
                                            if (fwrite_sha1_file(prev_buf,
                                                            1,
                                                            prev_read,
                                                            freq) == prev_read) {
                                                    prev_posn += prev_read;
                                            } else {
                                                    prev_read = -1;
                                            }
                                    }
                            } while (prev_read > 0);
                            close(prevlocal);
                    }
                    unlink_or_warn(prevfile.buf);
                    strbuf_release(&prevfile);

                    /*
                    * Reset inflate/SHA1 if there was an error reading the previous temp
                    * file; also rewind to the beginning of the local file.
                    */
                    if (prev_read == -1) {
                            git_inflate_end(&freq->stream);
                            memset(&freq->stream, 0, sizeof(freq->stream));
                            git_inflate_init(&freq->stream);
                            the_hash_algo->init_fn(&freq->c);
                            if (prev_posn>0) {
                                    prev_posn = 0;
                                    lseek(freq->localfile, 0, SEEK_SET);
                                    if (ftruncate(freq->localfile, 0) < 0) {
                                            error_errno("Couldn't truncate temporary file %s",
                                                    freq->tmpfile.buf);
                                            goto abort;
                                    }
                            }
                    }

                    freq->slot = get_active_slot();
                    freq->headers = object_request_headers();

                    curl_easy_setopt(freq->slot->curl, CURLOPT_WRITEDATA, freq);
                    curl_easy_setopt(freq->slot->curl, CURLOPT_FAILONERROR, 0);
                    curl_easy_setopt(freq->slot->curl, CURLOPT_WRITEFUNCTION, fwrite_sha1_file);
                    curl_easy_setopt(freq->slot->curl, CURLOPT_ERRORBUFFER, freq->errorstr);
                    curl_easy_setopt(freq->slot->curl, CURLOPT_URL, freq->url);
                    curl_easy_setopt(freq->slot->curl, CURLOPT_HTTPHEADER, freq->headers);

                    /*
                    * If we have successfully processed data from a previous fetch
                    * attempt, only fetch the data we don't already have.
                    */
                    if (prev_posn>0) {
                            if (http_is_verbose)
                                    fprintf(stderr,
                                            "Resuming fetch of object %s at byte %"PRIuMAX"\n",
                                            hex, (uintmax_t)prev_posn);
                            http_opt_request_remainder(freq->slot->curl, prev_posn);
                    }

                    return freq;

            abort:
                    strbuf_release(&prevfile);
                    free(freq->url);
                    free(freq);
                    return NULL;
            }

            void process_http_object_request(struct http_object_request *freq)
            {
                    if (!freq->slot)
                            return;
                    freq->curl_result = freq->slot->curl_result;
                    freq->http_code = freq->slot->http_code;
                    freq->slot = NULL;
            }

            int finish_http_object_request(struct http_object_request *freq)
            {
                    struct stat st;
                    struct strbuf filename = STRBUF_INIT;

                    close(freq->localfile);
                    freq->localfile = -1;

                    process_http_object_request(freq);

                    if (freq->http_code == 416) {
                            warning("requested range invalid; we may already have all the data.");
                    } else if (freq->curl_result != CURLE_OK) {
                            if (stat(freq->tmpfile.buf, &st) == 0)
                                    if (st.st_size == 0)
                                            unlink_or_warn(freq->tmpfile.buf);
                            return -1;
                    }

                    the_hash_algo->final_oid_fn(&freq->real_oid, &freq->c);
                    if (freq->zret != Z_STREAM_END) {
                            unlink_or_warn(freq->tmpfile.buf);
                            return -1;
                    }
                    if (!oideq(&freq->oid, &freq->real_oid)) {
                            unlink_or_warn(freq->tmpfile.buf);
                            return -1;
                    }
                    loose_object_path(the_repository, &filename, &freq->oid);
                    freq->rename = finalize_object_file(freq->tmpfile.buf, filename.buf);
                    strbuf_release(&filename);

                    return freq->rename;
            }

            void abort_http_object_request(struct http_object_request **freq_p)
            {
                    struct http_object_request *freq = *freq_p;
                    unlink_or_warn(freq->tmpfile.buf);

                    release_http_object_request(freq_p);
            }

            void release_http_object_request(struct http_object_request **freq_p)
            {
                    struct http_object_request *freq = *freq_p;
                    if (freq->localfile != -1) {
                            close(freq->localfile);
                            freq->localfile = -1;
                    }
                    FREE_AND_NULL(freq->url);
                    if (freq->slot) {
                            freq->slot->callback_func = NULL;
                            freq->slot->callback_data = NULL;
                            release_active_slot(freq->slot);
                            freq->slot = NULL;
                    }
                    curl_slist_free_all(freq->headers);
                    strbuf_release(&freq->tmpfile);
                    git_inflate_end(&freq->stream);

                    free(freq);
                    *freq_p = NULL;
            }



            """,
            "patche":
            """
            diff --git a/http.c b/http.c
            index c8fc15aa11..d72d87f27e 100644
            --- a/http.c
            +++ b/http.c
            @@ -1073,7 +1073,6 @@ static CURL *get_curl_handle(void)
                    if (ssl_cipherlist != NULL && *ssl_cipherlist)
                            curl_easy_setopt(result, CURLOPT_SSL_CIPHER_LIST,
                                            ssl_cipherlist);
            -
                    if (ssl_cert)
                            curl_easy_setopt(result, CURLOPT_SSLCERT, ssl_cert);
                    if (ssl_cert_type)
            @@ -1336,6 +1335,10 @@ void http_init(struct remote *remote, const char *url, int proactive_auth)
                    set_from_env(&ssl_key_type, "GIT_SSL_KEY_TYPE");
                    set_from_env(&ssl_capath, "GIT_SSL_CAPATH");
                    set_from_env(&ssl_cainfo, "GIT_SSL_CAINFO");
            +#ifdef __MVS__
            +  if (!ssl_cainfo)
            +     set_from_env(&ssl_cainfo, "ZOPEN_GIT_SSL_CAINFO");
            +#endif

                    set_from_env(&user_agent, "GIT_HTTP_USER_AGENT");



            """,
    },

    {
            "wrong code":
            """
                            /*
            * GIT - The information manager from hell
            *
            * Copyright (C) Linus Torvalds, 2005
            *
            * This handles basic git object files - packing, unpacking,
            * creation etc.
            */

            #define USE_THE_REPOSITORY_VARIABLE
            #define DISABLE_SIGN_COMPARE_WARNINGS

            #include "git-compat-util.h"
            #include "abspath.h"
            #include "config.h"
            #include "convert.h"
            #include "environment.h"
            #include "gettext.h"
            #include "hex.h"
            #include "string-list.h"
            #include "lockfile.h"
            #include "pack.h"
            #include "commit.h"
            #include "run-command.h"
            #include "refs.h"
            #include "bulk-checkin.h"
            #include "repository.h"
            #include "replace-object.h"
            #include "streaming.h"
            #include "dir.h"
            #include "list.h"
            #include "quote.h"
            #include "packfile.h"
            #include "object-file.h"
            #include "object-store.h"
            #include "oidtree.h"
            #include "path.h"
            #include "promisor-remote.h"
            #include "setup.h"
            #include "submodule.h"
            #include "fsck.h"
            #include "loose.h"
            #include "object-file-convert.h"

            /* The maximum size for an object header. */
            #define MAX_HEADER_LEN 32

            static const struct object_id empty_tree_oid = {
                    .hash = {
                            0x4b, 0x82, 0x5d, 0xc6, 0x42, 0xcb, 0x6e, 0xb9, 0xa0, 0x60,
                            0xe5, 0x4b, 0xf8, 0xd6, 0x92, 0x88, 0xfb, 0xee, 0x49, 0x04
                    },
                    .algo = GIT_HASH_SHA1,
            };
            static const struct object_id empty_blob_oid = {
                    .hash = {
                            0xe6, 0x9d, 0xe2, 0x9b, 0xb2, 0xd1, 0xd6, 0x43, 0x4b, 0x8b,
                            0x29, 0xae, 0x77, 0x5a, 0xd8, 0xc2, 0xe4, 0x8c, 0x53, 0x91
                    },
                    .algo = GIT_HASH_SHA1,
            };
            static const struct object_id null_oid_sha1 = {
                    .hash = {0},
                    .algo = GIT_HASH_SHA1,
            };
            static const struct object_id empty_tree_oid_sha256 = {
                    .hash = {
                            0x6e, 0xf1, 0x9b, 0x41, 0x22, 0x5c, 0x53, 0x69, 0xf1, 0xc1,
                            0x04, 0xd4, 0x5d, 0x8d, 0x85, 0xef, 0xa9, 0xb0, 0x57, 0xb5,
                            0x3b, 0x14, 0xb4, 0xb9, 0xb9, 0x39, 0xdd, 0x74, 0xde, 0xcc,
                            0x53, 0x21
                    },
                    .algo = GIT_HASH_SHA256,
            };
            static const struct object_id empty_blob_oid_sha256 = {
                    .hash = {
                            0x47, 0x3a, 0x0f, 0x4c, 0x3b, 0xe8, 0xa9, 0x36, 0x81, 0xa2,
                            0x67, 0xe3, 0xb1, 0xe9, 0xa7, 0xdc, 0xda, 0x11, 0x85, 0x43,
                            0x6f, 0xe1, 0x41, 0xf7, 0x74, 0x91, 0x20, 0xa3, 0x03, 0x72,
                            0x18, 0x13
                    },
                    .algo = GIT_HASH_SHA256,
            };
            static const struct object_id null_oid_sha256 = {
                    .hash = {0},
                    .algo = GIT_HASH_SHA256,
            };

            static void git_hash_sha1_init(git_hash_ctx *ctx)
            {
                    git_SHA1_Init(&ctx->sha1);
            }

            static void git_hash_sha1_clone(git_hash_ctx *dst, const git_hash_ctx *src)
            {
                    git_SHA1_Clone(&dst->sha1, &src->sha1);
            }

            static void git_hash_sha1_update(git_hash_ctx *ctx, const void *data, size_t len)
            {
                    git_SHA1_Update(&ctx->sha1, data, len);
            }

            static void git_hash_sha1_final(unsigned char *hash, git_hash_ctx *ctx)
            {
                    git_SHA1_Final(hash, &ctx->sha1);
            }

            static void git_hash_sha1_final_oid(struct object_id *oid, git_hash_ctx *ctx)
            {
                    git_SHA1_Final(oid->hash, &ctx->sha1);
                    memset(oid->hash + GIT_SHA1_RAWSZ, 0, GIT_MAX_RAWSZ - GIT_SHA1_RAWSZ);
                    oid->algo = GIT_HASH_SHA1;
            }

            static void git_hash_sha1_init_unsafe(git_hash_ctx *ctx)
            {
                    git_SHA1_Init_unsafe(&ctx->sha1_unsafe);
            }

            static void git_hash_sha1_clone_unsafe(git_hash_ctx *dst, const git_hash_ctx *src)
            {
                    git_SHA1_Clone_unsafe(&dst->sha1_unsafe, &src->sha1_unsafe);
            }

            static void git_hash_sha1_update_unsafe(git_hash_ctx *ctx, const void *data,
                                            size_t len)
            {
                    git_SHA1_Update_unsafe(&ctx->sha1_unsafe, data, len);
            }

            static void git_hash_sha1_final_unsafe(unsigned char *hash, git_hash_ctx *ctx)
            {
                    git_SHA1_Final_unsafe(hash, &ctx->sha1_unsafe);
            }

            static void git_hash_sha1_final_oid_unsafe(struct object_id *oid, git_hash_ctx *ctx)
            {
                    git_SHA1_Final_unsafe(oid->hash, &ctx->sha1_unsafe);
                    memset(oid->hash + GIT_SHA1_RAWSZ, 0, GIT_MAX_RAWSZ - GIT_SHA1_RAWSZ);
                    oid->algo = GIT_HASH_SHA1;
            }

            static void git_hash_sha256_init(git_hash_ctx *ctx)
            {
                    git_SHA256_Init(&ctx->sha256);
            }

            static void git_hash_sha256_clone(git_hash_ctx *dst, const git_hash_ctx *src)
            {
                    git_SHA256_Clone(&dst->sha256, &src->sha256);
            }

            static void git_hash_sha256_update(git_hash_ctx *ctx, const void *data, size_t len)
            {
                    git_SHA256_Update(&ctx->sha256, data, len);
            }

            static void git_hash_sha256_final(unsigned char *hash, git_hash_ctx *ctx)
            {
                    git_SHA256_Final(hash, &ctx->sha256);
            }

            static void git_hash_sha256_final_oid(struct object_id *oid, git_hash_ctx *ctx)
            {
                    git_SHA256_Final(oid->hash, &ctx->sha256);
                    /*
                    * This currently does nothing, so the compiler should optimize it out,
                    * but keep it in case we extend the hash size again.
                    */
                    memset(oid->hash + GIT_SHA256_RAWSZ, 0, GIT_MAX_RAWSZ - GIT_SHA256_RAWSZ);
                    oid->algo = GIT_HASH_SHA256;
            }

            static void git_hash_unknown_init(git_hash_ctx *ctx UNUSED)
            {
                    BUG("trying to init unknown hash");
            }

            static void git_hash_unknown_clone(git_hash_ctx *dst UNUSED,
                                            const git_hash_ctx *src UNUSED)
            {
                    BUG("trying to clone unknown hash");
            }

            static void git_hash_unknown_update(git_hash_ctx *ctx UNUSED,
                                            const void *data UNUSED,
                                            size_t len UNUSED)
            {
                    BUG("trying to update unknown hash");
            }

            static void git_hash_unknown_final(unsigned char *hash UNUSED,
                                            git_hash_ctx *ctx UNUSED)
            {
                    BUG("trying to finalize unknown hash");
            }

            static void git_hash_unknown_final_oid(struct object_id *oid UNUSED,
                                            git_hash_ctx *ctx UNUSED)
            {
                    BUG("trying to finalize unknown hash");
            }

            const struct git_hash_algo hash_algos[GIT_HASH_NALGOS] = {
                    {
                            .name = NULL,
                            .format_id = 0x00000000,
                            .rawsz = 0,
                            .hexsz = 0,
                            .blksz = 0,
                            .init_fn = git_hash_unknown_init,
                            .clone_fn = git_hash_unknown_clone,
                            .update_fn = git_hash_unknown_update,
                            .final_fn = git_hash_unknown_final,
                            .final_oid_fn = git_hash_unknown_final_oid,
                            .unsafe_init_fn = git_hash_unknown_init,
                            .unsafe_clone_fn = git_hash_unknown_clone,
                            .unsafe_update_fn = git_hash_unknown_update,
                            .unsafe_final_fn = git_hash_unknown_final,
                            .unsafe_final_oid_fn = git_hash_unknown_final_oid,
                            .empty_tree = NULL,
                            .empty_blob = NULL,
                            .null_oid = NULL,
                    },
                    {
                            .name = "sha1",
                            .format_id = GIT_SHA1_FORMAT_ID,
                            .rawsz = GIT_SHA1_RAWSZ,
                            .hexsz = GIT_SHA1_HEXSZ,
                            .blksz = GIT_SHA1_BLKSZ,
                            .init_fn = git_hash_sha1_init,
                            .clone_fn = git_hash_sha1_clone,
                            .update_fn = git_hash_sha1_update,
                            .final_fn = git_hash_sha1_final,
                            .final_oid_fn = git_hash_sha1_final_oid,
                            .unsafe_init_fn = git_hash_sha1_init_unsafe,
                            .unsafe_clone_fn = git_hash_sha1_clone_unsafe,
                            .unsafe_update_fn = git_hash_sha1_update_unsafe,
                            .unsafe_final_fn = git_hash_sha1_final_unsafe,
                            .unsafe_final_oid_fn = git_hash_sha1_final_oid_unsafe,
                            .empty_tree = &empty_tree_oid,
                            .empty_blob = &empty_blob_oid,
                            .null_oid = &null_oid_sha1,
                    },
                    {
                            .name = "sha256",
                            .format_id = GIT_SHA256_FORMAT_ID,
                            .rawsz = GIT_SHA256_RAWSZ,
                            .hexsz = GIT_SHA256_HEXSZ,
                            .blksz = GIT_SHA256_BLKSZ,
                            .init_fn = git_hash_sha256_init,
                            .clone_fn = git_hash_sha256_clone,
                            .update_fn = git_hash_sha256_update,
                            .final_fn = git_hash_sha256_final,
                            .final_oid_fn = git_hash_sha256_final_oid,
                            .unsafe_init_fn = git_hash_sha256_init,
                            .unsafe_clone_fn = git_hash_sha256_clone,
                            .unsafe_update_fn = git_hash_sha256_update,
                            .unsafe_final_fn = git_hash_sha256_final,
                            .unsafe_final_oid_fn = git_hash_sha256_final_oid,
                            .empty_tree = &empty_tree_oid_sha256,
                            .empty_blob = &empty_blob_oid_sha256,
                            .null_oid = &null_oid_sha256,
                    }
            };

            const struct object_id *null_oid(void)
            {
                    return the_hash_algo->null_oid;
            }

            const char *empty_tree_oid_hex(const struct git_hash_algo *algop)
            {
                    static char buf[GIT_MAX_HEXSZ + 1];
                    return oid_to_hex_r(buf, algop->empty_tree);
            }

            int hash_algo_by_name(const char *name)
            {
                    int i;
                    if (!name)
                            return GIT_HASH_UNKNOWN;
                    for (i = 1; i < GIT_HASH_NALGOS; i++)
                            if (!strcmp(name, hash_algos[i].name))
                                    return i;
                    return GIT_HASH_UNKNOWN;
            }

            int hash_algo_by_id(uint32_t format_id)
            {
                    int i;
                    for (i = 1; i < GIT_HASH_NALGOS; i++)
                            if (format_id == hash_algos[i].format_id)
                                    return i;
                    return GIT_HASH_UNKNOWN;
            }

            int hash_algo_by_length(int len)
            {
                    int i;
                    for (i = 1; i < GIT_HASH_NALGOS; i++)
                            if (len == hash_algos[i].rawsz)
                                    return i;
                    return GIT_HASH_UNKNOWN;
            }

            /*
            * This is meant to hold a *small* number of objects that you would
            * want repo_read_object_file() to be able to return, but yet you do not want
            * to write them into the object store (e.g. a browse-only
            * application).
            */
            static struct cached_object_entry {
                    struct object_id oid;
                    struct cached_object {
                            enum object_type type;
                            const void *buf;
                            unsigned long size;
                    } value;
            } *cached_objects;
            static int cached_object_nr, cached_object_alloc;

            static const struct cached_object *find_cached_object(const struct object_id *oid)
            {
                    static const struct cached_object empty_tree = {
                            .type = OBJ_TREE,
                            .buf = "",
                    };
                    int i;
                    const struct cached_object_entry *co = cached_objects;

                    for (i = 0; i < cached_object_nr; i++, co++) {
                            if (oideq(&co->oid, oid))
                                    return &co->value;
                    }
                    if (oideq(oid, the_hash_algo->empty_tree))
                            return &empty_tree;
                    return NULL;
            }


            static int get_conv_flags(unsigned flags)
            {
                    if (flags & HASH_RENORMALIZE)
                            return CONV_EOL_RENORMALIZE;
                    else if (flags & HASH_WRITE_OBJECT)
                            return global_conv_flags_eol | CONV_WRITE_OBJECT;
                    else
                            return 0;
            }


            int mkdir_in_gitdir(const char *path)
            {
                    if (mkdir(path, 0777)) {
                            int saved_errno = errno;
                            struct stat st;
                            struct strbuf sb = STRBUF_INIT;

                            if (errno != EEXIST)
                                    return -1;
                            /*
                            * Are we looking at a path in a symlinked worktree
                            * whose original repository does not yet have it?
                            * e.g. .git/rr-cache pointing at its original
                            * repository in which the user hasn't performed any
                            * conflict resolution yet?
                            */
                            if (lstat(path, &st) || !S_ISLNK(st.st_mode) ||
                            strbuf_readlink(&sb, path, st.st_size) ||
                            !is_absolute_path(sb.buf) ||
                            mkdir(sb.buf, 0777)) {
                                    strbuf_release(&sb);
                                    errno = saved_errno;
                                    return -1;
                            }
                            strbuf_release(&sb);
                    }
                    return adjust_shared_perm(path);
            }

            static enum scld_error safe_create_leading_directories_1(char *path, int share)
            {
                    char *next_component = path + offset_1st_component(path);
                    enum scld_error ret = SCLD_OK;

                    while (ret == SCLD_OK && next_component) {
                            struct stat st;
                            char *slash = next_component, slash_character;

                            while (*slash && !is_dir_sep(*slash))
                                    slash++;

                            if (!*slash)
                                    break;

                            next_component = slash + 1;
                            while (is_dir_sep(*next_component))
                                    next_component++;
                            if (!*next_component)
                                    break;

                            slash_character = *slash;
                            *slash = '\0';
                            if (!stat(path, &st)) {
                                    /* path exists */
                                    if (!S_ISDIR(st.st_mode)) {
                                            errno = ENOTDIR;
                                            ret = SCLD_EXISTS;
                                    }
                            } else if (mkdir(path, 0777)) {
                                    if (errno == EEXIST &&
                                    !stat(path, &st) && S_ISDIR(st.st_mode))
                                            ; /* somebody created it since we checked */
                                    else if (errno == ENOENT)
                                            /*
                                            * Either mkdir() failed because
                                            * somebody just pruned the containing
                                            * directory, or stat() failed because
                                            * the file that was in our way was
                                            * just removed.  Either way, inform
                                            * the caller that it might be worth
                                            * trying again:
                                            */
                                            ret = SCLD_VANISHED;
                                    else
                                            ret = SCLD_FAILED;
                            } else if (share && adjust_shared_perm(path)) {
                                    ret = SCLD_PERMS;
                            }
                            *slash = slash_character;
                    }
                    return ret;
            }

            enum scld_error safe_create_leading_directories(char *path)
            {
                    return safe_create_leading_directories_1(path, 1);
            }

            enum scld_error safe_create_leading_directories_no_share(char *path)
            {
                    return safe_create_leading_directories_1(path, 0);
            }

            enum scld_error safe_create_leading_directories_const(const char *path)
            {
                    int save_errno;
                    /* path points to cache entries, so xstrdup before messing with it */
                    char *buf = xstrdup(path);
                    enum scld_error result = safe_create_leading_directories(buf);

                    save_errno = errno;
                    free(buf);
                    errno = save_errno;
                    return result;
            }

            int odb_mkstemp(struct strbuf *temp_filename, const char *pattern)
            {
                    int fd;
                    /*
                    * we let the umask do its job, don't try to be more
                    * restrictive except to remove write permission.
                    */
                    int mode = 0444;
                    git_path_buf(temp_filename, "objects/%s", pattern);
                    fd = git_mkstemp_mode(temp_filename->buf, mode);
                    if (0 <= fd)
                            return fd;

                    /* slow path */
                    /* some mkstemp implementations erase temp_filename on failure */
                    git_path_buf(temp_filename, "objects/%s", pattern);
                    safe_create_leading_directories(temp_filename->buf);
                    return xmkstemp_mode(temp_filename->buf, mode);
            }

            int odb_pack_keep(const char *name)
            {
                    int fd;

                    fd = open(name, O_RDWR|O_CREAT|O_EXCL, 0600);
                    if (0 <= fd)
                            return fd;

                    /* slow path */
                    safe_create_leading_directories_const(name);
                    return open(name, O_RDWR|O_CREAT|O_EXCL, 0600);
            }

            static void fill_loose_path(struct strbuf *buf, const struct object_id *oid)
            {
                    int i;
                    for (i = 0; i < the_hash_algo->rawsz; i++) {
                            static char hex[] = "0123456789abcdef";
                            unsigned int val = oid->hash[i];
                            strbuf_addch(buf, hex[val >> 4]);
                            strbuf_addch(buf, hex[val & 0xf]);
                            if (!i)
                                    strbuf_addch(buf, '/');
                    }
            }

            static const char *odb_loose_path(struct object_directory *odb,
                                            struct strbuf *buf,
                                            const struct object_id *oid)
            {
                    strbuf_reset(buf);
                    strbuf_addstr(buf, odb->path);
                    strbuf_addch(buf, '/');
                    fill_loose_path(buf, oid);
                    return buf->buf;
            }

            const char *loose_object_path(struct repository *r, struct strbuf *buf,
                                    const struct object_id *oid)
            {
                    return odb_loose_path(r->objects->odb, buf, oid);
            }

            /*
            * Return non-zero iff the path is usable as an alternate object database.
            */
            static int alt_odb_usable(struct raw_object_store *o,
                                    struct strbuf *path,
                                    const char *normalized_objdir, khiter_t *pos)
            {
                    int r;

                    /* Detect cases where alternate disappeared */
                    if (!is_directory(path->buf)) {
                            error(_("object directory %s does not exist; "
                                    "check .git/objects/info/alternates"),
                            path->buf);
                            return 0;
                    }

                    /*
                    * Prevent the common mistake of listing the same
                    * thing twice, or object directory itself.
                    */
                    if (!o->odb_by_path) {
                            khiter_t p;

                            o->odb_by_path = kh_init_odb_path_map();
                            assert(!o->odb->next);
                            p = kh_put_odb_path_map(o->odb_by_path, o->odb->path, &r);
                            assert(r == 1); /* never used */
                            kh_value(o->odb_by_path, p) = o->odb;
                    }
                    if (fspatheq(path->buf, normalized_objdir))
                            return 0;
                    *pos = kh_put_odb_path_map(o->odb_by_path, path->buf, &r);
                    /* r: 0 = exists, 1 = never used, 2 = deleted */
                    return r == 0 ? 0 : 1;
            }

            /*
            * Prepare alternate object database registry.
            *
            * The variable alt_odb_list points at the list of struct
            * object_directory.  The elements on this list come from
            * non-empty elements from colon separated ALTERNATE_DB_ENVIRONMENT
            * environment variable, and $GIT_OBJECT_DIRECTORY/info/alternates,
            * whose contents is similar to that environment variable but can be
            * LF separated.  Its base points at a statically allocated buffer that
            * contains "/the/directory/corresponding/to/.git/objects/...", while
            * its name points just after the slash at the end of ".git/objects/"
            * in the example above, and has enough space to hold all hex characters
            * of the object ID, an extra slash for the first level indirection, and
            * the terminating NUL.
            */
            static void read_info_alternates(struct repository *r,
                                            const char *relative_base,
                                            int depth);
            static int link_alt_odb_entry(struct repository *r, const struct strbuf *entry,
                    const char *relative_base, int depth, const char *normalized_objdir)
            {
                    struct object_directory *ent;
                    struct strbuf pathbuf = STRBUF_INIT;
                    struct strbuf tmp = STRBUF_INIT;
                    khiter_t pos;
                    int ret = -1;

                    if (!is_absolute_path(entry->buf) && relative_base) {
                            strbuf_realpath(&pathbuf, relative_base, 1);
                            strbuf_addch(&pathbuf, '/');
                    }
                    strbuf_addbuf(&pathbuf, entry);

                    if (!strbuf_realpath(&tmp, pathbuf.buf, 0)) {
                            error(_("unable to normalize alternate object path: %s"),
                            pathbuf.buf);
                            goto error;
                    }
                    strbuf_swap(&pathbuf, &tmp);

                    /*
                    * The trailing slash after the directory name is given by
                    * this function at the end. Remove duplicates.
                    */
                    while (pathbuf.len && pathbuf.buf[pathbuf.len - 1] == '/')
                            strbuf_setlen(&pathbuf, pathbuf.len - 1);

                    if (!alt_odb_usable(r->objects, &pathbuf, normalized_objdir, &pos))
                            goto error;

                    CALLOC_ARRAY(ent, 1);
                    /* pathbuf.buf is already in r->objects->odb_by_path */
                    ent->path = strbuf_detach(&pathbuf, NULL);

                    /* add the alternate entry */
                    *r->objects->odb_tail = ent;
                    r->objects->odb_tail = &(ent->next);
                    ent->next = NULL;
                    assert(r->objects->odb_by_path);
                    kh_value(r->objects->odb_by_path, pos) = ent;

                    /* recursively add alternates */
                    read_info_alternates(r, ent->path, depth + 1);
                    ret = 0;
            error:
                    strbuf_release(&tmp);
                    strbuf_release(&pathbuf);
                    return ret;
            }

            static const char *parse_alt_odb_entry(const char *string,
                                            int sep,
                                            struct strbuf *out)
            {
                    const char *end;

                    strbuf_reset(out);

                    if (*string == '#') {
                            /* comment; consume up to next separator */
                            end = strchrnul(string, sep);
                    } else if (*string == '"' && !unquote_c_style(out, string, &end)) {
                            /*
                            * quoted path; unquote_c_style has copied the
                            * data for us and set "end". Broken quoting (e.g.,
                            * an entry that doesn't end with a quote) falls
                            * back to the unquoted case below.
                            */
                    } else {
                            /* normal, unquoted path */
                            end = strchrnul(string, sep);
                            strbuf_add(out, string, end - string);
                    }

                    if (*end)
                            end++;
                    return end;
            }

            static void link_alt_odb_entries(struct repository *r, const char *alt,
                                            int sep, const char *relative_base, int depth)
            {
                    struct strbuf objdirbuf = STRBUF_INIT;
                    struct strbuf entry = STRBUF_INIT;

                    if (!alt || !*alt)
                            return;

                    if (depth > 5) {
                            error(_("%s: ignoring alternate object stores, nesting too deep"),
                                            relative_base);
                            return;
                    }

                    strbuf_realpath(&objdirbuf, r->objects->odb->path, 1);

                    while (*alt) {
                            alt = parse_alt_odb_entry(alt, sep, &entry);
                            if (!entry.len)
                                    continue;
                            link_alt_odb_entry(r, &entry,
                                            relative_base, depth, objdirbuf.buf);
                    }
                    strbuf_release(&entry);
                    strbuf_release(&objdirbuf);
            }

            static void read_info_alternates(struct repository *r,
                                            const char *relative_base,
                                            int depth)
            {
                    char *path;
                    struct strbuf buf = STRBUF_INIT;

                    path = xstrfmt("%s/info/alternates", relative_base);
                    if (strbuf_read_file(&buf, path, 1024) < 0) {
                            warn_on_fopen_errors(path);
                            free(path);
                            return;
                    }

                    link_alt_odb_entries(r, buf.buf, '\n', relative_base, depth);
                    strbuf_release(&buf);
                    free(path);
            }

            void add_to_alternates_file(const char *reference)
            {
                    struct lock_file lock = LOCK_INIT;
                    char *alts = git_pathdup("objects/info/alternates");
                    FILE *in, *out;
                    int found = 0;

                    hold_lock_file_for_update(&lock, alts, LOCK_DIE_ON_ERROR);
                    out = fdopen_lock_file(&lock, "w");
                    if (!out)
                            die_errno(_("unable to fdopen alternates lockfile"));

                    in = fopen(alts, "r");
                    if (in) {
                            struct strbuf line = STRBUF_INIT;

                            while (strbuf_getline(&line, in) != EOF) {
                                    if (!strcmp(reference, line.buf)) {
                                            found = 1;
                                            break;
                                    }
                                    fprintf_or_die(out, "%s\n", line.buf);
                            }

                            strbuf_release(&line);
                            fclose(in);
                    }
                    else if (errno != ENOENT)
                            die_errno(_("unable to read alternates file"));

                    if (found) {
                            rollback_lock_file(&lock);
                    } else {
                            fprintf_or_die(out, "%s\n", reference);
                            if (commit_lock_file(&lock))
                                    die_errno(_("unable to move new alternates file into place"));
                            if (the_repository->objects->loaded_alternates)
                                    link_alt_odb_entries(the_repository, reference,
                                                    '\n', NULL, 0);
                    }
                    free(alts);
            }

            void add_to_alternates_memory(const char *reference)
            {
                    /*
                    * Make sure alternates are initialized, or else our entry may be
                    * overwritten when they are.
                    */
                    prepare_alt_odb(the_repository);

                    link_alt_odb_entries(the_repository, reference,
                                    '\n', NULL, 0);
            }

            struct object_directory *set_temporary_primary_odb(const char *dir, int will_destroy)
            {
                    struct object_directory *new_odb;

                    /*
                    * Make sure alternates are initialized, or else our entry may be
                    * overwritten when they are.
                    */
                    prepare_alt_odb(the_repository);

                    /*
                    * Make a new primary odb and link the old primary ODB in as an
                    * alternate
                    */
                    new_odb = xcalloc(1, sizeof(*new_odb));
                    new_odb->path = xstrdup(dir);

                    /*
                    * Disable ref updates while a temporary odb is active, since
                    * the objects in the database may roll back.
                    */
                    new_odb->disable_ref_updates = 1;
                    new_odb->will_destroy = will_destroy;
                    new_odb->next = the_repository->objects->odb;
                    the_repository->objects->odb = new_odb;
                    return new_odb->next;
            }

            void restore_primary_odb(struct object_directory *restore_odb, const char *old_path)
            {
                    struct object_directory *cur_odb = the_repository->objects->odb;

                    if (strcmp(old_path, cur_odb->path))
                            BUG("expected %s as primary object store; found %s",
                            old_path, cur_odb->path);

                    if (cur_odb->next != restore_odb)
                            BUG("we expect the old primary object store to be the first alternate");

                    the_repository->objects->odb = restore_odb;
                    free_object_directory(cur_odb);
            }

            /*
            * Compute the exact path an alternate is at and returns it. In case of
            * error NULL is returned and the human readable error is added to `err`
            * `path` may be relative and should point to $GIT_DIR.
            * `err` must not be null.
            */
            char *compute_alternate_path(const char *path, struct strbuf *err)
            {
                    char *ref_git = NULL;
                    const char *repo;
                    int seen_error = 0;

                    ref_git = real_pathdup(path, 0);
                    if (!ref_git) {
                            seen_error = 1;
                            strbuf_addf(err, _("path '%s' does not exist"), path);
                            goto out;
                    }

                    repo = read_gitfile(ref_git);
                    if (!repo)
                            repo = read_gitfile(mkpath("%s/.git", ref_git));
                    if (repo) {
                            free(ref_git);
                            ref_git = xstrdup(repo);
                    }

                    if (!repo && is_directory(mkpath("%s/.git/objects", ref_git))) {
                            char *ref_git_git = mkpathdup("%s/.git", ref_git);
                            free(ref_git);
                            ref_git = ref_git_git;
                    } else if (!is_directory(mkpath("%s/objects", ref_git))) {
                            struct strbuf sb = STRBUF_INIT;
                            seen_error = 1;
                            if (get_common_dir(&sb, ref_git)) {
                                    strbuf_addf(err,
                                            _("reference repository '%s' as a linked "
                                            "checkout is not supported yet."),
                                            path);
                                    goto out;
                            }

                            strbuf_addf(err, _("reference repository '%s' is not a "
                                                    "local repository."), path);
                            goto out;
                    }

                    if (!access(mkpath("%s/shallow", ref_git), F_OK)) {
                            strbuf_addf(err, _("reference repository '%s' is shallow"),
                                    path);
                            seen_error = 1;
                            goto out;
                    }

                    if (!access(mkpath("%s/info/grafts", ref_git), F_OK)) {
                            strbuf_addf(err,
                                    _("reference repository '%s' is grafted"),
                                    path);
                            seen_error = 1;
                            goto out;
                    }

            out:
                    if (seen_error) {
                            FREE_AND_NULL(ref_git);
                    }

                    return ref_git;
            }

            struct object_directory *find_odb(struct repository *r, const char *obj_dir)
            {
                    struct object_directory *odb;
                    char *obj_dir_real = real_pathdup(obj_dir, 1);
                    struct strbuf odb_path_real = STRBUF_INIT;

                    prepare_alt_odb(r);
                    for (odb = r->objects->odb; odb; odb = odb->next) {
                            strbuf_realpath(&odb_path_real, odb->path, 1);
                            if (!strcmp(obj_dir_real, odb_path_real.buf))
                                    break;
                    }

                    free(obj_dir_real);
                    strbuf_release(&odb_path_real);

                    if (!odb)
                            die(_("could not find object directory matching %s"), obj_dir);
                    return odb;
            }

            static void fill_alternate_refs_command(struct child_process *cmd,
                                                    const char *repo_path)
            {
                    const char *value;

                    if (!git_config_get_value("core.alternateRefsCommand", &value)) {
                            cmd->use_shell = 1;

                            strvec_push(&cmd->args, value);
                            strvec_push(&cmd->args, repo_path);
                    } else {
                            cmd->git_cmd = 1;

                            strvec_pushf(&cmd->args, "--git-dir=%s", repo_path);
                            strvec_push(&cmd->args, "for-each-ref");
                            strvec_push(&cmd->args, "--format=%(objectname)");

                            if (!git_config_get_value("core.alternateRefsPrefixes", &value)) {
                                    strvec_push(&cmd->args, "--");
                                    strvec_split(&cmd->args, value);
                            }
                    }

                    strvec_pushv(&cmd->env, (const char **)local_repo_env);
                    cmd->out = -1;
            }

            static void read_alternate_refs(const char *path,
                                            alternate_ref_fn *cb,
                                            void *data)
            {
                    struct child_process cmd = CHILD_PROCESS_INIT;
                    struct strbuf line = STRBUF_INIT;
                    FILE *fh;

                    fill_alternate_refs_command(&cmd, path);

                    if (start_command(&cmd))
                            return;

                    fh = xfdopen(cmd.out, "r");
                    while (strbuf_getline_lf(&line, fh) != EOF) {
                            struct object_id oid;
                            const char *p;

                            if (parse_oid_hex(line.buf, &oid, &p) || *p) {
                                    warning(_("invalid line while parsing alternate refs: %s"),
                                            line.buf);
                                    break;
                            }

                            cb(&oid, data);
                    }

                    fclose(fh);
                    finish_command(&cmd);
                    strbuf_release(&line);
            }

            struct alternate_refs_data {
                    alternate_ref_fn *fn;
                    void *data;
            };

            static int refs_from_alternate_cb(struct object_directory *e,
                                            void *data)
            {
                    struct strbuf path = STRBUF_INIT;
                    size_t base_len;
                    struct alternate_refs_data *cb = data;

                    if (!strbuf_realpath(&path, e->path, 0))
                            goto out;
                    if (!strbuf_strip_suffix(&path, "/objects"))
                            goto out;
                    base_len = path.len;

                    /* Is this a git repository with refs? */
                    strbuf_addstr(&path, "/refs");
                    if (!is_directory(path.buf))
                            goto out;
                    strbuf_setlen(&path, base_len);

                    read_alternate_refs(path.buf, cb->fn, cb->data);

            out:
                    strbuf_release(&path);
                    return 0;
            }

            void for_each_alternate_ref(alternate_ref_fn fn, void *data)
            {
                    struct alternate_refs_data cb;
                    cb.fn = fn;
                    cb.data = data;
                    foreach_alt_odb(refs_from_alternate_cb, &cb);
            }

            int foreach_alt_odb(alt_odb_fn fn, void *cb)
            {
                    struct object_directory *ent;
                    int r = 0;

                    prepare_alt_odb(the_repository);
                    for (ent = the_repository->objects->odb->next; ent; ent = ent->next) {
                            r = fn(ent, cb);
                            if (r)
                                    break;
                    }
                    return r;
            }

            void prepare_alt_odb(struct repository *r)
            {
                    if (r->objects->loaded_alternates)
                            return;

                    link_alt_odb_entries(r, r->objects->alternate_db, PATH_SEP, NULL, 0);

                    read_info_alternates(r, r->objects->odb->path, 0);
                    r->objects->loaded_alternates = 1;
            }

            int has_alt_odb(struct repository *r)
            {
                    prepare_alt_odb(r);
                    return !!r->objects->odb->next;
            }

            /* Returns 1 if we have successfully freshened the file, 0 otherwise. */
            static int freshen_file(const char *fn)
            {
                    return !utime(fn, NULL);
            }

            /*
            * All of the check_and_freshen functions return 1 if the file exists and was
            * freshened (if freshening was requested), 0 otherwise. If they return
            * 0, you should not assume that it is safe to skip a write of the object (it
            * either does not exist on disk, or has a stale mtime and may be subject to
            * pruning).
            */
            int check_and_freshen_file(const char *fn, int freshen)
            {
                    if (access(fn, F_OK))
                            return 0;
                    if (freshen && !freshen_file(fn))
                            return 0;
                    return 1;
            }

            static int check_and_freshen_odb(struct object_directory *odb,
                                            const struct object_id *oid,
                                            int freshen)
            {
                    static struct strbuf path = STRBUF_INIT;
                    odb_loose_path(odb, &path, oid);
                    return check_and_freshen_file(path.buf, freshen);
            }

            static int check_and_freshen_local(const struct object_id *oid, int freshen)
            {
                    return check_and_freshen_odb(the_repository->objects->odb, oid, freshen);
            }

            static int check_and_freshen_nonlocal(const struct object_id *oid, int freshen)
            {
                    struct object_directory *odb;

                    prepare_alt_odb(the_repository);
                    for (odb = the_repository->objects->odb->next; odb; odb = odb->next) {
                            if (check_and_freshen_odb(odb, oid, freshen))
                                    return 1;
                    }
                    return 0;
            }

            static int check_and_freshen(const struct object_id *oid, int freshen)
            {
                    return check_and_freshen_local(oid, freshen) ||
                    check_and_freshen_nonlocal(oid, freshen);
            }

            int has_loose_object_nonlocal(const struct object_id *oid)
            {
                    return check_and_freshen_nonlocal(oid, 0);
            }

            int has_loose_object(const struct object_id *oid)
            {
                    return check_and_freshen(oid, 0);
            }

            static void mmap_limit_check(size_t length)
            {
                    static size_t limit = 0;
                    if (!limit) {
                            limit = git_env_ulong("GIT_MMAP_LIMIT", 0);
                            if (!limit)
                                    limit = SIZE_MAX;
                    }
                    if (length > limit)
                            die(_("attempting to mmap %"PRIuMAX" over limit %"PRIuMAX),
                            (uintmax_t)length, (uintmax_t)limit);
            }

            void *xmmap_gently(void *start, size_t length,
                            int prot, int flags, int fd, off_t offset)
            {
                    void *ret;

                    mmap_limit_check(length);
                    ret = mmap(start, length, prot, flags, fd, offset);
                    if (ret == MAP_FAILED && !length)
                            ret = NULL;
                    return ret;
            }

            const char *mmap_os_err(void)
            {
                    static const char blank[] = "";
            #if defined(__linux__)
                    if (errno == ENOMEM) {
                            /* this continues an existing error message: */
                            static const char enomem[] =
            ", check sys.vm.max_map_count and/or RLIMIT_DATA";
                            return enomem;
                    }
            #endif /* OS-specific bits */
                    return blank;
            }

            void *xmmap(void *start, size_t length,
                    int prot, int flags, int fd, off_t offset)
            {
                    void *ret = xmmap_gently(start, length, prot, flags, fd, offset);
                    if (ret == MAP_FAILED)
                            die_errno(_("mmap failed%s"), mmap_os_err());
                    return ret;
            }

            static int format_object_header_literally(char *str, size_t size,
                                                    const char *type, size_t objsize)
            {
                    return xsnprintf(str, size, "%s %"PRIuMAX, type, (uintmax_t)objsize) + 1;
            }

            int format_object_header(char *str, size_t size, enum object_type type,
                                    size_t objsize)
            {
                    const char *name = type_name(type);

                    if (!name)
                            BUG("could not get a type name for 'enum object_type' value %d", type);

                    return format_object_header_literally(str, size, name, objsize);
            }

            int check_object_signature(struct repository *r, const struct object_id *oid,
                                    void *buf, unsigned long size,
                                    enum object_type type)
            {
                    const struct git_hash_algo *algo =
                            oid->algo ? &hash_algos[oid->algo] : r->hash_algo;
                    struct object_id real_oid;

                    hash_object_file(algo, buf, size, type, &real_oid);

                    return !oideq(oid, &real_oid) ? -1 : 0;
            }

            int stream_object_signature(struct repository *r, const struct object_id *oid)
            {
                    struct object_id real_oid;
                    unsigned long size;
                    enum object_type obj_type;
                    struct git_istream *st;
                    git_hash_ctx c;
                    char hdr[MAX_HEADER_LEN];
                    int hdrlen;

                    st = open_istream(r, oid, &obj_type, &size, NULL);
                    if (!st)
                            return -1;

                    /* Generate the header */
                    hdrlen = format_object_header(hdr, sizeof(hdr), obj_type, size);

                    /* Sha1.. */
                    r->hash_algo->init_fn(&c);
                    r->hash_algo->update_fn(&c, hdr, hdrlen);
                    for (;;) {
                            char buf[1024 * 16];
                            ssize_t readlen = read_istream(st, buf, sizeof(buf));

                            if (readlen < 0) {
                                    close_istream(st);
                                    return -1;
                            }
                            if (!readlen)
                                    break;
                            r->hash_algo->update_fn(&c, buf, readlen);
                    }
                    r->hash_algo->final_oid_fn(&real_oid, &c);
                    close_istream(st);
                    return !oideq(oid, &real_oid) ? -1 : 0;
            }

            int git_open_cloexec(const char *name, int flags)
            {
                    int fd;
                    static int o_cloexec = O_CLOEXEC;

                    fd = open(name, flags | o_cloexec);
                    if ((o_cloexec & O_CLOEXEC) && fd < 0 && errno == EINVAL) {
                            /* Try again w/o O_CLOEXEC: the kernel might not support it */
                            o_cloexec &= ~O_CLOEXEC;
                            fd = open(name, flags | o_cloexec);
                    }

            #if defined(F_GETFD) && defined(F_SETFD) && defined(FD_CLOEXEC)
                    {
                            static int fd_cloexec = FD_CLOEXEC;

                            if (!o_cloexec && 0 <= fd && fd_cloexec) {
                                    /* Opened w/o O_CLOEXEC?  try with fcntl(2) to add it */
                                    int flags = fcntl(fd, F_GETFD);
                                    if (fcntl(fd, F_SETFD, flags | fd_cloexec))
                                            fd_cloexec = 0;
                            }
                    }
            #endif
                    return fd;
            }

            /*
            * Find "oid" as a loose object in the local repository or in an alternate.
            * Returns 0 on success, negative on failure.
            *
            * The "path" out-parameter will give the path of the object we found (if any).
            * Note that it may point to static storage and is only valid until another
            * call to stat_loose_object().
            */
            static int stat_loose_object(struct repository *r, const struct object_id *oid,
                                    struct stat *st, const char **path)
            {
                    struct object_directory *odb;
                    static struct strbuf buf = STRBUF_INIT;

                    prepare_alt_odb(r);
                    for (odb = r->objects->odb; odb; odb = odb->next) {
                            *path = odb_loose_path(odb, &buf, oid);
                            if (!lstat(*path, st))
                                    return 0;
                    }

                    return -1;
            }

            /*
            * Like stat_loose_object(), but actually open the object and return the
            * descriptor. See the caveats on the "path" parameter above.
            */
            static int open_loose_object(struct repository *r,
                                    const struct object_id *oid, const char **path)
            {
                    int fd;
                    struct object_directory *odb;
                    int most_interesting_errno = ENOENT;
                    static struct strbuf buf = STRBUF_INIT;

                    prepare_alt_odb(r);
                    for (odb = r->objects->odb; odb; odb = odb->next) {
                            *path = odb_loose_path(odb, &buf, oid);
                            fd = git_open(*path);
                            if (fd >= 0)
                                    return fd;

                            if (most_interesting_errno == ENOENT)
                                    most_interesting_errno = errno;
                    }
                    errno = most_interesting_errno;
                    return -1;
            }

            static int quick_has_loose(struct repository *r,
                                    const struct object_id *oid)
            {
                    struct object_directory *odb;

                    prepare_alt_odb(r);
                    for (odb = r->objects->odb; odb; odb = odb->next) {
                            if (oidtree_contains(odb_loose_cache(odb, oid), oid))
                                    return 1;
                    }
                    return 0;
            }

            /*
            * Map and close the given loose object fd. The path argument is used for
            * error reporting.
            */
            static void *map_fd(int fd, const char *path, unsigned long *size)
            {
                    void *map = NULL;
                    struct stat st;

                    if (!fstat(fd, &st)) {
                            *size = xsize_t(st.st_size);
                            if (!*size) {
                                    /* mmap() is forbidden on empty files */
                                    error(_("object file %s is empty"), path);
                                    close(fd);
                                    return NULL;
                            }
                            map = xmmap(NULL, *size, PROT_READ, MAP_PRIVATE, fd, 0);
                    }
                    close(fd);
                    return map;
            }

            void *map_loose_object(struct repository *r,
                            const struct object_id *oid,
                            unsigned long *size)
            {
                    const char *p;
                    int fd = open_loose_object(r, oid, &p);

                    if (fd < 0)
                            return NULL;
                    return map_fd(fd, p, size);
            }

            enum unpack_loose_header_result unpack_loose_header(git_zstream *stream,
                                                            unsigned char *map,
                                                            unsigned long mapsize,
                                                            void *buffer,
                                                            unsigned long bufsiz,
                                                            struct strbuf *header)
            {
                    int status;

                    /* Get the data stream */
                    memset(stream, 0, sizeof(*stream));
                    stream->next_in = map;
                    stream->avail_in = mapsize;
                    stream->next_out = buffer;
                    stream->avail_out = bufsiz;

                    git_inflate_init(stream);
                    obj_read_unlock();
                    status = git_inflate(stream, 0);
                    obj_read_lock();
                    if (status < Z_OK)
                            return ULHR_BAD;

                    /*
                    * Check if entire header is unpacked in the first iteration.
                    */
                    if (memchr(buffer, '\0', stream->next_out - (unsigned char *)buffer))
                            return ULHR_OK;

                    /*
                    * We have a header longer than MAX_HEADER_LEN. The "header"
                    * here is only non-NULL when we run "cat-file
                    * --allow-unknown-type".
                    */
                    if (!header)
                            return ULHR_TOO_LONG;

                    /*
                    * buffer[0..bufsiz] was not large enough.  Copy the partial
                    * result out to header, and then append the result of further
                    * reading the stream.
                    */
                    strbuf_add(header, buffer, stream->next_out - (unsigned char *)buffer);
                    stream->next_out = buffer;
                    stream->avail_out = bufsiz;

                    do {
                            obj_read_unlock();
                            status = git_inflate(stream, 0);
                            obj_read_lock();
                            strbuf_add(header, buffer, stream->next_out - (unsigned char *)buffer);
                            if (memchr(buffer, '\0', stream->next_out - (unsigned char *)buffer))
                                    return 0;
                            stream->next_out = buffer;
                            stream->avail_out = bufsiz;
                    } while (status != Z_STREAM_END);
                    return ULHR_TOO_LONG;
            }

            static void *unpack_loose_rest(git_zstream *stream,
                                    void *buffer, unsigned long size,
                                    const struct object_id *oid)
            {
                    int bytes = strlen(buffer) + 1;
                    unsigned char *buf = xmallocz(size);
                    unsigned long n;
                    int status = Z_OK;

                    n = stream->total_out - bytes;
                    if (n > size)
                            n = size;
                    memcpy(buf, (char *) buffer + bytes, n);
                    bytes = n;
                    if (bytes <= size) {
                            /*
                            * The above condition must be (bytes <= size), not
                            * (bytes < size).  In other words, even though we
                            * expect no more output and set avail_out to zero,
                            * the input zlib stream may have bytes that express
                            * "this concludes the stream", and we *do* want to
                            * eat that input.
                            *
                            * Otherwise we would not be able to test that we
                            * consumed all the input to reach the expected size;
                            * we also want to check that zlib tells us that all
                            * went well with status == Z_STREAM_END at the end.
                            */
                            stream->next_out = buf + bytes;
                            stream->avail_out = size - bytes;
                            while (status == Z_OK) {
                                    obj_read_unlock();
                                    status = git_inflate(stream, Z_FINISH);
                                    obj_read_lock();
                            }
                    }
                    if (status == Z_STREAM_END && !stream->avail_in) {
                            git_inflate_end(stream);
                            return buf;
                    }

                    if (status < 0)
                            error(_("corrupt loose object '%s'"), oid_to_hex(oid));
                    else if (stream->avail_in)
                            error(_("garbage at end of loose object '%s'"),
                            oid_to_hex(oid));
                    free(buf);
                    return NULL;
            }

            /*
            * We used to just use "sscanf()", but that's actually way
            * too permissive for what we want to check. So do an anal
            * object header parse by hand.
            */
            int parse_loose_header(const char *hdr, struct object_info *oi)
            {
                    const char *type_buf = hdr;
                    size_t size;
                    int type, type_len = 0;

                    /*
                    * The type can be of any size but is followed by
                    * a space.
                    */
                    for (;;) {
                            char c = *hdr++;
                            if (!c)
                                    return -1;
                            if (c == ' ')
                                    break;
                            type_len++;
                    }

                    type = type_from_string_gently(type_buf, type_len, 1);
                    if (oi->type_name)
                            strbuf_add(oi->type_name, type_buf, type_len);
                    if (oi->typep)
                            *oi->typep = type;

                    /*
                    * The length must follow immediately, and be in canonical
                    * decimal format (ie "010" is not valid).
                    */
                    size = *hdr++ - '0';
                    if (size > 9)
                            return -1;
                    if (size) {
                            for (;;) {
                                    unsigned long c = *hdr - '0';
                                    if (c > 9)
                                            break;
                                    hdr++;
                                    size = st_add(st_mult(size, 10), c);
                            }
                    }

                    if (oi->sizep)
                            *oi->sizep = cast_size_t_to_ulong(size);

                    /*
                    * The length must be followed by a zero byte
                    */
                    if (*hdr)
                            return -1;

                    /*
                    * The format is valid, but the type may still be bogus. The
                    * Caller needs to check its oi->typep.
                    */
                    return 0;
            }

            static int loose_object_info(struct repository *r,
                                    const struct object_id *oid,
                                    struct object_info *oi, int flags)
            {
                    int status = 0;
                    int fd;
                    unsigned long mapsize;
                    const char *path;
                    void *map;
                    git_zstream stream;
                    char hdr[MAX_HEADER_LEN];
                    struct strbuf hdrbuf = STRBUF_INIT;
                    unsigned long size_scratch;
                    enum object_type type_scratch;
                    int allow_unknown = flags & OBJECT_INFO_ALLOW_UNKNOWN_TYPE;

                    if (oi->delta_base_oid)
                            oidclr(oi->delta_base_oid, the_repository->hash_algo);

                    /*
                    * If we don't care about type or size, then we don't
                    * need to look inside the object at all. Note that we
                    * do not optimize out the stat call, even if the
                    * caller doesn't care about the disk-size, since our
                    * return value implicitly indicates whether the
                    * object even exists.
                    */
                    if (!oi->typep && !oi->type_name && !oi->sizep && !oi->contentp) {
                            struct stat st;
                            if (!oi->disk_sizep && (flags & OBJECT_INFO_QUICK))
                                    return quick_has_loose(r, oid) ? 0 : -1;
                            if (stat_loose_object(r, oid, &st, &path) < 0)
                                    return -1;
                            if (oi->disk_sizep)
                                    *oi->disk_sizep = st.st_size;
                            return 0;
                    }

                    fd = open_loose_object(r, oid, &path);
                    if (fd < 0) {
                            if (errno != ENOENT)
                                    error_errno(_("unable to open loose object %s"), oid_to_hex(oid));
                            return -1;
                    }
                    map = map_fd(fd, path, &mapsize);
                    if (!map)
                            return -1;

                    if (!oi->sizep)
                            oi->sizep = &size_scratch;
                    if (!oi->typep)
                            oi->typep = &type_scratch;

                    if (oi->disk_sizep)
                            *oi->disk_sizep = mapsize;

                    switch (unpack_loose_header(&stream, map, mapsize, hdr, sizeof(hdr),
                                            allow_unknown ? &hdrbuf : NULL)) {
                    case ULHR_OK:
                            if (parse_loose_header(hdrbuf.len ? hdrbuf.buf : hdr, oi) < 0)
                                    status = error(_("unable to parse %s header"), oid_to_hex(oid));
                            else if (!allow_unknown && *oi->typep < 0)
                                    die(_("invalid object type"));

                            if (!oi->contentp)
                                    break;
                            *oi->contentp = unpack_loose_rest(&stream, hdr, *oi->sizep, oid);
                            if (*oi->contentp)
                                    goto cleanup;

                            status = -1;
                            break;
                    case ULHR_BAD:
                            status = error(_("unable to unpack %s header"),
                                    oid_to_hex(oid));
                            break;
                    case ULHR_TOO_LONG:
                            status = error(_("header for %s too long, exceeds %d bytes"),
                                    oid_to_hex(oid), MAX_HEADER_LEN);
                            break;
                    }

                    if (status && (flags & OBJECT_INFO_DIE_IF_CORRUPT))
                            die(_("loose object %s (stored in %s) is corrupt"),
                            oid_to_hex(oid), path);

                    git_inflate_end(&stream);
            cleanup:
                    munmap(map, mapsize);
                    if (oi->sizep == &size_scratch)
                            oi->sizep = NULL;
                    strbuf_release(&hdrbuf);
                    if (oi->typep == &type_scratch)
                            oi->typep = NULL;
                    oi->whence = OI_LOOSE;
                    return status;
            }

            int obj_read_use_lock = 0;
            pthread_mutex_t obj_read_mutex;

            void enable_obj_read_lock(void)
            {
                    if (obj_read_use_lock)
                            return;

                    obj_read_use_lock = 1;
                    init_recursive_mutex(&obj_read_mutex);
            }

            void disable_obj_read_lock(void)
            {
                    if (!obj_read_use_lock)
                            return;

                    obj_read_use_lock = 0;
                    pthread_mutex_destroy(&obj_read_mutex);
            }

            int fetch_if_missing = 1;

            static int do_oid_object_info_extended(struct repository *r,
                                            const struct object_id *oid,
                                            struct object_info *oi, unsigned flags)
            {
                    static struct object_info blank_oi = OBJECT_INFO_INIT;
                    const struct cached_object *co;
                    struct pack_entry e;
                    int rtype;
                    const struct object_id *real = oid;
                    int already_retried = 0;


                    if (flags & OBJECT_INFO_LOOKUP_REPLACE)
                            real = lookup_replace_object(r, oid);

                    if (is_null_oid(real))
                            return -1;

                    if (!oi)
                            oi = &blank_oi;

                    co = find_cached_object(real);
                    if (co) {
                            if (oi->typep)
                                    *(oi->typep) = co->type;
                            if (oi->sizep)
                                    *(oi->sizep) = co->size;
                            if (oi->disk_sizep)
                                    *(oi->disk_sizep) = 0;
                            if (oi->delta_base_oid)
                                    oidclr(oi->delta_base_oid, the_repository->hash_algo);
                            if (oi->type_name)
                                    strbuf_addstr(oi->type_name, type_name(co->type));
                            if (oi->contentp)
                                    *oi->contentp = xmemdupz(co->buf, co->size);
                            oi->whence = OI_CACHED;
                            return 0;
                    }

                    while (1) {
                            if (find_pack_entry(r, real, &e))
                                    break;

                            /* Most likely it's a loose object. */
                            if (!loose_object_info(r, real, oi, flags))
                                    return 0;

                            /* Not a loose object; someone else may have just packed it. */
                            if (!(flags & OBJECT_INFO_QUICK)) {
                                    reprepare_packed_git(r);
                                    if (find_pack_entry(r, real, &e))
                                            break;
                            }

                            /*
                            * If r is the_repository, this might be an attempt at
                            * accessing a submodule object as if it were in the_repository
                            * (having called add_submodule_odb() on that submodule's ODB).
                            * If any such ODBs exist, register them and try again.
                            */
                            if (r == the_repository &&
                            register_all_submodule_odb_as_alternates())
                                    /* We added some alternates; retry */
                                    continue;

                            /* Check if it is a missing object */
                            if (fetch_if_missing && repo_has_promisor_remote(r) &&
                            !already_retried &&
                            !(flags & OBJECT_INFO_SKIP_FETCH_OBJECT)) {
                                    promisor_remote_get_direct(r, real, 1);
                                    already_retried = 1;
                                    continue;
                            }

                            if (flags & OBJECT_INFO_DIE_IF_CORRUPT) {
                                    const struct packed_git *p;
                                    if ((flags & OBJECT_INFO_LOOKUP_REPLACE) && !oideq(real, oid))
                                            die(_("replacement %s not found for %s"),
                                            oid_to_hex(real), oid_to_hex(oid));
                                    if ((p = has_packed_and_bad(r, real)))
                                            die(_("packed object %s (stored in %s) is corrupt"),
                                            oid_to_hex(real), p->pack_name);
                            }
                            return -1;
                    }

                    if (oi == &blank_oi)
                            /*
                            * We know that the caller doesn't actually need the
                            * information below, so return early.
                            */
                            return 0;
                    rtype = packed_object_info(r, e.p, e.offset, oi);
                    if (rtype < 0) {
                            mark_bad_packed_object(e.p, real);
                            return do_oid_object_info_extended(r, real, oi, 0);
                    } else if (oi->whence == OI_PACKED) {
                            oi->u.packed.offset = e.offset;
                            oi->u.packed.pack = e.p;
                            oi->u.packed.is_delta = (rtype == OBJ_REF_DELTA ||
                                                    rtype == OBJ_OFS_DELTA);
                    }

                    return 0;
            }

            static int oid_object_info_convert(struct repository *r,
                                            const struct object_id *input_oid,
                                            struct object_info *input_oi, unsigned flags)
            {
                    const struct git_hash_algo *input_algo = &hash_algos[input_oid->algo];
                    int do_die = flags & OBJECT_INFO_DIE_IF_CORRUPT;
                    struct strbuf type_name = STRBUF_INIT;
                    struct object_id oid, delta_base_oid;
                    struct object_info new_oi, *oi;
                    unsigned long size;
                    void *content;
                    int ret;

                    if (repo_oid_to_algop(r, input_oid, the_hash_algo, &oid)) {
                            if (do_die)
                                    die(_("missing mapping of %s to %s"),
                                    oid_to_hex(input_oid), the_hash_algo->name);
                            return -1;
                    }

                    /* Is new_oi needed? */
                    oi = input_oi;
                    if (input_oi && (input_oi->delta_base_oid || input_oi->sizep ||
                                    input_oi->contentp)) {
                            new_oi = *input_oi;
                            /* Does delta_base_oid need to be converted? */
                            if (input_oi->delta_base_oid)
                                    new_oi.delta_base_oid = &delta_base_oid;
                            /* Will the attributes differ when converted? */
                            if (input_oi->sizep || input_oi->contentp) {
                                    new_oi.contentp = &content;
                                    new_oi.sizep = &size;
                                    new_oi.type_name = &type_name;
                            }
                            oi = &new_oi;
                    }

                    ret = oid_object_info_extended(r, &oid, oi, flags);
                    if (ret)
                            return -1;
                    if (oi == input_oi)
                            return ret;

                    if (new_oi.contentp) {
                            struct strbuf outbuf = STRBUF_INIT;
                            enum object_type type;

                            type = type_from_string_gently(type_name.buf, type_name.len,
                                                    !do_die);
                            if (type == -1)
                                    return -1;
                            if (type != OBJ_BLOB) {
                                    ret = convert_object_file(&outbuf,
                                                            the_hash_algo, input_algo,
                                                            content, size, type, !do_die);
                                    free(content);
                                    if (ret == -1)
                                            return -1;
                                    size = outbuf.len;
                                    content = strbuf_detach(&outbuf, NULL);
                            }
                            if (input_oi->sizep)
                                    *input_oi->sizep = size;
                            if (input_oi->contentp)
                                    *input_oi->contentp = content;
                            else
                                    free(content);
                            if (input_oi->type_name)
                                    *input_oi->type_name = type_name;
                            else
                                    strbuf_release(&type_name);
                    }
                    if (new_oi.delta_base_oid == &delta_base_oid) {
                            if (repo_oid_to_algop(r, &delta_base_oid, input_algo,
                                            input_oi->delta_base_oid)) {
                                    if (do_die)
                                            die(_("missing mapping of %s to %s"),
                                            oid_to_hex(&delta_base_oid),
                                            input_algo->name);
                                    return -1;
                            }
                    }
                    input_oi->whence = new_oi.whence;
                    input_oi->u = new_oi.u;
                    return ret;
            }

            int oid_object_info_extended(struct repository *r, const struct object_id *oid,
                                    struct object_info *oi, unsigned flags)
            {
                    int ret;

                    if (oid->algo && (hash_algo_by_ptr(r->hash_algo) != oid->algo))
                            return oid_object_info_convert(r, oid, oi, flags);

                    obj_read_lock();
                    ret = do_oid_object_info_extended(r, oid, oi, flags);
                    obj_read_unlock();
                    return ret;
            }


            /* returns enum object_type or negative */
            int oid_object_info(struct repository *r,
                            const struct object_id *oid,
                            unsigned long *sizep)
            {
                    enum object_type type;
                    struct object_info oi = OBJECT_INFO_INIT;

                    oi.typep = &type;
                    oi.sizep = sizep;
                    if (oid_object_info_extended(r, oid, &oi,
                                            OBJECT_INFO_LOOKUP_REPLACE) < 0)
                            return -1;
                    return type;
            }

            int pretend_object_file(void *buf, unsigned long len, enum object_type type,
                                    struct object_id *oid)
            {
                    struct cached_object_entry *co;
                    char *co_buf;

                    hash_object_file(the_hash_algo, buf, len, type, oid);
                    if (repo_has_object_file_with_flags(the_repository, oid, OBJECT_INFO_QUICK | OBJECT_INFO_SKIP_FETCH_OBJECT) ||
                    find_cached_object(oid))
                            return 0;
                    ALLOC_GROW(cached_objects, cached_object_nr + 1, cached_object_alloc);
                    co = &cached_objects[cached_object_nr++];
                    co->value.size = len;
                    co->value.type = type;
                    co_buf = xmalloc(len);
                    memcpy(co_buf, buf, len);
                    co->value.buf = co_buf;
                    oidcpy(&co->oid, oid);
                    return 0;
            }

            /*
            * This function dies on corrupt objects; the callers who want to
            * deal with them should arrange to call oid_object_info_extended() and give
            * error messages themselves.
            */
            void *repo_read_object_file(struct repository *r,
                                    const struct object_id *oid,
                                    enum object_type *type,
                                    unsigned long *size)
            {
                    struct object_info oi = OBJECT_INFO_INIT;
                    unsigned flags = OBJECT_INFO_DIE_IF_CORRUPT | OBJECT_INFO_LOOKUP_REPLACE;
                    void *data;

                    oi.typep = type;
                    oi.sizep = size;
                    oi.contentp = &data;
                    if (oid_object_info_extended(r, oid, &oi, flags))
                            return NULL;

                    return data;
            }

            void *read_object_with_reference(struct repository *r,
                                            const struct object_id *oid,
                                            enum object_type required_type,
                                            unsigned long *size,
                                            struct object_id *actual_oid_return)
            {
                    enum object_type type;
                    void *buffer;
                    unsigned long isize;
                    struct object_id actual_oid;

                    oidcpy(&actual_oid, oid);
                    while (1) {
                            int ref_length = -1;
                            const char *ref_type = NULL;

                            buffer = repo_read_object_file(r, &actual_oid, &type, &isize);
                            if (!buffer)
                                    return NULL;
                            if (type == required_type) {
                                    *size = isize;
                                    if (actual_oid_return)
                                            oidcpy(actual_oid_return, &actual_oid);
                                    return buffer;
                            }
                            /* Handle references */
                            else if (type == OBJ_COMMIT)
                                    ref_type = "tree ";
                            else if (type == OBJ_TAG)
                                    ref_type = "object ";
                            else {
                                    free(buffer);
                                    return NULL;
                            }
                            ref_length = strlen(ref_type);

                            if (ref_length + the_hash_algo->hexsz > isize ||
                            memcmp(buffer, ref_type, ref_length) ||
                            get_oid_hex((char *) buffer + ref_length, &actual_oid)) {
                                    free(buffer);
                                    return NULL;
                            }
                            free(buffer);
                            /* Now we have the ID of the referred-to object in
                            * actual_oid.  Check again. */
                    }
            }

            static void hash_object_body(const struct git_hash_algo *algo, git_hash_ctx *c,
                                    const void *buf, unsigned long len,
                                    struct object_id *oid,
                                    char *hdr, int *hdrlen)
            {
                    algo->init_fn(c);
                    algo->update_fn(c, hdr, *hdrlen);
                    algo->update_fn(c, buf, len);
                    algo->final_oid_fn(oid, c);
            }

            static void write_object_file_prepare(const struct git_hash_algo *algo,
                                            const void *buf, unsigned long len,
                                            enum object_type type, struct object_id *oid,
                                            char *hdr, int *hdrlen)
            {
                    git_hash_ctx c;

                    /* Generate the header */
                    *hdrlen = format_object_header(hdr, *hdrlen, type, len);

                    /* Sha1.. */
                    hash_object_body(algo, &c, buf, len, oid, hdr, hdrlen);
            }

            static void write_object_file_prepare_literally(const struct git_hash_algo *algo,
                                            const void *buf, unsigned long len,
                                            const char *type, struct object_id *oid,
                                            char *hdr, int *hdrlen)
            {
                    git_hash_ctx c;

                    *hdrlen = format_object_header_literally(hdr, *hdrlen, type, len);
                    hash_object_body(algo, &c, buf, len, oid, hdr, hdrlen);
            }

            static int check_collision(const char *filename_a, const char *filename_b)
            {
                    char buf_a[4096], buf_b[4096];
                    int fd_a = -1, fd_b = -1;
                    int ret = 0;

                    fd_a = open(filename_a, O_RDONLY);
                    if (fd_a < 0) {
                            ret = error_errno(_("unable to open %s"), filename_a);
                            goto out;
                    }

                    fd_b = open(filename_b, O_RDONLY);
                    if (fd_b < 0) {
                            ret = error_errno(_("unable to open %s"), filename_b);
                            goto out;
                    }

                    while (1) {
                            ssize_t sz_a, sz_b;

                            sz_a = read_in_full(fd_a, buf_a, sizeof(buf_a));
                            if (sz_a < 0) {
                                    ret = error_errno(_("unable to read %s"), filename_a);
                                    goto out;
                            }

                            sz_b = read_in_full(fd_b, buf_b, sizeof(buf_b));
                            if (sz_b < 0) {
                                    ret = error_errno(_("unable to read %s"), filename_b);
                                    goto out;
                            }

                            if (sz_a != sz_b || memcmp(buf_a, buf_b, sz_a)) {
                                    ret = error(_("files '%s' and '%s' differ in contents"),
                                            filename_a, filename_b);
                                    goto out;
                            }

                            if (sz_a < sizeof(buf_a))
                                    break;
                    }

            out:
                    if (fd_a > -1)
                            close(fd_a);
                    if (fd_b > -1)
                            close(fd_b);
                    return ret;
            }

            /*
            * Move the just written object into its final resting place.
            */
            int finalize_object_file(const char *tmpfile, const char *filename)
            {
                    return finalize_object_file_flags(tmpfile, filename, 0);
            }

            int finalize_object_file_flags(const char *tmpfile, const char *filename,
                                    enum finalize_object_file_flags flags)
            {
                    struct stat st;
                    int ret = 0;

                    if (object_creation_mode == OBJECT_CREATION_USES_RENAMES)
                            goto try_rename;
                    else if (link(tmpfile, filename))
                            ret = errno;
                    else
                            unlink_or_warn(tmpfile);

                    /*
                    * Coda hack - coda doesn't like cross-directory links,
                    * so we fall back to a rename, which will mean that it
                    * won't be able to check collisions, but that's not a
                    * big deal.
                    *
                    * The same holds for FAT formatted media.
                    *
                    * When this succeeds, we just return.  We have nothing
                    * left to unlink.
                    */
                    if (ret && ret != EEXIST) {
                    try_rename:
                            if (!stat(filename, &st))
                                    ret = EEXIST;
                            else if (!rename(tmpfile, filename))
                                    goto out;
                            else
                                    ret = errno;
                    }
                    if (ret) {
                            if (ret != EEXIST) {
                                    int saved_errno = errno;
                                    unlink_or_warn(tmpfile);
                                    errno = saved_errno;
                                    return error_errno(_("unable to write file %s"), filename);
                            }
                            if (!(flags & FOF_SKIP_COLLISION_CHECK) &&
                            check_collision(tmpfile, filename))
                                            return -1;
                            unlink_or_warn(tmpfile);
                    }

            out:
                    if (adjust_shared_perm(filename))
                            return error(_("unable to set permission to '%s'"), filename);
                    return 0;
            }

            static void hash_object_file_literally(const struct git_hash_algo *algo,
                                            const void *buf, unsigned long len,
                                            const char *type, struct object_id *oid)
            {
                    char hdr[MAX_HEADER_LEN];
                    int hdrlen = sizeof(hdr);

                    write_object_file_prepare_literally(algo, buf, len, type, oid, hdr, &hdrlen);
            }

            void hash_object_file(const struct git_hash_algo *algo, const void *buf,
                            unsigned long len, enum object_type type,
                            struct object_id *oid)
            {
                    hash_object_file_literally(algo, buf, len, type_name(type), oid);
            }

            /* Finalize a file on disk, and close it. */
            static void close_loose_object(int fd, const char *filename)
            {
                    if (the_repository->objects->odb->will_destroy)
                            goto out;

                    if (batch_fsync_enabled(FSYNC_COMPONENT_LOOSE_OBJECT))
                            fsync_loose_object_bulk_checkin(fd, filename);
                    else if (fsync_object_files > 0)
                            fsync_or_die(fd, filename);
                    else
                            fsync_component_or_die(FSYNC_COMPONENT_LOOSE_OBJECT, fd,
                                            filename);

            out:
                    if (close(fd) != 0)
                            die_errno(_("error when closing loose object file"));
            }

            /* Size of directory component, including the ending '/' */
            static inline int directory_size(const char *filename)
            {
                    const char *s = strrchr(filename, '/');
                    if (!s)
                            return 0;
                    return s - filename + 1;
            }

            /*
            * This creates a temporary file in the same directory as the final
            * 'filename'
            *
            * We want to avoid cross-directory filename renames, because those
            * can have problems on various filesystems (FAT, NFS, Coda).
            */
            static int create_tmpfile(struct strbuf *tmp, const char *filename)
            {
                    int fd, dirlen = directory_size(filename);

                    strbuf_reset(tmp);
                    strbuf_add(tmp, filename, dirlen);
                    strbuf_addstr(tmp, "tmp_obj_XXXXXX");
                    fd = git_mkstemp_mode(tmp->buf, 0444);
                    if (fd < 0 && dirlen && errno == ENOENT) {
                            /*
                            * Make sure the directory exists; note that the contents
                            * of the buffer are undefined after mkstemp returns an
                            * error, so we have to rewrite the whole buffer from
                            * scratch.
                            */
                            strbuf_reset(tmp);
                            strbuf_add(tmp, filename, dirlen - 1);
                            if (mkdir(tmp->buf, 0777) && errno != EEXIST)
                                    return -1;
                            if (adjust_shared_perm(tmp->buf))
                                    return -1;

                            /* Try again */
                            strbuf_addstr(tmp, "/tmp_obj_XXXXXX");
                            fd = git_mkstemp_mode(tmp->buf, 0444);
                    }
                    return fd;
            }

            /**
            * Common steps for loose object writers to start writing loose
            * objects:
            *
            * - Create tmpfile for the loose object.
            * - Setup zlib stream for compression.
            * - Start to feed header to zlib stream.
            *
            * Returns a "fd", which should later be provided to
            * end_loose_object_common().
            */
            static int start_loose_object_common(struct strbuf *tmp_file,
                                            const char *filename, unsigned flags,
                                            git_zstream *stream,
                                            unsigned char *buf, size_t buflen,
                                            git_hash_ctx *c, git_hash_ctx *compat_c,
                                            char *hdr, int hdrlen)
            {
                    struct repository *repo = the_repository;
                    const struct git_hash_algo *algo = repo->hash_algo;
                    const struct git_hash_algo *compat = repo->compat_hash_algo;
                    int fd;

                    fd = create_tmpfile(tmp_file, filename);
                    if (fd < 0) {
                            if (flags & HASH_SILENT)
                                    return -1;
                            else if (errno == EACCES)
                                    return error(_("insufficient permission for adding "
                                            "an object to repository database %s"),
                                            repo_get_object_directory(the_repository));
                            else
                                    return error_errno(
                                            _("unable to create temporary file"));
                    }

                    /*  Setup zlib stream for compression */
                    git_deflate_init(stream, zlib_compression_level);
                    stream->next_out = buf;
                    stream->avail_out = buflen;
                    algo->init_fn(c);
                    if (compat && compat_c)
                            compat->init_fn(compat_c);

                    /*  Start to feed header to zlib stream */
                    stream->next_in = (unsigned char *)hdr;
                    stream->avail_in = hdrlen;
                    while (git_deflate(stream, 0) == Z_OK)
                            ; /* nothing */
                    algo->update_fn(c, hdr, hdrlen);
                    if (compat && compat_c)
                            compat->update_fn(compat_c, hdr, hdrlen);

                    return fd;
            }

            /**
            * Common steps for the inner git_deflate() loop for writing loose
            * objects. Returns what git_deflate() returns.
            */
            static int write_loose_object_common(git_hash_ctx *c, git_hash_ctx *compat_c,
                                            git_zstream *stream, const int flush,
                                            unsigned char *in0, const int fd,
                                            unsigned char *compressed,
                                            const size_t compressed_len)
            {
                    struct repository *repo = the_repository;
                    const struct git_hash_algo *algo = repo->hash_algo;
                    const struct git_hash_algo *compat = repo->compat_hash_algo;
                    int ret;

                    ret = git_deflate(stream, flush ? Z_FINISH : 0);
                    algo->update_fn(c, in0, stream->next_in - in0);
                    if (compat && compat_c)
                            compat->update_fn(compat_c, in0, stream->next_in - in0);
                    if (write_in_full(fd, compressed, stream->next_out - compressed) < 0)
                            die_errno(_("unable to write loose object file"));
                    stream->next_out = compressed;
                    stream->avail_out = compressed_len;

                    return ret;
            }

            /**
            * Common steps for loose object writers to end writing loose objects:
            *
            * - End the compression of zlib stream.
            * - Get the calculated oid to "oid".
            */
            static int end_loose_object_common(git_hash_ctx *c, git_hash_ctx *compat_c,
                                            git_zstream *stream, struct object_id *oid,
                                            struct object_id *compat_oid)
            {
                    struct repository *repo = the_repository;
                    const struct git_hash_algo *algo = repo->hash_algo;
                    const struct git_hash_algo *compat = repo->compat_hash_algo;
                    int ret;

                    ret = git_deflate_end_gently(stream);
                    if (ret != Z_OK)
                            return ret;
                    algo->final_oid_fn(oid, c);
                    if (compat && compat_c)
                            compat->final_oid_fn(compat_oid, compat_c);

                    return Z_OK;
            }

            static int write_loose_object(const struct object_id *oid, char *hdr,
                                    int hdrlen, const void *buf, unsigned long len,
                                    time_t mtime, unsigned flags)
            {
                    int fd, ret;
                    unsigned char compressed[4096];
                    git_zstream stream;
                    git_hash_ctx c;
                    struct object_id parano_oid;
                    static struct strbuf tmp_file = STRBUF_INIT;
                    static struct strbuf filename = STRBUF_INIT;

                    if (batch_fsync_enabled(FSYNC_COMPONENT_LOOSE_OBJECT))
                            prepare_loose_object_bulk_checkin();

                    loose_object_path(the_repository, &filename, oid);

                    fd = start_loose_object_common(&tmp_file, filename.buf, flags,
                                            &stream, compressed, sizeof(compressed),
                                            &c, NULL, hdr, hdrlen);
                    if (fd < 0)
                            return -1;

                    /* Then the data itself.. */
                    stream.next_in = (void *)buf;
                    stream.avail_in = len;
                    do {
                            unsigned char *in0 = stream.next_in;

                            ret = write_loose_object_common(&c, NULL, &stream, 1, in0, fd,
                                                            compressed, sizeof(compressed));
                    } while (ret == Z_OK);

                    if (ret != Z_STREAM_END)
                            die(_("unable to deflate new object %s (%d)"), oid_to_hex(oid),
                            ret);
                    ret = end_loose_object_common(&c, NULL, &stream, &parano_oid, NULL);
                    if (ret != Z_OK)
                            die(_("deflateEnd on object %s failed (%d)"), oid_to_hex(oid),
                            ret);
                    if (!oideq(oid, &parano_oid))
                            die(_("confused by unstable object source data for %s"),
                            oid_to_hex(oid));

                    close_loose_object(fd, tmp_file.buf);

                    if (mtime) {
                            struct utimbuf utb;
                            utb.actime = mtime;
                            utb.modtime = mtime;
                            if (utime(tmp_file.buf, &utb) < 0 &&
                            !(flags & HASH_SILENT))
                                    warning_errno(_("failed utime() on %s"), tmp_file.buf);
                    }

                    return finalize_object_file_flags(tmp_file.buf, filename.buf,
                                                    FOF_SKIP_COLLISION_CHECK);
            }

            static int freshen_loose_object(const struct object_id *oid)
            {
                    return check_and_freshen(oid, 1);
            }

            static int freshen_packed_object(const struct object_id *oid)
            {
                    struct pack_entry e;
                    if (!find_pack_entry(the_repository, oid, &e))
                            return 0;
                    if (e.p->is_cruft)
                            return 0;
                    if (e.p->freshened)
                            return 1;
                    if (!freshen_file(e.p->pack_name))
                            return 0;
                    e.p->freshened = 1;
                    return 1;
            }

            int stream_loose_object(struct input_stream *in_stream, size_t len,
                                    struct object_id *oid)
            {
                    const struct git_hash_algo *compat = the_repository->compat_hash_algo;
                    struct object_id compat_oid;
                    int fd, ret, err = 0, flush = 0;
                    unsigned char compressed[4096];
                    git_zstream stream;
                    git_hash_ctx c, compat_c;
                    struct strbuf tmp_file = STRBUF_INIT;
                    struct strbuf filename = STRBUF_INIT;
                    int dirlen;
                    char hdr[MAX_HEADER_LEN];
                    int hdrlen;

                    if (batch_fsync_enabled(FSYNC_COMPONENT_LOOSE_OBJECT))
                            prepare_loose_object_bulk_checkin();

                    /* Since oid is not determined, save tmp file to odb path. */
                    strbuf_addf(&filename, "%s/", repo_get_object_directory(the_repository));
                    hdrlen = format_object_header(hdr, sizeof(hdr), OBJ_BLOB, len);

                    /*
                    * Common steps for write_loose_object and stream_loose_object to
                    * start writing loose objects:
                    *
                    *  - Create tmpfile for the loose object.
                    *  - Setup zlib stream for compression.
                    *  - Start to feed header to zlib stream.
                    */
                    fd = start_loose_object_common(&tmp_file, filename.buf, 0,
                                            &stream, compressed, sizeof(compressed),
                                            &c, &compat_c, hdr, hdrlen);
                    if (fd < 0) {
                            err = -1;
                            goto cleanup;
                    }

                    /* Then the data itself.. */
                    do {
                            unsigned char *in0 = stream.next_in;

                            if (!stream.avail_in && !in_stream->is_finished) {
                                    const void *in = in_stream->read(in_stream, &stream.avail_in);
                                    stream.next_in = (void *)in;
                                    in0 = (unsigned char *)in;
                                    /* All data has been read. */
                                    if (in_stream->is_finished)
                                            flush = 1;
                            }
                            ret = write_loose_object_common(&c, &compat_c, &stream, flush, in0, fd,
                                                            compressed, sizeof(compressed));
                            /*
                            * Unlike write_loose_object(), we do not have the entire
                            * buffer. If we get Z_BUF_ERROR due to too few input bytes,
                            * then we'll replenish them in the next input_stream->read()
                            * call when we loop.
                            */
                    } while (ret == Z_OK || ret == Z_BUF_ERROR);

                    if (stream.total_in != len + hdrlen)
                            die(_("write stream object %ld != %"PRIuMAX), stream.total_in,
                            (uintmax_t)len + hdrlen);

                    /*
                    * Common steps for write_loose_object and stream_loose_object to
                    * end writing loose object:
                    *
                    *  - End the compression of zlib stream.
                    *  - Get the calculated oid.
                    */
                    if (ret != Z_STREAM_END)
                            die(_("unable to stream deflate new object (%d)"), ret);
                    ret = end_loose_object_common(&c, &compat_c, &stream, oid, &compat_oid);
                    if (ret != Z_OK)
                            die(_("deflateEnd on stream object failed (%d)"), ret);
                    close_loose_object(fd, tmp_file.buf);

                    if (freshen_packed_object(oid) || freshen_loose_object(oid)) {
                            unlink_or_warn(tmp_file.buf);
                            goto cleanup;
                    }

                    loose_object_path(the_repository, &filename, oid);

                    /* We finally know the object path, and create the missing dir. */
                    dirlen = directory_size(filename.buf);
                    if (dirlen) {
                            struct strbuf dir = STRBUF_INIT;
                            strbuf_add(&dir, filename.buf, dirlen);

                            if (mkdir_in_gitdir(dir.buf) && errno != EEXIST) {
                                    err = error_errno(_("unable to create directory %s"), dir.buf);
                                    strbuf_release(&dir);
                                    goto cleanup;
                            }
                            strbuf_release(&dir);
                    }

                    err = finalize_object_file_flags(tmp_file.buf, filename.buf,
                                                    FOF_SKIP_COLLISION_CHECK);
                    if (!err && compat)
                            err = repo_add_loose_object_map(the_repository, oid, &compat_oid);
            cleanup:
                    strbuf_release(&tmp_file);
                    strbuf_release(&filename);
                    return err;
            }

            int write_object_file_flags(const void *buf, unsigned long len,
                                    enum object_type type, struct object_id *oid,
                                    struct object_id *compat_oid_in, unsigned flags)
            {
                    struct repository *repo = the_repository;
                    const struct git_hash_algo *algo = repo->hash_algo;
                    const struct git_hash_algo *compat = repo->compat_hash_algo;
                    struct object_id compat_oid;
                    char hdr[MAX_HEADER_LEN];
                    int hdrlen = sizeof(hdr);

                    /* Generate compat_oid */
                    if (compat) {
                            if (compat_oid_in)
                                    oidcpy(&compat_oid, compat_oid_in);
                            else if (type == OBJ_BLOB)
                                    hash_object_file(compat, buf, len, type, &compat_oid);
                            else {
                                    struct strbuf converted = STRBUF_INIT;
                                    convert_object_file(&converted, algo, compat,
                                                    buf, len, type, 0);
                                    hash_object_file(compat, converted.buf, converted.len,
                                                    type, &compat_oid);
                                    strbuf_release(&converted);
                            }
                    }

                    /* Normally if we have it in the pack then we do not bother writing
                    * it out into .git/objects/??/?{38} file.
                    */
                    write_object_file_prepare(algo, buf, len, type, oid, hdr, &hdrlen);
                    if (freshen_packed_object(oid) || freshen_loose_object(oid))
                            return 0;
                    if (write_loose_object(oid, hdr, hdrlen, buf, len, 0, flags))
                            return -1;
                    if (compat)
                            return repo_add_loose_object_map(repo, oid, &compat_oid);
                    return 0;
            }

            int write_object_file_literally(const void *buf, unsigned long len,
                                            const char *type, struct object_id *oid,
                                            unsigned flags)
            {
                    char *header;
                    struct repository *repo = the_repository;
                    const struct git_hash_algo *algo = repo->hash_algo;
                    const struct git_hash_algo *compat = repo->compat_hash_algo;
                    struct object_id compat_oid;
                    int hdrlen, status = 0;
                    int compat_type = -1;

                    if (compat) {
                            compat_type = type_from_string_gently(type, -1, 1);
                            if (compat_type == OBJ_BLOB)
                                    hash_object_file(compat, buf, len, compat_type,
                                                    &compat_oid);
                            else if (compat_type != -1) {
                                    struct strbuf converted = STRBUF_INIT;
                                    convert_object_file(&converted, algo, compat,
                                                    buf, len, compat_type, 0);
                                    hash_object_file(compat, converted.buf, converted.len,
                                                    compat_type, &compat_oid);
                                    strbuf_release(&converted);
                            }
                    }

                    /* type string, SP, %lu of the length plus NUL must fit this */
                    hdrlen = strlen(type) + MAX_HEADER_LEN;
                    header = xmalloc(hdrlen);
                    write_object_file_prepare_literally(the_hash_algo, buf, len, type,
                                                    oid, header, &hdrlen);

                    if (!(flags & HASH_WRITE_OBJECT))
                            goto cleanup;
                    if (freshen_packed_object(oid) || freshen_loose_object(oid))
                            goto cleanup;
                    status = write_loose_object(oid, header, hdrlen, buf, len, 0, 0);
                    if (compat_type != -1)
                            return repo_add_loose_object_map(repo, oid, &compat_oid);

            cleanup:
                    free(header);
                    return status;
            }

            int force_object_loose(const struct object_id *oid, time_t mtime)
            {
                    struct repository *repo = the_repository;
                    const struct git_hash_algo *compat = repo->compat_hash_algo;
                    void *buf;
                    unsigned long len;
                    struct object_info oi = OBJECT_INFO_INIT;
                    struct object_id compat_oid;
                    enum object_type type;
                    char hdr[MAX_HEADER_LEN];
                    int hdrlen;
                    int ret;

                    if (has_loose_object(oid))
                            return 0;
                    oi.typep = &type;
                    oi.sizep = &len;
                    oi.contentp = &buf;
                    if (oid_object_info_extended(the_repository, oid, &oi, 0))
                            return error(_("cannot read object for %s"), oid_to_hex(oid));
                    if (compat) {
                            if (repo_oid_to_algop(repo, oid, compat, &compat_oid))
                                    return error(_("cannot map object %s to %s"),
                                            oid_to_hex(oid), compat->name);
                    }
                    hdrlen = format_object_header(hdr, sizeof(hdr), type, len);
                    ret = write_loose_object(oid, hdr, hdrlen, buf, len, mtime, 0);
                    if (!ret && compat)
                            ret = repo_add_loose_object_map(the_repository, oid, &compat_oid);
                    free(buf);

                    return ret;
            }

            int has_object(struct repository *r, const struct object_id *oid,
                    unsigned flags)
            {
                    int quick = !(flags & HAS_OBJECT_RECHECK_PACKED);
                    unsigned object_info_flags = OBJECT_INFO_SKIP_FETCH_OBJECT |
                            (quick ? OBJECT_INFO_QUICK : 0);

                    if (!startup_info->have_repository)
                            return 0;
                    return oid_object_info_extended(r, oid, NULL, object_info_flags) >= 0;
            }

            int repo_has_object_file_with_flags(struct repository *r,
                                            const struct object_id *oid, int flags)
            {
                    if (!startup_info->have_repository)
                            return 0;
                    return oid_object_info_extended(r, oid, NULL, flags) >= 0;
            }

            int repo_has_object_file(struct repository *r,
                                    const struct object_id *oid)
            {
                    return repo_has_object_file_with_flags(r, oid, 0);
            }

            /*
            * We can't use the normal fsck_error_function() for index_mem(),
            * because we don't yet have a valid oid for it to report. Instead,
            * report the minimal fsck error here, and rely on the caller to
            * give more context.
            */
            static int hash_format_check_report(struct fsck_options *opts UNUSED,
                                            void *fsck_report UNUSED,
                                            enum fsck_msg_type msg_type UNUSED,
                                            enum fsck_msg_id msg_id UNUSED,
                                            const char *message)
            {
                    error(_("object fails fsck: %s"), message);
                    return 1;
            }

            static int index_mem(struct index_state *istate,
                            struct object_id *oid,
                            const void *buf, size_t size,
                            enum object_type type,
                            const char *path, unsigned flags)
            {
                    struct strbuf nbuf = STRBUF_INIT;
                    int ret = 0;
                    int write_object = flags & HASH_WRITE_OBJECT;

                    if (!type)
                            type = OBJ_BLOB;

                    /*
                    * Convert blobs to git internal format
                    */
                    if ((type == OBJ_BLOB) && path) {
                            if (convert_to_git(istate, path, buf, size, &nbuf,
                                            get_conv_flags(flags))) {
                                    buf = nbuf.buf;
                                    size = nbuf.len;
                            }
                    }
                    if (flags & HASH_FORMAT_CHECK) {
                            struct fsck_options opts = FSCK_OPTIONS_DEFAULT;

                            opts.strict = 1;
                            opts.error_func = hash_format_check_report;
                            if (fsck_buffer(null_oid(), type, buf, size, &opts))
                                    die(_("refusing to create malformed object"));
                            fsck_finish(&opts);
                    }

                    if (write_object)
                            ret = write_object_file(buf, size, type, oid);
                    else
                            hash_object_file(the_hash_algo, buf, size, type, oid);

                    strbuf_release(&nbuf);
                    return ret;
            }

            static int index_stream_convert_blob(struct index_state *istate,
                                            struct object_id *oid,
                                            int fd,
                                            const char *path,
                                            unsigned flags)
            {
                    int ret = 0;
                    const int write_object = flags & HASH_WRITE_OBJECT;
                    struct strbuf sbuf = STRBUF_INIT;

                    assert(path);
                    assert(would_convert_to_git_filter_fd(istate, path));

                    convert_to_git_filter_fd(istate, path, fd, &sbuf,
                                            get_conv_flags(flags));

                    if (write_object)
                            ret = write_object_file(sbuf.buf, sbuf.len, OBJ_BLOB,
                                                    oid);
                    else
                            hash_object_file(the_hash_algo, sbuf.buf, sbuf.len, OBJ_BLOB,
                                            oid);
                    strbuf_release(&sbuf);
                    return ret;
            }

            static int index_pipe(struct index_state *istate, struct object_id *oid,
                            int fd, enum object_type type,
                            const char *path, unsigned flags)
            {
                    struct strbuf sbuf = STRBUF_INIT;
                    int ret;

                    if (strbuf_read(&sbuf, fd, 4096) >= 0)
                            ret = index_mem(istate, oid, sbuf.buf, sbuf.len, type, path, flags);
                    else
                            ret = -1;
                    strbuf_release(&sbuf);
                    return ret;
            }

            #define SMALL_FILE_SIZE (32*1024)

            static int index_core(struct index_state *istate,
                            struct object_id *oid, int fd, size_t size,
                            enum object_type type, const char *path,
                            unsigned flags)
            {
                    int ret;

                    if (!size) {
                            ret = index_mem(istate, oid, "", size, type, path, flags);
                    } else if (size <= SMALL_FILE_SIZE) {
                            char *buf = xmalloc(size);
                            ssize_t read_result = read_in_full(fd, buf, size);
                            if (read_result < 0)
                                    ret = error_errno(_("read error while indexing %s"),
                                                    path ? path : "<unknown>");
                            else if (read_result != size)
                                    ret = error(_("short read while indexing %s"),
                                            path ? path : "<unknown>");
                            else
                                    ret = index_mem(istate, oid, buf, size, type, path, flags);
                            free(buf);
                    } else {
                            void *buf = xmmap(NULL, size, PROT_READ, MAP_PRIVATE, fd, 0);
                            ret = index_mem(istate, oid, buf, size, type, path, flags);
                            munmap(buf, size);
                    }
                    return ret;
            }

            /*
            * This creates one packfile per large blob unless bulk-checkin
            * machinery is "plugged".
            *
            * This also bypasses the usual "convert-to-git" dance, and that is on
            * purpose. We could write a streaming version of the converting
            * functions and insert that before feeding the data to fast-import
            * (or equivalent in-core API described above). However, that is
            * somewhat complicated, as we do not know the size of the filter
            * result, which we need to know beforehand when writing a git object.
            * Since the primary motivation for trying to stream from the working
            * tree file and to avoid mmaping it in core is to deal with large
            * binary blobs, they generally do not want to get any conversion, and
            * callers should avoid this code path when filters are requested.
            */
            static int index_blob_stream(struct object_id *oid, int fd, size_t size,
                                    const char *path,
                                    unsigned flags)
            {
                    return index_blob_bulk_checkin(oid, fd, size, path, flags);
            }

            int index_fd(struct index_state *istate, struct object_id *oid,
                    int fd, struct stat *st,
                    enum object_type type, const char *path, unsigned flags)
            {
                    int ret;

                    /*
                    * Call xsize_t() only when needed to avoid potentially unnecessary
                    * die() for large files.
                    */
                    if (type == OBJ_BLOB && path && would_convert_to_git_filter_fd(istate, path))
                            ret = index_stream_convert_blob(istate, oid, fd, path, flags);
                    else if (!S_ISREG(st->st_mode))
                            ret = index_pipe(istate, oid, fd, type, path, flags);
                    else if (st->st_size <= big_file_threshold || type != OBJ_BLOB ||
                            (path && would_convert_to_git(istate, path)))
                            ret = index_core(istate, oid, fd, xsize_t(st->st_size),
                                            type, path, flags);
                    else
                            ret = index_blob_stream(oid, fd, xsize_t(st->st_size), path,
                                                    flags);
                    close(fd);
                    return ret;
            }

            int index_path(struct index_state *istate, struct object_id *oid,
                    const char *path, struct stat *st, unsigned flags)
            {
                    int fd;
                    struct strbuf sb = STRBUF_INIT;
                    int rc = 0;

                    switch (st->st_mode & S_IFMT) {
                    case S_IFREG:
                            fd = open(path, O_RDONLY);
                            if (fd < 0)
                                    return error_errno("open(\"%s\")", path);
                            if (index_fd(istate, oid, fd, st, OBJ_BLOB, path, flags) < 0)
                                    return error(_("%s: failed to insert into database"),
                                            path);
                            break;
                    case S_IFLNK:
                            if (strbuf_readlink(&sb, path, st->st_size))
                                    return error_errno("readlink(\"%s\")", path);
                            if (!(flags & HASH_WRITE_OBJECT))
                                    hash_object_file(the_hash_algo, sb.buf, sb.len,
                                                    OBJ_BLOB, oid);
                            else if (write_object_file(sb.buf, sb.len, OBJ_BLOB, oid))
                                    rc = error(_("%s: failed to insert into database"), path);
                            strbuf_release(&sb);
                            break;
                    case S_IFDIR:
                            return repo_resolve_gitlink_ref(the_repository, path, "HEAD", oid);
                    default:
                            return error(_("%s: unsupported file type"), path);
                    }
                    return rc;
            }

            int read_pack_header(int fd, struct pack_header *header)
            {
                    if (read_in_full(fd, header, sizeof(*header)) != sizeof(*header))
                            /* "eof before pack header was fully read" */
                            return PH_ERROR_EOF;

                    if (header->hdr_signature != htonl(PACK_SIGNATURE))
                            /* "protocol error (pack signature mismatch detected)" */
                            return PH_ERROR_PACK_SIGNATURE;
                    if (!pack_version_ok(header->hdr_version))
                            /* "protocol error (pack version unsupported)" */
                            return PH_ERROR_PROTOCOL;
                    return 0;
            }

            void assert_oid_type(const struct object_id *oid, enum object_type expect)
            {
                    enum object_type type = oid_object_info(the_repository, oid, NULL);
                    if (type < 0)
                            die(_("%s is not a valid object"), oid_to_hex(oid));
                    if (type != expect)
                            die(_("%s is not a valid '%s' object"), oid_to_hex(oid),
                            type_name(expect));
            }

            int for_each_file_in_obj_subdir(unsigned int subdir_nr,
                                            struct strbuf *path,
                                            each_loose_object_fn obj_cb,
                                            each_loose_cruft_fn cruft_cb,
                                            each_loose_subdir_fn subdir_cb,
                                            void *data)
            {
                    size_t origlen, baselen;
                    DIR *dir;
                    struct dirent *de;
                    int r = 0;
                    struct object_id oid;

                    if (subdir_nr > 0xff)
                            BUG("invalid loose object subdirectory: %x", subdir_nr);

                    origlen = path->len;
                    strbuf_complete(path, '/');
                    strbuf_addf(path, "%02x", subdir_nr);

                    dir = opendir(path->buf);
                    if (!dir) {
                            if (errno != ENOENT)
                                    r = error_errno(_("unable to open %s"), path->buf);
                            strbuf_setlen(path, origlen);
                            return r;
                    }

                    oid.hash[0] = subdir_nr;
                    strbuf_addch(path, '/');
                    baselen = path->len;

                    while ((de = readdir_skip_dot_and_dotdot(dir))) {
                            size_t namelen;

                            namelen = strlen(de->d_name);
                            strbuf_setlen(path, baselen);
                            strbuf_add(path, de->d_name, namelen);
                            if (namelen == the_hash_algo->hexsz - 2 &&
                            !hex_to_bytes(oid.hash + 1, de->d_name,
                                            the_hash_algo->rawsz - 1)) {
                                    oid_set_algo(&oid, the_hash_algo);
                                    memset(oid.hash + the_hash_algo->rawsz, 0,
                                    GIT_MAX_RAWSZ - the_hash_algo->rawsz);
                                    if (obj_cb) {
                                            r = obj_cb(&oid, path->buf, data);
                                            if (r)
                                                    break;
                                    }
                                    continue;
                            }

                            if (cruft_cb) {
                                    r = cruft_cb(de->d_name, path->buf, data);
                                    if (r)
                                            break;
                            }
                    }
                    closedir(dir);

                    strbuf_setlen(path, baselen - 1);
                    if (!r && subdir_cb)
                            r = subdir_cb(subdir_nr, path->buf, data);

                    strbuf_setlen(path, origlen);

                    return r;
            }

            int for_each_loose_file_in_objdir_buf(struct strbuf *path,
                                    each_loose_object_fn obj_cb,
                                    each_loose_cruft_fn cruft_cb,
                                    each_loose_subdir_fn subdir_cb,
                                    void *data)
            {
                    int r = 0;
                    int i;

                    for (i = 0; i < 256; i++) {
                            r = for_each_file_in_obj_subdir(i, path, obj_cb, cruft_cb,
                                                            subdir_cb, data);
                            if (r)
                                    break;
                    }

                    return r;
            }

            int for_each_loose_file_in_objdir(const char *path,
                                            each_loose_object_fn obj_cb,
                                            each_loose_cruft_fn cruft_cb,
                                            each_loose_subdir_fn subdir_cb,
                                            void *data)
            {
                    struct strbuf buf = STRBUF_INIT;
                    int r;

                    strbuf_addstr(&buf, path);
                    r = for_each_loose_file_in_objdir_buf(&buf, obj_cb, cruft_cb,
                                                    subdir_cb, data);
                    strbuf_release(&buf);

                    return r;
            }

            int for_each_loose_object(each_loose_object_fn cb, void *data,
                                    enum for_each_object_flags flags)
            {
                    struct object_directory *odb;

                    prepare_alt_odb(the_repository);
                    for (odb = the_repository->objects->odb; odb; odb = odb->next) {
                            int r = for_each_loose_file_in_objdir(odb->path, cb, NULL,
                                                            NULL, data);
                            if (r)
                                    return r;

                            if (flags & FOR_EACH_OBJECT_LOCAL_ONLY)
                                    break;
                    }

                    return 0;
            }

            static int append_loose_object(const struct object_id *oid,
                                    const char *path UNUSED,
                                    void *data)
            {
                    oidtree_insert(data, oid);
                    return 0;
            }

            struct oidtree *odb_loose_cache(struct object_directory *odb,
                                            const struct object_id *oid)
            {
                    int subdir_nr = oid->hash[0];
                    struct strbuf buf = STRBUF_INIT;
                    size_t word_bits = bitsizeof(odb->loose_objects_subdir_seen[0]);
                    size_t word_index = subdir_nr / word_bits;
                    size_t mask = (size_t)1u << (subdir_nr % word_bits);
                    uint32_t *bitmap;

                    if (subdir_nr < 0 ||
                    subdir_nr >= bitsizeof(odb->loose_objects_subdir_seen))
                            BUG("subdir_nr out of range");

                    bitmap = &odb->loose_objects_subdir_seen[word_index];
                    if (*bitmap & mask)
                            return odb->loose_objects_cache;
                    if (!odb->loose_objects_cache) {
                            ALLOC_ARRAY(odb->loose_objects_cache, 1);
                            oidtree_init(odb->loose_objects_cache);
                    }
                    strbuf_addstr(&buf, odb->path);
                    for_each_file_in_obj_subdir(subdir_nr, &buf,
                                            append_loose_object,
                                            NULL, NULL,
                                            odb->loose_objects_cache);
                    *bitmap |= mask;
                    strbuf_release(&buf);
                    return odb->loose_objects_cache;
            }

            void odb_clear_loose_cache(struct object_directory *odb)
            {
                    oidtree_clear(odb->loose_objects_cache);
                    FREE_AND_NULL(odb->loose_objects_cache);
                    memset(&odb->loose_objects_subdir_seen, 0,
                    sizeof(odb->loose_objects_subdir_seen));
            }

            static int check_stream_oid(git_zstream *stream,
                                    const char *hdr,
                                    unsigned long size,
                                    const char *path,
                                    const struct object_id *expected_oid)
            {
                    git_hash_ctx c;
                    struct object_id real_oid;
                    unsigned char buf[4096];
                    unsigned long total_read;
                    int status = Z_OK;

                    the_hash_algo->init_fn(&c);
                    the_hash_algo->update_fn(&c, hdr, stream->total_out);

                    /*
                    * We already read some bytes into hdr, but the ones up to the NUL
                    * do not count against the object's content size.
                    */
                    total_read = stream->total_out - strlen(hdr) - 1;

                    /*
                    * This size comparison must be "<=" to read the final zlib packets;
                    * see the comment in unpack_loose_rest for details.
                    */
                    while (total_read <= size &&
                    (status == Z_OK ||
                            (status == Z_BUF_ERROR && !stream->avail_out))) {
                            stream->next_out = buf;
                            stream->avail_out = sizeof(buf);
                            if (size - total_read < stream->avail_out)
                                    stream->avail_out = size - total_read;
                            status = git_inflate(stream, Z_FINISH);
                            the_hash_algo->update_fn(&c, buf, stream->next_out - buf);
                            total_read += stream->next_out - buf;
                    }
                    git_inflate_end(stream);

                    if (status != Z_STREAM_END) {
                            error(_("corrupt loose object '%s'"), oid_to_hex(expected_oid));
                            return -1;
                    }
                    if (stream->avail_in) {
                            error(_("garbage at end of loose object '%s'"),
                            oid_to_hex(expected_oid));
                            return -1;
                    }

                    the_hash_algo->final_oid_fn(&real_oid, &c);
                    if (!oideq(expected_oid, &real_oid)) {
                            error(_("hash mismatch for %s (expected %s)"), path,
                            oid_to_hex(expected_oid));
                            return -1;
                    }

                    return 0;
            }

            int read_loose_object(const char *path,
                            const struct object_id *expected_oid,
                            struct object_id *real_oid,
                            void **contents,
                            struct object_info *oi)
            {
                    int ret = -1;
                    int fd;
                    void *map = NULL;
                    unsigned long mapsize;
                    git_zstream stream;
                    char hdr[MAX_HEADER_LEN];
                    unsigned long *size = oi->sizep;

                    fd = git_open(path);
                    if (fd >= 0)
                            map = map_fd(fd, path, &mapsize);
                    if (!map) {
                            error_errno(_("unable to mmap %s"), path);
                            goto out;
                    }

                    if (unpack_loose_header(&stream, map, mapsize, hdr, sizeof(hdr),
                                            NULL) != ULHR_OK) {
                            error(_("unable to unpack header of %s"), path);
                            git_inflate_end(&stream);
                            goto out;
                    }

                    if (parse_loose_header(hdr, oi) < 0) {
                            error(_("unable to parse header of %s"), path);
                            git_inflate_end(&stream);
                            goto out;
                    }

                    if (*oi->typep == OBJ_BLOB && *size > big_file_threshold) {
                            if (check_stream_oid(&stream, hdr, *size, path, expected_oid) < 0)
                                    goto out;
                    } else {
                            *contents = unpack_loose_rest(&stream, hdr, *size, expected_oid);
                            if (!*contents) {
                                    error(_("unable to unpack contents of %s"), path);
                                    git_inflate_end(&stream);
                                    goto out;
                            }
                            hash_object_file_literally(the_repository->hash_algo,
                                                    *contents, *size,
                                                    oi->type_name->buf, real_oid);
                            if (!oideq(expected_oid, real_oid))
                                    goto out;
                    }

                    ret = 0; /* everything checks out */

            out:
                    if (map)
                            munmap(map, mapsize);
                    return ret;
            }


            """,
            "Error":"Files are automatically validated for correct tags and encoding before being indexed.
                    EBCDIC files are converted to ASCII when appropriate, ensuring compatibility with Gits expected encoding.
                    Binary files are handled correctly, with automatic encoding conversions disabled.",
            "Error Category":"Functionality patche",

            "Corrected code":
            """
                            /*
            * GIT - The information manager from hell
            *
            * Copyright (C) Linus Torvalds, 2005
            *
            * This handles basic git object files - packing, unpacking,
            * creation etc.
            */

            #define USE_THE_REPOSITORY_VARIABLE
            #define DISABLE_SIGN_COMPARE_WARNINGS

            #include "git-compat-util.h"
            #include "abspath.h"
            #include "config.h"
            #include "convert.h"
            #include "environment.h"
            #include "gettext.h"
            #include "hex.h"
            #include "string-list.h"
            #include "lockfile.h"
            #include "pack.h"
            #include "commit.h"
            #include "run-command.h"
            #include "refs.h"
            #include "bulk-checkin.h"
            #include "repository.h"
            #include "replace-object.h"
            #include "streaming.h"
            #include "dir.h"
            #include "list.h"
            #include "quote.h"
            #include "packfile.h"
            #include "object-file.h"
            #include "object-store.h"
            #include "oidtree.h"
            #include "path.h"
            #include "promisor-remote.h"
            #include "setup.h"
            #include "submodule.h"
            #include "fsck.h"
            #include "loose.h"
            #include "object-file-convert.h"

            #ifdef __MVS__
            #include <_Ccsid.h>
            #include "read-cache-ll.h"
            #endif


            /* The maximum size for an object header. */
            #define MAX_HEADER_LEN 32

            static const struct object_id empty_tree_oid = {
                    .hash = {
                            0x4b, 0x82, 0x5d, 0xc6, 0x42, 0xcb, 0x6e, 0xb9, 0xa0, 0x60,
                            0xe5, 0x4b, 0xf8, 0xd6, 0x92, 0x88, 0xfb, 0xee, 0x49, 0x04
                    },
                    .algo = GIT_HASH_SHA1,
            };
            static const struct object_id empty_blob_oid = {
                    .hash = {
                            0xe6, 0x9d, 0xe2, 0x9b, 0xb2, 0xd1, 0xd6, 0x43, 0x4b, 0x8b,
                            0x29, 0xae, 0x77, 0x5a, 0xd8, 0xc2, 0xe4, 0x8c, 0x53, 0x91
                    },
                    .algo = GIT_HASH_SHA1,
            };
            static const struct object_id null_oid_sha1 = {
                    .hash = {0},
                    .algo = GIT_HASH_SHA1,
            };
            static const struct object_id empty_tree_oid_sha256 = {
                    .hash = {
                            0x6e, 0xf1, 0x9b, 0x41, 0x22, 0x5c, 0x53, 0x69, 0xf1, 0xc1,
                            0x04, 0xd4, 0x5d, 0x8d, 0x85, 0xef, 0xa9, 0xb0, 0x57, 0xb5,
                            0x3b, 0x14, 0xb4, 0xb9, 0xb9, 0x39, 0xdd, 0x74, 0xde, 0xcc,
                            0x53, 0x21
                    },
                    .algo = GIT_HASH_SHA256,
            };
            static const struct object_id empty_blob_oid_sha256 = {
                    .hash = {
                            0x47, 0x3a, 0x0f, 0x4c, 0x3b, 0xe8, 0xa9, 0x36, 0x81, 0xa2,
                            0x67, 0xe3, 0xb1, 0xe9, 0xa7, 0xdc, 0xda, 0x11, 0x85, 0x43,
                            0x6f, 0xe1, 0x41, 0xf7, 0x74, 0x91, 0x20, 0xa3, 0x03, 0x72,
                            0x18, 0x13
                    },
                    .algo = GIT_HASH_SHA256,
            };
            static const struct object_id null_oid_sha256 = {
                    .hash = {0},
                    .algo = GIT_HASH_SHA256,
            };

            static void git_hash_sha1_init(git_hash_ctx *ctx)
            {
                    git_SHA1_Init(&ctx->sha1);
            }

            static void git_hash_sha1_clone(git_hash_ctx *dst, const git_hash_ctx *src)
            {
                    git_SHA1_Clone(&dst->sha1, &src->sha1);
            }

            static void git_hash_sha1_update(git_hash_ctx *ctx, const void *data, size_t len)
            {
                    git_SHA1_Update(&ctx->sha1, data, len);
            }

            static void git_hash_sha1_final(unsigned char *hash, git_hash_ctx *ctx)
            {
                    git_SHA1_Final(hash, &ctx->sha1);
            }

            static void git_hash_sha1_final_oid(struct object_id *oid, git_hash_ctx *ctx)
            {
                    git_SHA1_Final(oid->hash, &ctx->sha1);
                    memset(oid->hash + GIT_SHA1_RAWSZ, 0, GIT_MAX_RAWSZ - GIT_SHA1_RAWSZ);
                    oid->algo = GIT_HASH_SHA1;
            }

            static void git_hash_sha1_init_unsafe(git_hash_ctx *ctx)
            {
                    git_SHA1_Init_unsafe(&ctx->sha1_unsafe);
            }

            static void git_hash_sha1_clone_unsafe(git_hash_ctx *dst, const git_hash_ctx *src)
            {
                    git_SHA1_Clone_unsafe(&dst->sha1_unsafe, &src->sha1_unsafe);
            }

            static void git_hash_sha1_update_unsafe(git_hash_ctx *ctx, const void *data,
                                            size_t len)
            {
                    git_SHA1_Update_unsafe(&ctx->sha1_unsafe, data, len);
            }

            static void git_hash_sha1_final_unsafe(unsigned char *hash, git_hash_ctx *ctx)
            {
                    git_SHA1_Final_unsafe(hash, &ctx->sha1_unsafe);
            }

            static void git_hash_sha1_final_oid_unsafe(struct object_id *oid, git_hash_ctx *ctx)
            {
                    git_SHA1_Final_unsafe(oid->hash, &ctx->sha1_unsafe);
                    memset(oid->hash + GIT_SHA1_RAWSZ, 0, GIT_MAX_RAWSZ - GIT_SHA1_RAWSZ);
                    oid->algo = GIT_HASH_SHA1;
            }

            static void git_hash_sha256_init(git_hash_ctx *ctx)
            {
                    git_SHA256_Init(&ctx->sha256);
            }

            static void git_hash_sha256_clone(git_hash_ctx *dst, const git_hash_ctx *src)
            {
                    git_SHA256_Clone(&dst->sha256, &src->sha256);
            }

            static void git_hash_sha256_update(git_hash_ctx *ctx, const void *data, size_t len)
            {
                    git_SHA256_Update(&ctx->sha256, data, len);
            }

            static void git_hash_sha256_final(unsigned char *hash, git_hash_ctx *ctx)
            {
                    git_SHA256_Final(hash, &ctx->sha256);
            }

            static void git_hash_sha256_final_oid(struct object_id *oid, git_hash_ctx *ctx)
            {
                    git_SHA256_Final(oid->hash, &ctx->sha256);
                    /*
                    * This currently does nothing, so the compiler should optimize it out,
                    * but keep it in case we extend the hash size again.
                    */
                    memset(oid->hash + GIT_SHA256_RAWSZ, 0, GIT_MAX_RAWSZ - GIT_SHA256_RAWSZ);
                    oid->algo = GIT_HASH_SHA256;
            }

            static void git_hash_unknown_init(git_hash_ctx *ctx UNUSED)
            {
                    BUG("trying to init unknown hash");
            }

            static void git_hash_unknown_clone(git_hash_ctx *dst UNUSED,
                                            const git_hash_ctx *src UNUSED)
            {
                    BUG("trying to clone unknown hash");
            }

            static void git_hash_unknown_update(git_hash_ctx *ctx UNUSED,
                                            const void *data UNUSED,
                                            size_t len UNUSED)
            {
                    BUG("trying to update unknown hash");
            }

            static void git_hash_unknown_final(unsigned char *hash UNUSED,
                                            git_hash_ctx *ctx UNUSED)
            {
                    BUG("trying to finalize unknown hash");
            }

            static void git_hash_unknown_final_oid(struct object_id *oid UNUSED,
                                            git_hash_ctx *ctx UNUSED)
            {
                    BUG("trying to finalize unknown hash");
            }

            const struct git_hash_algo hash_algos[GIT_HASH_NALGOS] = {
                    {
                            .name = NULL,
                            .format_id = 0x00000000,
                            .rawsz = 0,
                            .hexsz = 0,
                            .blksz = 0,
                            .init_fn = git_hash_unknown_init,
                            .clone_fn = git_hash_unknown_clone,
                            .update_fn = git_hash_unknown_update,
                            .final_fn = git_hash_unknown_final,
                            .final_oid_fn = git_hash_unknown_final_oid,
                            .unsafe_init_fn = git_hash_unknown_init,
                            .unsafe_clone_fn = git_hash_unknown_clone,
                            .unsafe_update_fn = git_hash_unknown_update,
                            .unsafe_final_fn = git_hash_unknown_final,
                            .unsafe_final_oid_fn = git_hash_unknown_final_oid,
                            .empty_tree = NULL,
                            .empty_blob = NULL,
                            .null_oid = NULL,
                    },
                    {
                            .name = "sha1",
                            .format_id = GIT_SHA1_FORMAT_ID,
                            .rawsz = GIT_SHA1_RAWSZ,
                            .hexsz = GIT_SHA1_HEXSZ,
                            .blksz = GIT_SHA1_BLKSZ,
                            .init_fn = git_hash_sha1_init,
                            .clone_fn = git_hash_sha1_clone,
                            .update_fn = git_hash_sha1_update,
                            .final_fn = git_hash_sha1_final,
                            .final_oid_fn = git_hash_sha1_final_oid,
                            .unsafe_init_fn = git_hash_sha1_init_unsafe,
                            .unsafe_clone_fn = git_hash_sha1_clone_unsafe,
                            .unsafe_update_fn = git_hash_sha1_update_unsafe,
                            .unsafe_final_fn = git_hash_sha1_final_unsafe,
                            .unsafe_final_oid_fn = git_hash_sha1_final_oid_unsafe,
                            .empty_tree = &empty_tree_oid,
                            .empty_blob = &empty_blob_oid,
                            .null_oid = &null_oid_sha1,
                    },
                    {
                            .name = "sha256",
                            .format_id = GIT_SHA256_FORMAT_ID,
                            .rawsz = GIT_SHA256_RAWSZ,
                            .hexsz = GIT_SHA256_HEXSZ,
                            .blksz = GIT_SHA256_BLKSZ,
                            .init_fn = git_hash_sha256_init,
                            .clone_fn = git_hash_sha256_clone,
                            .update_fn = git_hash_sha256_update,
                            .final_fn = git_hash_sha256_final,
                            .final_oid_fn = git_hash_sha256_final_oid,
                            .unsafe_init_fn = git_hash_sha256_init,
                            .unsafe_clone_fn = git_hash_sha256_clone,
                            .unsafe_update_fn = git_hash_sha256_update,
                            .unsafe_final_fn = git_hash_sha256_final,
                            .unsafe_final_oid_fn = git_hash_sha256_final_oid,
                            .empty_tree = &empty_tree_oid_sha256,
                            .empty_blob = &empty_blob_oid_sha256,
                            .null_oid = &null_oid_sha256,
                    }
            };

            const struct object_id *null_oid(void)
            {
                    return the_hash_algo->null_oid;
            }

            const char *empty_tree_oid_hex(const struct git_hash_algo *algop)
            {
                    static char buf[GIT_MAX_HEXSZ + 1];
                    return oid_to_hex_r(buf, algop->empty_tree);
            }

            int hash_algo_by_name(const char *name)
            {
                    int i;
                    if (!name)
                            return GIT_HASH_UNKNOWN;
                    for (i = 1; i < GIT_HASH_NALGOS; i++)
                            if (!strcmp(name, hash_algos[i].name))
                                    return i;
                    return GIT_HASH_UNKNOWN;
            }

            int hash_algo_by_id(uint32_t format_id)
            {
                    int i;
                    for (i = 1; i < GIT_HASH_NALGOS; i++)
                            if (format_id == hash_algos[i].format_id)
                                    return i;
                    return GIT_HASH_UNKNOWN;
            }

            int hash_algo_by_length(int len)
            {
                    int i;
                    for (i = 1; i < GIT_HASH_NALGOS; i++)
                            if (len == hash_algos[i].rawsz)
                                    return i;
                    return GIT_HASH_UNKNOWN;
            }

            /*
            * This is meant to hold a *small* number of objects that you would
            * want repo_read_object_file() to be able to return, but yet you do not want
            * to write them into the object store (e.g. a browse-only
            * application).
            */
            static struct cached_object_entry {
                    struct object_id oid;
                    struct cached_object {
                            enum object_type type;
                            const void *buf;
                            unsigned long size;
                    } value;
            } *cached_objects;
            static int cached_object_nr, cached_object_alloc;

            static const struct cached_object *find_cached_object(const struct object_id *oid)
            {
                    static const struct cached_object empty_tree = {
                            .type = OBJ_TREE,
                            .buf = "",
                    };
                    int i;
                    const struct cached_object_entry *co = cached_objects;

                    for (i = 0; i < cached_object_nr; i++, co++) {
                            if (oideq(&co->oid, oid))
                                    return &co->value;
                    }
                    if (oideq(oid, the_hash_algo->empty_tree))
                            return &empty_tree;
                    return NULL;
            }


            static int get_conv_flags(unsigned flags)
            {
                    if (flags & HASH_RENORMALIZE)
                            return CONV_EOL_RENORMALIZE;
                    else if (flags & HASH_WRITE_OBJECT)
                            return global_conv_flags_eol | CONV_WRITE_OBJECT;
                    else
                            return 0;
            }


            int mkdir_in_gitdir(const char *path)
            {
                    if (mkdir(path, 0777)) {
                            int saved_errno = errno;
                            struct stat st;
                            struct strbuf sb = STRBUF_INIT;

                            if (errno != EEXIST)
                                    return -1;
                            /*
                            * Are we looking at a path in a symlinked worktree
                            * whose original repository does not yet have it?
                            * e.g. .git/rr-cache pointing at its original
                            * repository in which the user hasn't performed any
                            * conflict resolution yet?
                            */
                            if (lstat(path, &st) || !S_ISLNK(st.st_mode) ||
                            strbuf_readlink(&sb, path, st.st_size) ||
                            !is_absolute_path(sb.buf) ||
                            mkdir(sb.buf, 0777)) {
                                    strbuf_release(&sb);
                                    errno = saved_errno;
                                    return -1;
                            }
                            strbuf_release(&sb);
                    }
                    return adjust_shared_perm(path);
            }

            static enum scld_error safe_create_leading_directories_1(char *path, int share)
            {
                    char *next_component = path + offset_1st_component(path);
                    enum scld_error ret = SCLD_OK;

                    while (ret == SCLD_OK && next_component) {
                            struct stat st;
                            char *slash = next_component, slash_character;

                            while (*slash && !is_dir_sep(*slash))
                                    slash++;

                            if (!*slash)
                                    break;

                            next_component = slash + 1;
                            while (is_dir_sep(*next_component))
                                    next_component++;
                            if (!*next_component)
                                    break;

                            slash_character = *slash;
                            *slash = '\0';
                            if (!stat(path, &st)) {
                                    /* path exists */
                                    if (!S_ISDIR(st.st_mode)) {
                                            errno = ENOTDIR;
                                            ret = SCLD_EXISTS;
                                    }
                            } else if (mkdir(path, 0777)) {
                                    if (errno == EEXIST &&
                                    !stat(path, &st) && S_ISDIR(st.st_mode))
                                            ; /* somebody created it since we checked */
                                    else if (errno == ENOENT)
                                            /*
                                            * Either mkdir() failed because
                                            * somebody just pruned the containing
                                            * directory, or stat() failed because
                                            * the file that was in our way was
                                            * just removed.  Either way, inform
                                            * the caller that it might be worth
                                            * trying again:
                                            */
                                            ret = SCLD_VANISHED;
                                    else
                                            ret = SCLD_FAILED;
                            } else if (share && adjust_shared_perm(path)) {
                                    ret = SCLD_PERMS;
                            }
                            *slash = slash_character;
                    }
                    return ret;
            }

            enum scld_error safe_create_leading_directories(char *path)
            {
                    return safe_create_leading_directories_1(path, 1);
            }

            enum scld_error safe_create_leading_directories_no_share(char *path)
            {
                    return safe_create_leading_directories_1(path, 0);
            }

            enum scld_error safe_create_leading_directories_const(const char *path)
            {
                    int save_errno;
                    /* path points to cache entries, so xstrdup before messing with it */
                    char *buf = xstrdup(path);
                    enum scld_error result = safe_create_leading_directories(buf);

                    save_errno = errno;
                    free(buf);
                    errno = save_errno;
                    return result;
            }

            int odb_mkstemp(struct strbuf *temp_filename, const char *pattern)
            {
                    int fd;
                    /*
                    * we let the umask do its job, don't try to be more
                    * restrictive except to remove write permission.
                    */
                    int mode = 0444;
                    git_path_buf(temp_filename, "objects/%s", pattern);
                    fd = git_mkstemp_mode(temp_filename->buf, mode);
                    if (0 <= fd)
                            return fd;

                    /* slow path */
                    /* some mkstemp implementations erase temp_filename on failure */
                    git_path_buf(temp_filename, "objects/%s", pattern);
                    safe_create_leading_directories(temp_filename->buf);
                    return xmkstemp_mode(temp_filename->buf, mode);
            }

            int odb_pack_keep(const char *name)
            {
                    int fd;

                    fd = open(name, O_RDWR|O_CREAT|O_EXCL, 0600);
                    if (0 <= fd)
                            return fd;

                    /* slow path */
                    safe_create_leading_directories_const(name);
                    return open(name, O_RDWR|O_CREAT|O_EXCL, 0600);
            }

            static void fill_loose_path(struct strbuf *buf, const struct object_id *oid)
            {
                    int i;
                    for (i = 0; i < the_hash_algo->rawsz; i++) {
                            static char hex[] = "0123456789abcdef";
                            unsigned int val = oid->hash[i];
                            strbuf_addch(buf, hex[val >> 4]);
                            strbuf_addch(buf, hex[val & 0xf]);
                            if (!i)
                                    strbuf_addch(buf, '/');
                    }
            }

            static const char *odb_loose_path(struct object_directory *odb,
                                            struct strbuf *buf,
                                            const struct object_id *oid)
            {
                    strbuf_reset(buf);
                    strbuf_addstr(buf, odb->path);
                    strbuf_addch(buf, '/');
                    fill_loose_path(buf, oid);
                    return buf->buf;
            }

            const char *loose_object_path(struct repository *r, struct strbuf *buf,
                                    const struct object_id *oid)
            {
                    return odb_loose_path(r->objects->odb, buf, oid);
            }

            /*
            * Return non-zero iff the path is usable as an alternate object database.
            */
            static int alt_odb_usable(struct raw_object_store *o,
                                    struct strbuf *path,
                                    const char *normalized_objdir, khiter_t *pos)
            {
                    int r;

                    /* Detect cases where alternate disappeared */
                    if (!is_directory(path->buf)) {
                            error(_("object directory %s does not exist; "
                                    "check .git/objects/info/alternates"),
                            path->buf);
                            return 0;
                    }

                    /*
                    * Prevent the common mistake of listing the same
                    * thing twice, or object directory itself.
                    */
                    if (!o->odb_by_path) {
                            khiter_t p;

                            o->odb_by_path = kh_init_odb_path_map();
                            assert(!o->odb->next);
                            p = kh_put_odb_path_map(o->odb_by_path, o->odb->path, &r);
                            assert(r == 1); /* never used */
                            kh_value(o->odb_by_path, p) = o->odb;
                    }
                    if (fspatheq(path->buf, normalized_objdir))
                            return 0;
                    *pos = kh_put_odb_path_map(o->odb_by_path, path->buf, &r);
                    /* r: 0 = exists, 1 = never used, 2 = deleted */
                    return r == 0 ? 0 : 1;
            }

            /*
            * Prepare alternate object database registry.
            *
            * The variable alt_odb_list points at the list of struct
            * object_directory.  The elements on this list come from
            * non-empty elements from colon separated ALTERNATE_DB_ENVIRONMENT
            * environment variable, and $GIT_OBJECT_DIRECTORY/info/alternates,
            * whose contents is similar to that environment variable but can be
            * LF separated.  Its base points at a statically allocated buffer that
            * contains "/the/directory/corresponding/to/.git/objects/...", while
            * its name points just after the slash at the end of ".git/objects/"
            * in the example above, and has enough space to hold all hex characters
            * of the object ID, an extra slash for the first level indirection, and
            * the terminating NUL.
            */
            static void read_info_alternates(struct repository *r,
                                            const char *relative_base,
                                            int depth);
            static int link_alt_odb_entry(struct repository *r, const struct strbuf *entry,
                    const char *relative_base, int depth, const char *normalized_objdir)
            {
                    struct object_directory *ent;
                    struct strbuf pathbuf = STRBUF_INIT;
                    struct strbuf tmp = STRBUF_INIT;
                    khiter_t pos;
                    int ret = -1;

                    if (!is_absolute_path(entry->buf) && relative_base) {
                            strbuf_realpath(&pathbuf, relative_base, 1);
                            strbuf_addch(&pathbuf, '/');
                    }
                    strbuf_addbuf(&pathbuf, entry);

                    if (!strbuf_realpath(&tmp, pathbuf.buf, 0)) {
                            error(_("unable to normalize alternate object path: %s"),
                            pathbuf.buf);
                            goto error;
                    }
                    strbuf_swap(&pathbuf, &tmp);

                    /*
                    * The trailing slash after the directory name is given by
                    * this function at the end. Remove duplicates.
                    */
                    while (pathbuf.len && pathbuf.buf[pathbuf.len - 1] == '/')
                            strbuf_setlen(&pathbuf, pathbuf.len - 1);

                    if (!alt_odb_usable(r->objects, &pathbuf, normalized_objdir, &pos))
                            goto error;

                    CALLOC_ARRAY(ent, 1);
                    /* pathbuf.buf is already in r->objects->odb_by_path */
                    ent->path = strbuf_detach(&pathbuf, NULL);

                    /* add the alternate entry */
                    *r->objects->odb_tail = ent;
                    r->objects->odb_tail = &(ent->next);
                    ent->next = NULL;
                    assert(r->objects->odb_by_path);
                    kh_value(r->objects->odb_by_path, pos) = ent;

                    /* recursively add alternates */
                    read_info_alternates(r, ent->path, depth + 1);
                    ret = 0;
            error:
                    strbuf_release(&tmp);
                    strbuf_release(&pathbuf);
                    return ret;
            }

            static const char *parse_alt_odb_entry(const char *string,
                                            int sep,
                                            struct strbuf *out)
            {
                    const char *end;

                    strbuf_reset(out);

                    if (*string == '#') {
                            /* comment; consume up to next separator */
                            end = strchrnul(string, sep);
                    } else if (*string == '"' && !unquote_c_style(out, string, &end)) {
                            /*
                            * quoted path; unquote_c_style has copied the
                            * data for us and set "end". Broken quoting (e.g.,
                            * an entry that doesn't end with a quote) falls
                            * back to the unquoted case below.
                            */
                    } else {
                            /* normal, unquoted path */
                            end = strchrnul(string, sep);
                            strbuf_add(out, string, end - string);
                    }

                    if (*end)
                            end++;
                    return end;
            }

            static void link_alt_odb_entries(struct repository *r, const char *alt,
                                            int sep, const char *relative_base, int depth)
            {
                    struct strbuf objdirbuf = STRBUF_INIT;
                    struct strbuf entry = STRBUF_INIT;

                    if (!alt || !*alt)
                            return;

                    if (depth > 5) {
                            error(_("%s: ignoring alternate object stores, nesting too deep"),
                                            relative_base);
                            return;
                    }

                    strbuf_realpath(&objdirbuf, r->objects->odb->path, 1);

                    while (*alt) {
                            alt = parse_alt_odb_entry(alt, sep, &entry);
                            if (!entry.len)
                                    continue;
                            link_alt_odb_entry(r, &entry,
                                            relative_base, depth, objdirbuf.buf);
                    }
                    strbuf_release(&entry);
                    strbuf_release(&objdirbuf);
            }

            static void read_info_alternates(struct repository *r,
                                            const char *relative_base,
                                            int depth)
            {
                    char *path;
                    struct strbuf buf = STRBUF_INIT;

                    path = xstrfmt("%s/info/alternates", relative_base);
                    if (strbuf_read_file(&buf, path, 1024) < 0) {
                            warn_on_fopen_errors(path);
                            free(path);
                            return;
                    }

                    link_alt_odb_entries(r, buf.buf, '\n', relative_base, depth);
                    strbuf_release(&buf);
                    free(path);
            }

            void add_to_alternates_file(const char *reference)
            {
                    struct lock_file lock = LOCK_INIT;
                    char *alts = git_pathdup("objects/info/alternates");
                    FILE *in, *out;
                    int found = 0;

                    hold_lock_file_for_update(&lock, alts, LOCK_DIE_ON_ERROR);
                    out = fdopen_lock_file(&lock, "w");
                    if (!out)
                            die_errno(_("unable to fdopen alternates lockfile"));

                    in = fopen(alts, "r");
                    if (in) {
                            struct strbuf line = STRBUF_INIT;

                            while (strbuf_getline(&line, in) != EOF) {
                                    if (!strcmp(reference, line.buf)) {
                                            found = 1;
                                            break;
                                    }
                                    fprintf_or_die(out, "%s\n", line.buf);
                            }

                            strbuf_release(&line);
                            fclose(in);
                    }
                    else if (errno != ENOENT)
                            die_errno(_("unable to read alternates file"));

                    if (found) {
                            rollback_lock_file(&lock);
                    } else {
                            fprintf_or_die(out, "%s\n", reference);
                            if (commit_lock_file(&lock))
                                    die_errno(_("unable to move new alternates file into place"));
                            if (the_repository->objects->loaded_alternates)
                                    link_alt_odb_entries(the_repository, reference,
                                                    '\n', NULL, 0);
                    }
                    free(alts);
            }

            void add_to_alternates_memory(const char *reference)
            {
                    /*
                    * Make sure alternates are initialized, or else our entry may be
                    * overwritten when they are.
                    */
                    prepare_alt_odb(the_repository);

                    link_alt_odb_entries(the_repository, reference,
                                    '\n', NULL, 0);
            }

            struct object_directory *set_temporary_primary_odb(const char *dir, int will_destroy)
            {
                    struct object_directory *new_odb;

                    /*
                    * Make sure alternates are initialized, or else our entry may be
                    * overwritten when they are.
                    */
                    prepare_alt_odb(the_repository);

                    /*
                    * Make a new primary odb and link the old primary ODB in as an
                    * alternate
                    */
                    new_odb = xcalloc(1, sizeof(*new_odb));
                    new_odb->path = xstrdup(dir);

                    /*
                    * Disable ref updates while a temporary odb is active, since
                    * the objects in the database may roll back.
                    */
                    new_odb->disable_ref_updates = 1;
                    new_odb->will_destroy = will_destroy;
                    new_odb->next = the_repository->objects->odb;
                    the_repository->objects->odb = new_odb;
                    return new_odb->next;
            }

            void restore_primary_odb(struct object_directory *restore_odb, const char *old_path)
            {
                    struct object_directory *cur_odb = the_repository->objects->odb;

                    if (strcmp(old_path, cur_odb->path))
                            BUG("expected %s as primary object store; found %s",
                            old_path, cur_odb->path);

                    if (cur_odb->next != restore_odb)
                            BUG("we expect the old primary object store to be the first alternate");

                    the_repository->objects->odb = restore_odb;
                    free_object_directory(cur_odb);
            }

            /*
            * Compute the exact path an alternate is at and returns it. In case of
            * error NULL is returned and the human readable error is added to `err`
            * `path` may be relative and should point to $GIT_DIR.
            * `err` must not be null.
            */
            char *compute_alternate_path(const char *path, struct strbuf *err)
            {
                    char *ref_git = NULL;
                    const char *repo;
                    int seen_error = 0;

                    ref_git = real_pathdup(path, 0);
                    if (!ref_git) {
                            seen_error = 1;
                            strbuf_addf(err, _("path '%s' does not exist"), path);
                            goto out;
                    }

                    repo = read_gitfile(ref_git);
                    if (!repo)
                            repo = read_gitfile(mkpath("%s/.git", ref_git));
                    if (repo) {
                            free(ref_git);
                            ref_git = xstrdup(repo);
                    }

                    if (!repo && is_directory(mkpath("%s/.git/objects", ref_git))) {
                            char *ref_git_git = mkpathdup("%s/.git", ref_git);
                            free(ref_git);
                            ref_git = ref_git_git;
                    } else if (!is_directory(mkpath("%s/objects", ref_git))) {
                            struct strbuf sb = STRBUF_INIT;
                            seen_error = 1;
                            if (get_common_dir(&sb, ref_git)) {
                                    strbuf_addf(err,
                                            _("reference repository '%s' as a linked "
                                            "checkout is not supported yet."),
                                            path);
                                    goto out;
                            }

                            strbuf_addf(err, _("reference repository '%s' is not a "
                                                    "local repository."), path);
                            goto out;
                    }

                    if (!access(mkpath("%s/shallow", ref_git), F_OK)) {
                            strbuf_addf(err, _("reference repository '%s' is shallow"),
                                    path);
                            seen_error = 1;
                            goto out;
                    }

                    if (!access(mkpath("%s/info/grafts", ref_git), F_OK)) {
                            strbuf_addf(err,
                                    _("reference repository '%s' is grafted"),
                                    path);
                            seen_error = 1;
                            goto out;
                    }

            out:
                    if (seen_error) {
                            FREE_AND_NULL(ref_git);
                    }

                    return ref_git;
            }

            struct object_directory *find_odb(struct repository *r, const char *obj_dir)
            {
                    struct object_directory *odb;
                    char *obj_dir_real = real_pathdup(obj_dir, 1);
                    struct strbuf odb_path_real = STRBUF_INIT;

                    prepare_alt_odb(r);
                    for (odb = r->objects->odb; odb; odb = odb->next) {
                            strbuf_realpath(&odb_path_real, odb->path, 1);
                            if (!strcmp(obj_dir_real, odb_path_real.buf))
                                    break;
                    }

                    free(obj_dir_real);
                    strbuf_release(&odb_path_real);

                    if (!odb)
                            die(_("could not find object directory matching %s"), obj_dir);
                    return odb;
            }

            static void fill_alternate_refs_command(struct child_process *cmd,
                                                    const char *repo_path)
            {
                    const char *value;

                    if (!git_config_get_value("core.alternateRefsCommand", &value)) {
                            cmd->use_shell = 1;

                            strvec_push(&cmd->args, value);
                            strvec_push(&cmd->args, repo_path);
                    } else {
                            cmd->git_cmd = 1;

                            strvec_pushf(&cmd->args, "--git-dir=%s", repo_path);
                            strvec_push(&cmd->args, "for-each-ref");
                            strvec_push(&cmd->args, "--format=%(objectname)");

                            if (!git_config_get_value("core.alternateRefsPrefixes", &value)) {
                                    strvec_push(&cmd->args, "--");
                                    strvec_split(&cmd->args, value);
                            }
                    }

                    strvec_pushv(&cmd->env, (const char **)local_repo_env);
                    cmd->out = -1;
            }

            static void read_alternate_refs(const char *path,
                                            alternate_ref_fn *cb,
                                            void *data)
            {
                    struct child_process cmd = CHILD_PROCESS_INIT;
                    struct strbuf line = STRBUF_INIT;
                    FILE *fh;

                    fill_alternate_refs_command(&cmd, path);

                    if (start_command(&cmd))
                            return;

                    fh = xfdopen(cmd.out, "r");
                    while (strbuf_getline_lf(&line, fh) != EOF) {
                            struct object_id oid;
                            const char *p;

                            if (parse_oid_hex(line.buf, &oid, &p) || *p) {
                                    warning(_("invalid line while parsing alternate refs: %s"),
                                            line.buf);
                                    break;
                            }

                            cb(&oid, data);
                    }

                    fclose(fh);
                    finish_command(&cmd);
                    strbuf_release(&line);
            }

            struct alternate_refs_data {
                    alternate_ref_fn *fn;
                    void *data;
            };

            static int refs_from_alternate_cb(struct object_directory *e,
                                            void *data)
            {
                    struct strbuf path = STRBUF_INIT;
                    size_t base_len;
                    struct alternate_refs_data *cb = data;

                    if (!strbuf_realpath(&path, e->path, 0))
                            goto out;
                    if (!strbuf_strip_suffix(&path, "/objects"))
                            goto out;
                    base_len = path.len;

                    /* Is this a git repository with refs? */
                    strbuf_addstr(&path, "/refs");
                    if (!is_directory(path.buf))
                            goto out;
                    strbuf_setlen(&path, base_len);

                    read_alternate_refs(path.buf, cb->fn, cb->data);

            out:
                    strbuf_release(&path);
                    return 0;
            }

            void for_each_alternate_ref(alternate_ref_fn fn, void *data)
            {
                    struct alternate_refs_data cb;
                    cb.fn = fn;
                    cb.data = data;
                    foreach_alt_odb(refs_from_alternate_cb, &cb);
            }

            int foreach_alt_odb(alt_odb_fn fn, void *cb)
            {
                    struct object_directory *ent;
                    int r = 0;

                    prepare_alt_odb(the_repository);
                    for (ent = the_repository->objects->odb->next; ent; ent = ent->next) {
                            r = fn(ent, cb);
                            if (r)
                                    break;
                    }
                    return r;
            }

            void prepare_alt_odb(struct repository *r)
            {
                    if (r->objects->loaded_alternates)
                            return;

                    link_alt_odb_entries(r, r->objects->alternate_db, PATH_SEP, NULL, 0);

                    read_info_alternates(r, r->objects->odb->path, 0);
                    r->objects->loaded_alternates = 1;
            }

            int has_alt_odb(struct repository *r)
            {
                    prepare_alt_odb(r);
                    return !!r->objects->odb->next;
            }

            /* Returns 1 if we have successfully freshened the file, 0 otherwise. */
            static int freshen_file(const char *fn)
            {
                    return !utime(fn, NULL);
            }

            /*
            * All of the check_and_freshen functions return 1 if the file exists and was
            * freshened (if freshening was requested), 0 otherwise. If they return
            * 0, you should not assume that it is safe to skip a write of the object (it
            * either does not exist on disk, or has a stale mtime and may be subject to
            * pruning).
            */
            int check_and_freshen_file(const char *fn, int freshen)
            {
                    if (access(fn, F_OK))
                            return 0;
                    if (freshen && !freshen_file(fn))
                            return 0;
                    return 1;
            }

            static int check_and_freshen_odb(struct object_directory *odb,
                                            const struct object_id *oid,
                                            int freshen)
            {
                    static struct strbuf path = STRBUF_INIT;
                    odb_loose_path(odb, &path, oid);
                    return check_and_freshen_file(path.buf, freshen);
            }

            static int check_and_freshen_local(const struct object_id *oid, int freshen)
            {
                    return check_and_freshen_odb(the_repository->objects->odb, oid, freshen);
            }

            static int check_and_freshen_nonlocal(const struct object_id *oid, int freshen)
            {
                    struct object_directory *odb;

                    prepare_alt_odb(the_repository);
                    for (odb = the_repository->objects->odb->next; odb; odb = odb->next) {
                            if (check_and_freshen_odb(odb, oid, freshen))
                                    return 1;
                    }
                    return 0;
            }

            static int check_and_freshen(const struct object_id *oid, int freshen)
            {
                    return check_and_freshen_local(oid, freshen) ||
                    check_and_freshen_nonlocal(oid, freshen);
            }

            int has_loose_object_nonlocal(const struct object_id *oid)
            {
                    return check_and_freshen_nonlocal(oid, 0);
            }

            int has_loose_object(const struct object_id *oid)
            {
                    return check_and_freshen(oid, 0);
            }

            static void mmap_limit_check(size_t length)
            {
                    static size_t limit = 0;
                    if (!limit) {
                            limit = git_env_ulong("GIT_MMAP_LIMIT", 0);
                            if (!limit)
                                    limit = SIZE_MAX;
                    }
                    if (length > limit)
                            die(_("attempting to mmap %"PRIuMAX" over limit %"PRIuMAX),
                            (uintmax_t)length, (uintmax_t)limit);
            }

            void *xmmap_gently(void *start, size_t length,
                            int prot, int flags, int fd, off_t offset)
            {
                    void *ret;

                    mmap_limit_check(length);
                    ret = mmap(start, length, prot, flags, fd, offset);
                    if (ret == MAP_FAILED && !length)
                            ret = NULL;
                    return ret;
            }

            const char *mmap_os_err(void)
            {
                    static const char blank[] = "";
            #if defined(__linux__)
                    if (errno == ENOMEM) {
                            /* this continues an existing error message: */
                            static const char enomem[] =
            ", check sys.vm.max_map_count and/or RLIMIT_DATA";
                            return enomem;
                    }
            #endif /* OS-specific bits */
                    return blank;
            }

            void *xmmap(void *start, size_t length,
                    int prot, int flags, int fd, off_t offset)
            {
                    void *ret = xmmap_gently(start, length, prot, flags, fd, offset);
                    if (ret == MAP_FAILED)
                            die_errno(_("mmap failed%s"), mmap_os_err());
                    return ret;
            }

            static int format_object_header_literally(char *str, size_t size,
                                                    const char *type, size_t objsize)
            {
                    return xsnprintf(str, size, "%s %"PRIuMAX, type, (uintmax_t)objsize) + 1;
            }

            int format_object_header(char *str, size_t size, enum object_type type,
                                    size_t objsize)
            {
                    const char *name = type_name(type);

                    if (!name)
                            BUG("could not get a type name for 'enum object_type' value %d", type);

                    return format_object_header_literally(str, size, name, objsize);
            }

            int check_object_signature(struct repository *r, const struct object_id *oid,
                                    void *buf, unsigned long size,
                                    enum object_type type)
            {
                    const struct git_hash_algo *algo =
                            oid->algo ? &hash_algos[oid->algo] : r->hash_algo;
                    struct object_id real_oid;

                    hash_object_file(algo, buf, size, type, &real_oid);

                    return !oideq(oid, &real_oid) ? -1 : 0;
            }

            int stream_object_signature(struct repository *r, const struct object_id *oid)
            {
                    struct object_id real_oid;
                    unsigned long size;
                    enum object_type obj_type;
                    struct git_istream *st;
                    git_hash_ctx c;
                    char hdr[MAX_HEADER_LEN];
                    int hdrlen;

                    st = open_istream(r, oid, &obj_type, &size, NULL);
                    if (!st)
                            return -1;

                    /* Generate the header */
                    hdrlen = format_object_header(hdr, sizeof(hdr), obj_type, size);

                    /* Sha1.. */
                    r->hash_algo->init_fn(&c);
                    r->hash_algo->update_fn(&c, hdr, hdrlen);
                    for (;;) {
                            char buf[1024 * 16];
                            ssize_t readlen = read_istream(st, buf, sizeof(buf));

                            if (readlen < 0) {
                                    close_istream(st);
                                    return -1;
                            }
                            if (!readlen)
                                    break;
                            r->hash_algo->update_fn(&c, buf, readlen);
                    }
                    r->hash_algo->final_oid_fn(&real_oid, &c);
                    close_istream(st);
                    return !oideq(oid, &real_oid) ? -1 : 0;
            }

            int git_open_cloexec(const char *name, int flags)
            {
                    int fd;
                    static int o_cloexec = O_CLOEXEC;

                    fd = open(name, flags | o_cloexec);
                    if ((o_cloexec & O_CLOEXEC) && fd < 0 && errno == EINVAL) {
                            /* Try again w/o O_CLOEXEC: the kernel might not support it */
                            o_cloexec &= ~O_CLOEXEC;
                            fd = open(name, flags | o_cloexec);
                    }

            #if defined(F_GETFD) && defined(F_SETFD) && defined(FD_CLOEXEC)
                    {
                            static int fd_cloexec = FD_CLOEXEC;

                            if (!o_cloexec && 0 <= fd && fd_cloexec) {
                                    /* Opened w/o O_CLOEXEC?  try with fcntl(2) to add it */
                                    int flags = fcntl(fd, F_GETFD);
                                    if (fcntl(fd, F_SETFD, flags | fd_cloexec))
                                            fd_cloexec = 0;
                            }
                    }
            #endif
                    return fd;
            }

            /*
            * Find "oid" as a loose object in the local repository or in an alternate.
            * Returns 0 on success, negative on failure.
            *
            * The "path" out-parameter will give the path of the object we found (if any).
            * Note that it may point to static storage and is only valid until another
            * call to stat_loose_object().
            */
            static int stat_loose_object(struct repository *r, const struct object_id *oid,
                                    struct stat *st, const char **path)
            {
                    struct object_directory *odb;
                    static struct strbuf buf = STRBUF_INIT;

                    prepare_alt_odb(r);
                    for (odb = r->objects->odb; odb; odb = odb->next) {
                            *path = odb_loose_path(odb, &buf, oid);
                            if (!lstat(*path, st))
                                    return 0;
                    }

                    return -1;
            }

            /*
            * Like stat_loose_object(), but actually open the object and return the
            * descriptor. See the caveats on the "path" parameter above.
            */
            static int open_loose_object(struct repository *r,
                                    const struct object_id *oid, const char **path)
            {
                    int fd;
                    struct object_directory *odb;
                    int most_interesting_errno = ENOENT;
                    static struct strbuf buf = STRBUF_INIT;

                    prepare_alt_odb(r);
                    for (odb = r->objects->odb; odb; odb = odb->next) {
                            *path = odb_loose_path(odb, &buf, oid);
                            fd = git_open(*path);
                            if (fd >= 0)
                                    return fd;

                            if (most_interesting_errno == ENOENT)
                                    most_interesting_errno = errno;
                    }
                    errno = most_interesting_errno;
                    return -1;
            }

            static int quick_has_loose(struct repository *r,
                                    const struct object_id *oid)
            {
                    struct object_directory *odb;

                    prepare_alt_odb(r);
                    for (odb = r->objects->odb; odb; odb = odb->next) {
                            if (oidtree_contains(odb_loose_cache(odb, oid), oid))
                                    return 1;
                    }
                    return 0;
            }

            /*
            * Map and close the given loose object fd. The path argument is used for
            * error reporting.
            */
            static void *map_fd(int fd, const char *path, unsigned long *size)
            {
                    void *map = NULL;
                    struct stat st;

                    if (!fstat(fd, &st)) {
                            *size = xsize_t(st.st_size);
                            if (!*size) {
                                    /* mmap() is forbidden on empty files */
                                    error(_("object file %s is empty"), path);
                                    close(fd);
                                    return NULL;
                            }
                            map = xmmap(NULL, *size, PROT_READ, MAP_PRIVATE, fd, 0);
                    }
                    close(fd);
                    return map;
            }

            void *map_loose_object(struct repository *r,
                            const struct object_id *oid,
                            unsigned long *size)
            {
                    const char *p;
                    int fd = open_loose_object(r, oid, &p);

                    if (fd < 0)
                            return NULL;
                    return map_fd(fd, p, size);
            }

            enum unpack_loose_header_result unpack_loose_header(git_zstream *stream,
                                                            unsigned char *map,
                                                            unsigned long mapsize,
                                                            void *buffer,
                                                            unsigned long bufsiz,
                                                            struct strbuf *header)
            {
                    int status;

                    /* Get the data stream */
                    memset(stream, 0, sizeof(*stream));
                    stream->next_in = map;
                    stream->avail_in = mapsize;
                    stream->next_out = buffer;
                    stream->avail_out = bufsiz;

                    git_inflate_init(stream);
                    obj_read_unlock();
                    status = git_inflate(stream, 0);
                    obj_read_lock();
                    if (status < Z_OK)
                            return ULHR_BAD;

                    /*
                    * Check if entire header is unpacked in the first iteration.
                    */
                    if (memchr(buffer, '\0', stream->next_out - (unsigned char *)buffer))
                            return ULHR_OK;

                    /*
                    * We have a header longer than MAX_HEADER_LEN. The "header"
                    * here is only non-NULL when we run "cat-file
                    * --allow-unknown-type".
                    */
                    if (!header)
                            return ULHR_TOO_LONG;

                    /*
                    * buffer[0..bufsiz] was not large enough.  Copy the partial
                    * result out to header, and then append the result of further
                    * reading the stream.
                    */
                    strbuf_add(header, buffer, stream->next_out - (unsigned char *)buffer);
                    stream->next_out = buffer;
                    stream->avail_out = bufsiz;

                    do {
                            obj_read_unlock();
                            status = git_inflate(stream, 0);
                            obj_read_lock();
                            strbuf_add(header, buffer, stream->next_out - (unsigned char *)buffer);
                            if (memchr(buffer, '\0', stream->next_out - (unsigned char *)buffer))
                                    return 0;
                            stream->next_out = buffer;
                            stream->avail_out = bufsiz;
                    } while (status != Z_STREAM_END);
                    return ULHR_TOO_LONG;
            }

            static void *unpack_loose_rest(git_zstream *stream,
                                    void *buffer, unsigned long size,
                                    const struct object_id *oid)
            {
                    int bytes = strlen(buffer) + 1;
                    unsigned char *buf = xmallocz(size);
                    unsigned long n;
                    int status = Z_OK;

                    n = stream->total_out - bytes;
                    if (n > size)
                            n = size;
                    memcpy(buf, (char *) buffer + bytes, n);
                    bytes = n;
                    if (bytes <= size) {
                            /*
                            * The above condition must be (bytes <= size), not
                            * (bytes < size).  In other words, even though we
                            * expect no more output and set avail_out to zero,
                            * the input zlib stream may have bytes that express
                            * "this concludes the stream", and we *do* want to
                            * eat that input.
                            *
                            * Otherwise we would not be able to test that we
                            * consumed all the input to reach the expected size;
                            * we also want to check that zlib tells us that all
                            * went well with status == Z_STREAM_END at the end.
                            */
                            stream->next_out = buf + bytes;
                            stream->avail_out = size - bytes;
                            while (status == Z_OK) {
                                    obj_read_unlock();
                                    status = git_inflate(stream, Z_FINISH);
                                    obj_read_lock();
                            }
                    }
                    if (status == Z_STREAM_END && !stream->avail_in) {
                            git_inflate_end(stream);
                            return buf;
                    }

                    if (status < 0)
                            error(_("corrupt loose object '%s'"), oid_to_hex(oid));
                    else if (stream->avail_in)
                            error(_("garbage at end of loose object '%s'"),
                            oid_to_hex(oid));
                    free(buf);
                    return NULL;
            }

            /*
            * We used to just use "sscanf()", but that's actually way
            * too permissive for what we want to check. So do an anal
            * object header parse by hand.
            */
            int parse_loose_header(const char *hdr, struct object_info *oi)
            {
                    const char *type_buf = hdr;
                    size_t size;
                    int type, type_len = 0;

                    /*
                    * The type can be of any size but is followed by
                    * a space.
                    */
                    for (;;) {
                            char c = *hdr++;
                            if (!c)
                                    return -1;
                            if (c == ' ')
                                    break;
                            type_len++;
                    }

                    type = type_from_string_gently(type_buf, type_len, 1);
                    if (oi->type_name)
                            strbuf_add(oi->type_name, type_buf, type_len);
                    if (oi->typep)
                            *oi->typep = type;

                    /*
                    * The length must follow immediately, and be in canonical
                    * decimal format (ie "010" is not valid).
                    */
                    size = *hdr++ - '0';
                    if (size > 9)
                            return -1;
                    if (size) {
                            for (;;) {
                                    unsigned long c = *hdr - '0';
                                    if (c > 9)
                                            break;
                                    hdr++;
                                    size = st_add(st_mult(size, 10), c);
                            }
                    }

                    if (oi->sizep)
                            *oi->sizep = cast_size_t_to_ulong(size);

                    /*
                    * The length must be followed by a zero byte
                    */
                    if (*hdr)
                            return -1;

                    /*
                    * The format is valid, but the type may still be bogus. The
                    * Caller needs to check its oi->typep.
                    */
                    return 0;
            }

            static int loose_object_info(struct repository *r,
                                    const struct object_id *oid,
                                    struct object_info *oi, int flags)
            {
                    int status = 0;
                    int fd;
                    unsigned long mapsize;
                    const char *path;
                    void *map;
                    git_zstream stream;
                    char hdr[MAX_HEADER_LEN];
                    struct strbuf hdrbuf = STRBUF_INIT;
                    unsigned long size_scratch;
                    enum object_type type_scratch;
                    int allow_unknown = flags & OBJECT_INFO_ALLOW_UNKNOWN_TYPE;

                    if (oi->delta_base_oid)
                            oidclr(oi->delta_base_oid, the_repository->hash_algo);

                    /*
                    * If we don't care about type or size, then we don't
                    * need to look inside the object at all. Note that we
                    * do not optimize out the stat call, even if the
                    * caller doesn't care about the disk-size, since our
                    * return value implicitly indicates whether the
                    * object even exists.
                    */
                    if (!oi->typep && !oi->type_name && !oi->sizep && !oi->contentp) {
                            struct stat st;
                            if (!oi->disk_sizep && (flags & OBJECT_INFO_QUICK))
                                    return quick_has_loose(r, oid) ? 0 : -1;
                            if (stat_loose_object(r, oid, &st, &path) < 0)
                                    return -1;
                            if (oi->disk_sizep)
                                    *oi->disk_sizep = st.st_size;
                            return 0;
                    }

                    fd = open_loose_object(r, oid, &path);
                    if (fd < 0) {
                            if (errno != ENOENT)
                                    error_errno(_("unable to open loose object %s"), oid_to_hex(oid));
                            return -1;
                    }
                    map = map_fd(fd, path, &mapsize);
                    if (!map)
                            return -1;

                    if (!oi->sizep)
                            oi->sizep = &size_scratch;
                    if (!oi->typep)
                            oi->typep = &type_scratch;

                    if (oi->disk_sizep)
                            *oi->disk_sizep = mapsize;

                    switch (unpack_loose_header(&stream, map, mapsize, hdr, sizeof(hdr),
                                            allow_unknown ? &hdrbuf : NULL)) {
                    case ULHR_OK:
                            if (parse_loose_header(hdrbuf.len ? hdrbuf.buf : hdr, oi) < 0)
                                    status = error(_("unable to parse %s header"), oid_to_hex(oid));
                            else if (!allow_unknown && *oi->typep < 0)
                                    die(_("invalid object type"));

                            if (!oi->contentp)
                                    break;
                            *oi->contentp = unpack_loose_rest(&stream, hdr, *oi->sizep, oid);
                            if (*oi->contentp)
                                    goto cleanup;

                            status = -1;
                            break;
                    case ULHR_BAD:
                            status = error(_("unable to unpack %s header"),
                                    oid_to_hex(oid));
                            break;
                    case ULHR_TOO_LONG:
                            status = error(_("header for %s too long, exceeds %d bytes"),
                                    oid_to_hex(oid), MAX_HEADER_LEN);
                            break;
                    }

                    if (status && (flags & OBJECT_INFO_DIE_IF_CORRUPT))
                            die(_("loose object %s (stored in %s) is corrupt"),
                            oid_to_hex(oid), path);

                    git_inflate_end(&stream);
            cleanup:
                    munmap(map, mapsize);
                    if (oi->sizep == &size_scratch)
                            oi->sizep = NULL;
                    strbuf_release(&hdrbuf);
                    if (oi->typep == &type_scratch)
                            oi->typep = NULL;
                    oi->whence = OI_LOOSE;
                    return status;
            }

            int obj_read_use_lock = 0;
            pthread_mutex_t obj_read_mutex;

            void enable_obj_read_lock(void)
            {
                    if (obj_read_use_lock)
                            return;

                    obj_read_use_lock = 1;
                    init_recursive_mutex(&obj_read_mutex);
            }

            void disable_obj_read_lock(void)
            {
                    if (!obj_read_use_lock)
                            return;

                    obj_read_use_lock = 0;
                    pthread_mutex_destroy(&obj_read_mutex);
            }

            int fetch_if_missing = 1;

            static int do_oid_object_info_extended(struct repository *r,
                                            const struct object_id *oid,
                                            struct object_info *oi, unsigned flags)
            {
                    static struct object_info blank_oi = OBJECT_INFO_INIT;
                    const struct cached_object *co;
                    struct pack_entry e;
                    int rtype;
                    const struct object_id *real = oid;
                    int already_retried = 0;


                    if (flags & OBJECT_INFO_LOOKUP_REPLACE)
                            real = lookup_replace_object(r, oid);

                    if (is_null_oid(real))
                            return -1;

                    if (!oi)
                            oi = &blank_oi;

                    co = find_cached_object(real);
                    if (co) {
                            if (oi->typep)
                                    *(oi->typep) = co->type;
                            if (oi->sizep)
                                    *(oi->sizep) = co->size;
                            if (oi->disk_sizep)
                                    *(oi->disk_sizep) = 0;
                            if (oi->delta_base_oid)
                                    oidclr(oi->delta_base_oid, the_repository->hash_algo);
                            if (oi->type_name)
                                    strbuf_addstr(oi->type_name, type_name(co->type));
                            if (oi->contentp)
                                    *oi->contentp = xmemdupz(co->buf, co->size);
                            oi->whence = OI_CACHED;
                            return 0;
                    }

                    while (1) {
                            if (find_pack_entry(r, real, &e))
                                    break;

                            /* Most likely it's a loose object. */
                            if (!loose_object_info(r, real, oi, flags))
                                    return 0;

                            /* Not a loose object; someone else may have just packed it. */
                            if (!(flags & OBJECT_INFO_QUICK)) {
                                    reprepare_packed_git(r);
                                    if (find_pack_entry(r, real, &e))
                                            break;
                            }

                            /*
                            * If r is the_repository, this might be an attempt at
                            * accessing a submodule object as if it were in the_repository
                            * (having called add_submodule_odb() on that submodule's ODB).
                            * If any such ODBs exist, register them and try again.
                            */
                            if (r == the_repository &&
                            register_all_submodule_odb_as_alternates())
                                    /* We added some alternates; retry */
                                    continue;

                            /* Check if it is a missing object */
                            if (fetch_if_missing && repo_has_promisor_remote(r) &&
                            !already_retried &&
                            !(flags & OBJECT_INFO_SKIP_FETCH_OBJECT)) {
                                    promisor_remote_get_direct(r, real, 1);
                                    already_retried = 1;
                                    continue;
                            }

                            if (flags & OBJECT_INFO_DIE_IF_CORRUPT) {
                                    const struct packed_git *p;
                                    if ((flags & OBJECT_INFO_LOOKUP_REPLACE) && !oideq(real, oid))
                                            die(_("replacement %s not found for %s"),
                                            oid_to_hex(real), oid_to_hex(oid));
                                    if ((p = has_packed_and_bad(r, real)))
                                            die(_("packed object %s (stored in %s) is corrupt"),
                                            oid_to_hex(real), p->pack_name);
                            }
                            return -1;
                    }

                    if (oi == &blank_oi)
                            /*
                            * We know that the caller doesn't actually need the
                            * information below, so return early.
                            */
                            return 0;
                    rtype = packed_object_info(r, e.p, e.offset, oi);
                    if (rtype < 0) {
                            mark_bad_packed_object(e.p, real);
                            return do_oid_object_info_extended(r, real, oi, 0);
                    } else if (oi->whence == OI_PACKED) {
                            oi->u.packed.offset = e.offset;
                            oi->u.packed.pack = e.p;
                            oi->u.packed.is_delta = (rtype == OBJ_REF_DELTA ||
                                                    rtype == OBJ_OFS_DELTA);
                    }

                    return 0;
            }

            static int oid_object_info_convert(struct repository *r,
                                            const struct object_id *input_oid,
                                            struct object_info *input_oi, unsigned flags)
            {
                    const struct git_hash_algo *input_algo = &hash_algos[input_oid->algo];
                    int do_die = flags & OBJECT_INFO_DIE_IF_CORRUPT;
                    struct strbuf type_name = STRBUF_INIT;
                    struct object_id oid, delta_base_oid;
                    struct object_info new_oi, *oi;
                    unsigned long size;
                    void *content;
                    int ret;

                    if (repo_oid_to_algop(r, input_oid, the_hash_algo, &oid)) {
                            if (do_die)
                                    die(_("missing mapping of %s to %s"),
                                    oid_to_hex(input_oid), the_hash_algo->name);
                            return -1;
                    }

                    /* Is new_oi needed? */
                    oi = input_oi;
                    if (input_oi && (input_oi->delta_base_oid || input_oi->sizep ||
                                    input_oi->contentp)) {
                            new_oi = *input_oi;
                            /* Does delta_base_oid need to be converted? */
                            if (input_oi->delta_base_oid)
                                    new_oi.delta_base_oid = &delta_base_oid;
                            /* Will the attributes differ when converted? */
                            if (input_oi->sizep || input_oi->contentp) {
                                    new_oi.contentp = &content;
                                    new_oi.sizep = &size;
                                    new_oi.type_name = &type_name;
                            }
                            oi = &new_oi;
                    }

                    ret = oid_object_info_extended(r, &oid, oi, flags);
                    if (ret)
                            return -1;
                    if (oi == input_oi)
                            return ret;

                    if (new_oi.contentp) {
                            struct strbuf outbuf = STRBUF_INIT;
                            enum object_type type;

                            type = type_from_string_gently(type_name.buf, type_name.len,
                                                    !do_die);
                            if (type == -1)
                                    return -1;
                            if (type != OBJ_BLOB) {
                                    ret = convert_object_file(&outbuf,
                                                            the_hash_algo, input_algo,
                                                            content, size, type, !do_die);
                                    free(content);
                                    if (ret == -1)
                                            return -1;
                                    size = outbuf.len;
                                    content = strbuf_detach(&outbuf, NULL);
                            }
                            if (input_oi->sizep)
                                    *input_oi->sizep = size;
                            if (input_oi->contentp)
                                    *input_oi->contentp = content;
                            else
                                    free(content);
                            if (input_oi->type_name)
                                    *input_oi->type_name = type_name;
                            else
                                    strbuf_release(&type_name);
                    }
                    if (new_oi.delta_base_oid == &delta_base_oid) {
                            if (repo_oid_to_algop(r, &delta_base_oid, input_algo,
                                            input_oi->delta_base_oid)) {
                                    if (do_die)
                                            die(_("missing mapping of %s to %s"),
                                            oid_to_hex(&delta_base_oid),
                                            input_algo->name);
                                    return -1;
                            }
                    }
                    input_oi->whence = new_oi.whence;
                    input_oi->u = new_oi.u;
                    return ret;
            }

            int oid_object_info_extended(struct repository *r, const struct object_id *oid,
                                    struct object_info *oi, unsigned flags)
            {
                    int ret;

                    if (oid->algo && (hash_algo_by_ptr(r->hash_algo) != oid->algo))
                            return oid_object_info_convert(r, oid, oi, flags);

                    obj_read_lock();
                    ret = do_oid_object_info_extended(r, oid, oi, flags);
                    obj_read_unlock();
                    return ret;
            }


            /* returns enum object_type or negative */
            int oid_object_info(struct repository *r,
                            const struct object_id *oid,
                            unsigned long *sizep)
            {
                    enum object_type type;
                    struct object_info oi = OBJECT_INFO_INIT;

                    oi.typep = &type;
                    oi.sizep = sizep;
                    if (oid_object_info_extended(r, oid, &oi,
                                            OBJECT_INFO_LOOKUP_REPLACE) < 0)
                            return -1;
                    return type;
            }

            int pretend_object_file(void *buf, unsigned long len, enum object_type type,
                                    struct object_id *oid)
            {
                    struct cached_object_entry *co;
                    char *co_buf;

                    hash_object_file(the_hash_algo, buf, len, type, oid);
                    if (repo_has_object_file_with_flags(the_repository, oid, OBJECT_INFO_QUICK | OBJECT_INFO_SKIP_FETCH_OBJECT) ||
                    find_cached_object(oid))
                            return 0;
                    ALLOC_GROW(cached_objects, cached_object_nr + 1, cached_object_alloc);
                    co = &cached_objects[cached_object_nr++];
                    co->value.size = len;
                    co->value.type = type;
                    co_buf = xmalloc(len);
                    memcpy(co_buf, buf, len);
                    co->value.buf = co_buf;
                    oidcpy(&co->oid, oid);
                    return 0;
            }

            /*
            * This function dies on corrupt objects; the callers who want to
            * deal with them should arrange to call oid_object_info_extended() and give
            * error messages themselves.
            */
            void *repo_read_object_file(struct repository *r,
                                    const struct object_id *oid,
                                    enum object_type *type,
                                    unsigned long *size)
            {
                    struct object_info oi = OBJECT_INFO_INIT;
                    unsigned flags = OBJECT_INFO_DIE_IF_CORRUPT | OBJECT_INFO_LOOKUP_REPLACE;
                    void *data;

                    oi.typep = type;
                    oi.sizep = size;
                    oi.contentp = &data;
                    if (oid_object_info_extended(r, oid, &oi, flags))
                            return NULL;

                    return data;
            }

            void *read_object_with_reference(struct repository *r,
                                            const struct object_id *oid,
                                            enum object_type required_type,
                                            unsigned long *size,
                                            struct object_id *actual_oid_return)
            {
                    enum object_type type;
                    void *buffer;
                    unsigned long isize;
                    struct object_id actual_oid;

                    oidcpy(&actual_oid, oid);
                    while (1) {
                            int ref_length = -1;
                            const char *ref_type = NULL;

                            buffer = repo_read_object_file(r, &actual_oid, &type, &isize);
                            if (!buffer)
                                    return NULL;
                            if (type == required_type) {
                                    *size = isize;
                                    if (actual_oid_return)
                                            oidcpy(actual_oid_return, &actual_oid);
                                    return buffer;
                            }
                            /* Handle references */
                            else if (type == OBJ_COMMIT)
                                    ref_type = "tree ";
                            else if (type == OBJ_TAG)
                                    ref_type = "object ";
                            else {
                                    free(buffer);
                                    return NULL;
                            }
                            ref_length = strlen(ref_type);

                            if (ref_length + the_hash_algo->hexsz > isize ||
                            memcmp(buffer, ref_type, ref_length) ||
                            get_oid_hex((char *) buffer + ref_length, &actual_oid)) {
                                    free(buffer);
                                    return NULL;
                            }
                            free(buffer);
                            /* Now we have the ID of the referred-to object in
                            * actual_oid.  Check again. */
                    }
            }

            static void hash_object_body(const struct git_hash_algo *algo, git_hash_ctx *c,
                                    const void *buf, unsigned long len,
                                    struct object_id *oid,
                                    char *hdr, int *hdrlen)
            {
                    algo->init_fn(c);
                    algo->update_fn(c, hdr, *hdrlen);
                    algo->update_fn(c, buf, len);
                    algo->final_oid_fn(oid, c);
            }

            static void write_object_file_prepare(const struct git_hash_algo *algo,
                                            const void *buf, unsigned long len,
                                            enum object_type type, struct object_id *oid,
                                            char *hdr, int *hdrlen)
            {
                    git_hash_ctx c;

                    /* Generate the header */
                    *hdrlen = format_object_header(hdr, *hdrlen, type, len);

                    /* Sha1.. */
                    hash_object_body(algo, &c, buf, len, oid, hdr, hdrlen);
            }

            static void write_object_file_prepare_literally(const struct git_hash_algo *algo,
                                            const void *buf, unsigned long len,
                                            const char *type, struct object_id *oid,
                                            char *hdr, int *hdrlen)
            {
                    git_hash_ctx c;

                    *hdrlen = format_object_header_literally(hdr, *hdrlen, type, len);
                    hash_object_body(algo, &c, buf, len, oid, hdr, hdrlen);
            }

            static int check_collision(const char *filename_a, const char *filename_b)
            {
                    char buf_a[4096], buf_b[4096];
                    int fd_a = -1, fd_b = -1;
                    int ret = 0;

                    fd_a = open(filename_a, O_RDONLY);
                    if (fd_a < 0) {
                            ret = error_errno(_("unable to open %s"), filename_a);
                            goto out;
                    }

                    fd_b = open(filename_b, O_RDONLY);
                    if (fd_b < 0) {
                            ret = error_errno(_("unable to open %s"), filename_b);
                            goto out;
                    }

                    while (1) {
                            ssize_t sz_a, sz_b;

                            sz_a = read_in_full(fd_a, buf_a, sizeof(buf_a));
                            if (sz_a < 0) {
                                    ret = error_errno(_("unable to read %s"), filename_a);
                                    goto out;
                            }

                            sz_b = read_in_full(fd_b, buf_b, sizeof(buf_b));
                            if (sz_b < 0) {
                                    ret = error_errno(_("unable to read %s"), filename_b);
                                    goto out;
                            }

                            if (sz_a != sz_b || memcmp(buf_a, buf_b, sz_a)) {
                                    ret = error(_("files '%s' and '%s' differ in contents"),
                                            filename_a, filename_b);
                                    goto out;
                            }

                            if (sz_a < sizeof(buf_a))
                                    break;
                    }

            out:
                    if (fd_a > -1)
                            close(fd_a);
                    if (fd_b > -1)
                            close(fd_b);
                    return ret;
            }

            /*
            * Move the just written object into its final resting place.
            */
            int finalize_object_file(const char *tmpfile, const char *filename)
            {
                    return finalize_object_file_flags(tmpfile, filename, 0);
            }

            int finalize_object_file_flags(const char *tmpfile, const char *filename,
                                    enum finalize_object_file_flags flags)
            {
                    struct stat st;
                    int ret = 0;

                    if (object_creation_mode == OBJECT_CREATION_USES_RENAMES)
                            goto try_rename;
                    else if (link(tmpfile, filename))
                            ret = errno;
                    else
                            unlink_or_warn(tmpfile);

                    /*
                    * Coda hack - coda doesn't like cross-directory links,
                    * so we fall back to a rename, which will mean that it
                    * won't be able to check collisions, but that's not a
                    * big deal.
                    *
                    * The same holds for FAT formatted media.
                    *
                    * When this succeeds, we just return.  We have nothing
                    * left to unlink.
                    */
                    if (ret && ret != EEXIST) {
                    try_rename:
                            if (!stat(filename, &st))
                                    ret = EEXIST;
                            else if (!rename(tmpfile, filename))
                                    goto out;
                            else
                                    ret = errno;
                    }
                    if (ret) {
                            if (ret != EEXIST) {
                                    int saved_errno = errno;
                                    unlink_or_warn(tmpfile);
                                    errno = saved_errno;
                                    return error_errno(_("unable to write file %s"), filename);
                            }
                            if (!(flags & FOF_SKIP_COLLISION_CHECK) &&
                            check_collision(tmpfile, filename))
                                            return -1;
                            unlink_or_warn(tmpfile);
                    }

            out:
                    if (adjust_shared_perm(filename))
                            return error(_("unable to set permission to '%s'"), filename);
                    return 0;
            }

            static void hash_object_file_literally(const struct git_hash_algo *algo,
                                            const void *buf, unsigned long len,
                                            const char *type, struct object_id *oid)
            {
                    char hdr[MAX_HEADER_LEN];
                    int hdrlen = sizeof(hdr);

                    write_object_file_prepare_literally(algo, buf, len, type, oid, hdr, &hdrlen);
            }

            void hash_object_file(const struct git_hash_algo *algo, const void *buf,
                            unsigned long len, enum object_type type,
                            struct object_id *oid)
            {
                    hash_object_file_literally(algo, buf, len, type_name(type), oid);
            }

            /* Finalize a file on disk, and close it. */
            static void close_loose_object(int fd, const char *filename)
            {
                    if (the_repository->objects->odb->will_destroy)
                            goto out;

                    if (batch_fsync_enabled(FSYNC_COMPONENT_LOOSE_OBJECT))
                            fsync_loose_object_bulk_checkin(fd, filename);
                    else if (fsync_object_files > 0)
                            fsync_or_die(fd, filename);
                    else
                            fsync_component_or_die(FSYNC_COMPONENT_LOOSE_OBJECT, fd,
                                            filename);

            out:
                    if (close(fd) != 0)
                            die_errno(_("error when closing loose object file"));
            }

            /* Size of directory component, including the ending '/' */
            static inline int directory_size(const char *filename)
            {
                    const char *s = strrchr(filename, '/');
                    if (!s)
                            return 0;
                    return s - filename + 1;
            }

            /*
            * This creates a temporary file in the same directory as the final
            * 'filename'
            *
            * We want to avoid cross-directory filename renames, because those
            * can have problems on various filesystems (FAT, NFS, Coda).
            */
            static int create_tmpfile(struct strbuf *tmp, const char *filename)
            {
                    int fd, dirlen = directory_size(filename);

                    strbuf_reset(tmp);
                    strbuf_add(tmp, filename, dirlen);
                    strbuf_addstr(tmp, "tmp_obj_XXXXXX");
                    fd = git_mkstemp_mode(tmp->buf, 0444);
                    if (fd < 0 && dirlen && errno == ENOENT) {
                            /*
                            * Make sure the directory exists; note that the contents
                            * of the buffer are undefined after mkstemp returns an
                            * error, so we have to rewrite the whole buffer from
                            * scratch.
                            */
                            strbuf_reset(tmp);
                            strbuf_add(tmp, filename, dirlen - 1);
                            if (mkdir(tmp->buf, 0777) && errno != EEXIST)
                                    return -1;
                            if (adjust_shared_perm(tmp->buf))
                                    return -1;

                            /* Try again */
                            strbuf_addstr(tmp, "/tmp_obj_XXXXXX");
                            fd = git_mkstemp_mode(tmp->buf, 0444);
                    }
                    return fd;
            }

            /**
            * Common steps for loose object writers to start writing loose
            * objects:
            *
            * - Create tmpfile for the loose object.
            * - Setup zlib stream for compression.
            * - Start to feed header to zlib stream.
            *
            * Returns a "fd", which should later be provided to
            * end_loose_object_common().
            */
            static int start_loose_object_common(struct strbuf *tmp_file,
                                            const char *filename, unsigned flags,
                                            git_zstream *stream,
                                            unsigned char *buf, size_t buflen,
                                            git_hash_ctx *c, git_hash_ctx *compat_c,
                                            char *hdr, int hdrlen)
            {
                    struct repository *repo = the_repository;
                    const struct git_hash_algo *algo = repo->hash_algo;
                    const struct git_hash_algo *compat = repo->compat_hash_algo;
                    int fd;

                    fd = create_tmpfile(tmp_file, filename);
                    if (fd < 0) {
                            if (flags & HASH_SILENT)
                                    return -1;
                            else if (errno == EACCES)
                                    return error(_("insufficient permission for adding "
                                            "an object to repository database %s"),
                                            repo_get_object_directory(the_repository));
                            else
                                    return error_errno(
                                            _("unable to create temporary file"));
                    }

                    /*  Setup zlib stream for compression */
                    git_deflate_init(stream, zlib_compression_level);
                    stream->next_out = buf;
                    stream->avail_out = buflen;
                    algo->init_fn(c);
                    if (compat && compat_c)
                            compat->init_fn(compat_c);

                    /*  Start to feed header to zlib stream */
                    stream->next_in = (unsigned char *)hdr;
                    stream->avail_in = hdrlen;
                    while (git_deflate(stream, 0) == Z_OK)
                            ; /* nothing */
                    algo->update_fn(c, hdr, hdrlen);
                    if (compat && compat_c)
                            compat->update_fn(compat_c, hdr, hdrlen);

                    return fd;
            }

            /**
            * Common steps for the inner git_deflate() loop for writing loose
            * objects. Returns what git_deflate() returns.
            */
            static int write_loose_object_common(git_hash_ctx *c, git_hash_ctx *compat_c,
                                            git_zstream *stream, const int flush,
                                            unsigned char *in0, const int fd,
                                            unsigned char *compressed,
                                            const size_t compressed_len)
            {
                    struct repository *repo = the_repository;
                    const struct git_hash_algo *algo = repo->hash_algo;
                    const struct git_hash_algo *compat = repo->compat_hash_algo;
                    int ret;

                    ret = git_deflate(stream, flush ? Z_FINISH : 0);
                    algo->update_fn(c, in0, stream->next_in - in0);
                    if (compat && compat_c)
                            compat->update_fn(compat_c, in0, stream->next_in - in0);
                    if (write_in_full(fd, compressed, stream->next_out - compressed) < 0)
                            die_errno(_("unable to write loose object file"));
                    stream->next_out = compressed;
                    stream->avail_out = compressed_len;

                    return ret;
            }

            /**
            * Common steps for loose object writers to end writing loose objects:
            *
            * - End the compression of zlib stream.
            * - Get the calculated oid to "oid".
            */
            static int end_loose_object_common(git_hash_ctx *c, git_hash_ctx *compat_c,
                                            git_zstream *stream, struct object_id *oid,
                                            struct object_id *compat_oid)
            {
                    struct repository *repo = the_repository;
                    const struct git_hash_algo *algo = repo->hash_algo;
                    const struct git_hash_algo *compat = repo->compat_hash_algo;
                    int ret;

                    ret = git_deflate_end_gently(stream);
                    if (ret != Z_OK)
                            return ret;
                    algo->final_oid_fn(oid, c);
                    if (compat && compat_c)
                            compat->final_oid_fn(compat_oid, compat_c);

                    return Z_OK;
            }

            static int write_loose_object(const struct object_id *oid, char *hdr,
                                    int hdrlen, const void *buf, unsigned long len,
                                    time_t mtime, unsigned flags)
            {
                    int fd, ret;
                    unsigned char compressed[4096];
                    git_zstream stream;
                    git_hash_ctx c;
                    struct object_id parano_oid;
                    static struct strbuf tmp_file = STRBUF_INIT;
                    static struct strbuf filename = STRBUF_INIT;

                    if (batch_fsync_enabled(FSYNC_COMPONENT_LOOSE_OBJECT))
                            prepare_loose_object_bulk_checkin();

                    loose_object_path(the_repository, &filename, oid);

                    fd = start_loose_object_common(&tmp_file, filename.buf, flags,
                                            &stream, compressed, sizeof(compressed),
                                            &c, NULL, hdr, hdrlen);
                    if (fd < 0)
                            return -1;

                    /* Then the data itself.. */
                    stream.next_in = (void *)buf;
                    stream.avail_in = len;
                    do {
                            unsigned char *in0 = stream.next_in;

                            ret = write_loose_object_common(&c, NULL, &stream, 1, in0, fd,
                                                            compressed, sizeof(compressed));
                    } while (ret == Z_OK);

                    if (ret != Z_STREAM_END)
                            die(_("unable to deflate new object %s (%d)"), oid_to_hex(oid),
                            ret);
                    ret = end_loose_object_common(&c, NULL, &stream, &parano_oid, NULL);
                    if (ret != Z_OK)
                            die(_("deflateEnd on object %s failed (%d)"), oid_to_hex(oid),
                            ret);
                    if (!oideq(oid, &parano_oid))
                            die(_("confused by unstable object source data for %s"),
                            oid_to_hex(oid));

                    close_loose_object(fd, tmp_file.buf);

                    if (mtime) {
                            struct utimbuf utb;
                            utb.actime = mtime;
                            utb.modtime = mtime;
                            if (utime(tmp_file.buf, &utb) < 0 &&
                            !(flags & HASH_SILENT))
                                    warning_errno(_("failed utime() on %s"), tmp_file.buf);
                    }

                    return finalize_object_file_flags(tmp_file.buf, filename.buf,
                                                    FOF_SKIP_COLLISION_CHECK);
            }

            static int freshen_loose_object(const struct object_id *oid)
            {
                    return check_and_freshen(oid, 1);
            }

            static int freshen_packed_object(const struct object_id *oid)
            {
                    struct pack_entry e;
                    if (!find_pack_entry(the_repository, oid, &e))
                            return 0;
                    if (e.p->is_cruft)
                            return 0;
                    if (e.p->freshened)
                            return 1;
                    if (!freshen_file(e.p->pack_name))
                            return 0;
                    e.p->freshened = 1;
                    return 1;
            }

            int stream_loose_object(struct input_stream *in_stream, size_t len,
                                    struct object_id *oid)
            {
                    const struct git_hash_algo *compat = the_repository->compat_hash_algo;
                    struct object_id compat_oid;
                    int fd, ret, err = 0, flush = 0;
                    unsigned char compressed[4096];
                    git_zstream stream;
                    git_hash_ctx c, compat_c;
                    struct strbuf tmp_file = STRBUF_INIT;
                    struct strbuf filename = STRBUF_INIT;
                    int dirlen;
                    char hdr[MAX_HEADER_LEN];
                    int hdrlen;

                    if (batch_fsync_enabled(FSYNC_COMPONENT_LOOSE_OBJECT))
                            prepare_loose_object_bulk_checkin();

                    /* Since oid is not determined, save tmp file to odb path. */
                    strbuf_addf(&filename, "%s/", repo_get_object_directory(the_repository));
                    hdrlen = format_object_header(hdr, sizeof(hdr), OBJ_BLOB, len);

                    /*
                    * Common steps for write_loose_object and stream_loose_object to
                    * start writing loose objects:
                    *
                    *  - Create tmpfile for the loose object.
                    *  - Setup zlib stream for compression.
                    *  - Start to feed header to zlib stream.
                    */
                    fd = start_loose_object_common(&tmp_file, filename.buf, 0,
                                            &stream, compressed, sizeof(compressed),
                                            &c, &compat_c, hdr, hdrlen);
                    if (fd < 0) {
                            err = -1;
                            goto cleanup;
                    }

                    /* Then the data itself.. */
                    do {
                            unsigned char *in0 = stream.next_in;

                            if (!stream.avail_in && !in_stream->is_finished) {
                                    const void *in = in_stream->read(in_stream, &stream.avail_in);
                                    stream.next_in = (void *)in;
                                    in0 = (unsigned char *)in;
                                    /* All data has been read. */
                                    if (in_stream->is_finished)
                                            flush = 1;
                            }
                            ret = write_loose_object_common(&c, &compat_c, &stream, flush, in0, fd,
                                                            compressed, sizeof(compressed));
                            /*
                            * Unlike write_loose_object(), we do not have the entire
                            * buffer. If we get Z_BUF_ERROR due to too few input bytes,
                            * then we'll replenish them in the next input_stream->read()
                            * call when we loop.
                            */
                    } while (ret == Z_OK || ret == Z_BUF_ERROR);

                    if (stream.total_in != len + hdrlen)
                            die(_("write stream object %ld != %"PRIuMAX), stream.total_in,
                            (uintmax_t)len + hdrlen);

                    /*
                    * Common steps for write_loose_object and stream_loose_object to
                    * end writing loose object:
                    *
                    *  - End the compression of zlib stream.
                    *  - Get the calculated oid.
                    */
                    if (ret != Z_STREAM_END)
                            die(_("unable to stream deflate new object (%d)"), ret);
                    ret = end_loose_object_common(&c, &compat_c, &stream, oid, &compat_oid);
                    if (ret != Z_OK)
                            die(_("deflateEnd on stream object failed (%d)"), ret);
                    close_loose_object(fd, tmp_file.buf);

                    if (freshen_packed_object(oid) || freshen_loose_object(oid)) {
                            unlink_or_warn(tmp_file.buf);
                            goto cleanup;
                    }

                    loose_object_path(the_repository, &filename, oid);

                    /* We finally know the object path, and create the missing dir. */
                    dirlen = directory_size(filename.buf);
                    if (dirlen) {
                            struct strbuf dir = STRBUF_INIT;
                            strbuf_add(&dir, filename.buf, dirlen);

                            if (mkdir_in_gitdir(dir.buf) && errno != EEXIST) {
                                    err = error_errno(_("unable to create directory %s"), dir.buf);
                                    strbuf_release(&dir);
                                    goto cleanup;
                            }
                            strbuf_release(&dir);
                    }

                    err = finalize_object_file_flags(tmp_file.buf, filename.buf,
                                                    FOF_SKIP_COLLISION_CHECK);
                    if (!err && compat)
                            err = repo_add_loose_object_map(the_repository, oid, &compat_oid);
            cleanup:
                    strbuf_release(&tmp_file);
                    strbuf_release(&filename);
                    return err;
            }

            int write_object_file_flags(const void *buf, unsigned long len,
                                    enum object_type type, struct object_id *oid,
                                    struct object_id *compat_oid_in, unsigned flags)
            {
                    struct repository *repo = the_repository;
                    const struct git_hash_algo *algo = repo->hash_algo;
                    const struct git_hash_algo *compat = repo->compat_hash_algo;
                    struct object_id compat_oid;
                    char hdr[MAX_HEADER_LEN];
                    int hdrlen = sizeof(hdr);

                    /* Generate compat_oid */
                    if (compat) {
                            if (compat_oid_in)
                                    oidcpy(&compat_oid, compat_oid_in);
                            else if (type == OBJ_BLOB)
                                    hash_object_file(compat, buf, len, type, &compat_oid);
                            else {
                                    struct strbuf converted = STRBUF_INIT;
                                    convert_object_file(&converted, algo, compat,
                                                    buf, len, type, 0);
                                    hash_object_file(compat, converted.buf, converted.len,
                                                    type, &compat_oid);
                                    strbuf_release(&converted);
                            }
                    }

                    /* Normally if we have it in the pack then we do not bother writing
                    * it out into .git/objects/??/?{38} file.
                    */
                    write_object_file_prepare(algo, buf, len, type, oid, hdr, &hdrlen);
                    if (freshen_packed_object(oid) || freshen_loose_object(oid))
                            return 0;
                    if (write_loose_object(oid, hdr, hdrlen, buf, len, 0, flags))
                            return -1;
                    if (compat)
                            return repo_add_loose_object_map(repo, oid, &compat_oid);
                    return 0;
            }

            int write_object_file_literally(const void *buf, unsigned long len,
                                            const char *type, struct object_id *oid,
                                            unsigned flags)
            {
                    char *header;
                    struct repository *repo = the_repository;
                    const struct git_hash_algo *algo = repo->hash_algo;
                    const struct git_hash_algo *compat = repo->compat_hash_algo;
                    struct object_id compat_oid;
                    int hdrlen, status = 0;
                    int compat_type = -1;

                    if (compat) {
                            compat_type = type_from_string_gently(type, -1, 1);
                            if (compat_type == OBJ_BLOB)
                                    hash_object_file(compat, buf, len, compat_type,
                                                    &compat_oid);
                            else if (compat_type != -1) {
                                    struct strbuf converted = STRBUF_INIT;
                                    convert_object_file(&converted, algo, compat,
                                                    buf, len, compat_type, 0);
                                    hash_object_file(compat, converted.buf, converted.len,
                                                    compat_type, &compat_oid);
                                    strbuf_release(&converted);
                            }
                    }

                    /* type string, SP, %lu of the length plus NUL must fit this */
                    hdrlen = strlen(type) + MAX_HEADER_LEN;
                    header = xmalloc(hdrlen);
                    write_object_file_prepare_literally(the_hash_algo, buf, len, type,
                                                    oid, header, &hdrlen);

                    if (!(flags & HASH_WRITE_OBJECT))
                            goto cleanup;
                    if (freshen_packed_object(oid) || freshen_loose_object(oid))
                            goto cleanup;
                    status = write_loose_object(oid, header, hdrlen, buf, len, 0, 0);
                    if (compat_type != -1)
                            return repo_add_loose_object_map(repo, oid, &compat_oid);

            cleanup:
                    free(header);
                    return status;
            }

            int force_object_loose(const struct object_id *oid, time_t mtime)
            {
                    struct repository *repo = the_repository;
                    const struct git_hash_algo *compat = repo->compat_hash_algo;
                    void *buf;
                    unsigned long len;
                    struct object_info oi = OBJECT_INFO_INIT;
                    struct object_id compat_oid;
                    enum object_type type;
                    char hdr[MAX_HEADER_LEN];
                    int hdrlen;
                    int ret;

                    if (has_loose_object(oid))
                            return 0;
                    oi.typep = &type;
                    oi.sizep = &len;
                    oi.contentp = &buf;
                    if (oid_object_info_extended(the_repository, oid, &oi, 0))
                            return error(_("cannot read object for %s"), oid_to_hex(oid));
                    if (compat) {
                            if (repo_oid_to_algop(repo, oid, compat, &compat_oid))
                                    return error(_("cannot map object %s to %s"),
                                            oid_to_hex(oid), compat->name);
                    }
                    hdrlen = format_object_header(hdr, sizeof(hdr), type, len);
                    ret = write_loose_object(oid, hdr, hdrlen, buf, len, mtime, 0);
                    if (!ret && compat)
                            ret = repo_add_loose_object_map(the_repository, oid, &compat_oid);
                    free(buf);

                    return ret;
            }

            int has_object(struct repository *r, const struct object_id *oid,
                    unsigned flags)
            {
                    int quick = !(flags & HAS_OBJECT_RECHECK_PACKED);
                    unsigned object_info_flags = OBJECT_INFO_SKIP_FETCH_OBJECT |
                            (quick ? OBJECT_INFO_QUICK : 0);

                    if (!startup_info->have_repository)
                            return 0;
                    return oid_object_info_extended(r, oid, NULL, object_info_flags) >= 0;
            }

            int repo_has_object_file_with_flags(struct repository *r,
                                            const struct object_id *oid, int flags)
            {
                    if (!startup_info->have_repository)
                            return 0;
                    return oid_object_info_extended(r, oid, NULL, flags) >= 0;
            }

            int repo_has_object_file(struct repository *r,
                                    const struct object_id *oid)
            {
                    return repo_has_object_file_with_flags(r, oid, 0);
            }

            /*
            * We can't use the normal fsck_error_function() for index_mem(),
            * because we don't yet have a valid oid for it to report. Instead,
            * report the minimal fsck error here, and rely on the caller to
            * give more context.
            */
            static int hash_format_check_report(struct fsck_options *opts UNUSED,
                                            void *fsck_report UNUSED,
                                            enum fsck_msg_type msg_type UNUSED,
                                            enum fsck_msg_id msg_id UNUSED,
                                            const char *message)
            {
                    error(_("object fails fsck: %s"), message);
                    return 1;
            }

            static int index_mem(struct index_state *istate,
                            struct object_id *oid,
                            const void *buf, size_t size,
                            enum object_type type,
                            const char *path, unsigned flags)
            {
                    struct strbuf nbuf = STRBUF_INIT;
                    int ret = 0;
                    int write_object = flags & HASH_WRITE_OBJECT;

                    if (!type)
                            type = OBJ_BLOB;

                    /*
                    * Convert blobs to git internal format
                    */
                    if ((type == OBJ_BLOB) && path) {
                            if (convert_to_git(istate, path, buf, size, &nbuf,
                                            get_conv_flags(flags))) {
                                    buf = nbuf.buf;
                                    size = nbuf.len;
                            }
                    }
                    if (flags & HASH_FORMAT_CHECK) {
                            struct fsck_options opts = FSCK_OPTIONS_DEFAULT;

                            opts.strict = 1;
                            opts.error_func = hash_format_check_report;
                            if (fsck_buffer(null_oid(), type, buf, size, &opts))
                                    die(_("refusing to create malformed object"));
                            fsck_finish(&opts);
                    }

                    if (write_object)
                            ret = write_object_file(buf, size, type, oid);
                    else
                            hash_object_file(the_hash_algo, buf, size, type, oid);

                    strbuf_release(&nbuf);
                    return ret;
            }

            static int index_stream_convert_blob(struct index_state *istate,
                                            struct object_id *oid,
                                            int fd,
                                            const char *path,
                                            unsigned flags)
            {
                    int ret = 0;
                    const int write_object = flags & HASH_WRITE_OBJECT;
                    struct strbuf sbuf = STRBUF_INIT;

                    assert(path);
                    assert(would_convert_to_git_filter_fd(istate, path));

                    convert_to_git_filter_fd(istate, path, fd, &sbuf,
                                            get_conv_flags(flags));

                    if (write_object)
                            ret = write_object_file(sbuf.buf, sbuf.len, OBJ_BLOB,
                                                    oid);
                    else
                            hash_object_file(the_hash_algo, sbuf.buf, sbuf.len, OBJ_BLOB,
                                            oid);
                    strbuf_release(&sbuf);
                    return ret;
            }

            static int index_pipe(struct index_state *istate, struct object_id *oid,
                            int fd, enum object_type type,
                            const char *path, unsigned flags)
            {
                    struct strbuf sbuf = STRBUF_INIT;
                    int ret;

                    if (strbuf_read(&sbuf, fd, 4096) >= 0)
                            ret = index_mem(istate, oid, sbuf.buf, sbuf.len, type, path, flags);
                    else
                            ret = -1;
                    strbuf_release(&sbuf);
                    return ret;
            }

            #define SMALL_FILE_SIZE (32*1024)

            static int index_core(struct index_state *istate,
                            struct object_id *oid, int fd, size_t size,
                            enum object_type type, const char *path,
                            unsigned flags)
            {
                    int ret;

                    if (!size) {
                            ret = index_mem(istate, oid, "", size, type, path, flags);
                    } else if (size <= SMALL_FILE_SIZE) {
                            char *buf = xmalloc(size);
                            ssize_t read_result = read_in_full(fd, buf, size);
                            if (read_result < 0)
                                    ret = error_errno(_("read error while indexing %s"),
                                                    path ? path : "<unknown>");
                            else if (read_result != size)
                                    ret = error(_("short read while indexing %s"),
                                            path ? path : "<unknown>");
                            else
                                    ret = index_mem(istate, oid, buf, size, type, path, flags);
                            free(buf);
                    } else {
                            void *buf = xmmap(NULL, size, PROT_READ, MAP_PRIVATE, fd, 0);
                            ret = index_mem(istate, oid, buf, size, type, path, flags);
                            munmap(buf, size);
                    }
                    return ret;
            }

            /*
            * This creates one packfile per large blob unless bulk-checkin
            * machinery is "plugged".
            *
            * This also bypasses the usual "convert-to-git" dance, and that is on
            * purpose. We could write a streaming version of the converting
            * functions and insert that before feeding the data to fast-import
            * (or equivalent in-core API described above). However, that is
            * somewhat complicated, as we do not know the size of the filter
            * result, which we need to know beforehand when writing a git object.
            * Since the primary motivation for trying to stream from the working
            * tree file and to avoid mmaping it in core is to deal with large
            * binary blobs, they generally do not want to get any conversion, and
            * callers should avoid this code path when filters are requested.
            */
            static int index_blob_stream(struct object_id *oid, int fd, size_t size,
                                    const char *path,
                                    unsigned flags)
            {
                    return index_blob_bulk_checkin(oid, fd, size, path, flags);
            }

            int index_fd(struct index_state *istate, struct object_id *oid,
                    int fd, struct stat *st,
                    enum object_type type, const char *path, unsigned flags)
            {
                    int ret;

                    /*
                    * Call xsize_t() only when needed to avoid potentially unnecessary
                    * die() for large files.
                    */
                    if (type == OBJ_BLOB && path && would_convert_to_git_filter_fd(istate, path))
                            ret = index_stream_convert_blob(istate, oid, fd, path, flags);
                    else if (!S_ISREG(st->st_mode))
                            ret = index_pipe(istate, oid, fd, type, path, flags);
                    else if (st->st_size <= big_file_threshold || type != OBJ_BLOB ||
                            (path && would_convert_to_git(istate, path)))
                            ret = index_core(istate, oid, fd, xsize_t(st->st_size),
                                            type, path, flags);
                    else
                            ret = index_blob_stream(oid, fd, xsize_t(st->st_size), path,
                                                    flags);
                    close(fd);
                    return ret;
            }

            #ifdef __MVS__
            void validate_codeset(struct index_state *istate, const char *path, int* autoconvertToASCII) {
            struct conv_attrs ca;
            struct stat st;
            unsigned short attr_ccsid;
            unsigned short file_ccsid;

            if (ignore_file_tags)
            return;

            *autoconvertToASCII = 0;
            convert_attrs(istate, &ca, path);
            if (ca.attr_action == CRLF_BINARY) {
            attr_ccsid = FT_BINARY;
            }
            else if (ca.working_tree_encoding) {
            attr_ccsid = __toCcsid(ca.working_tree_encoding);
            }
            else {
            attr_ccsid = utf8_ccsid;
            }

            if (stat(path, &st) < 0)
            return;

            file_ccsid = st.st_tag.ft_ccsid;

            if (file_ccsid == FT_UNTAGGED) {
            die("File %s is untagged, set the correct file tag (using the chtag command).", path);
            }

            if (attr_ccsid != file_ccsid) {
            if (file_ccsid == 1047 && attr_ccsid == 819) {
            *autoconvertToASCII = 1;
            return;
            }
            // Allow tag mixing of 819 and 1208
            if ((file_ccsid == 819 || file_ccsid == 1208) && (attr_ccsid == 1208 || attr_ccsid == 819)) {
            return;
            }
            // Don't check for binary files, just add them
            if (attr_ccsid == FT_BINARY)
            return;

            char attr_csname[_XOPEN_PATH_MAX] = {0};
            char file_csname[_XOPEN_PATH_MAX] = {0};
            if (attr_ccsid != FT_BINARY) {
            __toCSName(attr_ccsid, attr_csname);
            } else {
            snprintf(attr_csname, _XOPEN_PATH_MAX, "%s", "binary");
            }
            if (file_ccsid != FT_BINARY) {
            __toCSName(file_ccsid, file_csname);
            } else {
            snprintf(file_csname, _XOPEN_PATH_MAX, "%s", "binary");
            }
            die("%s added file: file tag (%s) does not match working-tree-encoding (%s)", path, file_csname, attr_csname);
            }
            }
            #endif

            int index_path(struct index_state *istate, struct object_id *oid,
                    const char *path, struct stat *st, unsigned flags)
            {
                    int fd;
                    struct strbuf sb = STRBUF_INIT;
                    int rc = 0;
                    struct conv_attrs ca;
                    int autocvtToASCII;

                    switch (st->st_mode & S_IFMT) {
                    case S_IFREG:
            #ifdef __MVS__
            validate_codeset(istate, path, &autocvtToASCII);
            #endif
                            fd = open(path, O_RDONLY);
                            if (fd < 0)
                                    return error_errno("open(\"%s\")", path);
            #ifdef __MVS__
            if (!autocvtToASCII)
            __disableautocvt(fd);
            #endif
                            if (index_fd(istate, oid, fd, st, OBJ_BLOB, path, flags) < 0)
                                    return error(_("%s: failed to insert into database"),
                                            path);
                            break;
                    case S_IFLNK:
                            if (strbuf_readlink(&sb, path, st->st_size))
                                    return error_errno("readlink(\"%s\")", path);
                            if (!(flags & HASH_WRITE_OBJECT))
                                    hash_object_file(the_hash_algo, sb.buf, sb.len,
                                                    OBJ_BLOB, oid);
                            else if (write_object_file(sb.buf, sb.len, OBJ_BLOB, oid))
                                    rc = error(_("%s: failed to insert into database"), path);
                            strbuf_release(&sb);
                            break;
                    case S_IFDIR:
                            return repo_resolve_gitlink_ref(the_repository, path, "HEAD", oid);
                    default:
                            return error(_("%s: unsupported file type"), path);
                    }
                    return rc;
            }

            int read_pack_header(int fd, struct pack_header *header)
            {
                    if (read_in_full(fd, header, sizeof(*header)) != sizeof(*header))
                            /* "eof before pack header was fully read" */
                            return PH_ERROR_EOF;

                    if (header->hdr_signature != htonl(PACK_SIGNATURE))
                            /* "protocol error (pack signature mismatch detected)" */
                            return PH_ERROR_PACK_SIGNATURE;
                    if (!pack_version_ok(header->hdr_version))
                            /* "protocol error (pack version unsupported)" */
                            return PH_ERROR_PROTOCOL;
                    return 0;
            }

            void assert_oid_type(const struct object_id *oid, enum object_type expect)
            {
                    enum object_type type = oid_object_info(the_repository, oid, NULL);
                    if (type < 0)
                            die(_("%s is not a valid object"), oid_to_hex(oid));
                    if (type != expect)
                            die(_("%s is not a valid '%s' object"), oid_to_hex(oid),
                            type_name(expect));
            }

            int for_each_file_in_obj_subdir(unsigned int subdir_nr,
                                            struct strbuf *path,
                                            each_loose_object_fn obj_cb,
                                            each_loose_cruft_fn cruft_cb,
                                            each_loose_subdir_fn subdir_cb,
                                            void *data)
            {
                    size_t origlen, baselen;
                    DIR *dir;
                    struct dirent *de;
                    int r = 0;
                    struct object_id oid;

                    if (subdir_nr > 0xff)
                            BUG("invalid loose object subdirectory: %x", subdir_nr);

                    origlen = path->len;
                    strbuf_complete(path, '/');
                    strbuf_addf(path, "%02x", subdir_nr);

                    dir = opendir(path->buf);
                    if (!dir) {
                            if (errno != ENOENT)
                                    r = error_errno(_("unable to open %s"), path->buf);
                            strbuf_setlen(path, origlen);
                            return r;
                    }

                    oid.hash[0] = subdir_nr;
                    strbuf_addch(path, '/');
                    baselen = path->len;

                    while ((de = readdir_skip_dot_and_dotdot(dir))) {
                            size_t namelen;

                            namelen = strlen(de->d_name);
                            strbuf_setlen(path, baselen);
                            strbuf_add(path, de->d_name, namelen);
                            if (namelen == the_hash_algo->hexsz - 2 &&
                            !hex_to_bytes(oid.hash + 1, de->d_name,
                                            the_hash_algo->rawsz - 1)) {
                                    oid_set_algo(&oid, the_hash_algo);
                                    memset(oid.hash + the_hash_algo->rawsz, 0,
                                    GIT_MAX_RAWSZ - the_hash_algo->rawsz);
                                    if (obj_cb) {
                                            r = obj_cb(&oid, path->buf, data);
                                            if (r)
                                                    break;
                                    }
                                    continue;
                            }

                            if (cruft_cb) {
                                    r = cruft_cb(de->d_name, path->buf, data);
                                    if (r)
                                            break;
                            }
                    }
                    closedir(dir);

                    strbuf_setlen(path, baselen - 1);
                    if (!r && subdir_cb)
                            r = subdir_cb(subdir_nr, path->buf, data);

                    strbuf_setlen(path, origlen);

                    return r;
            }

            int for_each_loose_file_in_objdir_buf(struct strbuf *path,
                                    each_loose_object_fn obj_cb,
                                    each_loose_cruft_fn cruft_cb,
                                    each_loose_subdir_fn subdir_cb,
                                    void *data)
            {
                    int r = 0;
                    int i;

                    for (i = 0; i < 256; i++) {
                            r = for_each_file_in_obj_subdir(i, path, obj_cb, cruft_cb,
                                                            subdir_cb, data);
                            if (r)
                                    break;
                    }

                    return r;
            }

            int for_each_loose_file_in_objdir(const char *path,
                                            each_loose_object_fn obj_cb,
                                            each_loose_cruft_fn cruft_cb,
                                            each_loose_subdir_fn subdir_cb,
                                            void *data)
            {
                    struct strbuf buf = STRBUF_INIT;
                    int r;

                    strbuf_addstr(&buf, path);
                    r = for_each_loose_file_in_objdir_buf(&buf, obj_cb, cruft_cb,
                                                    subdir_cb, data);
                    strbuf_release(&buf);

                    return r;
            }

            int for_each_loose_object(each_loose_object_fn cb, void *data,
                                    enum for_each_object_flags flags)
            {
                    struct object_directory *odb;

                    prepare_alt_odb(the_repository);
                    for (odb = the_repository->objects->odb; odb; odb = odb->next) {
                            int r = for_each_loose_file_in_objdir(odb->path, cb, NULL,
                                                            NULL, data);
                            if (r)
                                    return r;

                            if (flags & FOR_EACH_OBJECT_LOCAL_ONLY)
                                    break;
                    }

                    return 0;
            }

            static int append_loose_object(const struct object_id *oid,
                                    const char *path UNUSED,
                                    void *data)
            {
                    oidtree_insert(data, oid);
                    return 0;
            }

            struct oidtree *odb_loose_cache(struct object_directory *odb,
                                            const struct object_id *oid)
            {
                    int subdir_nr = oid->hash[0];
                    struct strbuf buf = STRBUF_INIT;
                    size_t word_bits = bitsizeof(odb->loose_objects_subdir_seen[0]);
                    size_t word_index = subdir_nr / word_bits;
                    size_t mask = (size_t)1u << (subdir_nr % word_bits);
                    uint32_t *bitmap;

                    if (subdir_nr < 0 ||
                    subdir_nr >= bitsizeof(odb->loose_objects_subdir_seen))
                            BUG("subdir_nr out of range");

                    bitmap = &odb->loose_objects_subdir_seen[word_index];
                    if (*bitmap & mask)
                            return odb->loose_objects_cache;
                    if (!odb->loose_objects_cache) {
                            ALLOC_ARRAY(odb->loose_objects_cache, 1);
                            oidtree_init(odb->loose_objects_cache);
                    }
                    strbuf_addstr(&buf, odb->path);
                    for_each_file_in_obj_subdir(subdir_nr, &buf,
                                            append_loose_object,
                                            NULL, NULL,
                                            odb->loose_objects_cache);
                    *bitmap |= mask;
                    strbuf_release(&buf);
                    return odb->loose_objects_cache;
            }

            void odb_clear_loose_cache(struct object_directory *odb)
            {
                    oidtree_clear(odb->loose_objects_cache);
                    FREE_AND_NULL(odb->loose_objects_cache);
                    memset(&odb->loose_objects_subdir_seen, 0,
                    sizeof(odb->loose_objects_subdir_seen));
            }

            static int check_stream_oid(git_zstream *stream,
                                    const char *hdr,
                                    unsigned long size,
                                    const char *path,
                                    const struct object_id *expected_oid)
            {
                    git_hash_ctx c;
                    struct object_id real_oid;
                    unsigned char buf[4096];
                    unsigned long total_read;
                    int status = Z_OK;

                    the_hash_algo->init_fn(&c);
                    the_hash_algo->update_fn(&c, hdr, stream->total_out);

                    /*
                    * We already read some bytes into hdr, but the ones up to the NUL
                    * do not count against the object's content size.
                    */
                    total_read = stream->total_out - strlen(hdr) - 1;

                    /*
                    * This size comparison must be "<=" to read the final zlib packets;
                    * see the comment in unpack_loose_rest for details.
                    */
                    while (total_read <= size &&
                    (status == Z_OK ||
                            (status == Z_BUF_ERROR && !stream->avail_out))) {
                            stream->next_out = buf;
                            stream->avail_out = sizeof(buf);
                            if (size - total_read < stream->avail_out)
                                    stream->avail_out = size - total_read;
                            status = git_inflate(stream, Z_FINISH);
                            the_hash_algo->update_fn(&c, buf, stream->next_out - buf);
                            total_read += stream->next_out - buf;
                    }
                    git_inflate_end(stream);

                    if (status != Z_STREAM_END) {
                            error(_("corrupt loose object '%s'"), oid_to_hex(expected_oid));
                            return -1;
                    }
                    if (stream->avail_in) {
                            error(_("garbage at end of loose object '%s'"),
                            oid_to_hex(expected_oid));
                            return -1;
                    }

                    the_hash_algo->final_oid_fn(&real_oid, &c);
                    if (!oideq(expected_oid, &real_oid)) {
                            error(_("hash mismatch for %s (expected %s)"), path,
                            oid_to_hex(expected_oid));
                            return -1;
                    }

                    return 0;
            }

            int read_loose_object(const char *path,
                            const struct object_id *expected_oid,
                            struct object_id *real_oid,
                            void **contents,
                            struct object_info *oi)
            {
                    int ret = -1;
                    int fd;
                    void *map = NULL;
                    unsigned long mapsize;
                    git_zstream stream;
                    char hdr[MAX_HEADER_LEN];
                    unsigned long *size = oi->sizep;

                    fd = git_open(path);
                    if (fd >= 0)
                            map = map_fd(fd, path, &mapsize);
                    if (!map) {
                            error_errno(_("unable to mmap %s"), path);
                            goto out;
                    }

                    if (unpack_loose_header(&stream, map, mapsize, hdr, sizeof(hdr),
                                            NULL) != ULHR_OK) {
                            error(_("unable to unpack header of %s"), path);
                            git_inflate_end(&stream);
                            goto out;
                    }

                    if (parse_loose_header(hdr, oi) < 0) {
                            error(_("unable to parse header of %s"), path);
                            git_inflate_end(&stream);
                            goto out;
                    }

                    if (*oi->typep == OBJ_BLOB && *size > big_file_threshold) {
                            if (check_stream_oid(&stream, hdr, *size, path, expected_oid) < 0)
                                    goto out;
                    } else {
                            *contents = unpack_loose_rest(&stream, hdr, *size, expected_oid);
                            if (!*contents) {
                                    error(_("unable to unpack contents of %s"), path);
                                    git_inflate_end(&stream);
                                    goto out;
                            }
                            hash_object_file_literally(the_repository->hash_algo,
                                                    *contents, *size,
                                                    oi->type_name->buf, real_oid);
                            if (!oideq(expected_oid, real_oid))
                                    goto out;
                    }

                    ret = 0; /* everything checks out */

            out:
                    if (map)
                            munmap(map, mapsize);
                    return ret;
            }


            """,
            "Patche":
            """
                            diff --git a/object-file.c b/object-file.c
            index 610b1f465c..9661518d01 100644
            --- a/object-file.c
            +++ b/object-file.c
            @@ -38,6 +38,12 @@
            #include "loose.h"
            #include "object-file-convert.h"

            +#ifdef __MVS__
            +#include <_Ccsid.h>
            +#include "read-cache-ll.h"
            +#endif
            +
            +
            /* The maximum size for an object header. */
            #define MAX_HEADER_LEN 32

            @@ -2642,18 +2648,88 @@ int index_fd(struct index_state *istate, struct object_id *oid,
                    return ret;
            }

            +#ifdef __MVS__
            +void validate_codeset(struct index_state *istate, const char *path, int* autoconvertToASCII) {
            +       struct conv_attrs ca;
            +  struct stat st;
            +  unsigned short attr_ccsid;
            +  unsigned short file_ccsid;
            +
            +  if (ignore_file_tags)
            +    return;
            +
            +  *autoconvertToASCII = 0;
            +       convert_attrs(istate, &ca, path);
            +  if (ca.attr_action == CRLF_BINARY) {
            +    attr_ccsid = FT_BINARY;
            +  }
            +  else if (ca.working_tree_encoding) {
            +    attr_ccsid = __toCcsid(ca.working_tree_encoding);
            +  }
            +  else {
            +    attr_ccsid = utf8_ccsid;
            +  }
            +
            +  if (stat(path, &st) < 0)
            +    return;
            +
            +  file_ccsid = st.st_tag.ft_ccsid;
            +
            +  if (file_ccsid == FT_UNTAGGED) {
            +    die("File %s is untagged, set the correct file tag (using the chtag command).", path);
            +  }
            +
            +  if (attr_ccsid != file_ccsid) {
            +    if (file_ccsid == 1047 && attr_ccsid == 819) {
            +      *autoconvertToASCII = 1;
            +      return;
            +    }
            +    // Allow tag mixing of 819 and 1208
            +    if ((file_ccsid == 819 || file_ccsid == 1208) && (attr_ccsid == 1208 || attr_ccsid == 819)) {
            +      return;
            +    }
            +    // Don't check for binary files, just add them
            +    if (attr_ccsid == FT_BINARY)
            +      return;
            +
            +   char attr_csname[_XOPEN_PATH_MAX] = {0};
            +    char file_csname[_XOPEN_PATH_MAX] = {0};
            +    if (attr_ccsid != FT_BINARY) {
            +      __toCSName(attr_ccsid, attr_csname);
            +    } else {
            +      snprintf(attr_csname, _XOPEN_PATH_MAX, "%s", "binary");
            +    }
            +    if (file_ccsid != FT_BINARY) {
            +      __toCSName(file_ccsid, file_csname);
            +    } else {
            +      snprintf(file_csname, _XOPEN_PATH_MAX, "%s", "binary");
            +    }
            +    die("%s added file: file tag (%s) does not match working-tree-encoding (%s)", path, file_csname, attr_csname);
            +  }
            +}
            +#endif
            +
            int index_path(struct index_state *istate, struct object_id *oid,
                    const char *path, struct stat *st, unsigned flags)
            {
                    int fd;
                    struct strbuf sb = STRBUF_INIT;
                    int rc = 0;
            +   struct conv_attrs ca;
            +   int autocvtToASCII;

                    switch (st->st_mode & S_IFMT) {
                    case S_IFREG:
            +#ifdef __MVS__
            +    validate_codeset(istate, path, &autocvtToASCII);
            +#endif
                            fd = open(path, O_RDONLY);
                            if (fd < 0)
                                    return error_errno("open(\"%s\")", path);
            +#ifdef __MVS__
            +    if (!autocvtToASCII)
            +      __disableautocvt(fd);
            +#endif
                            if (index_fd(istate, oid, fd, st, OBJ_BLOB, path, flags) < 0)
                                    return error(_("%s: failed to insert into database"),
                                            path);



            """,

    },

    {
            "wrong code":
            """
                            #define DISABLE_SIGN_COMPARE_WARNINGS

            #include "git-compat-util.h"
            #include "path.h"
            #include "quote.h"
            #include "strbuf.h"
            #include "strvec.h"

            int quote_path_fully = 1;

            static inline int need_bs_quote(char c)
            {
                    return (c == '\'' || c == '!');
            }

            /* Help to copy the thing properly quoted for the shell safety.
            * any single quote is replaced with '\'', any exclamation point
            * is replaced with '\!', and the whole thing is enclosed in a
            * single quote pair.
            *
            * E.g.
            *  original     sq_quote     result
            *  name     ==> name      ==> 'name'
            *  a b      ==> a b       ==> 'a b'
            *  a'b      ==> a'\''b    ==> 'a'\''b'
            *  a!b      ==> a'\!'b    ==> 'a'\!'b'
            */
            void sq_quote_buf(struct strbuf *dst, const char *src)
            {
                    char *to_free = NULL;

                    if (dst->buf == src)
                            to_free = strbuf_detach(dst, NULL);

                    strbuf_addch(dst, '\'');
                    while (*src) {
                            size_t len = strcspn(src, "'!");
                            strbuf_add(dst, src, len);
                            src += len;
                            while (need_bs_quote(*src)) {
                                    strbuf_addstr(dst, "'\\");
                                    strbuf_addch(dst, *src++);
                                    strbuf_addch(dst, '\'');
                            }
                    }
                    strbuf_addch(dst, '\'');
                    free(to_free);
            }

            void sq_quote_buf_pretty(struct strbuf *dst, const char *src)
            {
                    static const char ok_punct[] = "+,-./:=@_^";
                    const char *p;

                    /* Avoid losing a zero-length string by adding '' */
                    if (!*src) {
                            strbuf_addstr(dst, "''");
                            return;
                    }

                    for (p = src; *p; p++) {
                            if (!isalnum(*p) && !strchr(ok_punct, *p)) {
                                    sq_quote_buf(dst, src);
                                    return;
                            }
                    }

                    /* if we get here, we did not need quoting */
                    strbuf_addstr(dst, src);
            }

            void sq_quotef(struct strbuf *dst, const char *fmt, ...)
            {
                    struct strbuf src = STRBUF_INIT;

                    va_list ap;
                    va_start(ap, fmt);
                    strbuf_vaddf(&src, fmt, ap);
                    va_end(ap);

                    sq_quote_buf(dst, src.buf);
                    strbuf_release(&src);
            }

            void sq_quote_argv(struct strbuf *dst, const char **argv)
            {
                    int i;

                    /* Copy into destination buffer. */
                    strbuf_grow(dst, 255);
                    for (i = 0; argv[i]; ++i) {
                            strbuf_addch(dst, ' ');
                            sq_quote_buf(dst, argv[i]);
                    }
            }

            /*
            * Legacy function to append each argv value, quoted as necessasry,
            * with whitespace before each value.  This results in a leading
            * space in the result.
            */
            void sq_quote_argv_pretty(struct strbuf *dst, const char **argv)
            {
                    if (argv[0])
                            strbuf_addch(dst, ' ');
                    sq_append_quote_argv_pretty(dst, argv);
            }

            /*
            * Append each argv value, quoted as necessary, with whitespace between them.
            */
            void sq_append_quote_argv_pretty(struct strbuf *dst, const char **argv)
            {
                    int i;

                    for (i = 0; argv[i]; i++) {
                            if (i > 0)
                                    strbuf_addch(dst, ' ');
                            sq_quote_buf_pretty(dst, argv[i]);
                    }
            }

            char *sq_dequote_step(char *arg, char **next)
            {
                    char *dst = arg;
                    char *src = arg;
                    char c;

                    if (*src != '\'')
                            return NULL;
                    for (;;) {
                            c = *++src;
                            if (!c)
                                    return NULL;
                            if (c != '\'') {
                                    *dst++ = c;
                                    continue;
                            }
                            /* We stepped out of sq */
                            switch (*++src) {
                            case '\0':
                                    *dst = 0;
                                    if (next)
                                            *next = NULL;
                                    return arg;
                            case '\\':
                                    /*
                                    * Allow backslashed characters outside of
                                    * single-quotes only if they need escaping,
                                    * and only if we resume the single-quoted part
                                    * afterward.
                                    */
                                    if (need_bs_quote(src[1]) && src[2] == '\'') {
                                            *dst++ = src[1];
                                            src += 2;
                                            continue;
                                    }
                            /* Fallthrough */
                            default:
                                    if (!next)
                                            return NULL;
                                    *dst = 0;
                                    *next = src;
                                    return arg;
                            }
                    }
            }

            char *sq_dequote(char *arg)
            {
                    return sq_dequote_step(arg, NULL);
            }

            static int sq_dequote_to_argv_internal(char *arg,
                                            const char ***argv, int *nr, int *alloc,
                                            struct strvec *array)
            {
                    char *next = arg;

                    if (!*arg)
                            return 0;
                    do {
                            char *dequoted = sq_dequote_step(next, &next);
                            if (!dequoted)
                                    return -1;
                            if (next) {
                                    char c;
                                    if (!isspace(*next))
                                            return -1;
                                    do {
                                            c = *++next;
                                    } while (isspace(c));
                            }
                            if (argv) {
                                    ALLOC_GROW(*argv, *nr + 1, *alloc);
                                    (*argv)[(*nr)++] = dequoted;
                            }
                            if (array)
                                    strvec_push(array, dequoted);
                    } while (next);

                    return 0;
            }

            int sq_dequote_to_argv(char *arg, const char ***argv, int *nr, int *alloc)
            {
                    return sq_dequote_to_argv_internal(arg, argv, nr, alloc, NULL);
            }

            int sq_dequote_to_strvec(char *arg, struct strvec *array)
            {
                    return sq_dequote_to_argv_internal(arg, NULL, NULL, NULL, array);
            }

            /* 1 means: quote as octal
            * 0 means: quote as octal if (quote_path_fully)
            * -1 means: never quote
            * c: quote as "\\c"
            */
            #define X8(x)   x, x, x, x, x, x, x, x
            #define X16(x)  X8(x), X8(x)
            static signed char const cq_lookup[256] = {
                    /*           0    1    2    3    4    5    6    7 */
                    /* 0x00 */   1,   1,   1,   1,   1,   1,   1, 'a',
                    /* 0x08 */ 'b', 't', 'n', 'v', 'f', 'r',   1,   1,
                    /* 0x10 */ X16(1),
                    /* 0x20 */  -1,  -1, '"',  -1,  -1,  -1,  -1,  -1,
                    /* 0x28 */ X16(-1), X16(-1), X16(-1),
                    /* 0x58 */  -1,  -1,  -1,  -1,'\\',  -1,  -1,  -1,
                    /* 0x60 */ X16(-1), X8(-1),
                    /* 0x78 */  -1,  -1,  -1,  -1,  -1,  -1,  -1,   1,
                    /* 0x80 */ /* set to 0 */
            };

            static inline int cq_must_quote(char c)
            {
                    return cq_lookup[(unsigned char)c] + quote_path_fully > 0;
            }

            /* returns the longest prefix not needing a quote up to maxlen if positive.
            This stops at the first \0 because it's marked as a character needing an
            escape */
            static size_t next_quote_pos(const char *s, ssize_t maxlen)
            {
                    size_t len;
                    if (maxlen < 0) {
                            for (len = 0; !cq_must_quote(s[len]); len++);
                    } else {
                            for (len = 0; len < maxlen && !cq_must_quote(s[len]); len++);
                    }
                    return len;
            }

            /*
            * C-style name quoting.
            *
            * (1) if sb and fp are both NULL, inspect the input name and counts the
            *     number of bytes that are needed to hold c_style quoted version of name,
            *     counting the double quotes around it but not terminating NUL, and
            *     returns it.
            *     However, if name does not need c_style quoting, it returns 0.
            *
            * (2) if sb or fp are not NULL, it emits the c_style quoted version
            *     of name, enclosed with double quotes if asked and needed only.
            *     Return value is the same as in (1).
            */
            static size_t quote_c_style_counted(const char *name, ssize_t maxlen,
                                            struct strbuf *sb, FILE *fp, unsigned flags)
            {
            #undef EMIT
            #define EMIT(c)                                 \
                    do {                                        \
                            if (sb) strbuf_addch(sb, (c));          \
                            if (fp) fputc((c), fp);                 \
                            count++;                                \
                    } while (0)
            #define EMITBUF(s, l)                           \
                    do {                                        \
                            if (sb) strbuf_add(sb, (s), (l));       \
                            if (fp) fwrite((s), (l), 1, fp);        \
                            count += (l);                           \
                    } while (0)

                    int no_dq = !!(flags & CQUOTE_NODQ);
                    size_t len, count = 0;
                    const char *p = name;

                    for (;;) {
                            int ch;

                            len = next_quote_pos(p, maxlen);
                            if (len == maxlen || (maxlen < 0 && !p[len]))
                                    break;

                            if (!no_dq && p == name)
                                    EMIT('"');

                            EMITBUF(p, len);
                            EMIT('\\');
                            p += len;
                            ch = (unsigned char)*p++;
                            if (maxlen >= 0)
                                    maxlen -= len + 1;
                            if (cq_lookup[ch] >= ' ') {
                                    EMIT(cq_lookup[ch]);
                            } else {
                                    EMIT(((ch >> 6) & 03) + '0');
                                    EMIT(((ch >> 3) & 07) + '0');
                                    EMIT(((ch >> 0) & 07) + '0');
                            }
                    }

                    EMITBUF(p, len);
                    if (p == name)   /* no ending quote needed */
                            return 0;

                    if (!no_dq)
                            EMIT('"');
                    return count;
            }

            size_t quote_c_style(const char *name, struct strbuf *sb, FILE *fp, unsigned flags)
            {
                    return quote_c_style_counted(name, -1, sb, fp, flags);
            }

            void quote_two_c_style(struct strbuf *sb, const char *prefix, const char *path,
                            unsigned flags)
            {
                    int nodq = !!(flags & CQUOTE_NODQ);
                    if (quote_c_style(prefix, NULL, NULL, 0) ||
                    quote_c_style(path, NULL, NULL, 0)) {
                            if (!nodq)
                                    strbuf_addch(sb, '"');
                            quote_c_style(prefix, sb, NULL, CQUOTE_NODQ);
                            quote_c_style(path, sb, NULL, CQUOTE_NODQ);
                            if (!nodq)
                                    strbuf_addch(sb, '"');
                    } else {
                            strbuf_addstr(sb, prefix);
                            strbuf_addstr(sb, path);
                    }
            }

            void write_name_quoted(const char *name, FILE *fp, int terminator)
            {
                    if (terminator) {
                            quote_c_style(name, NULL, fp, 0);
                    } else {
                            fputs(name, fp);
                    }
                    fputc(terminator, fp);
            }

            void write_name_quoted_relative(const char *name, const char *prefix,
                                            FILE *fp, int terminator)
            {
                    struct strbuf sb = STRBUF_INIT;

                    name = relative_path(name, prefix, &sb);
                    write_name_quoted(name, fp, terminator);

                    strbuf_release(&sb);
            }

            /* quote path as relative to the given prefix */
            char *quote_path(const char *in, const char *prefix, struct strbuf *out, unsigned flags)
            {
                    struct strbuf sb = STRBUF_INIT;
                    const char *rel = relative_path(in, prefix, &sb);
                    int force_dq = ((flags & QUOTE_PATH_QUOTE_SP) && strchr(rel, ' '));

                    strbuf_reset(out);

                    /*
                    * If the caller wants us to enclose the output in a dq-pair
                    * whether quote_c_style_counted() needs to, we do it ourselves
                    * and tell quote_c_style_counted() not to.
                    */
                    if (force_dq)
                            strbuf_addch(out, '"');
                    quote_c_style_counted(rel, strlen(rel), out, NULL,
                                    force_dq ? CQUOTE_NODQ : 0);
                    if (force_dq)
                            strbuf_addch(out, '"');
                    strbuf_release(&sb);

                    return out->buf;
            }

            /*
            * C-style name unquoting.
            *
            * Quoted should point at the opening double quote.
            * + Returns 0 if it was able to unquote the string properly, and appends the
            *   result in the strbuf `sb'.
            * + Returns -1 in case of error, and doesn't touch the strbuf. Though note
            *   that this function will allocate memory in the strbuf, so calling
            *   strbuf_release is mandatory whichever result unquote_c_style returns.
            *
            * Updates endp pointer to point at one past the ending double quote if given.
            */
            int unquote_c_style(struct strbuf *sb, const char *quoted, const char **endp)
            {
                    size_t oldlen = sb->len, len;
                    int ch, ac;

                    if (*quoted++ != '"')
                            return -1;

                    for (;;) {
                            len = strcspn(quoted, "\"\\");
                            strbuf_add(sb, quoted, len);
                            quoted += len;

                            switch (*quoted++) {
                            case '"':
                                    if (endp)
                                            *endp = quoted;
                                    return 0;
                            case '\\':
                                    break;
                            default:
                                    goto error;
                            }

                            switch ((ch = *quoted++)) {
                            case 'a': ch = '\a'; break;
                            case 'b': ch = '\b'; break;
                            case 'f': ch = '\f'; break;
                            case 'n': ch = '\n'; break;
                            case 'r': ch = '\r'; break;
                            case 't': ch = '\t'; break;
                            case 'v': ch = '\v'; break;

                            case '\\': case '"':
                                    break; /* verbatim */

                            /* octal values with first digit over 4 overflow */
                            case '0': case '1': case '2': case '3':
                                                    ac = ((ch - '0') << 6);
                                    if ((ch = *quoted++) < '0' || '7' < ch)
                                            goto error;
                                                    ac |= ((ch - '0') << 3);
                                    if ((ch = *quoted++) < '0' || '7' < ch)
                                            goto error;
                                                    ac |= (ch - '0');
                                                    ch = ac;
                                                    break;
                                            default:
                                    goto error;
                                    }
                            strbuf_addch(sb, ch);
                            }

            error:
                    strbuf_setlen(sb, oldlen);
                    return -1;
            }

            /* quoting as a string literal for other languages */

            void perl_quote_buf(struct strbuf *sb, const char *src)
            {
                    const char sq = '\'';
                    const char bq = '\\';
                    char c;

                    strbuf_addch(sb, sq);
                    while ((c = *src++)) {
                            if (c == sq || c == bq)
                                    strbuf_addch(sb, bq);
                            strbuf_addch(sb, c);
                    }
                    strbuf_addch(sb, sq);
            }

            void perl_quote_buf_with_len(struct strbuf *sb, const char *src, size_t len)
            {
                    const char sq = '\'';
                    const char bq = '\\';
                    const char *c = src;
                    const char *end = src + len;

                    strbuf_addch(sb, sq);
                    while (c != end) {
                            if (*c == sq || *c == bq)
                                    strbuf_addch(sb, bq);
                            strbuf_addch(sb, *c);
                            c++;
                    }
                    strbuf_addch(sb, sq);
            }

            void python_quote_buf(struct strbuf *sb, const char *src)
            {
                    const char sq = '\'';
                    const char bq = '\\';
                    const char nl = '\n';
                    char c;

                    strbuf_addch(sb, sq);
                    while ((c = *src++)) {
                            if (c == nl) {
                                    strbuf_addch(sb, bq);
                                    strbuf_addch(sb, 'n');
                                    continue;
                            }
                            if (c == sq || c == bq)
                                    strbuf_addch(sb, bq);
                            strbuf_addch(sb, c);
                    }
                    strbuf_addch(sb, sq);
            }

            void tcl_quote_buf(struct strbuf *sb, const char *src)
            {
                    char c;

                    strbuf_addch(sb, '"');
                    while ((c = *src++)) {
                            switch (c) {
                            case '[': case ']':
                            case '{': case '}':
                            case '$': case '\\': case '"':
                                    strbuf_addch(sb, '\\');
                                    /* fallthrough */
                            default:
                                    strbuf_addch(sb, c);
                                    break;
                            case '\f':
                                    strbuf_addstr(sb, "\\f");
                                    break;
                            case '\r':
                                    strbuf_addstr(sb, "\\r");
                                    break;
                            case '\n':
                                    strbuf_addstr(sb, "\\n");
                                    break;
                            case '\t':
                                    strbuf_addstr(sb, "\\t");
                                    break;
                            case '\v':
                                    strbuf_addstr(sb, "\\v");
                                    break;
                            }
                    }
                    strbuf_addch(sb, '"');
            }

            void basic_regex_quote_buf(struct strbuf *sb, const char *src)
            {
                    char c;

                    if (*src == '^') {
                            /* only beginning '^' is special and needs quoting */
                            strbuf_addch(sb, '\\');
                            strbuf_addch(sb, *src++);
                    }
                    if (*src == '*')
                            /* beginning '*' is not special, no quoting */
                            strbuf_addch(sb, *src++);

                    while ((c = *src++)) {
                            switch (c) {
                            case '[':
                            case '.':
                            case '\\':
                            case '*':
                                    strbuf_addch(sb, '\\');
                                    strbuf_addch(sb, c);
                                    break;

                            case '$':
                                    /* only the end '$' is special and needs quoting */
                                    if (*src == '\0')
                                            strbuf_addch(sb, '\\');
                                    strbuf_addch(sb, c);
                                    break;

                            default:
                                    strbuf_addch(sb, c);
                                    break;
                            }
                    }
            }



            """,

            "Error":"The patch ensures that all characters in the 0x80 to 0xFF range are explicitly handled, improving the
                     robustness of Git's quoting logic.The use of macros makes the codebase easier to maintain and reduces
                     the likelihood of errors in future updates to the table.",
            "Error category":"Functionality Patche",

            "Corrected Code":
                            """
            #define DISABLE_SIGN_COMPARE_WARNINGS

            #include "git-compat-util.h"
            #include "path.h"
            #include "quote.h"
            #include "strbuf.h"
            #include "strvec.h"

            int quote_path_fully = 1;

            static inline int need_bs_quote(char c)
            {
                    return (c == '\'' || c == '!');
            }

            /* Help to copy the thing properly quoted for the shell safety.
            * any single quote is replaced with '\'', any exclamation point
            * is replaced with '\!', and the whole thing is enclosed in a
            * single quote pair.
            *
            * E.g.
            *  original     sq_quote     result
            *  name     ==> name      ==> 'name'
            *  a b      ==> a b       ==> 'a b'
            *  a'b      ==> a'\''b    ==> 'a'\''b'
            *  a!b      ==> a'\!'b    ==> 'a'\!'b'
            */
            void sq_quote_buf(struct strbuf *dst, const char *src)
            {
                    char *to_free = NULL;

                    if (dst->buf == src)
                            to_free = strbuf_detach(dst, NULL);

                    strbuf_addch(dst, '\'');
                    while (*src) {
                            size_t len = strcspn(src, "'!");
                            strbuf_add(dst, src, len);
                            src += len;
                            while (need_bs_quote(*src)) {
                                    strbuf_addstr(dst, "'\\");
                                    strbuf_addch(dst, *src++);
                                    strbuf_addch(dst, '\'');
                            }
                    }
                    strbuf_addch(dst, '\'');
                    free(to_free);
            }

            void sq_quote_buf_pretty(struct strbuf *dst, const char *src)
            {
                    static const char ok_punct[] = "+,-./:=@_^";
                    const char *p;

                    /* Avoid losing a zero-length string by adding '' */
                    if (!*src) {
                            strbuf_addstr(dst, "''");
                            return;
                    }

                    for (p = src; *p; p++) {
                            if (!isalnum(*p) && !strchr(ok_punct, *p)) {
                                    sq_quote_buf(dst, src);
                                    return;
                            }
                    }

                    /* if we get here, we did not need quoting */
                    strbuf_addstr(dst, src);
            }

            void sq_quotef(struct strbuf *dst, const char *fmt, ...)
            {
                    struct strbuf src = STRBUF_INIT;

                    va_list ap;
                    va_start(ap, fmt);
                    strbuf_vaddf(&src, fmt, ap);
                    va_end(ap);

                    sq_quote_buf(dst, src.buf);
                    strbuf_release(&src);
            }

            void sq_quote_argv(struct strbuf *dst, const char **argv)
            {
                    int i;

                    /* Copy into destination buffer. */
                    strbuf_grow(dst, 255);
                    for (i = 0; argv[i]; ++i) {
                            strbuf_addch(dst, ' ');
                            sq_quote_buf(dst, argv[i]);
                    }
            }

            /*
            * Legacy function to append each argv value, quoted as necessasry,
            * with whitespace before each value.  This results in a leading
            * space in the result.
            */
            void sq_quote_argv_pretty(struct strbuf *dst, const char **argv)
            {
                    if (argv[0])
                            strbuf_addch(dst, ' ');
                    sq_append_quote_argv_pretty(dst, argv);
            }

            /*
            * Append each argv value, quoted as necessary, with whitespace between them.
            */
            void sq_append_quote_argv_pretty(struct strbuf *dst, const char **argv)
            {
                    int i;

                    for (i = 0; argv[i]; i++) {
                            if (i > 0)
                                    strbuf_addch(dst, ' ');
                            sq_quote_buf_pretty(dst, argv[i]);
                    }
            }

            char *sq_dequote_step(char *arg, char **next)
            {
                    char *dst = arg;
                    char *src = arg;
                    char c;

                    if (*src != '\'')
                            return NULL;
                    for (;;) {
                            c = *++src;
                            if (!c)
                                    return NULL;
                            if (c != '\'') {
                                    *dst++ = c;
                                    continue;
                            }
                            /* We stepped out of sq */
                            switch (*++src) {
                            case '\0':
                                    *dst = 0;
                                    if (next)
                                            *next = NULL;
                                    return arg;
                            case '\\':
                                    /*
                                    * Allow backslashed characters outside of
                                    * single-quotes only if they need escaping,
                                    * and only if we resume the single-quoted part
                                    * afterward.
                                    */
                                    if (need_bs_quote(src[1]) && src[2] == '\'') {
                                            *dst++ = src[1];
                                            src += 2;
                                            continue;
                                    }
                            /* Fallthrough */
                            default:
                                    if (!next)
                                            return NULL;
                                    *dst = 0;
                                    *next = src;
                                    return arg;
                            }
                    }
            }

            char *sq_dequote(char *arg)
            {
                    return sq_dequote_step(arg, NULL);
            }

            static int sq_dequote_to_argv_internal(char *arg,
                                            const char ***argv, int *nr, int *alloc,
                                            struct strvec *array)
            {
                    char *next = arg;

                    if (!*arg)
                            return 0;
                    do {
                            char *dequoted = sq_dequote_step(next, &next);
                            if (!dequoted)
                                    return -1;
                            if (next) {
                                    char c;
                                    if (!isspace(*next))
                                            return -1;
                                    do {
                                            c = *++next;
                                    } while (isspace(c));
                            }
                            if (argv) {
                                    ALLOC_GROW(*argv, *nr + 1, *alloc);
                                    (*argv)[(*nr)++] = dequoted;
                            }
                            if (array)
                                    strvec_push(array, dequoted);
                    } while (next);

                    return 0;
            }

            int sq_dequote_to_argv(char *arg, const char ***argv, int *nr, int *alloc)
            {
                    return sq_dequote_to_argv_internal(arg, argv, nr, alloc, NULL);
            }

            int sq_dequote_to_strvec(char *arg, struct strvec *array)
            {
                    return sq_dequote_to_argv_internal(arg, NULL, NULL, NULL, array);
            }

            /* 1 means: quote as octal
            * 0 means: quote as octal if (quote_path_fully)
            * -1 means: never quote
            * c: quote as "\\c"
            */
            #define X8(x)   x, x, x, x, x, x, x, x
            #define X16(x)  X8(x), X8(x)
            #define X64(x)  X16(x), X16(x), X16(x), X16(x)
            #define X128(x) X64(x), X64(x)
            static signed char const cq_lookup[256] = {
                    /*           0    1    2    3    4    5    6    7 */
                    /* 0x00 */   1,   1,   1,   1,   1,   1,   1, 'a',
                    /* 0x08 */ 'b', 't', 'n', 'v', 'f', 'r',   1,   1,
                    /* 0x10 */ X16(1),
                    /* 0x20 */  -1,  -1, '"',  -1,  -1,  -1,  -1,  -1,
                    /* 0x28 */ X16(-1), X16(-1), X16(-1),
                    /* 0x58 */  -1,  -1,  -1,  -1,'\\',  -1,  -1,  -1,
                    /* 0x60 */ X16(-1), X8(-1),
                    /* 0x78 */  -1,  -1,  -1,  -1,  -1,  -1,  -1,   1,
                    /* 0x80 */ X128(-1)
            };

            static inline int cq_must_quote(char c)
            {
                    return cq_lookup[(unsigned char)c] + quote_path_fully > 0;
            }

            /* returns the longest prefix not needing a quote up to maxlen if positive.
            This stops at the first \0 because it's marked as a character needing an
            escape */
            static size_t next_quote_pos(const char *s, ssize_t maxlen)
            {
                    size_t len;
                    if (maxlen < 0) {
                            for (len = 0; !cq_must_quote(s[len]); len++);
                    } else {
                            for (len = 0; len < maxlen && !cq_must_quote(s[len]); len++);
                    }
                    return len;
            }

            /*
            * C-style name quoting.
            *
            * (1) if sb and fp are both NULL, inspect the input name and counts the
            *     number of bytes that are needed to hold c_style quoted version of name,
            *     counting the double quotes around it but not terminating NUL, and
            *     returns it.
            *     However, if name does not need c_style quoting, it returns 0.
            *
            * (2) if sb or fp are not NULL, it emits the c_style quoted version
            *     of name, enclosed with double quotes if asked and needed only.
            *     Return value is the same as in (1).
            */
            static size_t quote_c_style_counted(const char *name, ssize_t maxlen,
                                            struct strbuf *sb, FILE *fp, unsigned flags)
            {
            #undef EMIT
            #define EMIT(c)                                 \
                    do {                                        \
                            if (sb) strbuf_addch(sb, (c));          \
                            if (fp) fputc((c), fp);                 \
                            count++;                                \
                    } while (0)
            #define EMITBUF(s, l)                           \
                    do {                                        \
                            if (sb) strbuf_add(sb, (s), (l));       \
                            if (fp) fwrite((s), (l), 1, fp);        \
                            count += (l);                           \
                    } while (0)

                    int no_dq = !!(flags & CQUOTE_NODQ);
                    size_t len, count = 0;
                    const char *p = name;

                    for (;;) {
                            int ch;

                            len = next_quote_pos(p, maxlen);
                            if (len == maxlen || (maxlen < 0 && !p[len]))
                                    break;

                            if (!no_dq && p == name)
                                    EMIT('"');

                            EMITBUF(p, len);
                            EMIT('\\');
                            p += len;
                            ch = (unsigned char)*p++;
                            if (maxlen >= 0)
                                    maxlen -= len + 1;
                            if (cq_lookup[ch] >= ' ') {
                                    EMIT(cq_lookup[ch]);
                            } else {
                                    EMIT(((ch >> 6) & 03) + '0');
                                    EMIT(((ch >> 3) & 07) + '0');
                                    EMIT(((ch >> 0) & 07) + '0');
                            }
                    }

                    EMITBUF(p, len);
                    if (p == name)   /* no ending quote needed */
                            return 0;

                    if (!no_dq)
                            EMIT('"');
                    return count;
            }

            size_t quote_c_style(const char *name, struct strbuf *sb, FILE *fp, unsigned flags)
            {
                    return quote_c_style_counted(name, -1, sb, fp, flags);
            }

            void quote_two_c_style(struct strbuf *sb, const char *prefix, const char *path,
                            unsigned flags)
            {
                    int nodq = !!(flags & CQUOTE_NODQ);
                    if (quote_c_style(prefix, NULL, NULL, 0) ||
                    quote_c_style(path, NULL, NULL, 0)) {
                            if (!nodq)
                                    strbuf_addch(sb, '"');
                            quote_c_style(prefix, sb, NULL, CQUOTE_NODQ);
                            quote_c_style(path, sb, NULL, CQUOTE_NODQ);
                            if (!nodq)
                                    strbuf_addch(sb, '"');
                    } else {
                            strbuf_addstr(sb, prefix);
                            strbuf_addstr(sb, path);
                    }
            }

            void write_name_quoted(const char *name, FILE *fp, int terminator)
            {
                    if (terminator) {
                            quote_c_style(name, NULL, fp, 0);
                    } else {
                            fputs(name, fp);
                    }
                    fputc(terminator, fp);
            }

            void write_name_quoted_relative(const char *name, const char *prefix,
                                            FILE *fp, int terminator)
            {
                    struct strbuf sb = STRBUF_INIT;

                    name = relative_path(name, prefix, &sb);
                    write_name_quoted(name, fp, terminator);

                    strbuf_release(&sb);
            }

            /* quote path as relative to the given prefix */
            char *quote_path(const char *in, const char *prefix, struct strbuf *out, unsigned flags)
            {
                    struct strbuf sb = STRBUF_INIT;
                    const char *rel = relative_path(in, prefix, &sb);
                    int force_dq = ((flags & QUOTE_PATH_QUOTE_SP) && strchr(rel, ' '));

                    strbuf_reset(out);

                    /*
                    * If the caller wants us to enclose the output in a dq-pair
                    * whether quote_c_style_counted() needs to, we do it ourselves
                    * and tell quote_c_style_counted() not to.
                    */
                    if (force_dq)
                            strbuf_addch(out, '"');
                    quote_c_style_counted(rel, strlen(rel), out, NULL,
                                    force_dq ? CQUOTE_NODQ : 0);
                    if (force_dq)
                            strbuf_addch(out, '"');
                    strbuf_release(&sb);

                    return out->buf;
            }

            /*
            * C-style name unquoting.
            *
            * Quoted should point at the opening double quote.
            * + Returns 0 if it was able to unquote the string properly, and appends the
            *   result in the strbuf `sb'.
            * + Returns -1 in case of error, and doesn't touch the strbuf. Though note
            *   that this function will allocate memory in the strbuf, so calling
            *   strbuf_release is mandatory whichever result unquote_c_style returns.
            *
            * Updates endp pointer to point at one past the ending double quote if given.
            */
            int unquote_c_style(struct strbuf *sb, const char *quoted, const char **endp)
            {
                    size_t oldlen = sb->len, len;
                    int ch, ac;

                    if (*quoted++ != '"')
                            return -1;

                    for (;;) {
                            len = strcspn(quoted, "\"\\");
                            strbuf_add(sb, quoted, len);
                            quoted += len;

                            switch (*quoted++) {
                            case '"':
                                    if (endp)
                                            *endp = quoted;
                                    return 0;
                            case '\\':
                                    break;
                            default:
                                    goto error;
                            }

                            switch ((ch = *quoted++)) {
                            case 'a': ch = '\a'; break;
                            case 'b': ch = '\b'; break;
                            case 'f': ch = '\f'; break;
                            case 'n': ch = '\n'; break;
                            case 'r': ch = '\r'; break;
                            case 't': ch = '\t'; break;
                            case 'v': ch = '\v'; break;

                            case '\\': case '"':
                                    break; /* verbatim */

                            /* octal values with first digit over 4 overflow */
                            case '0': case '1': case '2': case '3':
                                                    ac = ((ch - '0') << 6);
                                    if ((ch = *quoted++) < '0' || '7' < ch)
                                            goto error;
                                                    ac |= ((ch - '0') << 3);
                                    if ((ch = *quoted++) < '0' || '7' < ch)
                                            goto error;
                                                    ac |= (ch - '0');
                                                    ch = ac;
                                                    break;
                                            default:
                                    goto error;
                                    }
                            strbuf_addch(sb, ch);
                            }

            error:
                    strbuf_setlen(sb, oldlen);
                    return -1;
            }

            /* quoting as a string literal for other languages */

            void perl_quote_buf(struct strbuf *sb, const char *src)
            {
                    const char sq = '\'';
                    const char bq = '\\';
                    char c;

                    strbuf_addch(sb, sq);
                    while ((c = *src++)) {
                            if (c == sq || c == bq)
                                    strbuf_addch(sb, bq);
                            strbuf_addch(sb, c);
                    }
                    strbuf_addch(sb, sq);
            }

            void perl_quote_buf_with_len(struct strbuf *sb, const char *src, size_t len)
            {
                    const char sq = '\'';
                    const char bq = '\\';
                    const char *c = src;
                    const char *end = src + len;

                    strbuf_addch(sb, sq);
                    while (c != end) {
                            if (*c == sq || *c == bq)
                                    strbuf_addch(sb, bq);
                            strbuf_addch(sb, *c);
                            c++;
                    }
                    strbuf_addch(sb, sq);
            }

            void python_quote_buf(struct strbuf *sb, const char *src)
            {
                    const char sq = '\'';
                    const char bq = '\\';
                    const char nl = '\n';
                    char c;

                    strbuf_addch(sb, sq);
                    while ((c = *src++)) {
                            if (c == nl) {
                                    strbuf_addch(sb, bq);
                                    strbuf_addch(sb, 'n');
                                    continue;
                            }
                            if (c == sq || c == bq)
                                    strbuf_addch(sb, bq);
                            strbuf_addch(sb, c);
                    }
                    strbuf_addch(sb, sq);
            }

            void tcl_quote_buf(struct strbuf *sb, const char *src)
            {
                    char c;

                    strbuf_addch(sb, '"');
                    while ((c = *src++)) {
                            switch (c) {
                            case '[': case ']':
                            case '{': case '}':
                            case '$': case '\\': case '"':
                                    strbuf_addch(sb, '\\');
                                    /* fallthrough */
                            default:
                                    strbuf_addch(sb, c);
                                    break;
                            case '\f':
                                    strbuf_addstr(sb, "\\f");
                                    break;
                            case '\r':
                                    strbuf_addstr(sb, "\\r");
                                    break;
                            case '\n':
                                    strbuf_addstr(sb, "\\n");
                                    break;
                            case '\t':
                                    strbuf_addstr(sb, "\\t");
                                    break;
                            case '\v':
                                    strbuf_addstr(sb, "\\v");
                                    break;
                            }
                    }
                    strbuf_addch(sb, '"');
            }

            void basic_regex_quote_buf(struct strbuf *sb, const char *src)
            {
                    char c;

                    if (*src == '^') {
                            /* only beginning '^' is special and needs quoting */
                            strbuf_addch(sb, '\\');
                            strbuf_addch(sb, *src++);
                    }
                    if (*src == '*')
                            /* beginning '*' is not special, no quoting */
                            strbuf_addch(sb, *src++);

                    while ((c = *src++)) {
                            switch (c) {
                            case '[':
                            case '.':
                            case '\\':
                            case '*':
                                    strbuf_addch(sb, '\\');
                                    strbuf_addch(sb, c);
                                    break;

                            case '$':
                                    /* only the end '$' is special and needs quoting */
                                    if (*src == '\0')
                                            strbuf_addch(sb, '\\');
                                    strbuf_addch(sb, c);
                                    break;

                            default:
                                    strbuf_addch(sb, c);
                                    break;
                            }
                    }
            }

            """,
            "Patche":
            """
            diff --git a/quote.c b/quote.c
            index 3c05194496..3643312db7 100644
            --- a/quote.c
            +++ b/quote.c
            @@ -217,6 +217,8 @@ int sq_dequote_to_strvec(char *arg, struct strvec *array)
            */
            #define X8(x)   x, x, x, x, x, x, x, x
            #define X16(x)  X8(x), X8(x)
            +#define X64(x)  X16(x), X16(x), X16(x), X16(x)
            +#define X128(x) X64(x), X64(x)
            static signed char const cq_lookup[256] = {
                    /*           0    1    2    3    4    5    6    7 */
                    /* 0x00 */   1,   1,   1,   1,   1,   1,   1, 'a',
            @@ -227,7 +229,7 @@ static signed char const cq_lookup[256] = {
                    /* 0x58 */  -1,  -1,  -1,  -1,'\\',  -1,  -1,  -1,
                    /* 0x60 */ X16(-1), X8(-1),
                    /* 0x78 */  -1,  -1,  -1,  -1,  -1,  -1,  -1,   1,
            -   /* 0x80 */ /* set to 0 */
            +   /* 0x80 */ X128(-1)
            };

            static inline int cq_must_quote(char c)


            """,
            },

    {
            "wrong code":

            """
                            #ifndef READ_CACHE_LL_H
            #define READ_CACHE_LL_H

            #include "hash.h"
            #include "hashmap.h"
            #include "statinfo.h"

            /*
            * Basic data structures for the directory cache
            */

            #define CACHE_SIGNATURE 0x44495243      /* "DIRC" */
            struct cache_header {
                    uint32_t hdr_signature;
                    uint32_t hdr_version;
                    uint32_t hdr_entries;
            };

            #define INDEX_FORMAT_LB 2
            #define INDEX_FORMAT_UB 4

            struct cache_entry {
                    struct hashmap_entry ent;
                    struct stat_data ce_stat_data;
                    unsigned int ce_mode;
                    unsigned int ce_flags;
                    unsigned int mem_pool_allocated;
                    unsigned int ce_namelen;
                    unsigned int index;     /* for link extension */
                    struct object_id oid;
                    char name[FLEX_ARRAY]; /* more */
            };

            #define CE_STAGEMASK (0x3000)
            #define CE_EXTENDED  (0x4000)
            #define CE_VALID     (0x8000)
            #define CE_STAGESHIFT 12

            /*
            * Range 0xFFFF0FFF in ce_flags is divided into
            * two parts: in-memory flags and on-disk ones.
            * Flags in CE_EXTENDED_FLAGS will get saved on-disk
            * if you want to save a new flag, add it in
            * CE_EXTENDED_FLAGS
            *
            * In-memory only flags
            */
            #define CE_UPDATE            (1 << 16)
            #define CE_REMOVE            (1 << 17)
            #define CE_UPTODATE          (1 << 18)
            #define CE_ADDED             (1 << 19)

            #define CE_HASHED            (1 << 20)
            #define CE_FSMONITOR_VALID   (1 << 21)
            #define CE_WT_REMOVE         (1 << 22) /* remove in work directory */
            #define CE_CONFLICTED        (1 << 23)

            #define CE_UNPACKED          (1 << 24)
            #define CE_NEW_SKIP_WORKTREE (1 << 25)

            /* used to temporarily mark paths matched by pathspecs */
            #define CE_MATCHED           (1 << 26)

            #define CE_UPDATE_IN_BASE    (1 << 27)
            #define CE_STRIP_NAME        (1 << 28)

            /*
            * Extended on-disk flags
            */
            #define CE_INTENT_TO_ADD     (1 << 29)
            #define CE_SKIP_WORKTREE     (1 << 30)
            /* CE_EXTENDED2 is for future extension */
            #define CE_EXTENDED2         (1U << 31)

            #define CE_EXTENDED_FLAGS (CE_INTENT_TO_ADD | CE_SKIP_WORKTREE)

            /*
            * Safeguard to avoid saving wrong flags:
            *  - CE_EXTENDED2 won't get saved until its semantic is known
            *  - Bits in 0x0000FFFF have been saved in ce_flags already
            *  - Bits in 0x003F0000 are currently in-memory flags
            */
            #if CE_EXTENDED_FLAGS & 0x803FFFFF
            #error "CE_EXTENDED_FLAGS out of range"
            #endif

            /* Forward structure decls */
            struct pathspec;
            struct tree;

            /*
            * Copy the sha1 and stat state of a cache entry from one to
            * another. But we never change the name, or the hash state!
            */
            static inline void copy_cache_entry(struct cache_entry *dst,
                                            const struct cache_entry *src)
            {
                    unsigned int state = dst->ce_flags & CE_HASHED;
                    int mem_pool_allocated = dst->mem_pool_allocated;

                    /* Don't copy hash chain and name */
                    memcpy(&dst->ce_stat_data, &src->ce_stat_data,
                                    offsetof(struct cache_entry, name) -
                                    offsetof(struct cache_entry, ce_stat_data));

                    /* Restore the hash state */
                    dst->ce_flags = (dst->ce_flags & ~CE_HASHED) | state;

                    /* Restore the mem_pool_allocated flag */
                    dst->mem_pool_allocated = mem_pool_allocated;
            }

            static inline unsigned create_ce_flags(unsigned stage)
            {
                    return (stage << CE_STAGESHIFT);
            }

            #define ce_namelen(ce) ((ce)->ce_namelen)
            #define ce_size(ce) cache_entry_size(ce_namelen(ce))
            #define ce_stage(ce) ((CE_STAGEMASK & (ce)->ce_flags) >> CE_STAGESHIFT)
            #define ce_uptodate(ce) ((ce)->ce_flags & CE_UPTODATE)
            #define ce_skip_worktree(ce) ((ce)->ce_flags & CE_SKIP_WORKTREE)
            #define ce_mark_uptodate(ce) ((ce)->ce_flags |= CE_UPTODATE)
            #define ce_intent_to_add(ce) ((ce)->ce_flags & CE_INTENT_TO_ADD)

            #define cache_entry_size(len) (offsetof(struct cache_entry,name) + (len) + 1)

            #define SOMETHING_CHANGED       (1 << 0) /* unclassified changes go here */
            #define CE_ENTRY_CHANGED        (1 << 1)
            #define CE_ENTRY_REMOVED        (1 << 2)
            #define CE_ENTRY_ADDED          (1 << 3)
            #define RESOLVE_UNDO_CHANGED    (1 << 4)
            #define CACHE_TREE_CHANGED      (1 << 5)
            #define SPLIT_INDEX_ORDERED     (1 << 6)
            #define UNTRACKED_CHANGED       (1 << 7)
            #define FSMONITOR_CHANGED       (1 << 8)

            struct split_index;
            struct untracked_cache;
            struct progress;
            struct pattern_list;

            enum sparse_index_mode {
                    /*
                    * There are no sparse directories in the index at all.
                    *
                    * Repositories that don't use cone-mode sparse-checkout will
                    * always have their indexes in this mode.
                    */
                    INDEX_EXPANDED = 0,

                    /*
                    * The index has already been collapsed to sparse directories
                    * wherever possible.
                    */
                    INDEX_COLLAPSED,

                    /*
                    * The sparse directories that exist are outside the
                    * sparse-checkout boundary, but it is possible that some file
                    * entries could collapse to sparse directory entries.
                    */
                    INDEX_PARTIALLY_SPARSE,
            };

            struct index_state {
                    struct cache_entry **cache;
                    unsigned int version;
                    unsigned int cache_nr, cache_alloc, cache_changed;
                    struct string_list *resolve_undo;
                    struct cache_tree *cache_tree;
                    struct split_index *split_index;
                    struct cache_time timestamp;
                    unsigned name_hash_initialized : 1,
                            initialized : 1,
                            drop_cache_tree : 1,
                            updated_workdir : 1,
                            updated_skipworktree : 1,
                            fsmonitor_has_run_once : 1;
                    enum sparse_index_mode sparse_index;
                    struct hashmap name_hash;
                    struct hashmap dir_hash;
                    struct object_id oid;
                    struct untracked_cache *untracked;
                    char *fsmonitor_last_update;
                    struct ewah_bitmap *fsmonitor_dirty;
                    struct mem_pool *ce_mem_pool;
                    struct progress *progress;
                    struct repository *repo;
                    struct pattern_list *sparse_checkout_patterns;
            };

            /**
            * A "struct index_state istate" must be initialized with
            * INDEX_STATE_INIT or the corresponding index_state_init().
            *
            * If the variable won't be used again, use release_index() to free()
            * its resources. If it needs to be used again use discard_index(),
            * which does the same thing, but will use index_state_init() at
            * the end. The discard_index() will use its own "istate->repo" as the
            * "r" argument to index_state_init() in that case.
            */
            #define INDEX_STATE_INIT(r) { \
                    .repo = (r), \
            }
            void index_state_init(struct index_state *istate, struct repository *r);
            void release_index(struct index_state *istate);

            /* Cache entry creation and cleanup */

            /*
            * Create cache_entry intended for use in the specified index. Caller
            * is responsible for discarding the cache_entry with
            * `discard_cache_entry`.
            */
            struct cache_entry *make_cache_entry(struct index_state *istate,
                                            unsigned int mode,
                                            const struct object_id *oid,
                                            const char *path,
                                            int stage,
                                            unsigned int refresh_options);

            struct cache_entry *make_empty_cache_entry(struct index_state *istate,
                                                    size_t name_len);

            /*
            * Create a cache_entry that is not intended to be added to an index. If
            * `ce_mem_pool` is not NULL, the entry is allocated within the given memory
            * pool. Caller is responsible for discarding "loose" entries with
            * `discard_cache_entry()` and the memory pool with
            * `mem_pool_discard(ce_mem_pool, should_validate_cache_entries())`.
            */
            struct cache_entry *make_transient_cache_entry(unsigned int mode,
                                                    const struct object_id *oid,
                                                    const char *path,
                                                    int stage,
                                                    struct mem_pool *ce_mem_pool);

            struct cache_entry *make_empty_transient_cache_entry(size_t len,
                                                            struct mem_pool *ce_mem_pool);

            /*
            * Discard cache entry.
            */
            void discard_cache_entry(struct cache_entry *ce);

            /*
            * Check configuration if we should perform extra validation on cache
            * entries.
            */
            int should_validate_cache_entries(void);

            /*
            * Duplicate a cache_entry. Allocate memory for the new entry from a
            * memory_pool. Takes into account cache_entry fields that are meant
            * for managing the underlying memory allocation of the cache_entry.
            */
            struct cache_entry *dup_cache_entry(const struct cache_entry *ce, struct index_state *istate);

            /*
            * Validate the cache entries in the index.  This is an internal
            * consistency check that the cache_entry structs are allocated from
            * the expected memory pool.
            */
            void validate_cache_entries(const struct index_state *istate);

            /*
            * Bulk prefetch all missing cache entries that are not GITLINKs and that match
            * the given predicate. This function should only be called if
            * repo_has_promisor_remote() returns true.
            */
            typedef int (*must_prefetch_predicate)(const struct cache_entry *);
            void prefetch_cache_entries(const struct index_state *istate,
                                    must_prefetch_predicate must_prefetch);

            /* Initialize and use the cache information */
            struct lock_file;
            int do_read_index(struct index_state *istate, const char *path,
                            int must_exist); /* for testting only! */
            int read_index_from(struct index_state *, const char *path,
                            const char *gitdir);
            int is_index_unborn(struct index_state *);

            /* For use with `write_locked_index()`. */
            #define COMMIT_LOCK             (1 << 0)
            #define SKIP_IF_UNCHANGED       (1 << 1)

            /*
            * Write the index while holding an already-taken lock. Close the lock,
            * and if `COMMIT_LOCK` is given, commit it.
            *
            * Unless a split index is in use, write the index into the lockfile.
            *
            * With a split index, write the shared index to a temporary file,
            * adjust its permissions and rename it into place, then write the
            * split index to the lockfile. If the temporary file for the shared
            * index cannot be created, fall back to the behavior described in
            * the previous paragraph.
            *
            * With `COMMIT_LOCK`, the lock is always committed or rolled back.
            * Without it, the lock is closed, but neither committed nor rolled
            * back.
            *
            * If `SKIP_IF_UNCHANGED` is given and the index is unchanged, nothing
            * is written (and the lock is rolled back if `COMMIT_LOCK` is given).
            */
            int write_locked_index(struct index_state *, struct lock_file *lock, unsigned flags);

            void discard_index(struct index_state *);
            void move_index_extensions(struct index_state *dst, struct index_state *src);
            int unmerged_index(const struct index_state *);

            /**
            * Returns 1 if istate differs from tree, 0 otherwise.  If tree is NULL,
            * compares istate to HEAD.  If tree is NULL and on an unborn branch,
            * returns 1 if there are entries in istate, 0 otherwise.  If an strbuf is
            * provided, the space-separated list of files that differ will be appended
            * to it.
            */
            int repo_index_has_changes(struct repository *repo,
                                    struct tree *tree,
                                    struct strbuf *sb);

            int verify_path(const char *path, unsigned mode);
            int strcmp_offset(const char *s1, const char *s2, size_t *first_change);

            /*
            * Searches for an entry defined by name and namelen in the given index.
            * If the return value is positive (including 0) it is the position of an
            * exact match. If the return value is negative, the negated value minus 1
            * is the position where the entry would be inserted.
            * Example: The current index consists of these files and its stages:
            *
            *   b#0, d#0, f#1, f#3
            *
            * index_name_pos(&index, "a", 1) -> -1
            * index_name_pos(&index, "b", 1) ->  0
            * index_name_pos(&index, "c", 1) -> -2
            * index_name_pos(&index, "d", 1) ->  1
            * index_name_pos(&index, "e", 1) -> -3
            * index_name_pos(&index, "f", 1) -> -3
            * index_name_pos(&index, "g", 1) -> -5
            */
            int index_name_pos(struct index_state *, const char *name, int namelen);

            /*
            * Like index_name_pos, returns the position of an entry of the given name in
            * the index if one exists, otherwise returns a negative value where the negated
            * value minus 1 is the position where the index entry would be inserted. Unlike
            * index_name_pos, however, a sparse index is not expanded to find an entry
            * inside a sparse directory.
            */
            int index_name_pos_sparse(struct index_state *, const char *name, int namelen);

            /*
            * Determines whether an entry with the given name exists within the
            * given index. The return value is 1 if an exact match is found, otherwise
            * it is 0. Note that, unlike index_name_pos, this function does not expand
            * the index if it is sparse. If an item exists within the full index but it
            * is contained within a sparse directory (and not in the sparse index), 0 is
            * returned.
            */
            int index_entry_exists(struct index_state *, const char *name, int namelen);

            /*
            * Some functions return the negative complement of an insert position when a
            * precise match was not found but a position was found where the entry would
            * need to be inserted. This helper protects that logic from any integer
            * underflow.
            */
            static inline int index_pos_to_insert_pos(uintmax_t pos)
            {
                    if (pos > INT_MAX)
                            die("overflow: -1 - %"PRIuMAX, pos);
                    return -1 - (int)pos;
            }

            #define ADD_CACHE_OK_TO_ADD 1           /* Ok to add */
            #define ADD_CACHE_OK_TO_REPLACE 2       /* Ok to replace file/directory */
            #define ADD_CACHE_SKIP_DFCHECK 4        /* Ok to skip DF conflict checks */
            #define ADD_CACHE_JUST_APPEND 8         /* Append only */
            #define ADD_CACHE_NEW_ONLY 16           /* Do not replace existing ones */
            #define ADD_CACHE_KEEP_CACHE_TREE 32    /* Do not invalidate cache-tree */
            #define ADD_CACHE_RENORMALIZE 64        /* Pass along HASH_RENORMALIZE */
            int add_index_entry(struct index_state *, struct cache_entry *ce, int option);
            void rename_index_entry_at(struct index_state *, int pos, const char *new_name);

            /* Remove entry, return true if there are more entries to go. */
            int remove_index_entry_at(struct index_state *, int pos);

            void remove_marked_cache_entries(struct index_state *istate, int invalidate);
            int remove_file_from_index(struct index_state *, const char *path);
            #define ADD_CACHE_VERBOSE 1
            #define ADD_CACHE_PRETEND 2
            #define ADD_CACHE_IGNORE_ERRORS 4
            #define ADD_CACHE_IGNORE_REMOVAL 8
            #define ADD_CACHE_INTENT 16
            /*
            * These two are used to add the contents of the file at path
            * to the index, marking the working tree up-to-date by storing
            * the cached stat info in the resulting cache entry.  A caller
            * that has already run lstat(2) on the path can call
            * add_to_index(), and all others can call add_file_to_index();
            * the latter will do necessary lstat(2) internally before
            * calling the former.
            */
            int add_to_index(struct index_state *, const char *path, struct stat *, int flags);
            int add_file_to_index(struct index_state *, const char *path, int flags);

            int chmod_index_entry(struct index_state *, struct cache_entry *ce, char flip);
            int ce_same_name(const struct cache_entry *a, const struct cache_entry *b);
            void set_object_name_for_intent_to_add_entry(struct cache_entry *ce);
            int index_name_is_other(struct index_state *, const char *, int);
            void *read_blob_data_from_index(struct index_state *, const char *, unsigned long *);

            /* do stat comparison even if CE_VALID is true */
            #define CE_MATCH_IGNORE_VALID           01
            /* do not check the contents but report dirty on racily-clean entries */
            #define CE_MATCH_RACY_IS_DIRTY          02
            /* do stat comparison even if CE_SKIP_WORKTREE is true */
            #define CE_MATCH_IGNORE_SKIP_WORKTREE   04
            /* ignore non-existent files during stat update  */
            #define CE_MATCH_IGNORE_MISSING         0x08
            /* enable stat refresh */
            #define CE_MATCH_REFRESH                0x10
            /* don't refresh_fsmonitor state or do stat comparison even if CE_FSMONITOR_VALID is true */
            #define CE_MATCH_IGNORE_FSMONITOR 0X20
            int is_racy_timestamp(const struct index_state *istate,
                            const struct cache_entry *ce);
            int has_racy_timestamp(struct index_state *istate);
            int ie_match_stat(struct index_state *, const struct cache_entry *, struct stat *, unsigned int);
            int ie_modified(struct index_state *, const struct cache_entry *, struct stat *, unsigned int);

            int match_stat_data_racy(const struct index_state *istate,
                                    const struct stat_data *sd, struct stat *st);

            void fill_stat_cache_info(struct index_state *istate, struct cache_entry *ce, struct stat *st);

            /*
            * Fill members of st by members of sd enough to convince match_stat()
            * to consider that they match.  It should be usable as a replacement
            * for lstat() for a tracked path that is known to be up-to-date via
            * some out-of-line means (like fsmonitor).
            */
            int fake_lstat(const struct cache_entry *ce, struct stat *st);

            #define REFRESH_REALLY                   (1 << 0) /* ignore_valid */
            #define REFRESH_UNMERGED                 (1 << 1) /* allow unmerged */
            #define REFRESH_QUIET                    (1 << 2) /* be quiet about it */
            #define REFRESH_IGNORE_MISSING           (1 << 3) /* ignore non-existent */
            #define REFRESH_IGNORE_SUBMODULES        (1 << 4) /* ignore submodules */
            #define REFRESH_IN_PORCELAIN             (1 << 5) /* user friendly output, not "needs update" */
            #define REFRESH_PROGRESS                 (1 << 6) /* show progress bar if stderr is tty */
            #define REFRESH_IGNORE_SKIP_WORKTREE     (1 << 7) /* ignore skip_worktree entries */
            int refresh_index(struct index_state *, unsigned int flags, const struct pathspec *pathspec, char *seen, const char *header_msg);
            /*
            * Refresh the index and write it to disk.
            *
            * 'refresh_flags' is passed directly to 'refresh_index()', while
            * 'COMMIT_LOCK | write_flags' is passed to 'write_locked_index()', so
            * the lockfile is always either committed or rolled back.
            *
            * If 'gentle' is passed, errors locking the index are ignored.
            *
            * Return 1 if refreshing the index returns an error, -1 if writing
            * the index to disk fails, 0 on success.
            *
            * Note that if refreshing the index returns an error, we still write
            * out the index (unless locking fails).
            */
            int repo_refresh_and_write_index(struct repository*, unsigned int refresh_flags, unsigned int write_flags, int gentle, const struct pathspec *, char *seen, const char *header_msg);

            struct cache_entry *refresh_cache_entry(struct index_state *, struct cache_entry *, unsigned int);

            void set_alternate_index_output(const char *);

            extern int verify_index_checksum;
            extern int verify_ce_order;

            int cmp_cache_name_compare(const void *a_, const void *b_);

            int add_files_to_cache(struct repository *repo, const char *prefix,
                            const struct pathspec *pathspec, char *ps_matched,
                            int include_sparse, int flags);

            void overlay_tree_on_index(struct index_state *istate,
                                    const char *tree_name, const char *prefix);

            #endif /* READ_CACHE_LL_H */


            """,

            "Error":"The ignore_file_tags variable becomes accessible throughout the codebase, ensuring that all relevant logic
             for file tag handling on z/OS can interact with it. This improves Gits compatibility and functionality on z/OS by
              allowing centralized control over file tag behavior.",
            "Error Category":"Functionality Patche",

            "Corrected Code":
                                    """
                    #ifndef READ_CACHE_LL_H
                    #define READ_CACHE_LL_H

                    #include "hash.h"
                    #include "hashmap.h"
                    #include "statinfo.h"

                    /*
                    * Basic data structures for the directory cache
                    */

                    #define CACHE_SIGNATURE 0x44495243      /* "DIRC" */
                    struct cache_header {
                            uint32_t hdr_signature;
                            uint32_t hdr_version;
                            uint32_t hdr_entries;
                    };

                    #define INDEX_FORMAT_LB 2
                    #define INDEX_FORMAT_UB 4

                    struct cache_entry {
                            struct hashmap_entry ent;
                            struct stat_data ce_stat_data;
                            unsigned int ce_mode;
                            unsigned int ce_flags;
                            unsigned int mem_pool_allocated;
                            unsigned int ce_namelen;
                            unsigned int index;     /* for link extension */
                            struct object_id oid;
                            char name[FLEX_ARRAY]; /* more */
                    };

                    #define CE_STAGEMASK (0x3000)
                    #define CE_EXTENDED  (0x4000)
                    #define CE_VALID     (0x8000)
                    #define CE_STAGESHIFT 12

                    /*
                    * Range 0xFFFF0FFF in ce_flags is divided into
                    * two parts: in-memory flags and on-disk ones.
                    * Flags in CE_EXTENDED_FLAGS will get saved on-disk
                    * if you want to save a new flag, add it in
                    * CE_EXTENDED_FLAGS
                    *
                    * In-memory only flags
                    */
                    #define CE_UPDATE            (1 << 16)
                    #define CE_REMOVE            (1 << 17)
                    #define CE_UPTODATE          (1 << 18)
                    #define CE_ADDED             (1 << 19)

                    #define CE_HASHED            (1 << 20)
                    #define CE_FSMONITOR_VALID   (1 << 21)
                    #define CE_WT_REMOVE         (1 << 22) /* remove in work directory */
                    #define CE_CONFLICTED        (1 << 23)

                    #define CE_UNPACKED          (1 << 24)
                    #define CE_NEW_SKIP_WORKTREE (1 << 25)

                    /* used to temporarily mark paths matched by pathspecs */
                    #define CE_MATCHED           (1 << 26)

                    #define CE_UPDATE_IN_BASE    (1 << 27)
                    #define CE_STRIP_NAME        (1 << 28)

                    /*
                    * Extended on-disk flags
                    */
                    #define CE_INTENT_TO_ADD     (1 << 29)
                    #define CE_SKIP_WORKTREE     (1 << 30)
                    /* CE_EXTENDED2 is for future extension */
                    #define CE_EXTENDED2         (1U << 31)

                    #define CE_EXTENDED_FLAGS (CE_INTENT_TO_ADD | CE_SKIP_WORKTREE)

                    /*
                    * Safeguard to avoid saving wrong flags:
                    *  - CE_EXTENDED2 won't get saved until its semantic is known
                    *  - Bits in 0x0000FFFF have been saved in ce_flags already
                    *  - Bits in 0x003F0000 are currently in-memory flags
                    */
                    #if CE_EXTENDED_FLAGS & 0x803FFFFF
                    #error "CE_EXTENDED_FLAGS out of range"
                    #endif

                    /* Forward structure decls */
                    struct pathspec;
                    struct tree;

                    /*
                    * Copy the sha1 and stat state of a cache entry from one to
                    * another. But we never change the name, or the hash state!
                    */
                    static inline void copy_cache_entry(struct cache_entry *dst,
                                                    const struct cache_entry *src)
                    {
                            unsigned int state = dst->ce_flags & CE_HASHED;
                            int mem_pool_allocated = dst->mem_pool_allocated;

                            /* Don't copy hash chain and name */
                            memcpy(&dst->ce_stat_data, &src->ce_stat_data,
                                            offsetof(struct cache_entry, name) -
                                            offsetof(struct cache_entry, ce_stat_data));

                            /* Restore the hash state */
                            dst->ce_flags = (dst->ce_flags & ~CE_HASHED) | state;

                            /* Restore the mem_pool_allocated flag */
                            dst->mem_pool_allocated = mem_pool_allocated;
                    }

                    static inline unsigned create_ce_flags(unsigned stage)
                    {
                            return (stage << CE_STAGESHIFT);
                    }

                    #define ce_namelen(ce) ((ce)->ce_namelen)
                    #define ce_size(ce) cache_entry_size(ce_namelen(ce))
                    #define ce_stage(ce) ((CE_STAGEMASK & (ce)->ce_flags) >> CE_STAGESHIFT)
                    #define ce_uptodate(ce) ((ce)->ce_flags & CE_UPTODATE)
                    #define ce_skip_worktree(ce) ((ce)->ce_flags & CE_SKIP_WORKTREE)
                    #define ce_mark_uptodate(ce) ((ce)->ce_flags |= CE_UPTODATE)
                    #define ce_intent_to_add(ce) ((ce)->ce_flags & CE_INTENT_TO_ADD)

                    #define cache_entry_size(len) (offsetof(struct cache_entry,name) + (len) + 1)

                    #define SOMETHING_CHANGED       (1 << 0) /* unclassified changes go here */
                    #define CE_ENTRY_CHANGED        (1 << 1)
                    #define CE_ENTRY_REMOVED        (1 << 2)
                    #define CE_ENTRY_ADDED          (1 << 3)
                    #define RESOLVE_UNDO_CHANGED    (1 << 4)
                    #define CACHE_TREE_CHANGED      (1 << 5)
                    #define SPLIT_INDEX_ORDERED     (1 << 6)
                    #define UNTRACKED_CHANGED       (1 << 7)
                    #define FSMONITOR_CHANGED       (1 << 8)

                    struct split_index;
                    struct untracked_cache;
                    struct progress;
                    struct pattern_list;

                    enum sparse_index_mode {
                            /*
                            * There are no sparse directories in the index at all.
                            *
                            * Repositories that don't use cone-mode sparse-checkout will
                            * always have their indexes in this mode.
                            */
                            INDEX_EXPANDED = 0,

                            /*
                            * The index has already been collapsed to sparse directories
                            * wherever possible.
                            */
                            INDEX_COLLAPSED,

                            /*
                            * The sparse directories that exist are outside the
                            * sparse-checkout boundary, but it is possible that some file
                            * entries could collapse to sparse directory entries.
                            */
                            INDEX_PARTIALLY_SPARSE,
                    };

                    struct index_state {
                            struct cache_entry **cache;
                            unsigned int version;
                            unsigned int cache_nr, cache_alloc, cache_changed;
                            struct string_list *resolve_undo;
                            struct cache_tree *cache_tree;
                            struct split_index *split_index;
                            struct cache_time timestamp;
                            unsigned name_hash_initialized : 1,
                                    initialized : 1,
                                    drop_cache_tree : 1,
                                    updated_workdir : 1,
                                    updated_skipworktree : 1,
                                    fsmonitor_has_run_once : 1;
                            enum sparse_index_mode sparse_index;
                            struct hashmap name_hash;
                            struct hashmap dir_hash;
                            struct object_id oid;
                            struct untracked_cache *untracked;
                            char *fsmonitor_last_update;
                            struct ewah_bitmap *fsmonitor_dirty;
                            struct mem_pool *ce_mem_pool;
                            struct progress *progress;
                            struct repository *repo;
                            struct pattern_list *sparse_checkout_patterns;
                    };

                    /**
                    * A "struct index_state istate" must be initialized with
                    * INDEX_STATE_INIT or the corresponding index_state_init().
                    *
                    * If the variable won't be used again, use release_index() to free()
                    * its resources. If it needs to be used again use discard_index(),
                    * which does the same thing, but will use index_state_init() at
                    * the end. The discard_index() will use its own "istate->repo" as the
                    * "r" argument to index_state_init() in that case.
                    */
                    #define INDEX_STATE_INIT(r) { \
                            .repo = (r), \
                    }
                    void index_state_init(struct index_state *istate, struct repository *r);
                    void release_index(struct index_state *istate);

                    /* Cache entry creation and cleanup */

                    /*
                    * Create cache_entry intended for use in the specified index. Caller
                    * is responsible for discarding the cache_entry with
                    * `discard_cache_entry`.
                    */
                    struct cache_entry *make_cache_entry(struct index_state *istate,
                                                    unsigned int mode,
                                                    const struct object_id *oid,
                                                    const char *path,
                                                    int stage,
                                                    unsigned int refresh_options);

                    struct cache_entry *make_empty_cache_entry(struct index_state *istate,
                                                            size_t name_len);

                    /*
                    * Create a cache_entry that is not intended to be added to an index. If
                    * `ce_mem_pool` is not NULL, the entry is allocated within the given memory
                    * pool. Caller is responsible for discarding "loose" entries with
                    * `discard_cache_entry()` and the memory pool with
                    * `mem_pool_discard(ce_mem_pool, should_validate_cache_entries())`.
                    */
                    struct cache_entry *make_transient_cache_entry(unsigned int mode,
                                                            const struct object_id *oid,
                                                            const char *path,
                                                            int stage,
                                                            struct mem_pool *ce_mem_pool);

                    struct cache_entry *make_empty_transient_cache_entry(size_t len,
                                                                    struct mem_pool *ce_mem_pool);

                    /*
                    * Discard cache entry.
                    */
                    void discard_cache_entry(struct cache_entry *ce);

                    /*
                    * Check configuration if we should perform extra validation on cache
                    * entries.
                    */
                    int should_validate_cache_entries(void);

                    /*
                    * Duplicate a cache_entry. Allocate memory for the new entry from a
                    * memory_pool. Takes into account cache_entry fields that are meant
                    * for managing the underlying memory allocation of the cache_entry.
                    */
                    struct cache_entry *dup_cache_entry(const struct cache_entry *ce, struct index_state *istate);

                    /*
                    * Validate the cache entries in the index.  This is an internal
                    * consistency check that the cache_entry structs are allocated from
                    * the expected memory pool.
                    */
                    void validate_cache_entries(const struct index_state *istate);

                    /*
                    * Bulk prefetch all missing cache entries that are not GITLINKs and that match
                    * the given predicate. This function should only be called if
                    * repo_has_promisor_remote() returns true.
                    */
                    typedef int (*must_prefetch_predicate)(const struct cache_entry *);
                    void prefetch_cache_entries(const struct index_state *istate,
                                            must_prefetch_predicate must_prefetch);

                    /* Initialize and use the cache information */
                    struct lock_file;
                    int do_read_index(struct index_state *istate, const char *path,
                                    int must_exist); /* for testting only! */
                    int read_index_from(struct index_state *, const char *path,
                                    const char *gitdir);
                    int is_index_unborn(struct index_state *);

                    /* For use with `write_locked_index()`. */
                    #define COMMIT_LOCK             (1 << 0)
                    #define SKIP_IF_UNCHANGED       (1 << 1)

                    /*
                    * Write the index while holding an already-taken lock. Close the lock,
                    * and if `COMMIT_LOCK` is given, commit it.
                    *
                    * Unless a split index is in use, write the index into the lockfile.
                    *
                    * With a split index, write the shared index to a temporary file,
                    * adjust its permissions and rename it into place, then write the
                    * split index to the lockfile. If the temporary file for the shared
                    * index cannot be created, fall back to the behavior described in
                    * the previous paragraph.
                    *
                    * With `COMMIT_LOCK`, the lock is always committed or rolled back.
                    * Without it, the lock is closed, but neither committed nor rolled
                    * back.
                    *
                    * If `SKIP_IF_UNCHANGED` is given and the index is unchanged, nothing
                    * is written (and the lock is rolled back if `COMMIT_LOCK` is given).
                    */
                    int write_locked_index(struct index_state *, struct lock_file *lock, unsigned flags);

                    void discard_index(struct index_state *);
                    void move_index_extensions(struct index_state *dst, struct index_state *src);
                    int unmerged_index(const struct index_state *);

                    /**
                    * Returns 1 if istate differs from tree, 0 otherwise.  If tree is NULL,
                    * compares istate to HEAD.  If tree is NULL and on an unborn branch,
                    * returns 1 if there are entries in istate, 0 otherwise.  If an strbuf is
                    * provided, the space-separated list of files that differ will be appended
                    * to it.
                    */
                    int repo_index_has_changes(struct repository *repo,
                                            struct tree *tree,
                                            struct strbuf *sb);

                    int verify_path(const char *path, unsigned mode);
                    int strcmp_offset(const char *s1, const char *s2, size_t *first_change);

                    /*
                    * Searches for an entry defined by name and namelen in the given index.
                    * If the return value is positive (including 0) it is the position of an
                    * exact match. If the return value is negative, the negated value minus 1
                    * is the position where the entry would be inserted.
                    * Example: The current index consists of these files and its stages:
                    *
                    *   b#0, d#0, f#1, f#3
                    *
                    * index_name_pos(&index, "a", 1) -> -1
                    * index_name_pos(&index, "b", 1) ->  0
                    * index_name_pos(&index, "c", 1) -> -2
                    * index_name_pos(&index, "d", 1) ->  1
                    * index_name_pos(&index, "e", 1) -> -3
                    * index_name_pos(&index, "f", 1) -> -3
                    * index_name_pos(&index, "g", 1) -> -5
                    */
                    int index_name_pos(struct index_state *, const char *name, int namelen);

                    /*
                    * Like index_name_pos, returns the position of an entry of the given name in
                    * the index if one exists, otherwise returns a negative value where the negated
                    * value minus 1 is the position where the index entry would be inserted. Unlike
                    * index_name_pos, however, a sparse index is not expanded to find an entry
                    * inside a sparse directory.
                    */
                    int index_name_pos_sparse(struct index_state *, const char *name, int namelen);

                    /*
                    * Determines whether an entry with the given name exists within the
                    * given index. The return value is 1 if an exact match is found, otherwise
                    * it is 0. Note that, unlike index_name_pos, this function does not expand
                    * the index if it is sparse. If an item exists within the full index but it
                    * is contained within a sparse directory (and not in the sparse index), 0 is
                    * returned.
                    */
                    int index_entry_exists(struct index_state *, const char *name, int namelen);

                    /*
                    * Some functions return the negative complement of an insert position when a
                    * precise match was not found but a position was found where the entry would
                    * need to be inserted. This helper protects that logic from any integer
                    * underflow.
                    */
                    static inline int index_pos_to_insert_pos(uintmax_t pos)
                    {
                            if (pos > INT_MAX)
                                    die("overflow: -1 - %"PRIuMAX, pos);
                            return -1 - (int)pos;
                    }

                    #define ADD_CACHE_OK_TO_ADD 1           /* Ok to add */
                    #define ADD_CACHE_OK_TO_REPLACE 2       /* Ok to replace file/directory */
                    #define ADD_CACHE_SKIP_DFCHECK 4        /* Ok to skip DF conflict checks */
                    #define ADD_CACHE_JUST_APPEND 8         /* Append only */
                    #define ADD_CACHE_NEW_ONLY 16           /* Do not replace existing ones */
                    #define ADD_CACHE_KEEP_CACHE_TREE 32    /* Do not invalidate cache-tree */
                    #define ADD_CACHE_RENORMALIZE 64        /* Pass along HASH_RENORMALIZE */
                    int add_index_entry(struct index_state *, struct cache_entry *ce, int option);
                    void rename_index_entry_at(struct index_state *, int pos, const char *new_name);

                    /* Remove entry, return true if there are more entries to go. */
                    int remove_index_entry_at(struct index_state *, int pos);

                    void remove_marked_cache_entries(struct index_state *istate, int invalidate);
                    int remove_file_from_index(struct index_state *, const char *path);
                    #define ADD_CACHE_VERBOSE 1
                    #define ADD_CACHE_PRETEND 2
                    #define ADD_CACHE_IGNORE_ERRORS 4
                    #define ADD_CACHE_IGNORE_REMOVAL 8
                    #define ADD_CACHE_INTENT 16
                    /*
                    * These two are used to add the contents of the file at path
                    * to the index, marking the working tree up-to-date by storing
                    * the cached stat info in the resulting cache entry.  A caller
                    * that has already run lstat(2) on the path can call
                    * add_to_index(), and all others can call add_file_to_index();
                    * the latter will do necessary lstat(2) internally before
                    * calling the former.
                    */
                    int add_to_index(struct index_state *, const char *path, struct stat *, int flags);
                    int add_file_to_index(struct index_state *, const char *path, int flags);

                    int chmod_index_entry(struct index_state *, struct cache_entry *ce, char flip);
                    int ce_same_name(const struct cache_entry *a, const struct cache_entry *b);
                    void set_object_name_for_intent_to_add_entry(struct cache_entry *ce);
                    int index_name_is_other(struct index_state *, const char *, int);
                    void *read_blob_data_from_index(struct index_state *, const char *, unsigned long *);

                    /* do stat comparison even if CE_VALID is true */
                    #define CE_MATCH_IGNORE_VALID           01
                    /* do not check the contents but report dirty on racily-clean entries */
                    #define CE_MATCH_RACY_IS_DIRTY          02
                    /* do stat comparison even if CE_SKIP_WORKTREE is true */
                    #define CE_MATCH_IGNORE_SKIP_WORKTREE   04
                    /* ignore non-existent files during stat update  */
                    #define CE_MATCH_IGNORE_MISSING         0x08
                    /* enable stat refresh */
                    #define CE_MATCH_REFRESH                0x10
                    /* don't refresh_fsmonitor state or do stat comparison even if CE_FSMONITOR_VALID is true */
                    #define CE_MATCH_IGNORE_FSMONITOR 0X20
                    int is_racy_timestamp(const struct index_state *istate,
                                    const struct cache_entry *ce);
                    int has_racy_timestamp(struct index_state *istate);
                    int ie_match_stat(struct index_state *, const struct cache_entry *, struct stat *, unsigned int);
                    int ie_modified(struct index_state *, const struct cache_entry *, struct stat *, unsigned int);

                    int match_stat_data_racy(const struct index_state *istate,
                                            const struct stat_data *sd, struct stat *st);

                    void fill_stat_cache_info(struct index_state *istate, struct cache_entry *ce, struct stat *st);

                    /*
                    * Fill members of st by members of sd enough to convince match_stat()
                    * to consider that they match.  It should be usable as a replacement
                    * for lstat() for a tracked path that is known to be up-to-date via
                    * some out-of-line means (like fsmonitor).
                    */
                    int fake_lstat(const struct cache_entry *ce, struct stat *st);

                    #define REFRESH_REALLY                   (1 << 0) /* ignore_valid */
                    #define REFRESH_UNMERGED                 (1 << 1) /* allow unmerged */
                    #define REFRESH_QUIET                    (1 << 2) /* be quiet about it */
                    #define REFRESH_IGNORE_MISSING           (1 << 3) /* ignore non-existent */
                    #define REFRESH_IGNORE_SUBMODULES        (1 << 4) /* ignore submodules */
                    #define REFRESH_IN_PORCELAIN             (1 << 5) /* user friendly output, not "needs update" */
                    #define REFRESH_PROGRESS                 (1 << 6) /* show progress bar if stderr is tty */
                    #define REFRESH_IGNORE_SKIP_WORKTREE     (1 << 7) /* ignore skip_worktree entries */
                    int refresh_index(struct index_state *, unsigned int flags, const struct pathspec *pathspec, char *seen, const char *header_msg);
                    /*
                    * Refresh the index and write it to disk.
                    *
                    * 'refresh_flags' is passed directly to 'refresh_index()', while
                    * 'COMMIT_LOCK | write_flags' is passed to 'write_locked_index()', so
                    * the lockfile is always either committed or rolled back.
                    *
                    * If 'gentle' is passed, errors locking the index are ignored.
                    *
                    * Return 1 if refreshing the index returns an error, -1 if writing
                    * the index to disk fails, 0 on success.
                    *
                    * Note that if refreshing the index returns an error, we still write
                    * out the index (unless locking fails).
                    */
                    int repo_refresh_and_write_index(struct repository*, unsigned int refresh_flags, unsigned int write_flags, int gentle, const struct pathspec *, char *seen, const char *header_msg);

                    struct cache_entry *refresh_cache_entry(struct index_state *, struct cache_entry *, unsigned int);

                    void set_alternate_index_output(const char *);

                    #ifdef __MVS__
                    extern int ignore_file_tags;
                    #endif

                    extern int verify_index_checksum;
                    extern int verify_ce_order;

                    int cmp_cache_name_compare(const void *a_, const void *b_);

                    int add_files_to_cache(struct repository *repo, const char *prefix,
                                    const struct pathspec *pathspec, char *ps_matched,
                                    int include_sparse, int flags);

                    void overlay_tree_on_index(struct index_state *istate,
                                            const char *tree_name, const char *prefix);

                    #endif /* READ_CACHE_LL_H */



            """,
            "Patche":
            """
                            diff --git a/read-cache-ll.h b/read-cache-ll.h
            index 9a1a7ed..a99eef7 100644
            --- a/read-cache-ll.h
            +++ b/read-cache-ll.h
            @@ -466,6 +466,10 @@ struct cache_entry *refresh_cache_entry(struct index_state *, struct cache_entry

            void set_alternate_index_output(const char *);

            +#ifdef __MVS__
            +extern int ignore_file_tags;
            +#endif
            +
            extern int verify_index_checksum;
            extern int verify_ce_order;

            """,
    },

    {
            "Wrong Code":
            """
                            /*
            * GIT - The information manager from hell
            *
            * Copyright (C) Linus Torvalds, 2005
            */

            #define USE_THE_REPOSITORY_VARIABLE
            #define DISABLE_SIGN_COMPARE_WARNINGS

            #include "git-compat-util.h"
            #include "bulk-checkin.h"
            #include "config.h"
            #include "date.h"
            #include "diff.h"
            #include "diffcore.h"
            #include "hex.h"
            #include "tempfile.h"
            #include "lockfile.h"
            #include "cache-tree.h"
            #include "refs.h"
            #include "dir.h"
            #include "object-file.h"
            #include "object-store-ll.h"
            #include "oid-array.h"
            #include "tree.h"
            #include "commit.h"
            #include "environment.h"
            #include "gettext.h"
            #include "mem-pool.h"
            #include "name-hash.h"
            #include "object-name.h"
            #include "path.h"
            #include "preload-index.h"
            #include "read-cache.h"
            #include "repository.h"
            #include "resolve-undo.h"
            #include "revision.h"
            #include "strbuf.h"
            #include "trace2.h"
            #include "varint.h"
            #include "split-index.h"
            #include "symlinks.h"
            #include "utf8.h"
            #include "fsmonitor.h"
            #include "thread-utils.h"
            #include "progress.h"
            #include "sparse-index.h"
            #include "csum-file.h"
            #include "promisor-remote.h"
            #include "hook.h"

            /* Mask for the name length in ce_flags in the on-disk index */

            #define CE_NAMEMASK  (0x0fff)

            /* Index extensions.
            *
            * The first letter should be 'A'..'Z' for extensions that are not
            * necessary for a correct operation (i.e. optimization data).
            * When new extensions are added that _needs_ to be understood in
            * order to correctly interpret the index file, pick character that
            * is outside the range, to cause the reader to abort.
            */

            #define CACHE_EXT(s) ( (s[0]<<24)|(s[1]<<16)|(s[2]<<8)|(s[3]) )
            #define CACHE_EXT_TREE 0x54524545       /* "TREE" */
            #define CACHE_EXT_RESOLVE_UNDO 0x52455543 /* "REUC" */
            #define CACHE_EXT_LINK 0x6c696e6b         /* "link" */
            #define CACHE_EXT_UNTRACKED 0x554E5452    /* "UNTR" */
            #define CACHE_EXT_FSMONITOR 0x46534D4E    /* "FSMN" */
            #define CACHE_EXT_ENDOFINDEXENTRIES 0x454F4945  /* "EOIE" */
            #define CACHE_EXT_INDEXENTRYOFFSETTABLE 0x49454F54 /* "IEOT" */
            #define CACHE_EXT_SPARSE_DIRECTORIES 0x73646972 /* "sdir" */

            /* changes that can be kept in $GIT_DIR/index (basically all extensions) */
            #define EXTMASK (RESOLVE_UNDO_CHANGED | CACHE_TREE_CHANGED | \
                            CE_ENTRY_ADDED | CE_ENTRY_REMOVED | CE_ENTRY_CHANGED | \
                            SPLIT_INDEX_ORDERED | UNTRACKED_CHANGED | FSMONITOR_CHANGED)


            /*
            * This is an estimate of the pathname length in the index.  We use
            * this for V4 index files to guess the un-deltafied size of the index
            * in memory because of pathname deltafication.  This is not required
            * for V2/V3 index formats because their pathnames are not compressed.
            * If the initial amount of memory set aside is not sufficient, the
            * mem pool will allocate extra memory.
            */
            #define CACHE_ENTRY_PATH_LENGTH 80

            enum index_search_mode {
                    NO_EXPAND_SPARSE = 0,
                    EXPAND_SPARSE = 1
            };

            static inline struct cache_entry *mem_pool__ce_alloc(struct mem_pool *mem_pool, size_t len)
            {
                    struct cache_entry *ce;
                    ce = mem_pool_alloc(mem_pool, cache_entry_size(len));
                    ce->mem_pool_allocated = 1;
                    return ce;
            }

            static inline struct cache_entry *mem_pool__ce_calloc(struct mem_pool *mem_pool, size_t len)
            {
                    struct cache_entry * ce;
                    ce = mem_pool_calloc(mem_pool, 1, cache_entry_size(len));
                    ce->mem_pool_allocated = 1;
                    return ce;
            }

            static struct mem_pool *find_mem_pool(struct index_state *istate)
            {
                    struct mem_pool **pool_ptr;

                    if (istate->split_index && istate->split_index->base)
                            pool_ptr = &istate->split_index->base->ce_mem_pool;
                    else
                            pool_ptr = &istate->ce_mem_pool;

                    if (!*pool_ptr) {
                            *pool_ptr = xmalloc(sizeof(**pool_ptr));
                            mem_pool_init(*pool_ptr, 0);
                    }

                    return *pool_ptr;
            }

            static const char *alternate_index_output;

            static void set_index_entry(struct index_state *istate, int nr, struct cache_entry *ce)
            {
                    if (S_ISSPARSEDIR(ce->ce_mode))
                            istate->sparse_index = INDEX_COLLAPSED;

                    istate->cache[nr] = ce;
                    add_name_hash(istate, ce);
            }

            static void replace_index_entry(struct index_state *istate, int nr, struct cache_entry *ce)
            {
                    struct cache_entry *old = istate->cache[nr];

                    replace_index_entry_in_base(istate, old, ce);
                    remove_name_hash(istate, old);
                    discard_cache_entry(old);
                    ce->ce_flags &= ~CE_HASHED;
                    set_index_entry(istate, nr, ce);
                    ce->ce_flags |= CE_UPDATE_IN_BASE;
                    mark_fsmonitor_invalid(istate, ce);
                    istate->cache_changed |= CE_ENTRY_CHANGED;
            }

            void rename_index_entry_at(struct index_state *istate, int nr, const char *new_name)
            {
                    struct cache_entry *old_entry = istate->cache[nr], *new_entry, *refreshed;
                    int namelen = strlen(new_name);

                    new_entry = make_empty_cache_entry(istate, namelen);
                    copy_cache_entry(new_entry, old_entry);
                    new_entry->ce_flags &= ~CE_HASHED;
                    new_entry->ce_namelen = namelen;
                    new_entry->index = 0;
                    memcpy(new_entry->name, new_name, namelen + 1);

                    cache_tree_invalidate_path(istate, old_entry->name);
                    untracked_cache_remove_from_index(istate, old_entry->name);
                    remove_index_entry_at(istate, nr);

                    /*
                    * Refresh the new index entry. Using 'refresh_cache_entry' ensures
                    * we only update stat info if the entry is otherwise up-to-date (i.e.,
                    * the contents/mode haven't changed). This ensures that we reflect the
                    * 'ctime' of the rename in the index without (incorrectly) updating
                    * the cached stat info to reflect unstaged changes on disk.
                    */
                    refreshed = refresh_cache_entry(istate, new_entry, CE_MATCH_REFRESH);
                    if (refreshed && refreshed != new_entry) {
                            add_index_entry(istate, refreshed, ADD_CACHE_OK_TO_ADD|ADD_CACHE_OK_TO_REPLACE);
                            discard_cache_entry(new_entry);
                    } else
                            add_index_entry(istate, new_entry, ADD_CACHE_OK_TO_ADD|ADD_CACHE_OK_TO_REPLACE);
            }

            /*
            * This only updates the "non-critical" parts of the directory
            * cache, ie the parts that aren't tracked by GIT, and only used
            * to validate the cache.
            */
            void fill_stat_cache_info(struct index_state *istate, struct cache_entry *ce, struct stat *st)
            {
                    fill_stat_data(&ce->ce_stat_data, st);

                    if (assume_unchanged)
                            ce->ce_flags |= CE_VALID;

                    if (S_ISREG(st->st_mode)) {
                            ce_mark_uptodate(ce);
                            mark_fsmonitor_valid(istate, ce);
                    }
            }

            static unsigned int st_mode_from_ce(const struct cache_entry *ce)
            {
                    extern int trust_executable_bit, has_symlinks;

                    switch (ce->ce_mode & S_IFMT) {
                    case S_IFLNK:
                            return has_symlinks ? S_IFLNK : (S_IFREG | 0644);
                    case S_IFREG:
                            return (ce->ce_mode & (trust_executable_bit ? 0755 : 0644)) | S_IFREG;
                    case S_IFGITLINK:
                            return S_IFDIR | 0755;
                    case S_IFDIR:
                            return ce->ce_mode;
                    default:
                            BUG("unsupported ce_mode: %o", ce->ce_mode);
                    }
            }

            int fake_lstat(const struct cache_entry *ce, struct stat *st)
            {
                    fake_lstat_data(&ce->ce_stat_data, st);
                    st->st_mode = st_mode_from_ce(ce);

                    /* always succeed as lstat() replacement */
                    return 0;
            }

            static int ce_compare_data(struct index_state *istate,
                                    const struct cache_entry *ce,
                                    struct stat *st)
            {
                    int match = -1;
                    int fd = git_open_cloexec(ce->name, O_RDONLY);

                    if (fd >= 0) {
                            struct object_id oid;
                            if (!index_fd(istate, &oid, fd, st, OBJ_BLOB, ce->name, 0))
                                    match = !oideq(&oid, &ce->oid);
                            /* index_fd() closed the file descriptor already */
                    }
                    return match;
            }

            static int ce_compare_link(const struct cache_entry *ce, size_t expected_size)
            {
                    int match = -1;
                    void *buffer;
                    unsigned long size;
                    enum object_type type;
                    struct strbuf sb = STRBUF_INIT;

                    if (strbuf_readlink(&sb, ce->name, expected_size))
                            return -1;

                    buffer = repo_read_object_file(the_repository, &ce->oid, &type, &size);
                    if (buffer) {
                            if (size == sb.len)
                                    match = memcmp(buffer, sb.buf, size);
                            free(buffer);
                    }
                    strbuf_release(&sb);
                    return match;
            }

            static int ce_compare_gitlink(const struct cache_entry *ce)
            {
                    struct object_id oid;

                    /*
                    * We don't actually require that the .git directory
                    * under GITLINK directory be a valid git directory. It
                    * might even be missing (in case nobody populated that
                    * sub-project).
                    *
                    * If so, we consider it always to match.
                    */
                    if (repo_resolve_gitlink_ref(the_repository, ce->name,
                                            "HEAD", &oid) < 0)
                            return 0;
                    return !oideq(&oid, &ce->oid);
            }

            static int ce_modified_check_fs(struct index_state *istate,
                                            const struct cache_entry *ce,
                                            struct stat *st)
            {
                    switch (st->st_mode & S_IFMT) {
                    case S_IFREG:
                            if (ce_compare_data(istate, ce, st))
                                    return DATA_CHANGED;
                            break;
                    case S_IFLNK:
                            if (ce_compare_link(ce, xsize_t(st->st_size)))
                                    return DATA_CHANGED;
                            break;
                    case S_IFDIR:
                            if (S_ISGITLINK(ce->ce_mode))
                                    return ce_compare_gitlink(ce) ? DATA_CHANGED : 0;
                            /* else fallthrough */
                    default:
                            return TYPE_CHANGED;
                    }
                    return 0;
            }

            static int ce_match_stat_basic(const struct cache_entry *ce, struct stat *st)
            {
                    unsigned int changed = 0;

                    if (ce->ce_flags & CE_REMOVE)
                            return MODE_CHANGED | DATA_CHANGED | TYPE_CHANGED;

                    switch (ce->ce_mode & S_IFMT) {
                    case S_IFREG:
                            changed |= !S_ISREG(st->st_mode) ? TYPE_CHANGED : 0;
                            /* We consider only the owner x bit to be relevant for
                            * "mode changes"
                            */
                            if (trust_executable_bit &&
                            (0100 & (ce->ce_mode ^ st->st_mode)))
                                    changed |= MODE_CHANGED;
                            break;
                    case S_IFLNK:
                            if (!S_ISLNK(st->st_mode) &&
                            (has_symlinks || !S_ISREG(st->st_mode)))
                                    changed |= TYPE_CHANGED;
                            break;
                    case S_IFGITLINK:
                            /* We ignore most of the st_xxx fields for gitlinks */
                            if (!S_ISDIR(st->st_mode))
                                    changed |= TYPE_CHANGED;
                            else if (ce_compare_gitlink(ce))
                                    changed |= DATA_CHANGED;
                            return changed;
                    default:
                            BUG("unsupported ce_mode: %o", ce->ce_mode);
                    }

                    changed |= match_stat_data(&ce->ce_stat_data, st);

                    /* Racily smudged entry? */
                    if (!ce->ce_stat_data.sd_size) {
                            if (!is_empty_blob_oid(&ce->oid, the_repository->hash_algo))
                                    changed |= DATA_CHANGED;
                    }

                    return changed;
            }

            static int is_racy_stat(const struct index_state *istate,
                                    const struct stat_data *sd)
            {
                    return (istate->timestamp.sec &&
            #ifdef USE_NSEC
                            /* nanosecond timestamped files can also be racy! */
                            (istate->timestamp.sec < sd->sd_mtime.sec ||
                            (istate->timestamp.sec == sd->sd_mtime.sec &&
                            istate->timestamp.nsec <= sd->sd_mtime.nsec))
            #else
                            istate->timestamp.sec <= sd->sd_mtime.sec
            #endif
                            );
            }

            int is_racy_timestamp(const struct index_state *istate,
                                    const struct cache_entry *ce)
            {
                    return (!S_ISGITLINK(ce->ce_mode) &&
                            is_racy_stat(istate, &ce->ce_stat_data));
            }

            int match_stat_data_racy(const struct index_state *istate,
                                    const struct stat_data *sd, struct stat *st)
            {
                    if (is_racy_stat(istate, sd))
                            return MTIME_CHANGED;
                    return match_stat_data(sd, st);
            }

            int ie_match_stat(struct index_state *istate,
                            const struct cache_entry *ce, struct stat *st,
                            unsigned int options)
            {
                    unsigned int changed;
                    int ignore_valid = options & CE_MATCH_IGNORE_VALID;
                    int ignore_skip_worktree = options & CE_MATCH_IGNORE_SKIP_WORKTREE;
                    int assume_racy_is_modified = options & CE_MATCH_RACY_IS_DIRTY;
                    int ignore_fsmonitor = options & CE_MATCH_IGNORE_FSMONITOR;

                    if (!ignore_fsmonitor)
                            refresh_fsmonitor(istate);
                    /*
                    * If it's marked as always valid in the index, it's
                    * valid whatever the checked-out copy says.
                    *
                    * skip-worktree has the same effect with higher precedence
                    */
                    if (!ignore_skip_worktree && ce_skip_worktree(ce))
                            return 0;
                    if (!ignore_valid && (ce->ce_flags & CE_VALID))
                            return 0;
                    if (!ignore_fsmonitor && (ce->ce_flags & CE_FSMONITOR_VALID))
                            return 0;

                    /*
                    * Intent-to-add entries have not been added, so the index entry
                    * by definition never matches what is in the work tree until it
                    * actually gets added.
                    */
                    if (ce_intent_to_add(ce))
                            return DATA_CHANGED | TYPE_CHANGED | MODE_CHANGED;

                    changed = ce_match_stat_basic(ce, st);

                    /*
                    * Within 1 second of this sequence:
                    *      echo xyzzy >file && git-update-index --add file
                    * running this command:
                    *      echo frotz >file
                    * would give a falsely clean cache entry.  The mtime and
                    * length match the cache, and other stat fields do not change.
                    *
                    * We could detect this at update-index time (the cache entry
                    * being registered/updated records the same time as "now")
                    * and delay the return from git-update-index, but that would
                    * effectively mean we can make at most one commit per second,
                    * which is not acceptable.  Instead, we check cache entries
                    * whose mtime are the same as the index file timestamp more
                    * carefully than others.
                    */
                    if (!changed && is_racy_timestamp(istate, ce)) {
                            if (assume_racy_is_modified)
                                    changed |= DATA_CHANGED;
                            else
                                    changed |= ce_modified_check_fs(istate, ce, st);
                    }

                    return changed;
            }

            int ie_modified(struct index_state *istate,
                            const struct cache_entry *ce,
                            struct stat *st, unsigned int options)
            {
                    int changed, changed_fs;

                    changed = ie_match_stat(istate, ce, st, options);
                    if (!changed)
                            return 0;
                    /*
                    * If the mode or type has changed, there's no point in trying
                    * to refresh the entry - it's not going to match
                    */
                    if (changed & (MODE_CHANGED | TYPE_CHANGED))
                            return changed;

                    /*
                    * Immediately after read-tree or update-index --cacheinfo,
                    * the length field is zero, as we have never even read the
                    * lstat(2) information once, and we cannot trust DATA_CHANGED
                    * returned by ie_match_stat() which in turn was returned by
                    * ce_match_stat_basic() to signal that the filesize of the
                    * blob changed.  We have to actually go to the filesystem to
                    * see if the contents match, and if so, should answer "unchanged".
                    *
                    * The logic does not apply to gitlinks, as ce_match_stat_basic()
                    * already has checked the actual HEAD from the filesystem in the
                    * subproject.  If ie_match_stat() already said it is different,
                    * then we know it is.
                    */
                    if ((changed & DATA_CHANGED) &&
                    (S_ISGITLINK(ce->ce_mode) || ce->ce_stat_data.sd_size != 0))
                            return changed;

                    changed_fs = ce_modified_check_fs(istate, ce, st);
                    if (changed_fs)
                            return changed | changed_fs;
                    return 0;
            }

            static int cache_name_stage_compare(const char *name1, int len1, int stage1,
                                            const char *name2, int len2, int stage2)
            {
                    int cmp;

                    cmp = name_compare(name1, len1, name2, len2);
                    if (cmp)
                            return cmp;

                    if (stage1 < stage2)
                            return -1;
                    if (stage1 > stage2)
                            return 1;
                    return 0;
            }

            int cmp_cache_name_compare(const void *a_, const void *b_)
            {
                    const struct cache_entry *ce1, *ce2;

                    ce1 = *((const struct cache_entry **)a_);
                    ce2 = *((const struct cache_entry **)b_);
                    return cache_name_stage_compare(ce1->name, ce1->ce_namelen, ce_stage(ce1),
                                            ce2->name, ce2->ce_namelen, ce_stage(ce2));
            }

            static int index_name_stage_pos(struct index_state *istate,
                                            const char *name, int namelen,
                                            int stage,
                                            enum index_search_mode search_mode)
            {
                    int first, last;

                    first = 0;
                    last = istate->cache_nr;
                    while (last > first) {
                            int next = first + ((last - first) >> 1);
                            struct cache_entry *ce = istate->cache[next];
                            int cmp = cache_name_stage_compare(name, namelen, stage, ce->name, ce_namelen(ce), ce_stage(ce));
                            if (!cmp)
                                    return next;
                            if (cmp < 0) {
                                    last = next;
                                    continue;
                            }
                            first = next+1;
                    }

                    if (search_mode == EXPAND_SPARSE && istate->sparse_index &&
                    first > 0) {
                            /* Note: first <= istate->cache_nr */
                            struct cache_entry *ce = istate->cache[first - 1];

                            /*
                            * If we are in a sparse-index _and_ the entry before the
                            * insertion position is a sparse-directory entry that is
                            * an ancestor of 'name', then we need to expand the index
                            * and search again. This will only trigger once, because
                            * thereafter the index is fully expanded.
                            */
                            if (S_ISSPARSEDIR(ce->ce_mode) &&
                            ce_namelen(ce) < namelen &&
                            !strncmp(name, ce->name, ce_namelen(ce))) {
                                    ensure_full_index(istate);
                                    return index_name_stage_pos(istate, name, namelen, stage, search_mode);
                            }
                    }

                    return -first-1;
            }

            int index_name_pos(struct index_state *istate, const char *name, int namelen)
            {
                    return index_name_stage_pos(istate, name, namelen, 0, EXPAND_SPARSE);
            }

            int index_name_pos_sparse(struct index_state *istate, const char *name, int namelen)
            {
                    return index_name_stage_pos(istate, name, namelen, 0, NO_EXPAND_SPARSE);
            }

            int index_entry_exists(struct index_state *istate, const char *name, int namelen)
            {
                    return index_name_stage_pos(istate, name, namelen, 0, NO_EXPAND_SPARSE) >= 0;
            }

            int remove_index_entry_at(struct index_state *istate, int pos)
            {
                    struct cache_entry *ce = istate->cache[pos];

                    record_resolve_undo(istate, ce);
                    remove_name_hash(istate, ce);
                    save_or_free_index_entry(istate, ce);
                    istate->cache_changed |= CE_ENTRY_REMOVED;
                    istate->cache_nr--;
                    if (pos >= istate->cache_nr)
                            return 0;
                    MOVE_ARRAY(istate->cache + pos, istate->cache + pos + 1,
                            istate->cache_nr - pos);
                    return 1;
            }

            /*
            * Remove all cache entries marked for removal, that is where
            * CE_REMOVE is set in ce_flags.  This is much more effective than
            * calling remove_index_entry_at() for each entry to be removed.
            */
            void remove_marked_cache_entries(struct index_state *istate, int invalidate)
            {
                    struct cache_entry **ce_array = istate->cache;
                    unsigned int i, j;

                    for (i = j = 0; i < istate->cache_nr; i++) {
                            if (ce_array[i]->ce_flags & CE_REMOVE) {
                                    if (invalidate) {
                                            cache_tree_invalidate_path(istate,
                                                                    ce_array[i]->name);
                                            untracked_cache_remove_from_index(istate,
                                                                            ce_array[i]->name);
                                    }
                                    remove_name_hash(istate, ce_array[i]);
                                    save_or_free_index_entry(istate, ce_array[i]);
                            }
                            else
                                    ce_array[j++] = ce_array[i];
                    }
                    if (j == istate->cache_nr)
                            return;
                    istate->cache_changed |= CE_ENTRY_REMOVED;
                    istate->cache_nr = j;
            }

            int remove_file_from_index(struct index_state *istate, const char *path)
            {
                    int pos = index_name_pos(istate, path, strlen(path));
                    if (pos < 0)
                            pos = -pos-1;
                    cache_tree_invalidate_path(istate, path);
                    untracked_cache_remove_from_index(istate, path);
                    while (pos < istate->cache_nr && !strcmp(istate->cache[pos]->name, path))
                            remove_index_entry_at(istate, pos);
                    return 0;
            }

            static int compare_name(struct cache_entry *ce, const char *path, int namelen)
            {
                    return namelen != ce_namelen(ce) || memcmp(path, ce->name, namelen);
            }

            static int index_name_pos_also_unmerged(struct index_state *istate,
                    const char *path, int namelen)
            {
                    int pos = index_name_pos(istate, path, namelen);
                    struct cache_entry *ce;

                    if (pos >= 0)
                            return pos;

                    /* maybe unmerged? */
                    pos = -1 - pos;
                    if (pos >= istate->cache_nr ||
                                    compare_name((ce = istate->cache[pos]), path, namelen))
                            return -1;

                    /* order of preference: stage 2, 1, 3 */
                    if (ce_stage(ce) == 1 && pos + 1 < istate->cache_nr &&
                                    ce_stage((ce = istate->cache[pos + 1])) == 2 &&
                                    !compare_name(ce, path, namelen))
                            pos++;
                    return pos;
            }

            static int different_name(struct cache_entry *ce, struct cache_entry *alias)
            {
                    int len = ce_namelen(ce);
                    return ce_namelen(alias) != len || memcmp(ce->name, alias->name, len);
            }

            /*
            * If we add a filename that aliases in the cache, we will use the
            * name that we already have - but we don't want to update the same
            * alias twice, because that implies that there were actually two
            * different files with aliasing names!
            *
            * So we use the CE_ADDED flag to verify that the alias was an old
            * one before we accept it as
            */
            static struct cache_entry *create_alias_ce(struct index_state *istate,
                                                    struct cache_entry *ce,
                                                    struct cache_entry *alias)
            {
                    int len;
                    struct cache_entry *new_entry;

                    if (alias->ce_flags & CE_ADDED)
                            die(_("will not add file alias '%s' ('%s' already exists in index)"),
                            ce->name, alias->name);

                    /* Ok, create the new entry using the name of the existing alias */
                    len = ce_namelen(alias);
                    new_entry = make_empty_cache_entry(istate, len);
                    memcpy(new_entry->name, alias->name, len);
                    copy_cache_entry(new_entry, ce);
                    save_or_free_index_entry(istate, ce);
                    return new_entry;
            }

            void set_object_name_for_intent_to_add_entry(struct cache_entry *ce)
            {
                    struct object_id oid;
                    if (write_object_file("", 0, OBJ_BLOB, &oid))
                            die(_("cannot create an empty blob in the object database"));
                    oidcpy(&ce->oid, &oid);
            }

            int add_to_index(struct index_state *istate, const char *path, struct stat *st, int flags)
            {
                    int namelen, was_same;
                    mode_t st_mode = st->st_mode;
                    struct cache_entry *ce, *alias = NULL;
                    unsigned ce_option = CE_MATCH_IGNORE_VALID|CE_MATCH_IGNORE_SKIP_WORKTREE|CE_MATCH_RACY_IS_DIRTY;
                    int verbose = flags & (ADD_CACHE_VERBOSE | ADD_CACHE_PRETEND);
                    int pretend = flags & ADD_CACHE_PRETEND;
                    int intent_only = flags & ADD_CACHE_INTENT;
                    int add_option = (ADD_CACHE_OK_TO_ADD|ADD_CACHE_OK_TO_REPLACE|
                                    (intent_only ? ADD_CACHE_NEW_ONLY : 0));
                    unsigned hash_flags = pretend ? 0 : HASH_WRITE_OBJECT;
                    struct object_id oid;

                    if (flags & ADD_CACHE_RENORMALIZE)
                            hash_flags |= HASH_RENORMALIZE;

                    if (!S_ISREG(st_mode) && !S_ISLNK(st_mode) && !S_ISDIR(st_mode))
                            return error(_("%s: can only add regular files, symbolic links or git-directories"), path);

                    namelen = strlen(path);
                    if (S_ISDIR(st_mode)) {
                            if (repo_resolve_gitlink_ref(the_repository, path, "HEAD", &oid) < 0)
                                    return error(_("'%s' does not have a commit checked out"), path);
                            while (namelen && path[namelen-1] == '/')
                                    namelen--;
                    }
                    ce = make_empty_cache_entry(istate, namelen);
                    memcpy(ce->name, path, namelen);
                    ce->ce_namelen = namelen;
                    if (!intent_only)
                            fill_stat_cache_info(istate, ce, st);
                    else
                            ce->ce_flags |= CE_INTENT_TO_ADD;


                    if (trust_executable_bit && has_symlinks) {
                            ce->ce_mode = create_ce_mode(st_mode);
                    } else {
                            /* If there is an existing entry, pick the mode bits and type
                            * from it, otherwise assume unexecutable regular file.
                            */
                            struct cache_entry *ent;
                            int pos = index_name_pos_also_unmerged(istate, path, namelen);

                            ent = (0 <= pos) ? istate->cache[pos] : NULL;
                            ce->ce_mode = ce_mode_from_stat(ent, st_mode);
                    }

                    /* When core.ignorecase=true, determine if a directory of the same name but differing
                    * case already exists within the Git repository.  If it does, ensure the directory
                    * case of the file being added to the repository matches (is folded into) the existing
                    * entry's directory case.
                    */
                    if (ignore_case) {
                            adjust_dirname_case(istate, ce->name);
                    }
                    if (!(flags & ADD_CACHE_RENORMALIZE)) {
                            alias = index_file_exists(istate, ce->name,
                                                    ce_namelen(ce), ignore_case);
                            if (alias &&
                            !ce_stage(alias) &&
                            !ie_match_stat(istate, alias, st, ce_option)) {
                                    /* Nothing changed, really */
                                    if (!S_ISGITLINK(alias->ce_mode))
                                            ce_mark_uptodate(alias);
                                    alias->ce_flags |= CE_ADDED;

                                    discard_cache_entry(ce);
                                    return 0;
                            }
                    }
                    if (!intent_only) {
                            if (index_path(istate, &ce->oid, path, st, hash_flags)) {
                                    discard_cache_entry(ce);
                                    return error(_("unable to index file '%s'"), path);
                            }
                    } else
                            set_object_name_for_intent_to_add_entry(ce);

                    if (ignore_case && alias && different_name(ce, alias))
                            ce = create_alias_ce(istate, ce, alias);
                    ce->ce_flags |= CE_ADDED;

                    /* It was suspected to be racily clean, but it turns out to be Ok */
                    was_same = (alias &&
                            !ce_stage(alias) &&
                            oideq(&alias->oid, &ce->oid) &&
                            ce->ce_mode == alias->ce_mode);

                    if (pretend)
                            discard_cache_entry(ce);
                    else if (add_index_entry(istate, ce, add_option)) {
                            discard_cache_entry(ce);
                            return error(_("unable to add '%s' to index"), path);
                    }
                    if (verbose && !was_same)
                            printf("add '%s'\n", path);
                    return 0;
            }

            int add_file_to_index(struct index_state *istate, const char *path, int flags)
            {
                    struct stat st;
                    if (lstat(path, &st))
                            die_errno(_("unable to stat '%s'"), path);
                    return add_to_index(istate, path, &st, flags);
            }

            struct cache_entry *make_empty_cache_entry(struct index_state *istate, size_t len)
            {
                    return mem_pool__ce_calloc(find_mem_pool(istate), len);
            }

            struct cache_entry *make_empty_transient_cache_entry(size_t len,
                                                            struct mem_pool *ce_mem_pool)
            {
                    if (ce_mem_pool)
                            return mem_pool__ce_calloc(ce_mem_pool, len);
                    return xcalloc(1, cache_entry_size(len));
            }

            enum verify_path_result {
                    PATH_OK,
                    PATH_INVALID,
                    PATH_DIR_WITH_SEP,
            };

            static enum verify_path_result verify_path_internal(const char *, unsigned);

            int verify_path(const char *path, unsigned mode)
            {
                    return verify_path_internal(path, mode) == PATH_OK;
            }

            struct cache_entry *make_cache_entry(struct index_state *istate,
                                            unsigned int mode,
                                            const struct object_id *oid,
                                            const char *path,
                                            int stage,
                                            unsigned int refresh_options)
            {
                    struct cache_entry *ce, *ret;
                    int len;

                    if (verify_path_internal(path, mode) == PATH_INVALID) {
                            error(_("invalid path '%s'"), path);
                            return NULL;
                    }

                    len = strlen(path);
                    ce = make_empty_cache_entry(istate, len);

                    oidcpy(&ce->oid, oid);
                    memcpy(ce->name, path, len);
                    ce->ce_flags = create_ce_flags(stage);
                    ce->ce_namelen = len;
                    ce->ce_mode = create_ce_mode(mode);

                    ret = refresh_cache_entry(istate, ce, refresh_options);
                    if (ret != ce)
                            discard_cache_entry(ce);
                    return ret;
            }

            struct cache_entry *make_transient_cache_entry(unsigned int mode,
                                                    const struct object_id *oid,
                                                    const char *path,
                                                    int stage,
                                                    struct mem_pool *ce_mem_pool)
            {
                    struct cache_entry *ce;
                    int len;

                    if (!verify_path(path, mode)) {
                            error(_("invalid path '%s'"), path);
                            return NULL;
                    }

                    len = strlen(path);
                    ce = make_empty_transient_cache_entry(len, ce_mem_pool);

                    oidcpy(&ce->oid, oid);
                    memcpy(ce->name, path, len);
                    ce->ce_flags = create_ce_flags(stage);
                    ce->ce_namelen = len;
                    ce->ce_mode = create_ce_mode(mode);

                    return ce;
            }

            /*
            * Chmod an index entry with either +x or -x.
            *
            * Returns -1 if the chmod for the particular cache entry failed (if it's
            * not a regular file), -2 if an invalid flip argument is passed in, 0
            * otherwise.
            */
            int chmod_index_entry(struct index_state *istate, struct cache_entry *ce,
                            char flip)
            {
                    if (!S_ISREG(ce->ce_mode))
                            return -1;
                    switch (flip) {
                    case '+':
                            ce->ce_mode |= 0111;
                            break;
                    case '-':
                            ce->ce_mode &= ~0111;
                            break;
                    default:
                            return -2;
                    }
                    cache_tree_invalidate_path(istate, ce->name);
                    ce->ce_flags |= CE_UPDATE_IN_BASE;
                    mark_fsmonitor_invalid(istate, ce);
                    istate->cache_changed |= CE_ENTRY_CHANGED;

                    return 0;
            }

            int ce_same_name(const struct cache_entry *a, const struct cache_entry *b)
            {
                    int len = ce_namelen(a);
                    return ce_namelen(b) == len && !memcmp(a->name, b->name, len);
            }

            /*
            * We fundamentally don't like some paths: we don't want
            * dot or dot-dot anywhere, and for obvious reasons don't
            * want to recurse into ".git" either.
            *
            * Also, we don't want double slashes or slashes at the
            * end that can make pathnames ambiguous.
            */
            static int verify_dotfile(const char *rest, unsigned mode)
            {
                    /*
                    * The first character was '.', but that
                    * has already been discarded, we now test
                    * the rest.
                    */

                    /* "." is not allowed */
                    if (*rest == '\0' || is_dir_sep(*rest))
                            return 0;

                    switch (*rest) {
                    /*
                    * ".git" followed by NUL or slash is bad. Note that we match
                    * case-insensitively here, even if ignore_case is not set.
                    * This outlaws ".GIT" everywhere out of an abundance of caution,
                    * since there's really no good reason to allow it.
                    *
                    * Once we've seen ".git", we can also find ".gitmodules", etc (also
                    * case-insensitively).
                    */
                    case 'g':
                    case 'G':
                            if (rest[1] != 'i' && rest[1] != 'I')
                                    break;
                            if (rest[2] != 't' && rest[2] != 'T')
                                    break;
                            if (rest[3] == '\0' || is_dir_sep(rest[3]))
                                    return 0;
                            if (S_ISLNK(mode)) {
                                    rest += 3;
                                    if (skip_iprefix(rest, "modules", &rest) &&
                                    (*rest == '\0' || is_dir_sep(*rest)))
                                            return 0;
                            }
                            break;
                    case '.':
                            if (rest[1] == '\0' || is_dir_sep(rest[1]))
                                    return 0;
                    }
                    return 1;
            }

            static enum verify_path_result verify_path_internal(const char *path,
                                                            unsigned mode)
            {
                    char c = 0;

                    if (has_dos_drive_prefix(path))
                            return PATH_INVALID;

                    if (!is_valid_path(path))
                            return PATH_INVALID;

                    goto inside;
                    for (;;) {
                            if (!c)
                                    return PATH_OK;
                            if (is_dir_sep(c)) {
            inside:
                                    if (protect_hfs) {

                                            if (is_hfs_dotgit(path))
                                                    return PATH_INVALID;
                                            if (S_ISLNK(mode)) {
                                                    if (is_hfs_dotgitmodules(path))
                                                            return PATH_INVALID;
                                            }
                                    }
                                    if (protect_ntfs) {
            #if defined GIT_WINDOWS_NATIVE || defined __CYGWIN__
                                            if (c == '\\')
                                                    return PATH_INVALID;
            #endif
                                            if (is_ntfs_dotgit(path))
                                                    return PATH_INVALID;
                                            if (S_ISLNK(mode)) {
                                                    if (is_ntfs_dotgitmodules(path))
                                                            return PATH_INVALID;
                                            }
                                    }

                                    c = *path++;
                                    if ((c == '.' && !verify_dotfile(path, mode)) ||
                                    is_dir_sep(c))
                                            return PATH_INVALID;
                                    /*
                                    * allow terminating directory separators for
                                    * sparse directory entries.
                                    */
                                    if (c == '\0')
                                            return S_ISDIR(mode) ? PATH_DIR_WITH_SEP :
                                                            PATH_INVALID;
                            } else if (c == '\\' && protect_ntfs) {
                                    if (is_ntfs_dotgit(path))
                                            return PATH_INVALID;
                                    if (S_ISLNK(mode)) {
                                            if (is_ntfs_dotgitmodules(path))
                                                    return PATH_INVALID;
                                    }
                            }

                            c = *path++;
                    }
            }

            /*
            * Do we have another file that has the beginning components being a
            * proper superset of the name we're trying to add?
            */
            static int has_file_name(struct index_state *istate,
                                    const struct cache_entry *ce, int pos, int ok_to_replace)
            {
                    int retval = 0;
                    int len = ce_namelen(ce);
                    int stage = ce_stage(ce);
                    const char *name = ce->name;

                    while (pos < istate->cache_nr) {
                            struct cache_entry *p = istate->cache[pos++];

                            if (len >= ce_namelen(p))
                                    break;
                            if (memcmp(name, p->name, len))
                                    break;
                            if (ce_stage(p) != stage)
                                    continue;
                            if (p->name[len] != '/')
                                    continue;
                            if (p->ce_flags & CE_REMOVE)
                                    continue;
                            retval = -1;
                            if (!ok_to_replace)
                                    break;
                            remove_index_entry_at(istate, --pos);
                    }
                    return retval;
            }


            /*
            * Like strcmp(), but also return the offset of the first change.
            * If strings are equal, return the length.
            */
            int strcmp_offset(const char *s1, const char *s2, size_t *first_change)
            {
                    size_t k;

                    if (!first_change)
                            return strcmp(s1, s2);

                    for (k = 0; s1[k] == s2[k]; k++)
                            if (s1[k] == '\0')
                                    break;

                    *first_change = k;
                    return (unsigned char)s1[k] - (unsigned char)s2[k];
            }

            /*
            * Do we have another file with a pathname that is a proper
            * subset of the name we're trying to add?
            *
            * That is, is there another file in the index with a path
            * that matches a sub-directory in the given entry?
            */
            static int has_dir_name(struct index_state *istate,
                                    const struct cache_entry *ce, int pos, int ok_to_replace)
            {
                    int retval = 0;
                    int stage = ce_stage(ce);
                    const char *name = ce->name;
                    const char *slash = name + ce_namelen(ce);
                    size_t len_eq_last;
                    int cmp_last = 0;

                    /*
                    * We are frequently called during an iteration on a sorted
                    * list of pathnames and while building a new index.  Therefore,
                    * there is a high probability that this entry will eventually
                    * be appended to the index, rather than inserted in the middle.
                    * If we can confirm that, we can avoid binary searches on the
                    * components of the pathname.
                    *
                    * Compare the entry's full path with the last path in the index.
                    */
                    if (istate->cache_nr > 0) {
                            cmp_last = strcmp_offset(name,
                                    istate->cache[istate->cache_nr - 1]->name,
                                    &len_eq_last);
                            if (cmp_last > 0) {
                                    if (name[len_eq_last] != '/') {
                                            /*
                                            * The entry sorts AFTER the last one in the
                                            * index.
                                            *
                                            * If there were a conflict with "file", then our
                                            * name would start with "file/" and the last index
                                            * entry would start with "file" but not "file/".
                                            *
                                            * The next character after common prefix is
                                            * not '/', so there can be no conflict.
                                            */
                                            return retval;
                                    } else {
                                            /*
                                            * The entry sorts AFTER the last one in the
                                            * index, and the next character after common
                                            * prefix is '/'.
                                            *
                                            * Either the last index entry is a file in
                                            * conflict with this entry, or it has a name
                                            * which sorts between this entry and the
                                            * potential conflicting file.
                                            *
                                            * In both cases, we fall through to the loop
                                            * below and let the regular search code handle it.
                                            */
                                    }
                            } else if (cmp_last == 0) {
                                    /*
                                    * The entry exactly matches the last one in the
                                    * index, but because of multiple stage and CE_REMOVE
                                    * items, we fall through and let the regular search
                                    * code handle it.
                                    */
                            }
                    }

                    for (;;) {
                            size_t len;

                            for (;;) {
                                    if (*--slash == '/')
                                            break;
                                    if (slash <= ce->name)
                                            return retval;
                            }
                            len = slash - name;

                            pos = index_name_stage_pos(istate, name, len, stage, EXPAND_SPARSE);
                            if (pos >= 0) {
                                    /*
                                    * Found one, but not so fast.  This could
                                    * be a marker that says "I was here, but
                                    * I am being removed".  Such an entry is
                                    * not a part of the resulting tree, and
                                    * it is Ok to have a directory at the same
                                    * path.
                                    */
                                    if (!(istate->cache[pos]->ce_flags & CE_REMOVE)) {
                                            retval = -1;
                                            if (!ok_to_replace)
                                                    break;
                                            remove_index_entry_at(istate, pos);
                                            continue;
                                    }
                            }
                            else
                                    pos = -pos-1;

                            /*
                            * Trivial optimization: if we find an entry that
                            * already matches the sub-directory, then we know
                            * we're ok, and we can exit.
                            */
                            while (pos < istate->cache_nr) {
                                    struct cache_entry *p = istate->cache[pos];
                                    if ((ce_namelen(p) <= len) ||
                                    (p->name[len] != '/') ||
                                    memcmp(p->name, name, len))
                                            break; /* not our subdirectory */
                                    if (ce_stage(p) == stage && !(p->ce_flags & CE_REMOVE))
                                            /*
                                            * p is at the same stage as our entry, and
                                            * is a subdirectory of what we are looking
                                            * at, so we cannot have conflicts at our
                                            * level or anything shorter.
                                            */
                                            return retval;
                                    pos++;
                            }
                    }
                    return retval;
            }

            /* We may be in a situation where we already have path/file and path
            * is being added, or we already have path and path/file is being
            * added.  Either one would result in a nonsense tree that has path
            * twice when git-write-tree tries to write it out.  Prevent it.
            *
            * If ok-to-replace is specified, we remove the conflicting entries
            * from the cache so the caller should recompute the insert position.
            * When this happens, we return non-zero.
            */
            static int check_file_directory_conflict(struct index_state *istate,
                                                    const struct cache_entry *ce,
                                                    int pos, int ok_to_replace)
            {
                    int retval;

                    /*
                    * When ce is an "I am going away" entry, we allow it to be added
                    */
                    if (ce->ce_flags & CE_REMOVE)
                            return 0;

                    /*
                    * We check if the path is a sub-path of a subsequent pathname
                    * first, since removing those will not change the position
                    * in the array.
                    */
                    retval = has_file_name(istate, ce, pos, ok_to_replace);

                    /*
                    * Then check if the path might have a clashing sub-directory
                    * before it.
                    */
                    return retval + has_dir_name(istate, ce, pos, ok_to_replace);
            }

            static int add_index_entry_with_check(struct index_state *istate, struct cache_entry *ce, int option)
            {
                    int pos;
                    int ok_to_add = option & ADD_CACHE_OK_TO_ADD;
                    int ok_to_replace = option & ADD_CACHE_OK_TO_REPLACE;
                    int skip_df_check = option & ADD_CACHE_SKIP_DFCHECK;
                    int new_only = option & ADD_CACHE_NEW_ONLY;

                    /*
                    * If this entry's path sorts after the last entry in the index,
                    * we can avoid searching for it.
                    */
                    if (istate->cache_nr > 0 &&
                            strcmp(ce->name, istate->cache[istate->cache_nr - 1]->name) > 0)
                            pos = index_pos_to_insert_pos(istate->cache_nr);
                    else
                            pos = index_name_stage_pos(istate, ce->name, ce_namelen(ce), ce_stage(ce), EXPAND_SPARSE);

                    /*
                    * Cache tree path should be invalidated only after index_name_stage_pos,
                    * in case it expands a sparse index.
                    */
                    if (!(option & ADD_CACHE_KEEP_CACHE_TREE))
                            cache_tree_invalidate_path(istate, ce->name);

                    /* existing match? Just replace it. */
                    if (pos >= 0) {
                            if (!new_only)
                                    replace_index_entry(istate, pos, ce);
                            return 0;
                    }
                    pos = -pos-1;

                    if (!(option & ADD_CACHE_KEEP_CACHE_TREE))
                            untracked_cache_add_to_index(istate, ce->name);

                    /*
                    * Inserting a merged entry ("stage 0") into the index
                    * will always replace all non-merged entries..
                    */
                    if (pos < istate->cache_nr && ce_stage(ce) == 0) {
                            while (ce_same_name(istate->cache[pos], ce)) {
                                    ok_to_add = 1;
                                    if (!remove_index_entry_at(istate, pos))
                                            break;
                            }
                    }

                    if (!ok_to_add)
                            return -1;
                    if (verify_path_internal(ce->name, ce->ce_mode) == PATH_INVALID)
                            return error(_("invalid path '%s'"), ce->name);

                    if (!skip_df_check &&
                    check_file_directory_conflict(istate, ce, pos, ok_to_replace)) {
                            if (!ok_to_replace)
                                    return error(_("'%s' appears as both a file and as a directory"),
                                            ce->name);
                            pos = index_name_stage_pos(istate, ce->name, ce_namelen(ce), ce_stage(ce), EXPAND_SPARSE);
                            pos = -pos-1;
                    }
                    return pos + 1;
            }

            int add_index_entry(struct index_state *istate, struct cache_entry *ce, int option)
            {
                    int pos;

                    if (option & ADD_CACHE_JUST_APPEND)
                            pos = istate->cache_nr;
                    else {
                            int ret;
                            ret = add_index_entry_with_check(istate, ce, option);
                            if (ret <= 0)
                                    return ret;
                            pos = ret - 1;
                    }

                    /* Make sure the array is big enough .. */
                    ALLOC_GROW(istate->cache, istate->cache_nr + 1, istate->cache_alloc);

                    /* Add it in.. */
                    istate->cache_nr++;
                    if (istate->cache_nr > pos + 1)
                            MOVE_ARRAY(istate->cache + pos + 1, istate->cache + pos,
                                    istate->cache_nr - pos - 1);
                    set_index_entry(istate, pos, ce);
                    istate->cache_changed |= CE_ENTRY_ADDED;
                    return 0;
            }

            /*
            * "refresh" does not calculate a new sha1 file or bring the
            * cache up-to-date for mode/content changes. But what it
            * _does_ do is to "re-match" the stat information of a file
            * with the cache, so that you can refresh the cache for a
            * file that hasn't been changed but where the stat entry is
            * out of date.
            *
            * For example, you'd want to do this after doing a "git-read-tree",
            * to link up the stat cache details with the proper files.
            */
            static struct cache_entry *refresh_cache_ent(struct index_state *istate,
                                                    struct cache_entry *ce,
                                                    unsigned int options, int *err,
                                                    int *changed_ret,
                                                    int *t2_did_lstat,
                                                    int *t2_did_scan)
            {
                    struct stat st;
                    struct cache_entry *updated;
                    int changed;
                    int refresh = options & CE_MATCH_REFRESH;
                    int ignore_valid = options & CE_MATCH_IGNORE_VALID;
                    int ignore_skip_worktree = options & CE_MATCH_IGNORE_SKIP_WORKTREE;
                    int ignore_missing = options & CE_MATCH_IGNORE_MISSING;
                    int ignore_fsmonitor = options & CE_MATCH_IGNORE_FSMONITOR;

                    if (!refresh || ce_uptodate(ce))
                            return ce;

                    if (!ignore_fsmonitor)
                            refresh_fsmonitor(istate);
                    /*
                    * CE_VALID or CE_SKIP_WORKTREE means the user promised us
                    * that the change to the work tree does not matter and told
                    * us not to worry.
                    */
                    if (!ignore_skip_worktree && ce_skip_worktree(ce)) {
                            ce_mark_uptodate(ce);
                            return ce;
                    }
                    if (!ignore_valid && (ce->ce_flags & CE_VALID)) {
                            ce_mark_uptodate(ce);
                            return ce;
                    }
                    if (!ignore_fsmonitor && (ce->ce_flags & CE_FSMONITOR_VALID)) {
                            ce_mark_uptodate(ce);
                            return ce;
                    }

                    if (has_symlink_leading_path(ce->name, ce_namelen(ce))) {
                            if (ignore_missing)
                                    return ce;
                            if (err)
                                    *err = ENOENT;
                            return NULL;
                    }

                    if (t2_did_lstat)
                            *t2_did_lstat = 1;
                    if (lstat(ce->name, &st) < 0) {
                            if (ignore_missing && errno == ENOENT)
                                    return ce;
                            if (err)
                                    *err = errno;
                            return NULL;
                    }

                    changed = ie_match_stat(istate, ce, &st, options);
                    if (changed_ret)
                            *changed_ret = changed;
                    if (!changed) {
                            /*
                            * The path is unchanged.  If we were told to ignore
                            * valid bit, then we did the actual stat check and
                            * found that the entry is unmodified.  If the entry
                            * is not marked VALID, this is the place to mark it
                            * valid again, under "assume unchanged" mode.
                            */
                            if (ignore_valid && assume_unchanged &&
                            !(ce->ce_flags & CE_VALID))
                                    ; /* mark this one VALID again */
                            else {
                                    /*
                                    * We do not mark the index itself "modified"
                                    * because CE_UPTODATE flag is in-core only;
                                    * we are not going to write this change out.
                                    */
                                    if (!S_ISGITLINK(ce->ce_mode)) {
                                            ce_mark_uptodate(ce);
                                            mark_fsmonitor_valid(istate, ce);
                                    }
                                    return ce;
                            }
                    }

                    if (t2_did_scan)
                            *t2_did_scan = 1;
                    if (ie_modified(istate, ce, &st, options)) {
                            if (err)
                                    *err = EINVAL;
                            return NULL;
                    }

                    updated = make_empty_cache_entry(istate, ce_namelen(ce));
                    copy_cache_entry(updated, ce);
                    memcpy(updated->name, ce->name, ce->ce_namelen + 1);
                    fill_stat_cache_info(istate, updated, &st);
                    /*
                    * If ignore_valid is not set, we should leave CE_VALID bit
                    * alone.  Otherwise, paths marked with --no-assume-unchanged
                    * (i.e. things to be edited) will reacquire CE_VALID bit
                    * automatically, which is not really what we want.
                    */
                    if (!ignore_valid && assume_unchanged &&
                    !(ce->ce_flags & CE_VALID))
                            updated->ce_flags &= ~CE_VALID;

                    /* istate->cache_changed is updated in the caller */
                    return updated;
            }

            static void show_file(const char * fmt, const char * name, int in_porcelain,
                            int * first, const char *header_msg)
            {
                    if (in_porcelain && *first && header_msg) {
                            printf("%s\n", header_msg);
                            *first = 0;
                    }
                    printf(fmt, name);
            }

            int repo_refresh_and_write_index(struct repository *repo,
                                            unsigned int refresh_flags,
                                            unsigned int write_flags,
                                            int gentle,
                                            const struct pathspec *pathspec,
                                            char *seen, const char *header_msg)
            {
                    struct lock_file lock_file = LOCK_INIT;
                    int fd, ret = 0;

                    fd = repo_hold_locked_index(repo, &lock_file, 0);
                    if (!gentle && fd < 0)
                            return -1;
                    if (refresh_index(repo->index, refresh_flags, pathspec, seen, header_msg))
                            ret = 1;
                    if (0 <= fd && write_locked_index(repo->index, &lock_file, COMMIT_LOCK | write_flags))
                            ret = -1;
                    return ret;
            }


            int refresh_index(struct index_state *istate, unsigned int flags,
                            const struct pathspec *pathspec,
                            char *seen, const char *header_msg)
            {
                    int i;
                    int has_errors = 0;
                    int really = (flags & REFRESH_REALLY) != 0;
                    int allow_unmerged = (flags & REFRESH_UNMERGED) != 0;
                    int quiet = (flags & REFRESH_QUIET) != 0;
                    int not_new = (flags & REFRESH_IGNORE_MISSING) != 0;
                    int ignore_submodules = (flags & REFRESH_IGNORE_SUBMODULES) != 0;
                    int ignore_skip_worktree = (flags & REFRESH_IGNORE_SKIP_WORKTREE) != 0;
                    int first = 1;
                    int in_porcelain = (flags & REFRESH_IN_PORCELAIN);
                    unsigned int options = (CE_MATCH_REFRESH |
                                            (really ? CE_MATCH_IGNORE_VALID : 0) |
                                            (not_new ? CE_MATCH_IGNORE_MISSING : 0));
                    const char *modified_fmt;
                    const char *deleted_fmt;
                    const char *typechange_fmt;
                    const char *added_fmt;
                    const char *unmerged_fmt;
                    struct progress *progress = NULL;
                    int t2_sum_lstat = 0;
                    int t2_sum_scan = 0;

                    if (flags & REFRESH_PROGRESS && isatty(2))
                            progress = start_delayed_progress(_("Refresh index"),
                                                            istate->cache_nr);

                    trace_performance_enter();
                    modified_fmt   = in_porcelain ? "M\t%s\n" : "%s: needs update\n";
                    deleted_fmt    = in_porcelain ? "D\t%s\n" : "%s: needs update\n";
                    typechange_fmt = in_porcelain ? "T\t%s\n" : "%s: needs update\n";
                    added_fmt      = in_porcelain ? "A\t%s\n" : "%s: needs update\n";
                    unmerged_fmt   = in_porcelain ? "U\t%s\n" : "%s: needs merge\n";
                    /*
                    * Use the multi-threaded preload_index() to refresh most of the
                    * cache entries quickly then in the single threaded loop below,
                    * we only have to do the special cases that are left.
                    */
                    preload_index(istate, pathspec, 0);
                    trace2_region_enter("index", "refresh", NULL);

                    for (i = 0; i < istate->cache_nr; i++) {
                            struct cache_entry *ce, *new_entry;
                            int cache_errno = 0;
                            int changed = 0;
                            int filtered = 0;
                            int t2_did_lstat = 0;
                            int t2_did_scan = 0;

                            ce = istate->cache[i];
                            if (ignore_submodules && S_ISGITLINK(ce->ce_mode))
                                    continue;
                            if (ignore_skip_worktree && ce_skip_worktree(ce))
                                    continue;

                            /*
                            * If this entry is a sparse directory, then there isn't
                            * any stat() information to update. Ignore the entry.
                            */
                            if (S_ISSPARSEDIR(ce->ce_mode))
                                    continue;

                            if (pathspec && !ce_path_match(istate, ce, pathspec, seen))
                                    filtered = 1;

                            if (ce_stage(ce)) {
                                    while ((i < istate->cache_nr) &&
                                    ! strcmp(istate->cache[i]->name, ce->name))
                                            i++;
                                    i--;
                                    if (allow_unmerged)
                                            continue;
                                    if (!filtered)
                                            show_file(unmerged_fmt, ce->name, in_porcelain,
                                                    &first, header_msg);
                                    has_errors = 1;
                                    continue;
                            }

                            if (filtered)
                                    continue;

                            new_entry = refresh_cache_ent(istate, ce, options,
                                                    &cache_errno, &changed,
                                                    &t2_did_lstat, &t2_did_scan);
                            t2_sum_lstat += t2_did_lstat;
                            t2_sum_scan += t2_did_scan;
                            if (new_entry == ce)
                                    continue;
                            display_progress(progress, i);
                            if (!new_entry) {
                                    const char *fmt;

                                    if (really && cache_errno == EINVAL) {
                                            /* If we are doing --really-refresh that
                                            * means the index is not valid anymore.
                                            */
                                            ce->ce_flags &= ~CE_VALID;
                                            ce->ce_flags |= CE_UPDATE_IN_BASE;
                                            mark_fsmonitor_invalid(istate, ce);
                                            istate->cache_changed |= CE_ENTRY_CHANGED;
                                    }
                                    if (quiet)
                                            continue;

                                    if (cache_errno == ENOENT)
                                            fmt = deleted_fmt;
                                    else if (ce_intent_to_add(ce))
                                            fmt = added_fmt; /* must be before other checks */
                                    else if (changed & TYPE_CHANGED)
                                            fmt = typechange_fmt;
                                    else
                                            fmt = modified_fmt;
                                    show_file(fmt,
                                            ce->name, in_porcelain, &first, header_msg);
                                    has_errors = 1;
                                    continue;
                            }

                            replace_index_entry(istate, i, new_entry);
                    }
                    trace2_data_intmax("index", NULL, "refresh/sum_lstat", t2_sum_lstat);
                    trace2_data_intmax("index", NULL, "refresh/sum_scan", t2_sum_scan);
                    trace2_region_leave("index", "refresh", NULL);
                    display_progress(progress, istate->cache_nr);
                    stop_progress(&progress);
                    trace_performance_leave("refresh index");
                    return has_errors;
            }

            struct cache_entry *refresh_cache_entry(struct index_state *istate,
                                                    struct cache_entry *ce,
                                                    unsigned int options)
            {
                    return refresh_cache_ent(istate, ce, options, NULL, NULL, NULL, NULL);
            }


            /*****************************************************************
            * Index File I/O
            *****************************************************************/

            #define INDEX_FORMAT_DEFAULT 3

            static unsigned int get_index_format_default(struct repository *r)
            {
                    char *envversion = getenv("GIT_INDEX_VERSION");
                    char *endp;
                    unsigned int version = INDEX_FORMAT_DEFAULT;

                    if (!envversion) {
                            prepare_repo_settings(r);

                            if (r->settings.index_version >= 0)
                                    version = r->settings.index_version;
                            if (version < INDEX_FORMAT_LB || INDEX_FORMAT_UB < version) {
                                    warning(_("index.version set, but the value is invalid.\n"
                                            "Using version %i"), INDEX_FORMAT_DEFAULT);
                                    return INDEX_FORMAT_DEFAULT;
                            }
                            return version;
                    }

                    version = strtoul(envversion, &endp, 10);
                    if (*endp ||
                    version < INDEX_FORMAT_LB || INDEX_FORMAT_UB < version) {
                            warning(_("GIT_INDEX_VERSION set, but the value is invalid.\n"
                                    "Using version %i"), INDEX_FORMAT_DEFAULT);
                            version = INDEX_FORMAT_DEFAULT;
                    }
                    return version;
            }

            /*
            * dev/ino/uid/gid/size are also just tracked to the low 32 bits
            * Again - this is just a (very strong in practice) heuristic that
            * the inode hasn't changed.
            *
            * We save the fields in big-endian order to allow using the
            * index file over NFS transparently.
            */
            struct ondisk_cache_entry {
                    struct cache_time ctime;
                    struct cache_time mtime;
                    uint32_t dev;
                    uint32_t ino;
                    uint32_t mode;
                    uint32_t uid;
                    uint32_t gid;
                    uint32_t size;
                    /*
                    * unsigned char hash[hashsz];
                    * uint16_t flags;
                    * if (flags & CE_EXTENDED)
                    *      uint16_t flags2;
                    */
                    unsigned char data[GIT_MAX_RAWSZ + 2 * sizeof(uint16_t)];
                    char name[FLEX_ARRAY];
            };

            /* These are only used for v3 or lower */
            #define align_padding_size(size, len) ((size + (len) + 8) & ~7) - (size + len)
            #define align_flex_name(STRUCT,len) ((offsetof(struct STRUCT,data) + (len) + 8) & ~7)
            #define ondisk_cache_entry_size(len) align_flex_name(ondisk_cache_entry,len)
            #define ondisk_data_size(flags, len) (the_hash_algo->rawsz + \
                                            ((flags & CE_EXTENDED) ? 2 : 1) * sizeof(uint16_t) + len)
            #define ondisk_data_size_max(len) (ondisk_data_size(CE_EXTENDED, len))
            #define ondisk_ce_size(ce) (ondisk_cache_entry_size(ondisk_data_size((ce)->ce_flags, ce_namelen(ce))))

            /* Allow fsck to force verification of the index checksum. */
            int verify_index_checksum;

            /* Allow fsck to force verification of the cache entry order. */
            int verify_ce_order;

            static int verify_hdr(const struct cache_header *hdr, unsigned long size)
            {
                    git_hash_ctx c;
                    unsigned char hash[GIT_MAX_RAWSZ];
                    int hdr_version;
                    unsigned char *start, *end;
                    struct object_id oid;

                    if (hdr->hdr_signature != htonl(CACHE_SIGNATURE))
                            return error(_("bad signature 0x%08x"), hdr->hdr_signature);
                    hdr_version = ntohl(hdr->hdr_version);
                    if (hdr_version < INDEX_FORMAT_LB || INDEX_FORMAT_UB < hdr_version)
                            return error(_("bad index version %d"), hdr_version);

                    if (!verify_index_checksum)
                            return 0;

                    end = (unsigned char *)hdr + size;
                    start = end - the_hash_algo->rawsz;
                    oidread(&oid, start, the_repository->hash_algo);
                    if (oideq(&oid, null_oid()))
                            return 0;

                    the_hash_algo->init_fn(&c);
                    the_hash_algo->update_fn(&c, hdr, size - the_hash_algo->rawsz);
                    the_hash_algo->final_fn(hash, &c);
                    if (!hasheq(hash, start, the_repository->hash_algo))
                            return error(_("bad index file sha1 signature"));
                    return 0;
            }

            static int read_index_extension(struct index_state *istate,
                                            const char *ext, const char *data, unsigned long sz)
            {
                    switch (CACHE_EXT(ext)) {
                    case CACHE_EXT_TREE:
                            istate->cache_tree = cache_tree_read(data, sz);
                            break;
                    case CACHE_EXT_RESOLVE_UNDO:
                            istate->resolve_undo = resolve_undo_read(data, sz);
                            break;
                    case CACHE_EXT_LINK:
                            if (read_link_extension(istate, data, sz))
                                    return -1;
                            break;
                    case CACHE_EXT_UNTRACKED:
                            istate->untracked = read_untracked_extension(data, sz);
                            break;
                    case CACHE_EXT_FSMONITOR:
                            read_fsmonitor_extension(istate, data, sz);
                            break;
                    case CACHE_EXT_ENDOFINDEXENTRIES:
                    case CACHE_EXT_INDEXENTRYOFFSETTABLE:
                            /* already handled in do_read_index() */
                            break;
                    case CACHE_EXT_SPARSE_DIRECTORIES:
                            /* no content, only an indicator */
                            istate->sparse_index = INDEX_COLLAPSED;
                            break;
                    default:
                            if (*ext < 'A' || 'Z' < *ext)
                                    return error(_("index uses %.4s extension, which we do not understand"),
                                            ext);
                            fprintf_ln(stderr, _("ignoring %.4s extension"), ext);
                            break;
                    }
                    return 0;
            }

            /*
            * Parses the contents of the cache entry contained within the 'ondisk' buffer
            * into a new incore 'cache_entry'.
            *
            * Note that 'char *ondisk' may not be aligned to a 4-byte address interval in
            * index v4, so we cannot cast it to 'struct ondisk_cache_entry *' and access
            * its members. Instead, we use the byte offsets of members within the struct to
            * identify where 'get_be16()', 'get_be32()', and 'oidread()' (which can all
            * read from an unaligned memory buffer) should read from the 'ondisk' buffer
            * into the corresponding incore 'cache_entry' members.
            */
            static struct cache_entry *create_from_disk(struct mem_pool *ce_mem_pool,
                                                    unsigned int version,
                                                    const char *ondisk,
                                                    unsigned long *ent_size,
                                                    const struct cache_entry *previous_ce)
            {
                    struct cache_entry *ce;
                    size_t len;
                    const char *name;
                    const unsigned hashsz = the_hash_algo->rawsz;
                    const char *flagsp = ondisk + offsetof(struct ondisk_cache_entry, data) + hashsz;
                    unsigned int flags;
                    size_t copy_len = 0;
                    /*
                    * Adjacent cache entries tend to share the leading paths, so it makes
                    * sense to only store the differences in later entries.  In the v4
                    * on-disk format of the index, each on-disk cache entry stores the
                    * number of bytes to be stripped from the end of the previous name,
                    * and the bytes to append to the result, to come up with its name.
                    */
                    int expand_name_field = version == 4;

                    /* On-disk flags are just 16 bits */
                    flags = get_be16(flagsp);
                    len = flags & CE_NAMEMASK;

                    if (flags & CE_EXTENDED) {
                            int extended_flags;
                            extended_flags = get_be16(flagsp + sizeof(uint16_t)) << 16;
                            /* We do not yet understand any bit out of CE_EXTENDED_FLAGS */
                            if (extended_flags & ~CE_EXTENDED_FLAGS)
                                    die(_("unknown index entry format 0x%08x"), extended_flags);
                            flags |= extended_flags;
                            name = (const char *)(flagsp + 2 * sizeof(uint16_t));
                    }
                    else
                            name = (const char *)(flagsp + sizeof(uint16_t));

                    if (expand_name_field) {
                            const unsigned char *cp = (const unsigned char *)name;
                            size_t strip_len, previous_len;

                            /* If we're at the beginning of a block, ignore the previous name */
                            strip_len = decode_varint(&cp);
                            if (previous_ce) {
                                    previous_len = previous_ce->ce_namelen;
                                    if (previous_len < strip_len)
                                            die(_("malformed name field in the index, near path '%s'"),
                                                    previous_ce->name);
                                    copy_len = previous_len - strip_len;
                            }
                            name = (const char *)cp;
                    }

                    if (len == CE_NAMEMASK) {
                            len = strlen(name);
                            if (expand_name_field)
                                    len += copy_len;
                    }

                    ce = mem_pool__ce_alloc(ce_mem_pool, len);

                    /*
                    * NEEDSWORK: using 'offsetof()' is cumbersome and should be replaced
                    * with something more akin to 'load_bitmap_entries_v1()'s use of
                    * 'read_be16'/'read_be32'. For consistency with the corresponding
                    * ondisk entry write function ('copy_cache_entry_to_ondisk()'), this
                    * should be done at the same time as removing references to
                    * 'ondisk_cache_entry' there.
                    */
                    ce->ce_stat_data.sd_ctime.sec = get_be32(ondisk + offsetof(struct ondisk_cache_entry, ctime)
                                                                    + offsetof(struct cache_time, sec));
                    ce->ce_stat_data.sd_mtime.sec = get_be32(ondisk + offsetof(struct ondisk_cache_entry, mtime)
                                                                    + offsetof(struct cache_time, sec));
                    ce->ce_stat_data.sd_ctime.nsec = get_be32(ondisk + offsetof(struct ondisk_cache_entry, ctime)
                                                                    + offsetof(struct cache_time, nsec));
                    ce->ce_stat_data.sd_mtime.nsec = get_be32(ondisk + offsetof(struct ondisk_cache_entry, mtime)
                                                                    + offsetof(struct cache_time, nsec));
                    ce->ce_stat_data.sd_dev   = get_be32(ondisk + offsetof(struct ondisk_cache_entry, dev));
                    ce->ce_stat_data.sd_ino   = get_be32(ondisk + offsetof(struct ondisk_cache_entry, ino));
                    ce->ce_mode  = get_be32(ondisk + offsetof(struct ondisk_cache_entry, mode));
                    ce->ce_stat_data.sd_uid   = get_be32(ondisk + offsetof(struct ondisk_cache_entry, uid));
                    ce->ce_stat_data.sd_gid   = get_be32(ondisk + offsetof(struct ondisk_cache_entry, gid));
                    ce->ce_stat_data.sd_size  = get_be32(ondisk + offsetof(struct ondisk_cache_entry, size));
                    ce->ce_flags = flags & ~CE_NAMEMASK;
                    ce->ce_namelen = len;
                    ce->index = 0;
                    oidread(&ce->oid, (const unsigned char *)ondisk + offsetof(struct ondisk_cache_entry, data),
                            the_repository->hash_algo);

                    if (expand_name_field) {
                            if (copy_len)
                                    memcpy(ce->name, previous_ce->name, copy_len);
                            memcpy(ce->name + copy_len, name, len + 1 - copy_len);
                            *ent_size = (name - ((char *)ondisk)) + len + 1 - copy_len;
                    } else {
                            memcpy(ce->name, name, len + 1);
                            *ent_size = ondisk_ce_size(ce);
                    }
                    return ce;
            }

            static void check_ce_order(struct index_state *istate)
            {
                    unsigned int i;

                    if (!verify_ce_order)
                            return;

                    for (i = 1; i < istate->cache_nr; i++) {
                            struct cache_entry *ce = istate->cache[i - 1];
                            struct cache_entry *next_ce = istate->cache[i];
                            int name_compare = strcmp(ce->name, next_ce->name);

                            if (0 < name_compare)
                                    die(_("unordered stage entries in index"));
                            if (!name_compare) {
                                    if (!ce_stage(ce))
                                            die(_("multiple stage entries for merged file '%s'"),
                                            ce->name);
                                    if (ce_stage(ce) > ce_stage(next_ce))
                                            die(_("unordered stage entries for '%s'"),
                                            ce->name);
                            }
                    }
            }

            static void tweak_untracked_cache(struct index_state *istate)
            {
                    struct repository *r = the_repository;

                    prepare_repo_settings(r);

                    switch (r->settings.core_untracked_cache) {
                    case UNTRACKED_CACHE_REMOVE:
                            remove_untracked_cache(istate);
                            break;
                    case UNTRACKED_CACHE_WRITE:
                            add_untracked_cache(istate);
                            break;
                    case UNTRACKED_CACHE_KEEP:
                            /*
                            * Either an explicit "core.untrackedCache=keep", the
                            * default if "core.untrackedCache" isn't configured,
                            * or a fallback on an unknown "core.untrackedCache"
                            * value.
                            */
                            break;
                    }
            }

            static void tweak_split_index(struct index_state *istate)
            {
                    switch (repo_config_get_split_index(the_repository)) {
                    case -1: /* unset: do nothing */
                            break;
                    case 0: /* false */
                            remove_split_index(istate);
                            break;
                    case 1: /* true */
                            add_split_index(istate);
                            break;
                    default: /* unknown value: do nothing */
                            break;
                    }
            }

            static void post_read_index_from(struct index_state *istate)
            {
                    check_ce_order(istate);
                    tweak_untracked_cache(istate);
                    tweak_split_index(istate);
                    tweak_fsmonitor(istate);
            }

            static size_t estimate_cache_size_from_compressed(unsigned int entries)
            {
                    return entries * (sizeof(struct cache_entry) + CACHE_ENTRY_PATH_LENGTH);
            }

            static size_t estimate_cache_size(size_t ondisk_size, unsigned int entries)
            {
                    long per_entry = sizeof(struct cache_entry) - sizeof(struct ondisk_cache_entry);

                    /*
                    * Account for potential alignment differences.
                    */
                    per_entry += align_padding_size(per_entry, 0);
                    return ondisk_size + entries * per_entry;
            }

            struct index_entry_offset
            {
                    /* starting byte offset into index file, count of index entries in this block */
                    int offset, nr;
            };

            struct index_entry_offset_table
            {
                    int nr;
                    struct index_entry_offset entries[FLEX_ARRAY];
            };

            static struct index_entry_offset_table *read_ieot_extension(const char *mmap, size_t mmap_size, size_t offset);
            static void write_ieot_extension(struct strbuf *sb, struct index_entry_offset_table *ieot);

            static size_t read_eoie_extension(const char *mmap, size_t mmap_size);
            static void write_eoie_extension(struct strbuf *sb, git_hash_ctx *eoie_context, size_t offset);

            struct load_index_extensions
            {
                    pthread_t pthread;
                    struct index_state *istate;
                    const char *mmap;
                    size_t mmap_size;
                    unsigned long src_offset;
            };

            static void *load_index_extensions(void *_data)
            {
                    struct load_index_extensions *p = _data;
                    unsigned long src_offset = p->src_offset;

                    while (src_offset <= p->mmap_size - the_hash_algo->rawsz - 8) {
                            /* After an array of active_nr index entries,
                            * there can be arbitrary number of extended
                            * sections, each of which is prefixed with
                            * extension name (4-byte) and section length
                            * in 4-byte network byte order.
                            */
                            uint32_t extsize = get_be32(p->mmap + src_offset + 4);
                            if (read_index_extension(p->istate,
                                                    p->mmap + src_offset,
                                                    p->mmap + src_offset + 8,
                                                    extsize) < 0) {
                                    munmap((void *)p->mmap, p->mmap_size);
                                    die(_("index file corrupt"));
                            }
                            src_offset += 8;
                            src_offset += extsize;
                    }

                    return NULL;
            }

            /*
            * A helper function that will load the specified range of cache entries
            * from the memory mapped file and add them to the given index.
            */
            static unsigned long load_cache_entry_block(struct index_state *istate,
                                    struct mem_pool *ce_mem_pool, int offset, int nr, const char *mmap,
                                    unsigned long start_offset, const struct cache_entry *previous_ce)
            {
                    int i;
                    unsigned long src_offset = start_offset;

                    for (i = offset; i < offset + nr; i++) {
                            struct cache_entry *ce;
                            unsigned long consumed;

                            ce = create_from_disk(ce_mem_pool, istate->version,
                                            mmap + src_offset,
                                            &consumed, previous_ce);
                            set_index_entry(istate, i, ce);

                            src_offset += consumed;
                            previous_ce = ce;
                    }
                    return src_offset - start_offset;
            }

            static unsigned long load_all_cache_entries(struct index_state *istate,
                                    const char *mmap, size_t mmap_size, unsigned long src_offset)
            {
                    unsigned long consumed;

                    istate->ce_mem_pool = xmalloc(sizeof(*istate->ce_mem_pool));
                    if (istate->version == 4) {
                            mem_pool_init(istate->ce_mem_pool,
                                            estimate_cache_size_from_compressed(istate->cache_nr));
                    } else {
                            mem_pool_init(istate->ce_mem_pool,
                                            estimate_cache_size(mmap_size, istate->cache_nr));
                    }

                    consumed = load_cache_entry_block(istate, istate->ce_mem_pool,
                                                    0, istate->cache_nr, mmap, src_offset, NULL);
                    return consumed;
            }

            /*
            * Mostly randomly chosen maximum thread counts: we
            * cap the parallelism to online_cpus() threads, and we want
            * to have at least 10000 cache entries per thread for it to
            * be worth starting a thread.
            */

            #define THREAD_COST             (10000)

            struct load_cache_entries_thread_data
            {
                    pthread_t pthread;
                    struct index_state *istate;
                    struct mem_pool *ce_mem_pool;
                    int offset;
                    const char *mmap;
                    struct index_entry_offset_table *ieot;
                    int ieot_start;         /* starting index into the ieot array */
                    int ieot_blocks;        /* count of ieot entries to process */
                    unsigned long consumed; /* return # of bytes in index file processed */
            };

            /*
            * A thread proc to run the load_cache_entries() computation
            * across multiple background threads.
            */
            static void *load_cache_entries_thread(void *_data)
            {
                    struct load_cache_entries_thread_data *p = _data;
                    int i;

                    /* iterate across all ieot blocks assigned to this thread */
                    for (i = p->ieot_start; i < p->ieot_start + p->ieot_blocks; i++) {
                            p->consumed += load_cache_entry_block(p->istate, p->ce_mem_pool,
                                    p->offset, p->ieot->entries[i].nr, p->mmap, p->ieot->entries[i].offset, NULL);
                            p->offset += p->ieot->entries[i].nr;
                    }
                    return NULL;
            }

            static unsigned long load_cache_entries_threaded(struct index_state *istate, const char *mmap, size_t mmap_size,
                                                            int nr_threads, struct index_entry_offset_table *ieot)
            {
                    int i, offset, ieot_blocks, ieot_start, err;
                    struct load_cache_entries_thread_data *data;
                    unsigned long consumed = 0;

                    /* a little sanity checking */
                    if (istate->name_hash_initialized)
                            BUG("the name hash isn't thread safe");

                    istate->ce_mem_pool = xmalloc(sizeof(*istate->ce_mem_pool));
                    mem_pool_init(istate->ce_mem_pool, 0);

                    /* ensure we have no more threads than we have blocks to process */
                    if (nr_threads > ieot->nr)
                            nr_threads = ieot->nr;
                    CALLOC_ARRAY(data, nr_threads);

                    offset = ieot_start = 0;
                    ieot_blocks = DIV_ROUND_UP(ieot->nr, nr_threads);
                    for (i = 0; i < nr_threads; i++) {
                            struct load_cache_entries_thread_data *p = &data[i];
                            int nr, j;

                            if (ieot_start + ieot_blocks > ieot->nr)
                                    ieot_blocks = ieot->nr - ieot_start;

                            p->istate = istate;
                            p->offset = offset;
                            p->mmap = mmap;
                            p->ieot = ieot;
                            p->ieot_start = ieot_start;
                            p->ieot_blocks = ieot_blocks;

                            /* create a mem_pool for each thread */
                            nr = 0;
                            for (j = p->ieot_start; j < p->ieot_start + p->ieot_blocks; j++)
                                    nr += p->ieot->entries[j].nr;
                            p->ce_mem_pool = xmalloc(sizeof(*istate->ce_mem_pool));
                            if (istate->version == 4) {
                                    mem_pool_init(p->ce_mem_pool,
                                            estimate_cache_size_from_compressed(nr));
                            } else {
                                    mem_pool_init(p->ce_mem_pool,
                                            estimate_cache_size(mmap_size, nr));
                            }

                            err = pthread_create(&p->pthread, NULL, load_cache_entries_thread, p);
                            if (err)
                                    die(_("unable to create load_cache_entries thread: %s"), strerror(err));

                            /* increment by the number of cache entries in the ieot block being processed */
                            for (j = 0; j < ieot_blocks; j++)
                                    offset += ieot->entries[ieot_start + j].nr;
                            ieot_start += ieot_blocks;
                    }

                    for (i = 0; i < nr_threads; i++) {
                            struct load_cache_entries_thread_data *p = &data[i];

                            err = pthread_join(p->pthread, NULL);
                            if (err)
                                    die(_("unable to join load_cache_entries thread: %s"), strerror(err));
                            mem_pool_combine(istate->ce_mem_pool, p->ce_mem_pool);
                            free(p->ce_mem_pool);
                            consumed += p->consumed;
                    }

                    free(data);

                    return consumed;
            }

            static void set_new_index_sparsity(struct index_state *istate)
            {
                    /*
                    * If the index's repo exists, mark it sparse according to
                    * repo settings.
                    */
                    prepare_repo_settings(istate->repo);
                    if (!istate->repo->settings.command_requires_full_index &&
                    is_sparse_index_allowed(istate, 0))
                            istate->sparse_index = 1;
            }

            /* remember to discard_cache() before reading a different cache! */
            int do_read_index(struct index_state *istate, const char *path, int must_exist)
            {
                    int fd;
                    struct stat st;
                    unsigned long src_offset;
                    const struct cache_header *hdr;
                    const char *mmap;
                    size_t mmap_size;
                    struct load_index_extensions p;
                    size_t extension_offset = 0;
                    int nr_threads, cpus;
                    struct index_entry_offset_table *ieot = NULL;

                    if (istate->initialized)
                            return istate->cache_nr;

                    istate->timestamp.sec = 0;
                    istate->timestamp.nsec = 0;
                    fd = open(path, O_RDONLY);
                    if (fd < 0) {
                            if (!must_exist && errno == ENOENT) {
                                    set_new_index_sparsity(istate);
                                    istate->initialized = 1;
                                    return 0;
                            }
                            die_errno(_("%s: index file open failed"), path);
                    }

                    if (fstat(fd, &st))
                            die_errno(_("%s: cannot stat the open index"), path);

                    mmap_size = xsize_t(st.st_size);
                    if (mmap_size < sizeof(struct cache_header) + the_hash_algo->rawsz)
                            die(_("%s: index file smaller than expected"), path);

                    mmap = xmmap_gently(NULL, mmap_size, PROT_READ, MAP_PRIVATE, fd, 0);
                    if (mmap == MAP_FAILED)
                            die_errno(_("%s: unable to map index file%s"), path,
                                    mmap_os_err());
                    close(fd);

                    hdr = (const struct cache_header *)mmap;
                    if (verify_hdr(hdr, mmap_size) < 0)
                            goto unmap;

                    oidread(&istate->oid, (const unsigned char *)hdr + mmap_size - the_hash_algo->rawsz,
                            the_repository->hash_algo);
                    istate->version = ntohl(hdr->hdr_version);
                    istate->cache_nr = ntohl(hdr->hdr_entries);
                    istate->cache_alloc = alloc_nr(istate->cache_nr);
                    CALLOC_ARRAY(istate->cache, istate->cache_alloc);
                    istate->initialized = 1;

                    p.istate = istate;
                    p.mmap = mmap;
                    p.mmap_size = mmap_size;

                    src_offset = sizeof(*hdr);

                    if (repo_config_get_index_threads(the_repository, &nr_threads))
                            nr_threads = 1;

                    /* TODO: does creating more threads than cores help? */
                    if (!nr_threads) {
                            nr_threads = istate->cache_nr / THREAD_COST;
                            cpus = online_cpus();
                            if (nr_threads > cpus)
                                    nr_threads = cpus;
                    }

                    if (!HAVE_THREADS)
                            nr_threads = 1;

                    if (nr_threads > 1) {
                            extension_offset = read_eoie_extension(mmap, mmap_size);
                            if (extension_offset) {
                                    int err;

                                    p.src_offset = extension_offset;
                                    err = pthread_create(&p.pthread, NULL, load_index_extensions, &p);
                                    if (err)
                                            die(_("unable to create load_index_extensions thread: %s"), strerror(err));

                                    nr_threads--;
                            }
                    }

                    /*
                    * Locate and read the index entry offset table so that we can use it
                    * to multi-thread the reading of the cache entries.
                    */
                    if (extension_offset && nr_threads > 1)
                            ieot = read_ieot_extension(mmap, mmap_size, extension_offset);

                    if (ieot) {
                            src_offset += load_cache_entries_threaded(istate, mmap, mmap_size, nr_threads, ieot);
                            free(ieot);
                    } else {
                            src_offset += load_all_cache_entries(istate, mmap, mmap_size, src_offset);
                    }

                    istate->timestamp.sec = st.st_mtime;
                    istate->timestamp.nsec = ST_MTIME_NSEC(st);

                    /* if we created a thread, join it otherwise load the extensions on the primary thread */
                    if (extension_offset) {
                            int ret = pthread_join(p.pthread, NULL);
                            if (ret)
                                    die(_("unable to join load_index_extensions thread: %s"), strerror(ret));
                    } else {
                            p.src_offset = src_offset;
                            load_index_extensions(&p);
                    }
                    munmap((void *)mmap, mmap_size);

                    /*
                    * TODO trace2: replace "the_repository" with the actual repo instance
                    * that is associated with the given "istate".
                    */
                    trace2_data_intmax("index", the_repository, "read/version",
                                    istate->version);
                    trace2_data_intmax("index", the_repository, "read/cache_nr",
                                    istate->cache_nr);

                    /*
                    * If the command explicitly requires a full index, force it
                    * to be full. Otherwise, correct the sparsity based on repository
                    * settings and other properties of the index (if necessary).
                    */
                    prepare_repo_settings(istate->repo);
                    if (istate->repo->settings.command_requires_full_index)
                            ensure_full_index(istate);
                    else
                            ensure_correct_sparsity(istate);

                    return istate->cache_nr;

            unmap:
                    munmap((void *)mmap, mmap_size);
                    die(_("index file corrupt"));
            }

            /*
            * Signal that the shared index is used by updating its mtime.
            *
            * This way, shared index can be removed if they have not been used
            * for some time.
            */
            static void freshen_shared_index(const char *shared_index, int warn)
            {
                    if (!check_and_freshen_file(shared_index, 1) && warn)
                            warning(_("could not freshen shared index '%s'"), shared_index);
            }

            int read_index_from(struct index_state *istate, const char *path,
                            const char *gitdir)
            {
                    struct split_index *split_index;
                    int ret;
                    char *base_oid_hex;
                    char *base_path;

                    /* istate->initialized covers both .git/index and .git/sharedindex.xxx */
                    if (istate->initialized)
                            return istate->cache_nr;

                    /*
                    * TODO trace2: replace "the_repository" with the actual repo instance
                    * that is associated with the given "istate".
                    */
                    trace2_region_enter_printf("index", "do_read_index", the_repository,
                                            "%s", path);
                    trace_performance_enter();
                    ret = do_read_index(istate, path, 0);
                    trace_performance_leave("read cache %s", path);
                    trace2_region_leave_printf("index", "do_read_index", the_repository,
                                            "%s", path);

                    split_index = istate->split_index;
                    if (!split_index || is_null_oid(&split_index->base_oid)) {
                            post_read_index_from(istate);
                            return ret;
                    }

                    trace_performance_enter();
                    if (split_index->base)
                            release_index(split_index->base);
                    else
                            ALLOC_ARRAY(split_index->base, 1);
                    index_state_init(split_index->base, istate->repo);

                    base_oid_hex = oid_to_hex(&split_index->base_oid);
                    base_path = xstrfmt("%s/sharedindex.%s", gitdir, base_oid_hex);
                    if (file_exists(base_path)) {
                            trace2_region_enter_printf("index", "shared/do_read_index",
                                                    the_repository, "%s", base_path);

                            ret = do_read_index(split_index->base, base_path, 0);
                            trace2_region_leave_printf("index", "shared/do_read_index",
                                                    the_repository, "%s", base_path);
                    } else {
                            char *path_copy = xstrdup(path);
                            char *base_path2 = xstrfmt("%s/sharedindex.%s",
                                                    dirname(path_copy), base_oid_hex);
                            free(path_copy);
                            trace2_region_enter_printf("index", "shared/do_read_index",
                                                    the_repository, "%s", base_path2);
                            ret = do_read_index(split_index->base, base_path2, 1);
                            trace2_region_leave_printf("index", "shared/do_read_index",
                                                    the_repository, "%s", base_path2);
                            free(base_path2);
                    }
                    if (!oideq(&split_index->base_oid, &split_index->base->oid))
                            die(_("broken index, expect %s in %s, got %s"),
                            base_oid_hex, base_path,
                            oid_to_hex(&split_index->base->oid));

                    freshen_shared_index(base_path, 0);
                    merge_base_index(istate);
                    post_read_index_from(istate);
                    trace_performance_leave("read cache %s", base_path);
                    free(base_path);
                    return ret;
            }

            int is_index_unborn(struct index_state *istate)
            {
                    return (!istate->cache_nr && !istate->timestamp.sec);
            }

            void index_state_init(struct index_state *istate, struct repository *r)
            {
                    struct index_state blank = INDEX_STATE_INIT(r);
                    memcpy(istate, &blank, sizeof(*istate));
            }

            void release_index(struct index_state *istate)
            {
                    /*
                    * Cache entries in istate->cache[] should have been allocated
                    * from the memory pool associated with this index, or from an
                    * associated split_index. There is no need to free individual
                    * cache entries. validate_cache_entries can detect when this
                    * assertion does not hold.
                    */
                    validate_cache_entries(istate);

                    resolve_undo_clear_index(istate);
                    free_name_hash(istate);
                    cache_tree_free(&(istate->cache_tree));
                    free(istate->fsmonitor_last_update);
                    free(istate->cache);
                    discard_split_index(istate);
                    free_untracked_cache(istate->untracked);

                    if (istate->sparse_checkout_patterns) {
                            clear_pattern_list(istate->sparse_checkout_patterns);
                            FREE_AND_NULL(istate->sparse_checkout_patterns);
                    }

                    if (istate->ce_mem_pool) {
                            mem_pool_discard(istate->ce_mem_pool, should_validate_cache_entries());
                            FREE_AND_NULL(istate->ce_mem_pool);
                    }
            }

            void discard_index(struct index_state *istate)
            {
                    release_index(istate);
                    index_state_init(istate, istate->repo);
            }

            /*
            * Validate the cache entries of this index.
            * All cache entries associated with this index
            * should have been allocated by the memory pool
            * associated with this index, or by a referenced
            * split index.
            */
            void validate_cache_entries(const struct index_state *istate)
            {
                    int i;

                    if (!should_validate_cache_entries() ||!istate || !istate->initialized)
                            return;

                    for (i = 0; i < istate->cache_nr; i++) {
                            if (!istate) {
                                    BUG("cache entry is not allocated from expected memory pool");
                            } else if (!istate->ce_mem_pool ||
                                    !mem_pool_contains(istate->ce_mem_pool, istate->cache[i])) {
                                    if (!istate->split_index ||
                                            !istate->split_index->base ||
                                            !istate->split_index->base->ce_mem_pool ||
                                            !mem_pool_contains(istate->split_index->base->ce_mem_pool, istate->cache[i])) {
                                            BUG("cache entry is not allocated from expected memory pool");
                                    }
                            }
                    }

                    if (istate->split_index)
                            validate_cache_entries(istate->split_index->base);
            }

            int unmerged_index(const struct index_state *istate)
            {
                    int i;
                    for (i = 0; i < istate->cache_nr; i++) {
                            if (ce_stage(istate->cache[i]))
                                    return 1;
                    }
                    return 0;
            }

            int repo_index_has_changes(struct repository *repo,
                                    struct tree *tree,
                                    struct strbuf *sb)
            {
                    struct index_state *istate = repo->index;
                    struct object_id cmp;
                    int i;

                    if (tree)
                            cmp = tree->object.oid;
                    if (tree || !repo_get_oid_tree(repo, "HEAD", &cmp)) {
                            struct diff_options opt;

                            repo_diff_setup(repo, &opt);
                            opt.flags.exit_with_status = 1;
                            if (!sb)
                                    opt.flags.quick = 1;
                            diff_setup_done(&opt);
                            do_diff_cache(&cmp, &opt);
                            diffcore_std(&opt);
                            for (i = 0; sb && i < diff_queued_diff.nr; i++) {
                                    if (i)
                                            strbuf_addch(sb, ' ');
                                    strbuf_addstr(sb, diff_queued_diff.queue[i]->two->path);
                            }
                            diff_flush(&opt);
                            return opt.flags.has_changes != 0;
                    } else {
                            /* TODO: audit for interaction with sparse-index. */
                            ensure_full_index(istate);
                            for (i = 0; sb && i < istate->cache_nr; i++) {
                                    if (i)
                                            strbuf_addch(sb, ' ');
                                    strbuf_addstr(sb, istate->cache[i]->name);
                            }
                            return !!istate->cache_nr;
                    }
            }

            static int write_index_ext_header(struct hashfile *f,
                                            git_hash_ctx *eoie_f,
                                            unsigned int ext,
                                            unsigned int sz)
            {
                    hashwrite_be32(f, ext);
                    hashwrite_be32(f, sz);

                    if (eoie_f) {
                            ext = htonl(ext);
                            sz = htonl(sz);
                            the_hash_algo->update_fn(eoie_f, &ext, sizeof(ext));
                            the_hash_algo->update_fn(eoie_f, &sz, sizeof(sz));
                    }
                    return 0;
            }

            static void ce_smudge_racily_clean_entry(struct index_state *istate,
                                                    struct cache_entry *ce)
            {
                    /*
                    * The only thing we care about in this function is to smudge the
                    * falsely clean entry due to touch-update-touch race, so we leave
                    * everything else as they are.  We are called for entries whose
                    * ce_stat_data.sd_mtime match the index file mtime.
                    *
                    * Note that this actually does not do much for gitlinks, for
                    * which ce_match_stat_basic() always goes to the actual
                    * contents.  The caller checks with is_racy_timestamp() which
                    * always says "no" for gitlinks, so we are not called for them ;-)
                    */
                    struct stat st;

                    if (lstat(ce->name, &st) < 0)
                            return;
                    if (ce_match_stat_basic(ce, &st))
                            return;
                    if (ce_modified_check_fs(istate, ce, &st)) {
                            /* This is "racily clean"; smudge it.  Note that this
                            * is a tricky code.  At first glance, it may appear
                            * that it can break with this sequence:
                            *
                            * $ echo xyzzy >frotz
                            * $ git-update-index --add frotz
                            * $ : >frotz
                            * $ sleep 3
                            * $ echo filfre >nitfol
                            * $ git-update-index --add nitfol
                            *
                            * but it does not.  When the second update-index runs,
                            * it notices that the entry "frotz" has the same timestamp
                            * as index, and if we were to smudge it by resetting its
                            * size to zero here, then the object name recorded
                            * in index is the 6-byte file but the cached stat information
                            * becomes zero --- which would then match what we would
                            * obtain from the filesystem next time we stat("frotz").
                            *
                            * However, the second update-index, before calling
                            * this function, notices that the cached size is 6
                            * bytes and what is on the filesystem is an empty
                            * file, and never calls us, so the cached size information
                            * for "frotz" stays 6 which does not match the filesystem.
                            */
                            ce->ce_stat_data.sd_size = 0;
                    }
            }

            /* Copy miscellaneous fields but not the name */
            static void copy_cache_entry_to_ondisk(struct ondisk_cache_entry *ondisk,
                                            struct cache_entry *ce)
            {
                    short flags;
                    const unsigned hashsz = the_hash_algo->rawsz;
                    uint16_t *flagsp = (uint16_t *)(ondisk->data + hashsz);

                    ondisk->ctime.sec = htonl(ce->ce_stat_data.sd_ctime.sec);
                    ondisk->mtime.sec = htonl(ce->ce_stat_data.sd_mtime.sec);
                    ondisk->ctime.nsec = htonl(ce->ce_stat_data.sd_ctime.nsec);
                    ondisk->mtime.nsec = htonl(ce->ce_stat_data.sd_mtime.nsec);
                    ondisk->dev  = htonl(ce->ce_stat_data.sd_dev);
                    ondisk->ino  = htonl(ce->ce_stat_data.sd_ino);
                    ondisk->mode = htonl(ce->ce_mode);
                    ondisk->uid  = htonl(ce->ce_stat_data.sd_uid);
                    ondisk->gid  = htonl(ce->ce_stat_data.sd_gid);
                    ondisk->size = htonl(ce->ce_stat_data.sd_size);
                    hashcpy(ondisk->data, ce->oid.hash, the_repository->hash_algo);

                    flags = ce->ce_flags & ~CE_NAMEMASK;
                    flags |= (ce_namelen(ce) >= CE_NAMEMASK ? CE_NAMEMASK : ce_namelen(ce));
                    flagsp[0] = htons(flags);
                    if (ce->ce_flags & CE_EXTENDED) {
                            flagsp[1] = htons((ce->ce_flags & CE_EXTENDED_FLAGS) >> 16);
                    }
            }

            static int ce_write_entry(struct hashfile *f, struct cache_entry *ce,
                                    struct strbuf *previous_name, struct ondisk_cache_entry *ondisk)
            {
                    int size;
                    unsigned int saved_namelen;
                    int stripped_name = 0;
                    static unsigned char padding[8] = { 0x00 };

                    if (ce->ce_flags & CE_STRIP_NAME) {
                            saved_namelen = ce_namelen(ce);
                            ce->ce_namelen = 0;
                            stripped_name = 1;
                    }

                    size = offsetof(struct ondisk_cache_entry,data) + ondisk_data_size(ce->ce_flags, 0);

                    if (!previous_name) {
                            int len = ce_namelen(ce);
                            copy_cache_entry_to_ondisk(ondisk, ce);
                            hashwrite(f, ondisk, size);
                            hashwrite(f, ce->name, len);
                            hashwrite(f, padding, align_padding_size(size, len));
                    } else {
                            int common, to_remove, prefix_size;
                            unsigned char to_remove_vi[16];
                            for (common = 0;
                            (ce->name[common] &&
                            common < previous_name->len &&
                            ce->name[common] == previous_name->buf[common]);
                            common++)
                                    ; /* still matching */
                            to_remove = previous_name->len - common;
                            prefix_size = encode_varint(to_remove, to_remove_vi);

                            copy_cache_entry_to_ondisk(ondisk, ce);
                            hashwrite(f, ondisk, size);
                            hashwrite(f, to_remove_vi, prefix_size);
                            hashwrite(f, ce->name + common, ce_namelen(ce) - common);
                            hashwrite(f, padding, 1);

                            strbuf_splice(previous_name, common, to_remove,
                                    ce->name + common, ce_namelen(ce) - common);
                    }
                    if (stripped_name) {
                            ce->ce_namelen = saved_namelen;
                            ce->ce_flags &= ~CE_STRIP_NAME;
                    }

                    return 0;
            }

            /*
            * This function verifies if index_state has the correct sha1 of the
            * index file.  Don't die if we have any other failure, just return 0.
            */
            static int verify_index_from(const struct index_state *istate, const char *path)
            {
                    int fd;
                    ssize_t n;
                    struct stat st;
                    unsigned char hash[GIT_MAX_RAWSZ];

                    if (!istate->initialized)
                            return 0;

                    fd = open(path, O_RDONLY);
                    if (fd < 0)
                            return 0;

                    if (fstat(fd, &st))
                            goto out;

                    if (st.st_size < sizeof(struct cache_header) + the_hash_algo->rawsz)
                            goto out;

                    n = pread_in_full(fd, hash, the_hash_algo->rawsz, st.st_size - the_hash_algo->rawsz);
                    if (n != the_hash_algo->rawsz)
                            goto out;

                    if (!hasheq(istate->oid.hash, hash, the_repository->hash_algo))
                            goto out;

                    close(fd);
                    return 1;

            out:
                    close(fd);
                    return 0;
            }

            static int repo_verify_index(struct repository *repo)
            {
                    return verify_index_from(repo->index, repo->index_file);
            }

            int has_racy_timestamp(struct index_state *istate)
            {
                    int entries = istate->cache_nr;
                    int i;

                    for (i = 0; i < entries; i++) {
                            struct cache_entry *ce = istate->cache[i];
                            if (is_racy_timestamp(istate, ce))
                                    return 1;
                    }
                    return 0;
            }

            void repo_update_index_if_able(struct repository *repo,
                                    struct lock_file *lockfile)
            {
                    if ((repo->index->cache_changed ||
                    has_racy_timestamp(repo->index)) &&
                    repo_verify_index(repo))
                            write_locked_index(repo->index, lockfile, COMMIT_LOCK);
                    else
                            rollback_lock_file(lockfile);
            }

            static int record_eoie(void)
            {
                    int val;

                    if (!git_config_get_bool("index.recordendofindexentries", &val))
                            return val;

                    /*
                    * As a convenience, the end of index entries extension
                    * used for threading is written by default if the user
                    * explicitly requested threaded index reads.
                    */
                    return !repo_config_get_index_threads(the_repository, &val) && val != 1;
            }

            static int record_ieot(void)
            {
                    int val;

                    if (!git_config_get_bool("index.recordoffsettable", &val))
                            return val;

                    /*
                    * As a convenience, the offset table used for threading is
                    * written by default if the user explicitly requested
                    * threaded index reads.
                    */
                    return !repo_config_get_index_threads(the_repository, &val) && val != 1;
            }

            enum write_extensions {
                    WRITE_NO_EXTENSION =              0,
                    WRITE_SPLIT_INDEX_EXTENSION =     1<<0,
                    WRITE_CACHE_TREE_EXTENSION =      1<<1,
                    WRITE_RESOLVE_UNDO_EXTENSION =    1<<2,
                    WRITE_UNTRACKED_CACHE_EXTENSION = 1<<3,
                    WRITE_FSMONITOR_EXTENSION =       1<<4,
            };
            #define WRITE_ALL_EXTENSIONS ((enum write_extensions)-1)

            /*
            * On success, `tempfile` is closed. If it is the temporary file
            * of a `struct lock_file`, we will therefore effectively perform
            * a 'close_lock_file_gently()`. Since that is an implementation
            * detail of lockfiles, callers of `do_write_index()` should not
            * rely on it.
            */
            static int do_write_index(struct index_state *istate, struct tempfile *tempfile,
                                    enum write_extensions write_extensions, unsigned flags)
            {
                    uint64_t start = getnanotime();
                    struct hashfile *f;
                    git_hash_ctx *eoie_c = NULL;
                    struct cache_header hdr;
                    int i, err = 0, removed, extended, hdr_version;
                    struct cache_entry **cache = istate->cache;
                    int entries = istate->cache_nr;
                    struct stat st;
                    struct ondisk_cache_entry ondisk;
                    struct strbuf previous_name_buf = STRBUF_INIT, *previous_name;
                    int drop_cache_tree = istate->drop_cache_tree;
                    off_t offset;
                    int csum_fsync_flag;
                    int ieot_entries = 1;
                    struct index_entry_offset_table *ieot = NULL;
                    struct repository *r = istate->repo;
                    struct strbuf sb = STRBUF_INIT;
                    int nr, nr_threads, ret;

                    f = hashfd(tempfile->fd, tempfile->filename.buf);

                    prepare_repo_settings(r);
                    f->skip_hash = r->settings.index_skip_hash;

                    for (i = removed = extended = 0; i < entries; i++) {
                            if (cache[i]->ce_flags & CE_REMOVE)
                                    removed++;

                            /* reduce extended entries if possible */
                            cache[i]->ce_flags &= ~CE_EXTENDED;
                            if (cache[i]->ce_flags & CE_EXTENDED_FLAGS) {
                                    extended++;
                                    cache[i]->ce_flags |= CE_EXTENDED;
                            }
                    }

                    if (!istate->version)
                            istate->version = get_index_format_default(r);

                    /* demote version 3 to version 2 when the latter suffices */
                    if (istate->version == 3 || istate->version == 2)
                            istate->version = extended ? 3 : 2;

                    hdr_version = istate->version;

                    hdr.hdr_signature = htonl(CACHE_SIGNATURE);
                    hdr.hdr_version = htonl(hdr_version);
                    hdr.hdr_entries = htonl(entries - removed);

                    hashwrite(f, &hdr, sizeof(hdr));

                    if (!HAVE_THREADS || repo_config_get_index_threads(the_repository, &nr_threads))
                            nr_threads = 1;

                    if (nr_threads != 1 && record_ieot()) {
                            int ieot_blocks, cpus;

                            /*
                            * ensure default number of ieot blocks maps evenly to the
                            * default number of threads that will process them leaving
                            * room for the thread to load the index extensions.
                            */
                            if (!nr_threads) {
                                    ieot_blocks = istate->cache_nr / THREAD_COST;
                                    cpus = online_cpus();
                                    if (ieot_blocks > cpus - 1)
                                            ieot_blocks = cpus - 1;
                            } else {
                                    ieot_blocks = nr_threads;
                                    if (ieot_blocks > istate->cache_nr)
                                            ieot_blocks = istate->cache_nr;
                            }

                            /*
                            * no reason to write out the IEOT extension if we don't
                            * have enough blocks to utilize multi-threading
                            */
                            if (ieot_blocks > 1) {
                                    ieot = xcalloc(1, sizeof(struct index_entry_offset_table)
                                            + (ieot_blocks * sizeof(struct index_entry_offset)));
                                    ieot_entries = DIV_ROUND_UP(entries, ieot_blocks);
                            }
                    }

                    offset = hashfile_total(f);

                    nr = 0;
                    previous_name = (hdr_version == 4) ? &previous_name_buf : NULL;

                    for (i = 0; i < entries; i++) {
                            struct cache_entry *ce = cache[i];
                            if (ce->ce_flags & CE_REMOVE)
                                    continue;
                            if (!ce_uptodate(ce) && is_racy_timestamp(istate, ce))
                                    ce_smudge_racily_clean_entry(istate, ce);
                            if (is_null_oid(&ce->oid)) {
                                    static const char msg[] = "cache entry has null sha1: %s";
                                    static int allow = -1;

                                    if (allow < 0)
                                            allow = git_env_bool("GIT_ALLOW_NULL_SHA1", 0);
                                    if (allow)
                                            warning(msg, ce->name);
                                    else
                                            err = error(msg, ce->name);

                                    drop_cache_tree = 1;
                            }
                            if (ieot && i && (i % ieot_entries == 0)) {
                                    ieot->entries[ieot->nr].nr = nr;
                                    ieot->entries[ieot->nr].offset = offset;
                                    ieot->nr++;
                                    /*
                                    * If we have a V4 index, set the first byte to an invalid
                                    * character to ensure there is nothing common with the previous
                                    * entry
                                    */
                                    if (previous_name)
                                            previous_name->buf[0] = 0;
                                    nr = 0;

                                    offset = hashfile_total(f);
                            }
                            if (ce_write_entry(f, ce, previous_name, (struct ondisk_cache_entry *)&ondisk) < 0)
                                    err = -1;

                            if (err)
                                    break;
                            nr++;
                    }
                    if (ieot && nr) {
                            ieot->entries[ieot->nr].nr = nr;
                            ieot->entries[ieot->nr].offset = offset;
                            ieot->nr++;
                    }
                    strbuf_release(&previous_name_buf);

                    if (err) {
                            ret = err;
                            goto out;
                    }

                    offset = hashfile_total(f);

                    /*
                    * The extension headers must be hashed on their own for the
                    * EOIE extension. Create a hashfile here to compute that hash.
                    */
                    if (offset && record_eoie()) {
                            CALLOC_ARRAY(eoie_c, 1);
                            the_hash_algo->init_fn(eoie_c);
                    }

                    /*
                    * Lets write out CACHE_EXT_INDEXENTRYOFFSETTABLE first so that we
                    * can minimize the number of extensions we have to scan through to
                    * find it during load.  Write it out regardless of the
                    * strip_extensions parameter as we need it when loading the shared
                    * index.
                    */
                    if (ieot) {
                            strbuf_reset(&sb);

                            write_ieot_extension(&sb, ieot);
                            err = write_index_ext_header(f, eoie_c, CACHE_EXT_INDEXENTRYOFFSETTABLE, sb.len) < 0;
                            hashwrite(f, sb.buf, sb.len);
                            if (err) {
                                    ret = -1;
                                    goto out;
                            }
                    }

                    if (write_extensions & WRITE_SPLIT_INDEX_EXTENSION &&
                    istate->split_index) {
                            strbuf_reset(&sb);

                            if (istate->sparse_index)
                                    die(_("cannot write split index for a sparse index"));

                            err = write_link_extension(&sb, istate) < 0 ||
                                    write_index_ext_header(f, eoie_c, CACHE_EXT_LINK,
                                                    sb.len) < 0;
                            hashwrite(f, sb.buf, sb.len);
                            if (err) {
                                    ret = -1;
                                    goto out;
                            }
                    }
                    if (write_extensions & WRITE_CACHE_TREE_EXTENSION &&
                    !drop_cache_tree && istate->cache_tree) {
                            strbuf_reset(&sb);

                            cache_tree_write(&sb, istate->cache_tree);
                            err = write_index_ext_header(f, eoie_c, CACHE_EXT_TREE, sb.len) < 0;
                            hashwrite(f, sb.buf, sb.len);
                            if (err) {
                                    ret = -1;
                                    goto out;
                            }
                    }
                    if (write_extensions & WRITE_RESOLVE_UNDO_EXTENSION &&
                    istate->resolve_undo) {
                            strbuf_reset(&sb);

                            resolve_undo_write(&sb, istate->resolve_undo);
                            err = write_index_ext_header(f, eoie_c, CACHE_EXT_RESOLVE_UNDO,
                                                    sb.len) < 0;
                            hashwrite(f, sb.buf, sb.len);
                            if (err) {
                                    ret = -1;
                                    goto out;
                            }
                    }
                    if (write_extensions & WRITE_UNTRACKED_CACHE_EXTENSION &&
                    istate->untracked) {
                            strbuf_reset(&sb);

                            write_untracked_extension(&sb, istate->untracked);
                            err = write_index_ext_header(f, eoie_c, CACHE_EXT_UNTRACKED,
                                                    sb.len) < 0;
                            hashwrite(f, sb.buf, sb.len);
                            if (err) {
                                    ret = -1;
                                    goto out;
                            }
                    }
                    if (write_extensions & WRITE_FSMONITOR_EXTENSION &&
                    istate->fsmonitor_last_update) {
                            strbuf_reset(&sb);

                            write_fsmonitor_extension(&sb, istate);
                            err = write_index_ext_header(f, eoie_c, CACHE_EXT_FSMONITOR, sb.len) < 0;
                            hashwrite(f, sb.buf, sb.len);
                            if (err) {
                                    ret = -1;
                                    goto out;
                            }
                    }
                    if (istate->sparse_index) {
                            if (write_index_ext_header(f, eoie_c, CACHE_EXT_SPARSE_DIRECTORIES, 0) < 0) {
                                    ret = -1;
                                    goto out;
                            }
                    }

                    /*
                    * CACHE_EXT_ENDOFINDEXENTRIES must be written as the last entry before the SHA1
                    * so that it can be found and processed before all the index entries are
                    * read.  Write it out regardless of the strip_extensions parameter as we need it
                    * when loading the shared index.
                    */
                    if (eoie_c) {
                            strbuf_reset(&sb);

                            write_eoie_extension(&sb, eoie_c, offset);
                            err = write_index_ext_header(f, NULL, CACHE_EXT_ENDOFINDEXENTRIES, sb.len) < 0;
                            hashwrite(f, sb.buf, sb.len);
                            if (err) {
                                    ret = -1;
                                    goto out;
                            }
                    }

                    csum_fsync_flag = 0;
                    if (!alternate_index_output && (flags & COMMIT_LOCK))
                            csum_fsync_flag = CSUM_FSYNC;

                    finalize_hashfile(f, istate->oid.hash, FSYNC_COMPONENT_INDEX,
                                    CSUM_HASH_IN_STREAM | csum_fsync_flag);
                    f = NULL;

                    if (close_tempfile_gently(tempfile)) {
                            ret = error(_("could not close '%s'"), get_tempfile_path(tempfile));
                            goto out;
                    }
                    if (stat(get_tempfile_path(tempfile), &st)) {
                            ret = -1;
                            goto out;
                    }
                    istate->timestamp.sec = (unsigned int)st.st_mtime;
                    istate->timestamp.nsec = ST_MTIME_NSEC(st);
                    trace_performance_since(start, "write index, changed mask = %x", istate->cache_changed);

                    /*
                    * TODO trace2: replace "the_repository" with the actual repo instance
                    * that is associated with the given "istate".
                    */
                    trace2_data_intmax("index", the_repository, "write/version",
                                    istate->version);
                    trace2_data_intmax("index", the_repository, "write/cache_nr",
                                    istate->cache_nr);

                    ret = 0;

            out:
                    if (f)
                            free_hashfile(f);
                    strbuf_release(&sb);
                    free(eoie_c);
                    free(ieot);
                    return ret;
            }

            void set_alternate_index_output(const char *name)
            {
                    alternate_index_output = name;
            }

            static int commit_locked_index(struct lock_file *lk)
            {
                    if (alternate_index_output)
                            return commit_lock_file_to(lk, alternate_index_output);
                    else
                            return commit_lock_file(lk);
            }

            static int do_write_locked_index(struct index_state *istate,
                                            struct lock_file *lock,
                                            unsigned flags,
                                            enum write_extensions write_extensions)
            {
                    int ret;
                    int was_full = istate->sparse_index == INDEX_EXPANDED;

                    ret = convert_to_sparse(istate, 0);

                    if (ret) {
                            warning(_("failed to convert to a sparse-index"));
                            return ret;
                    }

                    /*
                    * TODO trace2: replace "the_repository" with the actual repo instance
                    * that is associated with the given "istate".
                    */
                    trace2_region_enter_printf("index", "do_write_index", the_repository,
                                            "%s", get_lock_file_path(lock));
                    ret = do_write_index(istate, lock->tempfile, write_extensions, flags);
                    trace2_region_leave_printf("index", "do_write_index", the_repository,
                                            "%s", get_lock_file_path(lock));

                    if (was_full)
                            ensure_full_index(istate);

                    if (ret)
                            return ret;
                    if (flags & COMMIT_LOCK)
                            ret = commit_locked_index(lock);
                    else
                            ret = close_lock_file_gently(lock);

                    run_hooks_l(the_repository, "post-index-change",
                            istate->updated_workdir ? "1" : "0",
                            istate->updated_skipworktree ? "1" : "0", NULL);
                    istate->updated_workdir = 0;
                    istate->updated_skipworktree = 0;

                    return ret;
            }

            static int write_split_index(struct index_state *istate,
                                    struct lock_file *lock,
                                    unsigned flags)
            {
                    int ret;
                    prepare_to_write_split_index(istate);
                    ret = do_write_locked_index(istate, lock, flags, WRITE_ALL_EXTENSIONS);
                    finish_writing_split_index(istate);
                    return ret;
            }

            static unsigned long get_shared_index_expire_date(void)
            {
                    static unsigned long shared_index_expire_date;
                    static int shared_index_expire_date_prepared;

                    if (!shared_index_expire_date_prepared) {
                            const char *shared_index_expire = "2.weeks.ago";
                            char *value = NULL;

                            repo_config_get_expiry(the_repository, "splitindex.sharedindexexpire",
                                            &value);
                            if (value)
                                    shared_index_expire = value;

                            shared_index_expire_date = approxidate(shared_index_expire);
                            shared_index_expire_date_prepared = 1;

                            free(value);
                    }

                    return shared_index_expire_date;
            }

            static int should_delete_shared_index(const char *shared_index_path)
            {
                    struct stat st;
                    unsigned long expiration;

                    /* Check timestamp */
                    expiration = get_shared_index_expire_date();
                    if (!expiration)
                            return 0;
                    if (stat(shared_index_path, &st))
                            return error_errno(_("could not stat '%s'"), shared_index_path);
                    if (st.st_mtime > expiration)
                            return 0;

                    return 1;
            }

            static int clean_shared_index_files(const char *current_hex)
            {
                    struct dirent *de;
                    DIR *dir = opendir(repo_get_git_dir(the_repository));

                    if (!dir)
                            return error_errno(_("unable to open git dir: %s"),
                                            repo_get_git_dir(the_repository));

                    while ((de = readdir(dir)) != NULL) {
                            const char *sha1_hex;
                            const char *shared_index_path;
                            if (!skip_prefix(de->d_name, "sharedindex.", &sha1_hex))
                                    continue;
                            if (!strcmp(sha1_hex, current_hex))
                                    continue;
                            shared_index_path = git_path("%s", de->d_name);
                            if (should_delete_shared_index(shared_index_path) > 0 &&
                            unlink(shared_index_path))
                                    warning_errno(_("unable to unlink: %s"), shared_index_path);
                    }
                    closedir(dir);

                    return 0;
            }

            static int write_shared_index(struct index_state *istate,
                                    struct tempfile **temp, unsigned flags)
            {
                    struct split_index *si = istate->split_index;
                    int ret, was_full = !istate->sparse_index;

                    move_cache_to_base_index(istate);
                    convert_to_sparse(istate, 0);

                    trace2_region_enter_printf("index", "shared/do_write_index",
                                            the_repository, "%s", get_tempfile_path(*temp));
                    ret = do_write_index(si->base, *temp, WRITE_NO_EXTENSION, flags);
                    trace2_region_leave_printf("index", "shared/do_write_index",
                                            the_repository, "%s", get_tempfile_path(*temp));

                    if (was_full)
                            ensure_full_index(istate);

                    if (ret)
                            return ret;
                    ret = adjust_shared_perm(get_tempfile_path(*temp));
                    if (ret) {
                            error(_("cannot fix permission bits on '%s'"), get_tempfile_path(*temp));
                            return ret;
                    }
                    ret = rename_tempfile(temp,
                                    git_path("sharedindex.%s", oid_to_hex(&si->base->oid)));
                    if (!ret) {
                            oidcpy(&si->base_oid, &si->base->oid);
                            clean_shared_index_files(oid_to_hex(&si->base->oid));
                    }

                    return ret;
            }

            static const int default_max_percent_split_change = 20;

            static int too_many_not_shared_entries(struct index_state *istate)
            {
                    int i, not_shared = 0;
                    int max_split = repo_config_get_max_percent_split_change(the_repository);

                    switch (max_split) {
                    case -1:
                            /* not or badly configured: use the default value */
                            max_split = default_max_percent_split_change;
                            break;
                    case 0:
                            return 1; /* 0% means always write a new shared index */
                    case 100:
                            return 0; /* 100% means never write a new shared index */
                    default:
                            break; /* just use the configured value */
                    }

                    /* Count not shared entries */
                    for (i = 0; i < istate->cache_nr; i++) {
                            struct cache_entry *ce = istate->cache[i];
                            if (!ce->index)
                                    not_shared++;
                    }

                    return (int64_t)istate->cache_nr * max_split < (int64_t)not_shared * 100;
            }

            int write_locked_index(struct index_state *istate, struct lock_file *lock,
                            unsigned flags)
            {
                    int new_shared_index, ret, test_split_index_env;
                    struct split_index *si = istate->split_index;

                    if (git_env_bool("GIT_TEST_CHECK_CACHE_TREE", 0) &&
                    cache_tree_verify(the_repository, istate) < 0)
                            return -1;

                    if ((flags & SKIP_IF_UNCHANGED) && !istate->cache_changed) {
                            if (flags & COMMIT_LOCK)
                                    rollback_lock_file(lock);
                            return 0;
                    }

                    if (istate->fsmonitor_last_update)
                            fill_fsmonitor_bitmap(istate);

                    test_split_index_env = git_env_bool("GIT_TEST_SPLIT_INDEX", 0);

                    if ((!si && !test_split_index_env) ||
                    alternate_index_output ||
                    (istate->cache_changed & ~EXTMASK)) {
                            ret = do_write_locked_index(istate, lock, flags,
                                                    ~WRITE_SPLIT_INDEX_EXTENSION);
                            goto out;
                    }

                    if (test_split_index_env) {
                            if (!si) {
                                    si = init_split_index(istate);
                                    istate->cache_changed |= SPLIT_INDEX_ORDERED;
                            } else {
                                    int v = si->base_oid.hash[0];
                                    if ((v & 15) < 6)
                                            istate->cache_changed |= SPLIT_INDEX_ORDERED;
                            }
                    }
                    if (too_many_not_shared_entries(istate))
                            istate->cache_changed |= SPLIT_INDEX_ORDERED;

                    new_shared_index = istate->cache_changed & SPLIT_INDEX_ORDERED;

                    if (new_shared_index) {
                            struct tempfile *temp;
                            int saved_errno;

                            /* Same initial permissions as the main .git/index file */
                            temp = mks_tempfile_sm(git_path("sharedindex_XXXXXX"), 0, 0666);
                            if (!temp) {
                                    ret = do_write_locked_index(istate, lock, flags,
                                                            ~WRITE_SPLIT_INDEX_EXTENSION);
                                    goto out;
                            }
                            ret = write_shared_index(istate, &temp, flags);

                            saved_errno = errno;
                            if (is_tempfile_active(temp))
                                    delete_tempfile(&temp);
                            errno = saved_errno;

                            if (ret)
                                    goto out;
                    }

                    ret = write_split_index(istate, lock, flags);

                    /* Freshen the shared index only if the split-index was written */
                    if (!ret && !new_shared_index && !is_null_oid(&si->base_oid)) {
                            const char *shared_index = git_path("sharedindex.%s",
                                                            oid_to_hex(&si->base_oid));
                            freshen_shared_index(shared_index, 1);
                    }

            out:
                    if (flags & COMMIT_LOCK)
                            rollback_lock_file(lock);
                    return ret;
            }

            /*
            * Read the index file that is potentially unmerged into given
            * index_state, dropping any unmerged entries to stage #0 (potentially
            * resulting in a path appearing as both a file and a directory in the
            * index; the caller is responsible to clear out the extra entries
            * before writing the index to a tree).  Returns true if the index is
            * unmerged.  Callers who want to refuse to work from an unmerged
            * state can call this and check its return value, instead of calling
            * read_cache().
            */
            int repo_read_index_unmerged(struct repository *repo)
            {
                    struct index_state *istate;
                    int i;
                    int unmerged = 0;

                    repo_read_index(repo);
                    istate = repo->index;
                    for (i = 0; i < istate->cache_nr; i++) {
                            struct cache_entry *ce = istate->cache[i];
                            struct cache_entry *new_ce;
                            int len;

                            if (!ce_stage(ce))
                                    continue;
                            unmerged = 1;
                            len = ce_namelen(ce);
                            new_ce = make_empty_cache_entry(istate, len);
                            memcpy(new_ce->name, ce->name, len);
                            new_ce->ce_flags = create_ce_flags(0) | CE_CONFLICTED;
                            new_ce->ce_namelen = len;
                            new_ce->ce_mode = ce->ce_mode;
                            if (add_index_entry(istate, new_ce, ADD_CACHE_SKIP_DFCHECK))
                                    return error(_("%s: cannot drop to stage #0"),
                                            new_ce->name);
                    }
                    return unmerged;
            }

            /*
            * Returns 1 if the path is an "other" path with respect to
            * the index; that is, the path is not mentioned in the index at all,
            * either as a file, a directory with some files in the index,
            * or as an unmerged entry.
            *
            * We helpfully remove a trailing "/" from directories so that
            * the output of read_directory can be used as-is.
            */
            int index_name_is_other(struct index_state *istate, const char *name,
                                    int namelen)
            {
                    int pos;
                    if (namelen && name[namelen - 1] == '/')
                            namelen--;
                    pos = index_name_pos(istate, name, namelen);
                    if (0 <= pos)
                            return 0;       /* exact match */
                    pos = -pos - 1;
                    if (pos < istate->cache_nr) {
                            struct cache_entry *ce = istate->cache[pos];
                            if (ce_namelen(ce) == namelen &&
                            !memcmp(ce->name, name, namelen))
                                    return 0; /* Yup, this one exists unmerged */
                    }
                    return 1;
            }

            void *read_blob_data_from_index(struct index_state *istate,
                                            const char *path, unsigned long *size)
            {
                    int pos, len;
                    unsigned long sz;
                    enum object_type type;
                    void *data;

                    len = strlen(path);
                    pos = index_name_pos(istate, path, len);
                    if (pos < 0) {
                            /*
                            * We might be in the middle of a merge, in which
                            * case we would read stage #2 (ours).
                            */
                            int i;
                            for (i = -pos - 1;
                            (pos < 0 && i < istate->cache_nr &&
                            !strcmp(istate->cache[i]->name, path));
                            i++)
                                    if (ce_stage(istate->cache[i]) == 2)
                                            pos = i;
                    }
                    if (pos < 0)
                            return NULL;
                    data = repo_read_object_file(the_repository, &istate->cache[pos]->oid,
                                            &type, &sz);
                    if (!data || type != OBJ_BLOB) {
                            free(data);
                            return NULL;
                    }
                    if (size)
                            *size = sz;
                    return data;
            }

            void move_index_extensions(struct index_state *dst, struct index_state *src)
            {
                    dst->untracked = src->untracked;
                    src->untracked = NULL;
                    dst->cache_tree = src->cache_tree;
                    src->cache_tree = NULL;
            }

            struct cache_entry *dup_cache_entry(const struct cache_entry *ce,
                                            struct index_state *istate)
            {
                    unsigned int size = ce_size(ce);
                    int mem_pool_allocated;
                    struct cache_entry *new_entry = make_empty_cache_entry(istate, ce_namelen(ce));
                    mem_pool_allocated = new_entry->mem_pool_allocated;

                    memcpy(new_entry, ce, size);
                    new_entry->mem_pool_allocated = mem_pool_allocated;
                    return new_entry;
            }

            void discard_cache_entry(struct cache_entry *ce)
            {
                    if (ce && should_validate_cache_entries())
                            memset(ce, 0xCD, cache_entry_size(ce->ce_namelen));

                    if (ce && ce->mem_pool_allocated)
                            return;

                    free(ce);
            }

            int should_validate_cache_entries(void)
            {
                    static int validate_index_cache_entries = -1;

                    if (validate_index_cache_entries < 0) {
                            if (getenv("GIT_TEST_VALIDATE_INDEX_CACHE_ENTRIES"))
                                    validate_index_cache_entries = 1;
                            else
                                    validate_index_cache_entries = 0;
                    }

                    return validate_index_cache_entries;
            }

            #define EOIE_SIZE (4 + GIT_SHA1_RAWSZ) /* <4-byte offset> + <20-byte hash> */
            #define EOIE_SIZE_WITH_HEADER (4 + 4 + EOIE_SIZE) /* <4-byte signature> + <4-byte length> + EOIE_SIZE */

            static size_t read_eoie_extension(const char *mmap, size_t mmap_size)
            {
                    /*
                    * The end of index entries (EOIE) extension is guaranteed to be last
                    * so that it can be found by scanning backwards from the EOF.
                    *
                    * "EOIE"
                    * <4-byte length>
                    * <4-byte offset>
                    * <20-byte hash>
                    */
                    const char *index, *eoie;
                    uint32_t extsize;
                    size_t offset, src_offset;
                    unsigned char hash[GIT_MAX_RAWSZ];
                    git_hash_ctx c;

                    /* ensure we have an index big enough to contain an EOIE extension */
                    if (mmap_size < sizeof(struct cache_header) + EOIE_SIZE_WITH_HEADER + the_hash_algo->rawsz)
                            return 0;

                    /* validate the extension signature */
                    index = eoie = mmap + mmap_size - EOIE_SIZE_WITH_HEADER - the_hash_algo->rawsz;
                    if (CACHE_EXT(index) != CACHE_EXT_ENDOFINDEXENTRIES)
                            return 0;
                    index += sizeof(uint32_t);

                    /* validate the extension size */
                    extsize = get_be32(index);
                    if (extsize != EOIE_SIZE)
                            return 0;
                    index += sizeof(uint32_t);

                    /*
                    * Validate the offset we're going to look for the first extension
                    * signature is after the index header and before the eoie extension.
                    */
                    offset = get_be32(index);
                    if (mmap + offset < mmap + sizeof(struct cache_header))
                            return 0;
                    if (mmap + offset >= eoie)
                            return 0;
                    index += sizeof(uint32_t);

                    /*
                    * The hash is computed over extension types and their sizes (but not
                    * their contents).  E.g. if we have "TREE" extension that is N-bytes
                    * long, "REUC" extension that is M-bytes long, followed by "EOIE",
                    * then the hash would be:
                    *
                    * SHA-1("TREE" + <binary representation of N> +
                    *       "REUC" + <binary representation of M>)
                    */
                    src_offset = offset;
                    the_hash_algo->init_fn(&c);
                    while (src_offset < mmap_size - the_hash_algo->rawsz - EOIE_SIZE_WITH_HEADER) {
                            /* After an array of active_nr index entries,
                            * there can be arbitrary number of extended
                            * sections, each of which is prefixed with
                            * extension name (4-byte) and section length
                            * in 4-byte network byte order.
                            */
                            uint32_t extsize;
                            memcpy(&extsize, mmap + src_offset + 4, 4);
                            extsize = ntohl(extsize);

                            /* verify the extension size isn't so large it will wrap around */
                            if (src_offset + 8 + extsize < src_offset)
                                    return 0;

                            the_hash_algo->update_fn(&c, mmap + src_offset, 8);

                            src_offset += 8;
                            src_offset += extsize;
                    }
                    the_hash_algo->final_fn(hash, &c);
                    if (!hasheq(hash, (const unsigned char *)index, the_repository->hash_algo))
                            return 0;

                    /* Validate that the extension offsets returned us back to the eoie extension. */
                    if (src_offset != mmap_size - the_hash_algo->rawsz - EOIE_SIZE_WITH_HEADER)
                            return 0;

                    return offset;
            }

            static void write_eoie_extension(struct strbuf *sb, git_hash_ctx *eoie_context, size_t offset)
            {
                    uint32_t buffer;
                    unsigned char hash[GIT_MAX_RAWSZ];

                    /* offset */
                    put_be32(&buffer, offset);
                    strbuf_add(sb, &buffer, sizeof(uint32_t));

                    /* hash */
                    the_hash_algo->final_fn(hash, eoie_context);
                    strbuf_add(sb, hash, the_hash_algo->rawsz);
            }

            #define IEOT_VERSION    (1)

            static struct index_entry_offset_table *read_ieot_extension(const char *mmap, size_t mmap_size, size_t offset)
            {
                    const char *index = NULL;
                    uint32_t extsize, ext_version;
                    struct index_entry_offset_table *ieot;
                    int i, nr;

                    /* find the IEOT extension */
                    if (!offset)
                            return NULL;
                    while (offset <= mmap_size - the_hash_algo->rawsz - 8) {
                            extsize = get_be32(mmap + offset + 4);
                            if (CACHE_EXT((mmap + offset)) == CACHE_EXT_INDEXENTRYOFFSETTABLE) {
                                    index = mmap + offset + 4 + 4;
                                    break;
                            }
                            offset += 8;
                            offset += extsize;
                    }
                    if (!index)
                            return NULL;

                    /* validate the version is IEOT_VERSION */
                    ext_version = get_be32(index);
                    if (ext_version != IEOT_VERSION) {
                            error("invalid IEOT version %d", ext_version);
                            return NULL;
                    }
                    index += sizeof(uint32_t);

                    /* extension size - version bytes / bytes per entry */
                    nr = (extsize - sizeof(uint32_t)) / (sizeof(uint32_t) + sizeof(uint32_t));
                    if (!nr) {
                            error("invalid number of IEOT entries %d", nr);
                            return NULL;
                    }
                    ieot = xmalloc(sizeof(struct index_entry_offset_table)
                            + (nr * sizeof(struct index_entry_offset)));
                    ieot->nr = nr;
                    for (i = 0; i < nr; i++) {
                            ieot->entries[i].offset = get_be32(index);
                            index += sizeof(uint32_t);
                            ieot->entries[i].nr = get_be32(index);
                            index += sizeof(uint32_t);
                    }

                    return ieot;
            }

            static void write_ieot_extension(struct strbuf *sb, struct index_entry_offset_table *ieot)
            {
                    uint32_t buffer;
                    int i;

                    /* version */
                    put_be32(&buffer, IEOT_VERSION);
                    strbuf_add(sb, &buffer, sizeof(uint32_t));

                    /* ieot */
                    for (i = 0; i < ieot->nr; i++) {

                            /* offset */
                            put_be32(&buffer, ieot->entries[i].offset);
                            strbuf_add(sb, &buffer, sizeof(uint32_t));

                            /* count */
                            put_be32(&buffer, ieot->entries[i].nr);
                            strbuf_add(sb, &buffer, sizeof(uint32_t));
                    }
            }

            void prefetch_cache_entries(const struct index_state *istate,
                                    must_prefetch_predicate must_prefetch)
            {
                    int i;
                    struct oid_array to_fetch = OID_ARRAY_INIT;

                    for (i = 0; i < istate->cache_nr; i++) {
                            struct cache_entry *ce = istate->cache[i];

                            if (S_ISGITLINK(ce->ce_mode) || !must_prefetch(ce))
                                    continue;
                            if (!oid_object_info_extended(the_repository, &ce->oid,
                                                    NULL,
                                                    OBJECT_INFO_FOR_PREFETCH))
                                    continue;
                            oid_array_append(&to_fetch, &ce->oid);
                    }
                    promisor_remote_get_direct(the_repository,
                                            to_fetch.oid, to_fetch.nr);
                    oid_array_clear(&to_fetch);
            }

            static int read_one_entry_opt(struct index_state *istate,
                                    const struct object_id *oid,
                                    struct strbuf *base,
                                    const char *pathname,
                                    unsigned mode, int opt)
            {
                    int len;
                    struct cache_entry *ce;

                    if (S_ISDIR(mode))
                            return READ_TREE_RECURSIVE;

                    len = strlen(pathname);
                    ce = make_empty_cache_entry(istate, base->len + len);

                    ce->ce_mode = create_ce_mode(mode);
                    ce->ce_flags = create_ce_flags(1);
                    ce->ce_namelen = base->len + len;
                    memcpy(ce->name, base->buf, base->len);
                    memcpy(ce->name + base->len, pathname, len+1);
                    oidcpy(&ce->oid, oid);
                    return add_index_entry(istate, ce, opt);
            }

            static int read_one_entry(const struct object_id *oid, struct strbuf *base,
                                    const char *pathname, unsigned mode,
                                    void *context)
            {
                    struct index_state *istate = context;
                    return read_one_entry_opt(istate, oid, base, pathname,
                                            mode,
                                            ADD_CACHE_OK_TO_ADD|ADD_CACHE_SKIP_DFCHECK);
            }

            /*
            * This is used when the caller knows there is no existing entries at
            * the stage that will conflict with the entry being added.
            */
            static int read_one_entry_quick(const struct object_id *oid, struct strbuf *base,
                                            const char *pathname, unsigned mode,
                                            void *context)
            {
                    struct index_state *istate = context;
                    return read_one_entry_opt(istate, oid, base, pathname,
                                            mode, ADD_CACHE_JUST_APPEND);
            }

            /*
            * Read the tree specified with --with-tree option
            * (typically, HEAD) into stage #1 and then
            * squash them down to stage #0.  This is used for
            * --error-unmatch to list and check the path patterns
            * that were given from the command line.  We are not
            * going to write this index out.
            */
            void overlay_tree_on_index(struct index_state *istate,
                                    const char *tree_name, const char *prefix)
            {
                    struct tree *tree;
                    struct object_id oid;
                    struct pathspec pathspec;
                    struct cache_entry *last_stage0 = NULL;
                    int i;
                    read_tree_fn_t fn = NULL;
                    int err;

                    if (repo_get_oid(the_repository, tree_name, &oid))
                            die("tree-ish %s not found.", tree_name);
                    tree = parse_tree_indirect(&oid);
                    if (!tree)
                            die("bad tree-ish %s", tree_name);

                    /* Hoist the unmerged entries up to stage #3 to make room */
                    /* TODO: audit for interaction with sparse-index. */
                    ensure_full_index(istate);
                    for (i = 0; i < istate->cache_nr; i++) {
                            struct cache_entry *ce = istate->cache[i];
                            if (!ce_stage(ce))
                                    continue;
                            ce->ce_flags |= CE_STAGEMASK;
                    }

                    if (prefix) {
                            static const char *(matchbuf[1]);
                            matchbuf[0] = NULL;
                            parse_pathspec(&pathspec, PATHSPEC_ALL_MAGIC,
                                    PATHSPEC_PREFER_CWD, prefix, matchbuf);
                    } else
                            memset(&pathspec, 0, sizeof(pathspec));

                    /*
                    * See if we have cache entry at the stage.  If so,
                    * do it the original slow way, otherwise, append and then
                    * sort at the end.
                    */
                    for (i = 0; !fn && i < istate->cache_nr; i++) {
                            const struct cache_entry *ce = istate->cache[i];
                            if (ce_stage(ce) == 1)
                                    fn = read_one_entry;
                    }

                    if (!fn)
                            fn = read_one_entry_quick;
                    err = read_tree(the_repository, tree, &pathspec, fn, istate);
                    clear_pathspec(&pathspec);
                    if (err)
                            die("unable to read tree entries %s", tree_name);

                    /*
                    * Sort the cache entry -- we need to nuke the cache tree, though.
                    */
                    if (fn == read_one_entry_quick) {
                            cache_tree_free(&istate->cache_tree);
                            QSORT(istate->cache, istate->cache_nr, cmp_cache_name_compare);
                    }

                    for (i = 0; i < istate->cache_nr; i++) {
                            struct cache_entry *ce = istate->cache[i];
                            switch (ce_stage(ce)) {
                            case 0:
                                    last_stage0 = ce;
                                    /* fallthru */
                            default:
                                    continue;
                            case 1:
                                    /*
                                    * If there is stage #0 entry for this, we do not
                                    * need to show it.  We use CE_UPDATE bit to mark
                                    * such an entry.
                                    */
                                    if (last_stage0 &&
                                    !strcmp(last_stage0->name, ce->name))
                                            ce->ce_flags |= CE_UPDATE;
                            }
                    }
            }

            struct update_callback_data {
                    struct index_state *index;
                    int include_sparse;
                    int flags;
                    int add_errors;
            };

            static int fix_unmerged_status(struct diff_filepair *p,
                                    struct update_callback_data *data)
            {
                    if (p->status != DIFF_STATUS_UNMERGED)
                            return p->status;
                    if (!(data->flags & ADD_CACHE_IGNORE_REMOVAL) && !p->two->mode)
                            /*
                            * This is not an explicit add request, and the
                            * path is missing from the working tree (deleted)
                            */
                            return DIFF_STATUS_DELETED;
                    else
                            /*
                            * Either an explicit add request, or path exists
                            * in the working tree.  An attempt to explicitly
                            * add a path that does not exist in the working tree
                            * will be caught as an error by the caller immediately.
                            */
                            return DIFF_STATUS_MODIFIED;
            }

            static void update_callback(struct diff_queue_struct *q,
                                    struct diff_options *opt UNUSED, void *cbdata)
            {
                    int i;
                    struct update_callback_data *data = cbdata;

                    for (i = 0; i < q->nr; i++) {
                            struct diff_filepair *p = q->queue[i];
                            const char *path = p->one->path;

                            if (!data->include_sparse &&
                            !path_in_sparse_checkout(path, data->index))
                                    continue;

                            switch (fix_unmerged_status(p, data)) {
                            default:
                                    die(_("unexpected diff status %c"), p->status);
                            case DIFF_STATUS_MODIFIED:
                            case DIFF_STATUS_TYPE_CHANGED:
                                    if (add_file_to_index(data->index, path, data->flags)) {
                                            if (!(data->flags & ADD_CACHE_IGNORE_ERRORS))
                                                    die(_("updating files failed"));
                                            data->add_errors++;
                                    }
                                    break;
                            case DIFF_STATUS_DELETED:
                                    if (data->flags & ADD_CACHE_IGNORE_REMOVAL)
                                            break;
                                    if (!(data->flags & ADD_CACHE_PRETEND))
                                            remove_file_from_index(data->index, path);
                                    if (data->flags & (ADD_CACHE_PRETEND|ADD_CACHE_VERBOSE))
                                            printf(_("remove '%s'\n"), path);
                                    break;
                            }
                    }
            }

            int add_files_to_cache(struct repository *repo, const char *prefix,
                            const struct pathspec *pathspec, char *ps_matched,
                            int include_sparse, int flags)
            {
                    struct update_callback_data data;
                    struct rev_info rev;

                    memset(&data, 0, sizeof(data));
                    data.index = repo->index;
                    data.include_sparse = include_sparse;
                    data.flags = flags;

                    repo_init_revisions(repo, &rev, prefix);
                    setup_revisions(0, NULL, &rev, NULL);
                    if (pathspec) {
                            copy_pathspec(&rev.prune_data, pathspec);
                            rev.ps_matched = ps_matched;
                    }
                    rev.diffopt.output_format = DIFF_FORMAT_CALLBACK;
                    rev.diffopt.format_callback = update_callback;
                    rev.diffopt.format_callback_data = &data;
                    rev.diffopt.flags.override_submodule_config = 1;
                    rev.max_count = 0; /* do not compare unmerged paths with stage #2 */

                    /*
                    * Use an ODB transaction to optimize adding multiple objects.
                    * This function is invoked from commands other than 'add', which
                    * may not have their own transaction active.
                    */
                    begin_odb_transaction();
                    run_diff_files(&rev, DIFF_RACY_IS_MODIFIED);
                    end_odb_transaction();

                    release_revisions(&rev);
                    return !!data.add_errors;
            }



            """,
            "Error":"Automatic encoding conversions are explicitly disabled for file descriptors used in ce_compare_data, ensuring:
                    Accurate comparisons between working directory files and index entries.
                    Reliable hashing and object ID computation.
                    This improves Gits reliability and compatibility on z/OS, making it more robust and user-friendly in this environment.",
            "Error Category":"Functionality patche",

            "Corrected Code":
            """
                            /*
            * GIT - The information manager from hell
            *
            * Copyright (C) Linus Torvalds, 2005
            */

            #define USE_THE_REPOSITORY_VARIABLE
            #define DISABLE_SIGN_COMPARE_WARNINGS

            #include "git-compat-util.h"
            #include "bulk-checkin.h"
            #include "config.h"
            #include "date.h"
            #include "diff.h"
            #include "diffcore.h"
            #include "hex.h"
            #include "tempfile.h"
            #include "lockfile.h"
            #include "cache-tree.h"
            #include "refs.h"
            #include "dir.h"
            #include "object-file.h"
            #include "object-store-ll.h"
            #include "oid-array.h"
            #include "tree.h"
            #include "commit.h"
            #include "environment.h"
            #include "gettext.h"
            #include "mem-pool.h"
            #include "name-hash.h"
            #include "object-name.h"
            #include "path.h"
            #include "preload-index.h"
            #include "read-cache.h"
            #include "repository.h"
            #include "resolve-undo.h"
            #include "revision.h"
            #include "strbuf.h"
            #include "trace2.h"
            #include "varint.h"
            #include "split-index.h"
            #include "symlinks.h"
            #include "utf8.h"
            #include "fsmonitor.h"
            #include "thread-utils.h"
            #include "progress.h"
            #include "sparse-index.h"
            #include "csum-file.h"
            #include "promisor-remote.h"
            #include "hook.h"

            /* Mask for the name length in ce_flags in the on-disk index */

            #define CE_NAMEMASK  (0x0fff)

            /* Index extensions.
            *
            * The first letter should be 'A'..'Z' for extensions that are not
            * necessary for a correct operation (i.e. optimization data).
            * When new extensions are added that _needs_ to be understood in
            * order to correctly interpret the index file, pick character that
            * is outside the range, to cause the reader to abort.
            */

            #define CACHE_EXT(s) ( (s[0]<<24)|(s[1]<<16)|(s[2]<<8)|(s[3]) )
            #define CACHE_EXT_TREE 0x54524545       /* "TREE" */
            #define CACHE_EXT_RESOLVE_UNDO 0x52455543 /* "REUC" */
            #define CACHE_EXT_LINK 0x6c696e6b         /* "link" */
            #define CACHE_EXT_UNTRACKED 0x554E5452    /* "UNTR" */
            #define CACHE_EXT_FSMONITOR 0x46534D4E    /* "FSMN" */
            #define CACHE_EXT_ENDOFINDEXENTRIES 0x454F4945  /* "EOIE" */
            #define CACHE_EXT_INDEXENTRYOFFSETTABLE 0x49454F54 /* "IEOT" */
            #define CACHE_EXT_SPARSE_DIRECTORIES 0x73646972 /* "sdir" */

            /* changes that can be kept in $GIT_DIR/index (basically all extensions) */
            #define EXTMASK (RESOLVE_UNDO_CHANGED | CACHE_TREE_CHANGED | \
                            CE_ENTRY_ADDED | CE_ENTRY_REMOVED | CE_ENTRY_CHANGED | \
                            SPLIT_INDEX_ORDERED | UNTRACKED_CHANGED | FSMONITOR_CHANGED)


            /*
            * This is an estimate of the pathname length in the index.  We use
            * this for V4 index files to guess the un-deltafied size of the index
            * in memory because of pathname deltafication.  This is not required
            * for V2/V3 index formats because their pathnames are not compressed.
            * If the initial amount of memory set aside is not sufficient, the
            * mem pool will allocate extra memory.
            */
            #define CACHE_ENTRY_PATH_LENGTH 80

            enum index_search_mode {
                    NO_EXPAND_SPARSE = 0,
                    EXPAND_SPARSE = 1
            };

            static inline struct cache_entry *mem_pool__ce_alloc(struct mem_pool *mem_pool, size_t len)
            {
                    struct cache_entry *ce;
                    ce = mem_pool_alloc(mem_pool, cache_entry_size(len));
                    ce->mem_pool_allocated = 1;
                    return ce;
            }

            static inline struct cache_entry *mem_pool__ce_calloc(struct mem_pool *mem_pool, size_t len)
            {
                    struct cache_entry * ce;
                    ce = mem_pool_calloc(mem_pool, 1, cache_entry_size(len));
                    ce->mem_pool_allocated = 1;
                    return ce;
            }

            static struct mem_pool *find_mem_pool(struct index_state *istate)
            {
                    struct mem_pool **pool_ptr;

                    if (istate->split_index && istate->split_index->base)
                            pool_ptr = &istate->split_index->base->ce_mem_pool;
                    else
                            pool_ptr = &istate->ce_mem_pool;

                    if (!*pool_ptr) {
                            *pool_ptr = xmalloc(sizeof(**pool_ptr));
                            mem_pool_init(*pool_ptr, 0);
                    }

                    return *pool_ptr;
            }

            static const char *alternate_index_output;

            static void set_index_entry(struct index_state *istate, int nr, struct cache_entry *ce)
            {
                    if (S_ISSPARSEDIR(ce->ce_mode))
                            istate->sparse_index = INDEX_COLLAPSED;

                    istate->cache[nr] = ce;
                    add_name_hash(istate, ce);
            }

            static void replace_index_entry(struct index_state *istate, int nr, struct cache_entry *ce)
            {
                    struct cache_entry *old = istate->cache[nr];

                    replace_index_entry_in_base(istate, old, ce);
                    remove_name_hash(istate, old);
                    discard_cache_entry(old);
                    ce->ce_flags &= ~CE_HASHED;
                    set_index_entry(istate, nr, ce);
                    ce->ce_flags |= CE_UPDATE_IN_BASE;
                    mark_fsmonitor_invalid(istate, ce);
                    istate->cache_changed |= CE_ENTRY_CHANGED;
            }

            void rename_index_entry_at(struct index_state *istate, int nr, const char *new_name)
            {
                    struct cache_entry *old_entry = istate->cache[nr], *new_entry, *refreshed;
                    int namelen = strlen(new_name);

                    new_entry = make_empty_cache_entry(istate, namelen);
                    copy_cache_entry(new_entry, old_entry);
                    new_entry->ce_flags &= ~CE_HASHED;
                    new_entry->ce_namelen = namelen;
                    new_entry->index = 0;
                    memcpy(new_entry->name, new_name, namelen + 1);

                    cache_tree_invalidate_path(istate, old_entry->name);
                    untracked_cache_remove_from_index(istate, old_entry->name);
                    remove_index_entry_at(istate, nr);

                    /*
                    * Refresh the new index entry. Using 'refresh_cache_entry' ensures
                    * we only update stat info if the entry is otherwise up-to-date (i.e.,
                    * the contents/mode haven't changed). This ensures that we reflect the
                    * 'ctime' of the rename in the index without (incorrectly) updating
                    * the cached stat info to reflect unstaged changes on disk.
                    */
                    refreshed = refresh_cache_entry(istate, new_entry, CE_MATCH_REFRESH);
                    if (refreshed && refreshed != new_entry) {
                            add_index_entry(istate, refreshed, ADD_CACHE_OK_TO_ADD|ADD_CACHE_OK_TO_REPLACE);
                            discard_cache_entry(new_entry);
                    } else
                            add_index_entry(istate, new_entry, ADD_CACHE_OK_TO_ADD|ADD_CACHE_OK_TO_REPLACE);
            }

            /*
            * This only updates the "non-critical" parts of the directory
            * cache, ie the parts that aren't tracked by GIT, and only used
            * to validate the cache.
            */
            void fill_stat_cache_info(struct index_state *istate, struct cache_entry *ce, struct stat *st)
            {
                    fill_stat_data(&ce->ce_stat_data, st);

                    if (assume_unchanged)
                            ce->ce_flags |= CE_VALID;

                    if (S_ISREG(st->st_mode)) {
                            ce_mark_uptodate(ce);
                            mark_fsmonitor_valid(istate, ce);
                    }
            }

            static unsigned int st_mode_from_ce(const struct cache_entry *ce)
            {
                    extern int trust_executable_bit, has_symlinks;

                    switch (ce->ce_mode & S_IFMT) {
                    case S_IFLNK:
                            return has_symlinks ? S_IFLNK : (S_IFREG | 0644);
                    case S_IFREG:
                            return (ce->ce_mode & (trust_executable_bit ? 0755 : 0644)) | S_IFREG;
                    case S_IFGITLINK:
                            return S_IFDIR | 0755;
                    case S_IFDIR:
                            return ce->ce_mode;
                    default:
                            BUG("unsupported ce_mode: %o", ce->ce_mode);
                    }
            }

            int fake_lstat(const struct cache_entry *ce, struct stat *st)
            {
                    fake_lstat_data(&ce->ce_stat_data, st);
                    st->st_mode = st_mode_from_ce(ce);

                    /* always succeed as lstat() replacement */
                    return 0;
            }

            static int ce_compare_data(struct index_state *istate,
                                    const struct cache_entry *ce,
                                    struct stat *st)
            {
                    int match = -1;
                    int fd = git_open_cloexec(ce->name, O_RDONLY);

                    if (fd >= 0) {
            #ifdef __MVS__
            __disableautocvt(fd);
            #endif
                            struct object_id oid;
                            if (!index_fd(istate, &oid, fd, st, OBJ_BLOB, ce->name, 0))
                                    match = !oideq(&oid, &ce->oid);
                            /* index_fd() closed the file descriptor already */
                    }
                    return match;
            }

            static int ce_compare_link(const struct cache_entry *ce, size_t expected_size)
            {
                    int match = -1;
                    void *buffer;
                    unsigned long size;
                    enum object_type type;
                    struct strbuf sb = STRBUF_INIT;

                    if (strbuf_readlink(&sb, ce->name, expected_size))
                            return -1;

                    buffer = repo_read_object_file(the_repository, &ce->oid, &type, &size);
                    if (buffer) {
                            if (size == sb.len)
                                    match = memcmp(buffer, sb.buf, size);
                            free(buffer);
                    }
                    strbuf_release(&sb);
                    return match;
            }

            static int ce_compare_gitlink(const struct cache_entry *ce)
            {
                    struct object_id oid;

                    /*
                    * We don't actually require that the .git directory
                    * under GITLINK directory be a valid git directory. It
                    * might even be missing (in case nobody populated that
                    * sub-project).
                    *
                    * If so, we consider it always to match.
                    */
                    if (repo_resolve_gitlink_ref(the_repository, ce->name,
                                            "HEAD", &oid) < 0)
                            return 0;
                    return !oideq(&oid, &ce->oid);
            }

            static int ce_modified_check_fs(struct index_state *istate,
                                            const struct cache_entry *ce,
                                            struct stat *st)
            {
                    switch (st->st_mode & S_IFMT) {
                    case S_IFREG:
                            if (ce_compare_data(istate, ce, st))
                                    return DATA_CHANGED;
                            break;
                    case S_IFLNK:
                            if (ce_compare_link(ce, xsize_t(st->st_size)))
                                    return DATA_CHANGED;
                            break;
                    case S_IFDIR:
                            if (S_ISGITLINK(ce->ce_mode))
                                    return ce_compare_gitlink(ce) ? DATA_CHANGED : 0;
                            /* else fallthrough */
                    default:
                            return TYPE_CHANGED;
                    }
                    return 0;
            }

            static int ce_match_stat_basic(const struct cache_entry *ce, struct stat *st)
            {
                    unsigned int changed = 0;

                    if (ce->ce_flags & CE_REMOVE)
                            return MODE_CHANGED | DATA_CHANGED | TYPE_CHANGED;

                    switch (ce->ce_mode & S_IFMT) {
                    case S_IFREG:
                            changed |= !S_ISREG(st->st_mode) ? TYPE_CHANGED : 0;
                            /* We consider only the owner x bit to be relevant for
                            * "mode changes"
                            */
                            if (trust_executable_bit &&
                            (0100 & (ce->ce_mode ^ st->st_mode)))
                                    changed |= MODE_CHANGED;
                            break;
                    case S_IFLNK:
                            if (!S_ISLNK(st->st_mode) &&
                            (has_symlinks || !S_ISREG(st->st_mode)))
                                    changed |= TYPE_CHANGED;
                            break;
                    case S_IFGITLINK:
                            /* We ignore most of the st_xxx fields for gitlinks */
                            if (!S_ISDIR(st->st_mode))
                                    changed |= TYPE_CHANGED;
                            else if (ce_compare_gitlink(ce))
                                    changed |= DATA_CHANGED;
                            return changed;
                    default:
                            BUG("unsupported ce_mode: %o", ce->ce_mode);
                    }

                    changed |= match_stat_data(&ce->ce_stat_data, st);

                    /* Racily smudged entry? */
                    if (!ce->ce_stat_data.sd_size) {
                            if (!is_empty_blob_oid(&ce->oid, the_repository->hash_algo))
                                    changed |= DATA_CHANGED;
                    }

                    return changed;
            }

            static int is_racy_stat(const struct index_state *istate,
                                    const struct stat_data *sd)
            {
                    return (istate->timestamp.sec &&
            #ifdef USE_NSEC
                            /* nanosecond timestamped files can also be racy! */
                            (istate->timestamp.sec < sd->sd_mtime.sec ||
                            (istate->timestamp.sec == sd->sd_mtime.sec &&
                            istate->timestamp.nsec <= sd->sd_mtime.nsec))
            #else
                            istate->timestamp.sec <= sd->sd_mtime.sec
            #endif
                            );
            }

            int is_racy_timestamp(const struct index_state *istate,
                                    const struct cache_entry *ce)
            {
                    return (!S_ISGITLINK(ce->ce_mode) &&
                            is_racy_stat(istate, &ce->ce_stat_data));
            }

            int match_stat_data_racy(const struct index_state *istate,
                                    const struct stat_data *sd, struct stat *st)
            {
                    if (is_racy_stat(istate, sd))
                            return MTIME_CHANGED;
                    return match_stat_data(sd, st);
            }

            int ie_match_stat(struct index_state *istate,
                            const struct cache_entry *ce, struct stat *st,
                            unsigned int options)
            {
                    unsigned int changed;
                    int ignore_valid = options & CE_MATCH_IGNORE_VALID;
                    int ignore_skip_worktree = options & CE_MATCH_IGNORE_SKIP_WORKTREE;
                    int assume_racy_is_modified = options & CE_MATCH_RACY_IS_DIRTY;
                    int ignore_fsmonitor = options & CE_MATCH_IGNORE_FSMONITOR;

                    if (!ignore_fsmonitor)
                            refresh_fsmonitor(istate);
                    /*
                    * If it's marked as always valid in the index, it's
                    * valid whatever the checked-out copy says.
                    *
                    * skip-worktree has the same effect with higher precedence
                    */
                    if (!ignore_skip_worktree && ce_skip_worktree(ce))
                            return 0;
                    if (!ignore_valid && (ce->ce_flags & CE_VALID))
                            return 0;
                    if (!ignore_fsmonitor && (ce->ce_flags & CE_FSMONITOR_VALID))
                            return 0;

                    /*
                    * Intent-to-add entries have not been added, so the index entry
                    * by definition never matches what is in the work tree until it
                    * actually gets added.
                    */
                    if (ce_intent_to_add(ce))
                            return DATA_CHANGED | TYPE_CHANGED | MODE_CHANGED;

                    changed = ce_match_stat_basic(ce, st);

                    /*
                    * Within 1 second of this sequence:
                    *      echo xyzzy >file && git-update-index --add file
                    * running this command:
                    *      echo frotz >file
                    * would give a falsely clean cache entry.  The mtime and
                    * length match the cache, and other stat fields do not change.
                    *
                    * We could detect this at update-index time (the cache entry
                    * being registered/updated records the same time as "now")
                    * and delay the return from git-update-index, but that would
                    * effectively mean we can make at most one commit per second,
                    * which is not acceptable.  Instead, we check cache entries
                    * whose mtime are the same as the index file timestamp more
                    * carefully than others.
                    */
                    if (!changed && is_racy_timestamp(istate, ce)) {
                            if (assume_racy_is_modified)
                                    changed |= DATA_CHANGED;
                            else
                                    changed |= ce_modified_check_fs(istate, ce, st);
                    }

                    return changed;
            }

            int ie_modified(struct index_state *istate,
                            const struct cache_entry *ce,
                            struct stat *st, unsigned int options)
            {
                    int changed, changed_fs;

                    changed = ie_match_stat(istate, ce, st, options);
                    if (!changed)
                            return 0;
                    /*
                    * If the mode or type has changed, there's no point in trying
                    * to refresh the entry - it's not going to match
                    */
                    if (changed & (MODE_CHANGED | TYPE_CHANGED))
                            return changed;

                    /*
                    * Immediately after read-tree or update-index --cacheinfo,
                    * the length field is zero, as we have never even read the
                    * lstat(2) information once, and we cannot trust DATA_CHANGED
                    * returned by ie_match_stat() which in turn was returned by
                    * ce_match_stat_basic() to signal that the filesize of the
                    * blob changed.  We have to actually go to the filesystem to
                    * see if the contents match, and if so, should answer "unchanged".
                    *
                    * The logic does not apply to gitlinks, as ce_match_stat_basic()
                    * already has checked the actual HEAD from the filesystem in the
                    * subproject.  If ie_match_stat() already said it is different,
                    * then we know it is.
                    */
                    if ((changed & DATA_CHANGED) &&
                    (S_ISGITLINK(ce->ce_mode) || ce->ce_stat_data.sd_size != 0))
                            return changed;

                    changed_fs = ce_modified_check_fs(istate, ce, st);
                    if (changed_fs)
                            return changed | changed_fs;
                    return 0;
            }

            static int cache_name_stage_compare(const char *name1, int len1, int stage1,
                                            const char *name2, int len2, int stage2)
            {
                    int cmp;

                    cmp = name_compare(name1, len1, name2, len2);
                    if (cmp)
                            return cmp;

                    if (stage1 < stage2)
                            return -1;
                    if (stage1 > stage2)
                            return 1;
                    return 0;
            }

            int cmp_cache_name_compare(const void *a_, const void *b_)
            {
                    const struct cache_entry *ce1, *ce2;

                    ce1 = *((const struct cache_entry **)a_);
                    ce2 = *((const struct cache_entry **)b_);
                    return cache_name_stage_compare(ce1->name, ce1->ce_namelen, ce_stage(ce1),
                                            ce2->name, ce2->ce_namelen, ce_stage(ce2));
            }

            static int index_name_stage_pos(struct index_state *istate,
                                            const char *name, int namelen,
                                            int stage,
                                            enum index_search_mode search_mode)
            {
                    int first, last;

                    first = 0;
                    last = istate->cache_nr;
                    while (last > first) {
                            int next = first + ((last - first) >> 1);
                            struct cache_entry *ce = istate->cache[next];
                            int cmp = cache_name_stage_compare(name, namelen, stage, ce->name, ce_namelen(ce), ce_stage(ce));
                            if (!cmp)
                                    return next;
                            if (cmp < 0) {
                                    last = next;
                                    continue;
                            }
                            first = next+1;
                    }

                    if (search_mode == EXPAND_SPARSE && istate->sparse_index &&
                    first > 0) {
                            /* Note: first <= istate->cache_nr */
                            struct cache_entry *ce = istate->cache[first - 1];

                            /*
                            * If we are in a sparse-index _and_ the entry before the
                            * insertion position is a sparse-directory entry that is
                            * an ancestor of 'name', then we need to expand the index
                            * and search again. This will only trigger once, because
                            * thereafter the index is fully expanded.
                            */
                            if (S_ISSPARSEDIR(ce->ce_mode) &&
                            ce_namelen(ce) < namelen &&
                            !strncmp(name, ce->name, ce_namelen(ce))) {
                                    ensure_full_index(istate);
                                    return index_name_stage_pos(istate, name, namelen, stage, search_mode);
                            }
                    }

                    return -first-1;
            }

            int index_name_pos(struct index_state *istate, const char *name, int namelen)
            {
                    return index_name_stage_pos(istate, name, namelen, 0, EXPAND_SPARSE);
            }

            int index_name_pos_sparse(struct index_state *istate, const char *name, int namelen)
            {
                    return index_name_stage_pos(istate, name, namelen, 0, NO_EXPAND_SPARSE);
            }

            int index_entry_exists(struct index_state *istate, const char *name, int namelen)
            {
                    return index_name_stage_pos(istate, name, namelen, 0, NO_EXPAND_SPARSE) >= 0;
            }

            int remove_index_entry_at(struct index_state *istate, int pos)
            {
                    struct cache_entry *ce = istate->cache[pos];

                    record_resolve_undo(istate, ce);
                    remove_name_hash(istate, ce);
                    save_or_free_index_entry(istate, ce);
                    istate->cache_changed |= CE_ENTRY_REMOVED;
                    istate->cache_nr--;
                    if (pos >= istate->cache_nr)
                            return 0;
                    MOVE_ARRAY(istate->cache + pos, istate->cache + pos + 1,
                            istate->cache_nr - pos);
                    return 1;
            }

            /*
            * Remove all cache entries marked for removal, that is where
            * CE_REMOVE is set in ce_flags.  This is much more effective than
            * calling remove_index_entry_at() for each entry to be removed.
            */
            void remove_marked_cache_entries(struct index_state *istate, int invalidate)
            {
                    struct cache_entry **ce_array = istate->cache;
                    unsigned int i, j;

                    for (i = j = 0; i < istate->cache_nr; i++) {
                            if (ce_array[i]->ce_flags & CE_REMOVE) {
                                    if (invalidate) {
                                            cache_tree_invalidate_path(istate,
                                                                    ce_array[i]->name);
                                            untracked_cache_remove_from_index(istate,
                                                                            ce_array[i]->name);
                                    }
                                    remove_name_hash(istate, ce_array[i]);
                                    save_or_free_index_entry(istate, ce_array[i]);
                            }
                            else
                                    ce_array[j++] = ce_array[i];
                    }
                    if (j == istate->cache_nr)
                            return;
                    istate->cache_changed |= CE_ENTRY_REMOVED;
                    istate->cache_nr = j;
            }

            int remove_file_from_index(struct index_state *istate, const char *path)
            {
                    int pos = index_name_pos(istate, path, strlen(path));
                    if (pos < 0)
                            pos = -pos-1;
                    cache_tree_invalidate_path(istate, path);
                    untracked_cache_remove_from_index(istate, path);
                    while (pos < istate->cache_nr && !strcmp(istate->cache[pos]->name, path))
                            remove_index_entry_at(istate, pos);
                    return 0;
            }

            static int compare_name(struct cache_entry *ce, const char *path, int namelen)
            {
                    return namelen != ce_namelen(ce) || memcmp(path, ce->name, namelen);
            }

            static int index_name_pos_also_unmerged(struct index_state *istate,
                    const char *path, int namelen)
            {
                    int pos = index_name_pos(istate, path, namelen);
                    struct cache_entry *ce;

                    if (pos >= 0)
                            return pos;

                    /* maybe unmerged? */
                    pos = -1 - pos;
                    if (pos >= istate->cache_nr ||
                                    compare_name((ce = istate->cache[pos]), path, namelen))
                            return -1;

                    /* order of preference: stage 2, 1, 3 */
                    if (ce_stage(ce) == 1 && pos + 1 < istate->cache_nr &&
                                    ce_stage((ce = istate->cache[pos + 1])) == 2 &&
                                    !compare_name(ce, path, namelen))
                            pos++;
                    return pos;
            }

            static int different_name(struct cache_entry *ce, struct cache_entry *alias)
            {
                    int len = ce_namelen(ce);
                    return ce_namelen(alias) != len || memcmp(ce->name, alias->name, len);
            }

            /*
            * If we add a filename that aliases in the cache, we will use the
            * name that we already have - but we don't want to update the same
            * alias twice, because that implies that there were actually two
            * different files with aliasing names!
            *
            * So we use the CE_ADDED flag to verify that the alias was an old
            * one before we accept it as
            */
            static struct cache_entry *create_alias_ce(struct index_state *istate,
                                                    struct cache_entry *ce,
                                                    struct cache_entry *alias)
            {
                    int len;
                    struct cache_entry *new_entry;

                    if (alias->ce_flags & CE_ADDED)
                            die(_("will not add file alias '%s' ('%s' already exists in index)"),
                            ce->name, alias->name);

                    /* Ok, create the new entry using the name of the existing alias */
                    len = ce_namelen(alias);
                    new_entry = make_empty_cache_entry(istate, len);
                    memcpy(new_entry->name, alias->name, len);
                    copy_cache_entry(new_entry, ce);
                    save_or_free_index_entry(istate, ce);
                    return new_entry;
            }

            void set_object_name_for_intent_to_add_entry(struct cache_entry *ce)
            {
                    struct object_id oid;
                    if (write_object_file("", 0, OBJ_BLOB, &oid))
                            die(_("cannot create an empty blob in the object database"));
                    oidcpy(&ce->oid, &oid);
            }

            int add_to_index(struct index_state *istate, const char *path, struct stat *st, int flags)
            {
                    int namelen, was_same;
                    mode_t st_mode = st->st_mode;
                    struct cache_entry *ce, *alias = NULL;
                    unsigned ce_option = CE_MATCH_IGNORE_VALID|CE_MATCH_IGNORE_SKIP_WORKTREE|CE_MATCH_RACY_IS_DIRTY;
                    int verbose = flags & (ADD_CACHE_VERBOSE | ADD_CACHE_PRETEND);
                    int pretend = flags & ADD_CACHE_PRETEND;
                    int intent_only = flags & ADD_CACHE_INTENT;
                    int add_option = (ADD_CACHE_OK_TO_ADD|ADD_CACHE_OK_TO_REPLACE|
                                    (intent_only ? ADD_CACHE_NEW_ONLY : 0));
                    unsigned hash_flags = pretend ? 0 : HASH_WRITE_OBJECT;
                    struct object_id oid;

                    if (flags & ADD_CACHE_RENORMALIZE)
                            hash_flags |= HASH_RENORMALIZE;

                    if (!S_ISREG(st_mode) && !S_ISLNK(st_mode) && !S_ISDIR(st_mode))
                            return error(_("%s: can only add regular files, symbolic links or git-directories"), path);

                    namelen = strlen(path);
                    if (S_ISDIR(st_mode)) {
                            if (repo_resolve_gitlink_ref(the_repository, path, "HEAD", &oid) < 0)
                                    return error(_("'%s' does not have a commit checked out"), path);
                            while (namelen && path[namelen-1] == '/')
                                    namelen--;
                    }
                    ce = make_empty_cache_entry(istate, namelen);
                    memcpy(ce->name, path, namelen);
                    ce->ce_namelen = namelen;
                    if (!intent_only)
                            fill_stat_cache_info(istate, ce, st);
                    else
                            ce->ce_flags |= CE_INTENT_TO_ADD;


                    if (trust_executable_bit && has_symlinks) {
                            ce->ce_mode = create_ce_mode(st_mode);
                    } else {
                            /* If there is an existing entry, pick the mode bits and type
                            * from it, otherwise assume unexecutable regular file.
                            */
                            struct cache_entry *ent;
                            int pos = index_name_pos_also_unmerged(istate, path, namelen);

                            ent = (0 <= pos) ? istate->cache[pos] : NULL;
                            ce->ce_mode = ce_mode_from_stat(ent, st_mode);
                    }

                    /* When core.ignorecase=true, determine if a directory of the same name but differing
                    * case already exists within the Git repository.  If it does, ensure the directory
                    * case of the file being added to the repository matches (is folded into) the existing
                    * entry's directory case.
                    */
                    if (ignore_case) {
                            adjust_dirname_case(istate, ce->name);
                    }
                    if (!(flags & ADD_CACHE_RENORMALIZE)) {
                            alias = index_file_exists(istate, ce->name,
                                                    ce_namelen(ce), ignore_case);
                            if (alias &&
                            !ce_stage(alias) &&
                            !ie_match_stat(istate, alias, st, ce_option)) {
                                    /* Nothing changed, really */
                                    if (!S_ISGITLINK(alias->ce_mode))
                                            ce_mark_uptodate(alias);
                                    alias->ce_flags |= CE_ADDED;

                                    discard_cache_entry(ce);
                                    return 0;
                            }
                    }
                    if (!intent_only) {
                            if (index_path(istate, &ce->oid, path, st, hash_flags)) {
                                    discard_cache_entry(ce);
                                    return error(_("unable to index file '%s'"), path);
                            }
                    } else
                            set_object_name_for_intent_to_add_entry(ce);

                    if (ignore_case && alias && different_name(ce, alias))
                            ce = create_alias_ce(istate, ce, alias);
                    ce->ce_flags |= CE_ADDED;

                    /* It was suspected to be racily clean, but it turns out to be Ok */
                    was_same = (alias &&
                            !ce_stage(alias) &&
                            oideq(&alias->oid, &ce->oid) &&
                            ce->ce_mode == alias->ce_mode);

                    if (pretend)
                            discard_cache_entry(ce);
                    else if (add_index_entry(istate, ce, add_option)) {
                            discard_cache_entry(ce);
                            return error(_("unable to add '%s' to index"), path);
                    }
                    if (verbose && !was_same)
                            printf("add '%s'\n", path);
                    return 0;
            }

            int add_file_to_index(struct index_state *istate, const char *path, int flags)
            {
                    struct stat st;
                    if (lstat(path, &st))
                            die_errno(_("unable to stat '%s'"), path);
                    return add_to_index(istate, path, &st, flags);
            }

            struct cache_entry *make_empty_cache_entry(struct index_state *istate, size_t len)
            {
                    return mem_pool__ce_calloc(find_mem_pool(istate), len);
            }

            struct cache_entry *make_empty_transient_cache_entry(size_t len,
                                                            struct mem_pool *ce_mem_pool)
            {
                    if (ce_mem_pool)
                            return mem_pool__ce_calloc(ce_mem_pool, len);
                    return xcalloc(1, cache_entry_size(len));
            }

            enum verify_path_result {
                    PATH_OK,
                    PATH_INVALID,
                    PATH_DIR_WITH_SEP,
            };

            static enum verify_path_result verify_path_internal(const char *, unsigned);

            int verify_path(const char *path, unsigned mode)
            {
                    return verify_path_internal(path, mode) == PATH_OK;
            }

            struct cache_entry *make_cache_entry(struct index_state *istate,
                                            unsigned int mode,
                                            const struct object_id *oid,
                                            const char *path,
                                            int stage,
                                            unsigned int refresh_options)
            {
                    struct cache_entry *ce, *ret;
                    int len;

                    if (verify_path_internal(path, mode) == PATH_INVALID) {
                            error(_("invalid path '%s'"), path);
                            return NULL;
                    }

                    len = strlen(path);
                    ce = make_empty_cache_entry(istate, len);

                    oidcpy(&ce->oid, oid);
                    memcpy(ce->name, path, len);
                    ce->ce_flags = create_ce_flags(stage);
                    ce->ce_namelen = len;
                    ce->ce_mode = create_ce_mode(mode);

                    ret = refresh_cache_entry(istate, ce, refresh_options);
                    if (ret != ce)
                            discard_cache_entry(ce);
                    return ret;
            }

            struct cache_entry *make_transient_cache_entry(unsigned int mode,
                                                    const struct object_id *oid,
                                                    const char *path,
                                                    int stage,
                                                    struct mem_pool *ce_mem_pool)
            {
                    struct cache_entry *ce;
                    int len;

                    if (!verify_path(path, mode)) {
                            error(_("invalid path '%s'"), path);
                            return NULL;
                    }

                    len = strlen(path);
                    ce = make_empty_transient_cache_entry(len, ce_mem_pool);

                    oidcpy(&ce->oid, oid);
                    memcpy(ce->name, path, len);
                    ce->ce_flags = create_ce_flags(stage);
                    ce->ce_namelen = len;
                    ce->ce_mode = create_ce_mode(mode);

                    return ce;
            }

            /*
            * Chmod an index entry with either +x or -x.
            *
            * Returns -1 if the chmod for the particular cache entry failed (if it's
            * not a regular file), -2 if an invalid flip argument is passed in, 0
            * otherwise.
            */
            int chmod_index_entry(struct index_state *istate, struct cache_entry *ce,
                            char flip)
            {
                    if (!S_ISREG(ce->ce_mode))
                            return -1;
                    switch (flip) {
                    case '+':
                            ce->ce_mode |= 0111;
                            break;
                    case '-':
                            ce->ce_mode &= ~0111;
                            break;
                    default:
                            return -2;
                    }
                    cache_tree_invalidate_path(istate, ce->name);
                    ce->ce_flags |= CE_UPDATE_IN_BASE;
                    mark_fsmonitor_invalid(istate, ce);
                    istate->cache_changed |= CE_ENTRY_CHANGED;

                    return 0;
            }

            int ce_same_name(const struct cache_entry *a, const struct cache_entry *b)
            {
                    int len = ce_namelen(a);
                    return ce_namelen(b) == len && !memcmp(a->name, b->name, len);
            }

            /*
            * We fundamentally don't like some paths: we don't want
            * dot or dot-dot anywhere, and for obvious reasons don't
            * want to recurse into ".git" either.
            *
            * Also, we don't want double slashes or slashes at the
            * end that can make pathnames ambiguous.
            */
            static int verify_dotfile(const char *rest, unsigned mode)
            {
                    /*
                    * The first character was '.', but that
                    * has already been discarded, we now test
                    * the rest.
                    */

                    /* "." is not allowed */
                    if (*rest == '\0' || is_dir_sep(*rest))
                            return 0;

                    switch (*rest) {
                    /*
                    * ".git" followed by NUL or slash is bad. Note that we match
                    * case-insensitively here, even if ignore_case is not set.
                    * This outlaws ".GIT" everywhere out of an abundance of caution,
                    * since there's really no good reason to allow it.
                    *
                    * Once we've seen ".git", we can also find ".gitmodules", etc (also
                    * case-insensitively).
                    */
                    case 'g':
                    case 'G':
                            if (rest[1] != 'i' && rest[1] != 'I')
                                    break;
                            if (rest[2] != 't' && rest[2] != 'T')
                                    break;
                            if (rest[3] == '\0' || is_dir_sep(rest[3]))
                                    return 0;
                            if (S_ISLNK(mode)) {
                                    rest += 3;
                                    if (skip_iprefix(rest, "modules", &rest) &&
                                    (*rest == '\0' || is_dir_sep(*rest)))
                                            return 0;
                            }
                            break;
                    case '.':
                            if (rest[1] == '\0' || is_dir_sep(rest[1]))
                                    return 0;
                    }
                    return 1;
            }

            static enum verify_path_result verify_path_internal(const char *path,
                                                            unsigned mode)
            {
                    char c = 0;

                    if (has_dos_drive_prefix(path))
                            return PATH_INVALID;

                    if (!is_valid_path(path))
                            return PATH_INVALID;

                    goto inside;
                    for (;;) {
                            if (!c)
                                    return PATH_OK;
                            if (is_dir_sep(c)) {
            inside:
                                    if (protect_hfs) {

                                            if (is_hfs_dotgit(path))
                                                    return PATH_INVALID;
                                            if (S_ISLNK(mode)) {
                                                    if (is_hfs_dotgitmodules(path))
                                                            return PATH_INVALID;
                                            }
                                    }
                                    if (protect_ntfs) {
            #if defined GIT_WINDOWS_NATIVE || defined __CYGWIN__
                                            if (c == '\\')
                                                    return PATH_INVALID;
            #endif
                                            if (is_ntfs_dotgit(path))
                                                    return PATH_INVALID;
                                            if (S_ISLNK(mode)) {
                                                    if (is_ntfs_dotgitmodules(path))
                                                            return PATH_INVALID;
                                            }
                                    }

                                    c = *path++;
                                    if ((c == '.' && !verify_dotfile(path, mode)) ||
                                    is_dir_sep(c))
                                            return PATH_INVALID;
                                    /*
                                    * allow terminating directory separators for
                                    * sparse directory entries.
                                    */
                                    if (c == '\0')
                                            return S_ISDIR(mode) ? PATH_DIR_WITH_SEP :
                                                            PATH_INVALID;
                            } else if (c == '\\' && protect_ntfs) {
                                    if (is_ntfs_dotgit(path))
                                            return PATH_INVALID;
                                    if (S_ISLNK(mode)) {
                                            if (is_ntfs_dotgitmodules(path))
                                                    return PATH_INVALID;
                                    }
                            }

                            c = *path++;
                    }
            }

            /*
            * Do we have another file that has the beginning components being a
            * proper superset of the name we're trying to add?
            */
            static int has_file_name(struct index_state *istate,
                                    const struct cache_entry *ce, int pos, int ok_to_replace)
            {
                    int retval = 0;
                    int len = ce_namelen(ce);
                    int stage = ce_stage(ce);
                    const char *name = ce->name;

                    while (pos < istate->cache_nr) {
                            struct cache_entry *p = istate->cache[pos++];

                            if (len >= ce_namelen(p))
                                    break;
                            if (memcmp(name, p->name, len))
                                    break;
                            if (ce_stage(p) != stage)
                                    continue;
                            if (p->name[len] != '/')
                                    continue;
                            if (p->ce_flags & CE_REMOVE)
                                    continue;
                            retval = -1;
                            if (!ok_to_replace)
                                    break;
                            remove_index_entry_at(istate, --pos);
                    }
                    return retval;
            }


            /*
            * Like strcmp(), but also return the offset of the first change.
            * If strings are equal, return the length.
            */
            int strcmp_offset(const char *s1, const char *s2, size_t *first_change)
            {
                    size_t k;

                    if (!first_change)
                            return strcmp(s1, s2);

                    for (k = 0; s1[k] == s2[k]; k++)
                            if (s1[k] == '\0')
                                    break;

                    *first_change = k;
                    return (unsigned char)s1[k] - (unsigned char)s2[k];
            }

            /*
            * Do we have another file with a pathname that is a proper
            * subset of the name we're trying to add?
            *
            * That is, is there another file in the index with a path
            * that matches a sub-directory in the given entry?
            */
            static int has_dir_name(struct index_state *istate,
                                    const struct cache_entry *ce, int pos, int ok_to_replace)
            {
                    int retval = 0;
                    int stage = ce_stage(ce);
                    const char *name = ce->name;
                    const char *slash = name + ce_namelen(ce);
                    size_t len_eq_last;
                    int cmp_last = 0;

                    /*
                    * We are frequently called during an iteration on a sorted
                    * list of pathnames and while building a new index.  Therefore,
                    * there is a high probability that this entry will eventually
                    * be appended to the index, rather than inserted in the middle.
                    * If we can confirm that, we can avoid binary searches on the
                    * components of the pathname.
                    *
                    * Compare the entry's full path with the last path in the index.
                    */
                    if (istate->cache_nr > 0) {
                            cmp_last = strcmp_offset(name,
                                    istate->cache[istate->cache_nr - 1]->name,
                                    &len_eq_last);
                            if (cmp_last > 0) {
                                    if (name[len_eq_last] != '/') {
                                            /*
                                            * The entry sorts AFTER the last one in the
                                            * index.
                                            *
                                            * If there were a conflict with "file", then our
                                            * name would start with "file/" and the last index
                                            * entry would start with "file" but not "file/".
                                            *
                                            * The next character after common prefix is
                                            * not '/', so there can be no conflict.
                                            */
                                            return retval;
                                    } else {
                                            /*
                                            * The entry sorts AFTER the last one in the
                                            * index, and the next character after common
                                            * prefix is '/'.
                                            *
                                            * Either the last index entry is a file in
                                            * conflict with this entry, or it has a name
                                            * which sorts between this entry and the
                                            * potential conflicting file.
                                            *
                                            * In both cases, we fall through to the loop
                                            * below and let the regular search code handle it.
                                            */
                                    }
                            } else if (cmp_last == 0) {
                                    /*
                                    * The entry exactly matches the last one in the
                                    * index, but because of multiple stage and CE_REMOVE
                                    * items, we fall through and let the regular search
                                    * code handle it.
                                    */
                            }
                    }

                    for (;;) {
                            size_t len;

                            for (;;) {
                                    if (*--slash == '/')
                                            break;
                                    if (slash <= ce->name)
                                            return retval;
                            }
                            len = slash - name;

                            pos = index_name_stage_pos(istate, name, len, stage, EXPAND_SPARSE);
                            if (pos >= 0) {
                                    /*
                                    * Found one, but not so fast.  This could
                                    * be a marker that says "I was here, but
                                    * I am being removed".  Such an entry is
                                    * not a part of the resulting tree, and
                                    * it is Ok to have a directory at the same
                                    * path.
                                    */
                                    if (!(istate->cache[pos]->ce_flags & CE_REMOVE)) {
                                            retval = -1;
                                            if (!ok_to_replace)
                                                    break;
                                            remove_index_entry_at(istate, pos);
                                            continue;
                                    }
                            }
                            else
                                    pos = -pos-1;

                            /*
                            * Trivial optimization: if we find an entry that
                            * already matches the sub-directory, then we know
                            * we're ok, and we can exit.
                            */
                            while (pos < istate->cache_nr) {
                                    struct cache_entry *p = istate->cache[pos];
                                    if ((ce_namelen(p) <= len) ||
                                    (p->name[len] != '/') ||
                                    memcmp(p->name, name, len))
                                            break; /* not our subdirectory */
                                    if (ce_stage(p) == stage && !(p->ce_flags & CE_REMOVE))
                                            /*
                                            * p is at the same stage as our entry, and
                                            * is a subdirectory of what we are looking
                                            * at, so we cannot have conflicts at our
                                            * level or anything shorter.
                                            */
                                            return retval;
                                    pos++;
                            }
                    }
                    return retval;
            }

            /* We may be in a situation where we already have path/file and path
            * is being added, or we already have path and path/file is being
            * added.  Either one would result in a nonsense tree that has path
            * twice when git-write-tree tries to write it out.  Prevent it.
            *
            * If ok-to-replace is specified, we remove the conflicting entries
            * from the cache so the caller should recompute the insert position.
            * When this happens, we return non-zero.
            */
            static int check_file_directory_conflict(struct index_state *istate,
                                                    const struct cache_entry *ce,
                                                    int pos, int ok_to_replace)
            {
                    int retval;

                    /*
                    * When ce is an "I am going away" entry, we allow it to be added
                    */
                    if (ce->ce_flags & CE_REMOVE)
                            return 0;

                    /*
                    * We check if the path is a sub-path of a subsequent pathname
                    * first, since removing those will not change the position
                    * in the array.
                    */
                    retval = has_file_name(istate, ce, pos, ok_to_replace);

                    /*
                    * Then check if the path might have a clashing sub-directory
                    * before it.
                    */
                    return retval + has_dir_name(istate, ce, pos, ok_to_replace);
            }

            static int add_index_entry_with_check(struct index_state *istate, struct cache_entry *ce, int option)
            {
                    int pos;
                    int ok_to_add = option & ADD_CACHE_OK_TO_ADD;
                    int ok_to_replace = option & ADD_CACHE_OK_TO_REPLACE;
                    int skip_df_check = option & ADD_CACHE_SKIP_DFCHECK;
                    int new_only = option & ADD_CACHE_NEW_ONLY;

                    /*
                    * If this entry's path sorts after the last entry in the index,
                    * we can avoid searching for it.
                    */
                    if (istate->cache_nr > 0 &&
                            strcmp(ce->name, istate->cache[istate->cache_nr - 1]->name) > 0)
                            pos = index_pos_to_insert_pos(istate->cache_nr);
                    else
                            pos = index_name_stage_pos(istate, ce->name, ce_namelen(ce), ce_stage(ce), EXPAND_SPARSE);

                    /*
                    * Cache tree path should be invalidated only after index_name_stage_pos,
                    * in case it expands a sparse index.
                    */
                    if (!(option & ADD_CACHE_KEEP_CACHE_TREE))
                            cache_tree_invalidate_path(istate, ce->name);

                    /* existing match? Just replace it. */
                    if (pos >= 0) {
                            if (!new_only)
                                    replace_index_entry(istate, pos, ce);
                            return 0;
                    }
                    pos = -pos-1;

                    if (!(option & ADD_CACHE_KEEP_CACHE_TREE))
                            untracked_cache_add_to_index(istate, ce->name);

                    /*
                    * Inserting a merged entry ("stage 0") into the index
                    * will always replace all non-merged entries..
                    */
                    if (pos < istate->cache_nr && ce_stage(ce) == 0) {
                            while (ce_same_name(istate->cache[pos], ce)) {
                                    ok_to_add = 1;
                                    if (!remove_index_entry_at(istate, pos))
                                            break;
                            }
                    }

                    if (!ok_to_add)
                            return -1;
                    if (verify_path_internal(ce->name, ce->ce_mode) == PATH_INVALID)
                            return error(_("invalid path '%s'"), ce->name);

                    if (!skip_df_check &&
                    check_file_directory_conflict(istate, ce, pos, ok_to_replace)) {
                            if (!ok_to_replace)
                                    return error(_("'%s' appears as both a file and as a directory"),
                                            ce->name);
                            pos = index_name_stage_pos(istate, ce->name, ce_namelen(ce), ce_stage(ce), EXPAND_SPARSE);
                            pos = -pos-1;
                    }
                    return pos + 1;
            }

            int add_index_entry(struct index_state *istate, struct cache_entry *ce, int option)
            {
                    int pos;

                    if (option & ADD_CACHE_JUST_APPEND)
                            pos = istate->cache_nr;
                    else {
                            int ret;
                            ret = add_index_entry_with_check(istate, ce, option);
                            if (ret <= 0)
                                    return ret;
                            pos = ret - 1;
                    }

                    /* Make sure the array is big enough .. */
                    ALLOC_GROW(istate->cache, istate->cache_nr + 1, istate->cache_alloc);

                    /* Add it in.. */
                    istate->cache_nr++;
                    if (istate->cache_nr > pos + 1)
                            MOVE_ARRAY(istate->cache + pos + 1, istate->cache + pos,
                                    istate->cache_nr - pos - 1);
                    set_index_entry(istate, pos, ce);
                    istate->cache_changed |= CE_ENTRY_ADDED;
                    return 0;
            }

            /*
            * "refresh" does not calculate a new sha1 file or bring the
            * cache up-to-date for mode/content changes. But what it
            * _does_ do is to "re-match" the stat information of a file
            * with the cache, so that you can refresh the cache for a
            * file that hasn't been changed but where the stat entry is
            * out of date.
            *
            * For example, you'd want to do this after doing a "git-read-tree",
            * to link up the stat cache details with the proper files.
            */
            static struct cache_entry *refresh_cache_ent(struct index_state *istate,
                                                    struct cache_entry *ce,
                                                    unsigned int options, int *err,
                                                    int *changed_ret,
                                                    int *t2_did_lstat,
                                                    int *t2_did_scan)
            {
                    struct stat st;
                    struct cache_entry *updated;
                    int changed;
                    int refresh = options & CE_MATCH_REFRESH;
                    int ignore_valid = options & CE_MATCH_IGNORE_VALID;
                    int ignore_skip_worktree = options & CE_MATCH_IGNORE_SKIP_WORKTREE;
                    int ignore_missing = options & CE_MATCH_IGNORE_MISSING;
                    int ignore_fsmonitor = options & CE_MATCH_IGNORE_FSMONITOR;

                    if (!refresh || ce_uptodate(ce))
                            return ce;

                    if (!ignore_fsmonitor)
                            refresh_fsmonitor(istate);
                    /*
                    * CE_VALID or CE_SKIP_WORKTREE means the user promised us
                    * that the change to the work tree does not matter and told
                    * us not to worry.
                    */
                    if (!ignore_skip_worktree && ce_skip_worktree(ce)) {
                            ce_mark_uptodate(ce);
                            return ce;
                    }
                    if (!ignore_valid && (ce->ce_flags & CE_VALID)) {
                            ce_mark_uptodate(ce);
                            return ce;
                    }
                    if (!ignore_fsmonitor && (ce->ce_flags & CE_FSMONITOR_VALID)) {
                            ce_mark_uptodate(ce);
                            return ce;
                    }

                    if (has_symlink_leading_path(ce->name, ce_namelen(ce))) {
                            if (ignore_missing)
                                    return ce;
                            if (err)
                                    *err = ENOENT;
                            return NULL;
                    }

                    if (t2_did_lstat)
                            *t2_did_lstat = 1;
                    if (lstat(ce->name, &st) < 0) {
                            if (ignore_missing && errno == ENOENT)
                                    return ce;
                            if (err)
                                    *err = errno;
                            return NULL;
                    }

                    changed = ie_match_stat(istate, ce, &st, options);
                    if (changed_ret)
                            *changed_ret = changed;
                    if (!changed) {
                            /*
                            * The path is unchanged.  If we were told to ignore
                            * valid bit, then we did the actual stat check and
                            * found that the entry is unmodified.  If the entry
                            * is not marked VALID, this is the place to mark it
                            * valid again, under "assume unchanged" mode.
                            */
                            if (ignore_valid && assume_unchanged &&
                            !(ce->ce_flags & CE_VALID))
                                    ; /* mark this one VALID again */
                            else {
                                    /*
                                    * We do not mark the index itself "modified"
                                    * because CE_UPTODATE flag is in-core only;
                                    * we are not going to write this change out.
                                    */
                                    if (!S_ISGITLINK(ce->ce_mode)) {
                                            ce_mark_uptodate(ce);
                                            mark_fsmonitor_valid(istate, ce);
                                    }
                                    return ce;
                            }
                    }

                    if (t2_did_scan)
                            *t2_did_scan = 1;
                    if (ie_modified(istate, ce, &st, options)) {
                            if (err)
                                    *err = EINVAL;
                            return NULL;
                    }

                    updated = make_empty_cache_entry(istate, ce_namelen(ce));
                    copy_cache_entry(updated, ce);
                    memcpy(updated->name, ce->name, ce->ce_namelen + 1);
                    fill_stat_cache_info(istate, updated, &st);
                    /*
                    * If ignore_valid is not set, we should leave CE_VALID bit
                    * alone.  Otherwise, paths marked with --no-assume-unchanged
                    * (i.e. things to be edited) will reacquire CE_VALID bit
                    * automatically, which is not really what we want.
                    */
                    if (!ignore_valid && assume_unchanged &&
                    !(ce->ce_flags & CE_VALID))
                            updated->ce_flags &= ~CE_VALID;

                    /* istate->cache_changed is updated in the caller */
                    return updated;
            }

            static void show_file(const char * fmt, const char * name, int in_porcelain,
                            int * first, const char *header_msg)
            {
                    if (in_porcelain && *first && header_msg) {
                            printf("%s\n", header_msg);
                            *first = 0;
                    }
                    printf(fmt, name);
            }

            int repo_refresh_and_write_index(struct repository *repo,
                                            unsigned int refresh_flags,
                                            unsigned int write_flags,
                                            int gentle,
                                            const struct pathspec *pathspec,
                                            char *seen, const char *header_msg)
            {
                    struct lock_file lock_file = LOCK_INIT;
                    int fd, ret = 0;

                    fd = repo_hold_locked_index(repo, &lock_file, 0);
                    if (!gentle && fd < 0)
                            return -1;
                    if (refresh_index(repo->index, refresh_flags, pathspec, seen, header_msg))
                            ret = 1;
                    if (0 <= fd && write_locked_index(repo->index, &lock_file, COMMIT_LOCK | write_flags))
                            ret = -1;
                    return ret;
            }


            int refresh_index(struct index_state *istate, unsigned int flags,
                            const struct pathspec *pathspec,
                            char *seen, const char *header_msg)
            {
                    int i;
                    int has_errors = 0;
                    int really = (flags & REFRESH_REALLY) != 0;
                    int allow_unmerged = (flags & REFRESH_UNMERGED) != 0;
                    int quiet = (flags & REFRESH_QUIET) != 0;
                    int not_new = (flags & REFRESH_IGNORE_MISSING) != 0;
                    int ignore_submodules = (flags & REFRESH_IGNORE_SUBMODULES) != 0;
                    int ignore_skip_worktree = (flags & REFRESH_IGNORE_SKIP_WORKTREE) != 0;
                    int first = 1;
                    int in_porcelain = (flags & REFRESH_IN_PORCELAIN);
                    unsigned int options = (CE_MATCH_REFRESH |
                                            (really ? CE_MATCH_IGNORE_VALID : 0) |
                                            (not_new ? CE_MATCH_IGNORE_MISSING : 0));
                    const char *modified_fmt;
                    const char *deleted_fmt;
                    const char *typechange_fmt;
                    const char *added_fmt;
                    const char *unmerged_fmt;
                    struct progress *progress = NULL;
                    int t2_sum_lstat = 0;
                    int t2_sum_scan = 0;

                    if (flags & REFRESH_PROGRESS && isatty(2))
                            progress = start_delayed_progress(_("Refresh index"),
                                                            istate->cache_nr);

                    trace_performance_enter();
                    modified_fmt   = in_porcelain ? "M\t%s\n" : "%s: needs update\n";
                    deleted_fmt    = in_porcelain ? "D\t%s\n" : "%s: needs update\n";
                    typechange_fmt = in_porcelain ? "T\t%s\n" : "%s: needs update\n";
                    added_fmt      = in_porcelain ? "A\t%s\n" : "%s: needs update\n";
                    unmerged_fmt   = in_porcelain ? "U\t%s\n" : "%s: needs merge\n";
                    /*
                    * Use the multi-threaded preload_index() to refresh most of the
                    * cache entries quickly then in the single threaded loop below,
                    * we only have to do the special cases that are left.
                    */
                    preload_index(istate, pathspec, 0);
                    trace2_region_enter("index", "refresh", NULL);

                    for (i = 0; i < istate->cache_nr; i++) {
                            struct cache_entry *ce, *new_entry;
                            int cache_errno = 0;
                            int changed = 0;
                            int filtered = 0;
                            int t2_did_lstat = 0;
                            int t2_did_scan = 0;

                            ce = istate->cache[i];
                            if (ignore_submodules && S_ISGITLINK(ce->ce_mode))
                                    continue;
                            if (ignore_skip_worktree && ce_skip_worktree(ce))
                                    continue;

                            /*
                            * If this entry is a sparse directory, then there isn't
                            * any stat() information to update. Ignore the entry.
                            */
                            if (S_ISSPARSEDIR(ce->ce_mode))
                                    continue;

                            if (pathspec && !ce_path_match(istate, ce, pathspec, seen))
                                    filtered = 1;

                            if (ce_stage(ce)) {
                                    while ((i < istate->cache_nr) &&
                                    ! strcmp(istate->cache[i]->name, ce->name))
                                            i++;
                                    i--;
                                    if (allow_unmerged)
                                            continue;
                                    if (!filtered)
                                            show_file(unmerged_fmt, ce->name, in_porcelain,
                                                    &first, header_msg);
                                    has_errors = 1;
                                    continue;
                            }

                            if (filtered)
                                    continue;

                            new_entry = refresh_cache_ent(istate, ce, options,
                                                    &cache_errno, &changed,
                                                    &t2_did_lstat, &t2_did_scan);
                            t2_sum_lstat += t2_did_lstat;
                            t2_sum_scan += t2_did_scan;
                            if (new_entry == ce)
                                    continue;
                            display_progress(progress, i);
                            if (!new_entry) {
                                    const char *fmt;

                                    if (really && cache_errno == EINVAL) {
                                            /* If we are doing --really-refresh that
                                            * means the index is not valid anymore.
                                            */
                                            ce->ce_flags &= ~CE_VALID;
                                            ce->ce_flags |= CE_UPDATE_IN_BASE;
                                            mark_fsmonitor_invalid(istate, ce);
                                            istate->cache_changed |= CE_ENTRY_CHANGED;
                                    }
                                    if (quiet)
                                            continue;

                                    if (cache_errno == ENOENT)
                                            fmt = deleted_fmt;
                                    else if (ce_intent_to_add(ce))
                                            fmt = added_fmt; /* must be before other checks */
                                    else if (changed & TYPE_CHANGED)
                                            fmt = typechange_fmt;
                                    else
                                            fmt = modified_fmt;
                                    show_file(fmt,
                                            ce->name, in_porcelain, &first, header_msg);
                                    has_errors = 1;
                                    continue;
                            }

                            replace_index_entry(istate, i, new_entry);
                    }
                    trace2_data_intmax("index", NULL, "refresh/sum_lstat", t2_sum_lstat);
                    trace2_data_intmax("index", NULL, "refresh/sum_scan", t2_sum_scan);
                    trace2_region_leave("index", "refresh", NULL);
                    display_progress(progress, istate->cache_nr);
                    stop_progress(&progress);
                    trace_performance_leave("refresh index");
                    return has_errors;
            }

            struct cache_entry *refresh_cache_entry(struct index_state *istate,
                                                    struct cache_entry *ce,
                                                    unsigned int options)
            {
                    return refresh_cache_ent(istate, ce, options, NULL, NULL, NULL, NULL);
            }


            /*****************************************************************
            * Index File I/O
            *****************************************************************/

            #define INDEX_FORMAT_DEFAULT 3

            static unsigned int get_index_format_default(struct repository *r)
            {
                    char *envversion = getenv("GIT_INDEX_VERSION");
                    char *endp;
                    unsigned int version = INDEX_FORMAT_DEFAULT;

                    if (!envversion) {
                            prepare_repo_settings(r);

                            if (r->settings.index_version >= 0)
                                    version = r->settings.index_version;
                            if (version < INDEX_FORMAT_LB || INDEX_FORMAT_UB < version) {
                                    warning(_("index.version set, but the value is invalid.\n"
                                            "Using version %i"), INDEX_FORMAT_DEFAULT);
                                    return INDEX_FORMAT_DEFAULT;
                            }
                            return version;
                    }

                    version = strtoul(envversion, &endp, 10);
                    if (*endp ||
                    version < INDEX_FORMAT_LB || INDEX_FORMAT_UB < version) {
                            warning(_("GIT_INDEX_VERSION set, but the value is invalid.\n"
                                    "Using version %i"), INDEX_FORMAT_DEFAULT);
                            version = INDEX_FORMAT_DEFAULT;
                    }
                    return version;
            }

            /*
            * dev/ino/uid/gid/size are also just tracked to the low 32 bits
            * Again - this is just a (very strong in practice) heuristic that
            * the inode hasn't changed.
            *
            * We save the fields in big-endian order to allow using the
            * index file over NFS transparently.
            */
            struct ondisk_cache_entry {
                    struct cache_time ctime;
                    struct cache_time mtime;
                    uint32_t dev;
                    uint32_t ino;
                    uint32_t mode;
                    uint32_t uid;
                    uint32_t gid;
                    uint32_t size;
                    /*
                    * unsigned char hash[hashsz];
                    * uint16_t flags;
                    * if (flags & CE_EXTENDED)
                    *      uint16_t flags2;
                    */
                    unsigned char data[GIT_MAX_RAWSZ + 2 * sizeof(uint16_t)];
                    char name[FLEX_ARRAY];
            };

            /* These are only used for v3 or lower */
            #define align_padding_size(size, len) ((size + (len) + 8) & ~7) - (size + len)
            #define align_flex_name(STRUCT,len) ((offsetof(struct STRUCT,data) + (len) + 8) & ~7)
            #define ondisk_cache_entry_size(len) align_flex_name(ondisk_cache_entry,len)
            #define ondisk_data_size(flags, len) (the_hash_algo->rawsz + \
                                            ((flags & CE_EXTENDED) ? 2 : 1) * sizeof(uint16_t) + len)
            #define ondisk_data_size_max(len) (ondisk_data_size(CE_EXTENDED, len))
            #define ondisk_ce_size(ce) (ondisk_cache_entry_size(ondisk_data_size((ce)->ce_flags, ce_namelen(ce))))

            /* Allow fsck to force verification of the index checksum. */
            int verify_index_checksum;

            /* Allow fsck to force verification of the cache entry order. */
            int verify_ce_order;

            static int verify_hdr(const struct cache_header *hdr, unsigned long size)
            {
                    git_hash_ctx c;
                    unsigned char hash[GIT_MAX_RAWSZ];
                    int hdr_version;
                    unsigned char *start, *end;
                    struct object_id oid;

                    if (hdr->hdr_signature != htonl(CACHE_SIGNATURE))
                            return error(_("bad signature 0x%08x"), hdr->hdr_signature);
                    hdr_version = ntohl(hdr->hdr_version);
                    if (hdr_version < INDEX_FORMAT_LB || INDEX_FORMAT_UB < hdr_version)
                            return error(_("bad index version %d"), hdr_version);

                    if (!verify_index_checksum)
                            return 0;

                    end = (unsigned char *)hdr + size;
                    start = end - the_hash_algo->rawsz;
                    oidread(&oid, start, the_repository->hash_algo);
                    if (oideq(&oid, null_oid()))
                            return 0;

                    the_hash_algo->init_fn(&c);
                    the_hash_algo->update_fn(&c, hdr, size - the_hash_algo->rawsz);
                    the_hash_algo->final_fn(hash, &c);
                    if (!hasheq(hash, start, the_repository->hash_algo))
                            return error(_("bad index file sha1 signature"));
                    return 0;
            }

            static int read_index_extension(struct index_state *istate,
                                            const char *ext, const char *data, unsigned long sz)
            {
                    switch (CACHE_EXT(ext)) {
                    case CACHE_EXT_TREE:
                            istate->cache_tree = cache_tree_read(data, sz);
                            break;
                    case CACHE_EXT_RESOLVE_UNDO:
                            istate->resolve_undo = resolve_undo_read(data, sz);
                            break;
                    case CACHE_EXT_LINK:
                            if (read_link_extension(istate, data, sz))
                                    return -1;
                            break;
                    case CACHE_EXT_UNTRACKED:
                            istate->untracked = read_untracked_extension(data, sz);
                            break;
                    case CACHE_EXT_FSMONITOR:
                            read_fsmonitor_extension(istate, data, sz);
                            break;
                    case CACHE_EXT_ENDOFINDEXENTRIES:
                    case CACHE_EXT_INDEXENTRYOFFSETTABLE:
                            /* already handled in do_read_index() */
                            break;
                    case CACHE_EXT_SPARSE_DIRECTORIES:
                            /* no content, only an indicator */
                            istate->sparse_index = INDEX_COLLAPSED;
                            break;
                    default:
                            if (*ext < 'A' || 'Z' < *ext)
                                    return error(_("index uses %.4s extension, which we do not understand"),
                                            ext);
                            fprintf_ln(stderr, _("ignoring %.4s extension"), ext);
                            break;
                    }
                    return 0;
            }

            /*
            * Parses the contents of the cache entry contained within the 'ondisk' buffer
            * into a new incore 'cache_entry'.
            *
            * Note that 'char *ondisk' may not be aligned to a 4-byte address interval in
            * index v4, so we cannot cast it to 'struct ondisk_cache_entry *' and access
            * its members. Instead, we use the byte offsets of members within the struct to
            * identify where 'get_be16()', 'get_be32()', and 'oidread()' (which can all
            * read from an unaligned memory buffer) should read from the 'ondisk' buffer
            * into the corresponding incore 'cache_entry' members.
            */
            static struct cache_entry *create_from_disk(struct mem_pool *ce_mem_pool,
                                                    unsigned int version,
                                                    const char *ondisk,
                                                    unsigned long *ent_size,
                                                    const struct cache_entry *previous_ce)
            {
                    struct cache_entry *ce;
                    size_t len;
                    const char *name;
                    const unsigned hashsz = the_hash_algo->rawsz;
                    const char *flagsp = ondisk + offsetof(struct ondisk_cache_entry, data) + hashsz;
                    unsigned int flags;
                    size_t copy_len = 0;
                    /*
                    * Adjacent cache entries tend to share the leading paths, so it makes
                    * sense to only store the differences in later entries.  In the v4
                    * on-disk format of the index, each on-disk cache entry stores the
                    * number of bytes to be stripped from the end of the previous name,
                    * and the bytes to append to the result, to come up with its name.
                    */
                    int expand_name_field = version == 4;

                    /* On-disk flags are just 16 bits */
                    flags = get_be16(flagsp);
                    len = flags & CE_NAMEMASK;

                    if (flags & CE_EXTENDED) {
                            int extended_flags;
                            extended_flags = get_be16(flagsp + sizeof(uint16_t)) << 16;
                            /* We do not yet understand any bit out of CE_EXTENDED_FLAGS */
                            if (extended_flags & ~CE_EXTENDED_FLAGS)
                                    die(_("unknown index entry format 0x%08x"), extended_flags);
                            flags |= extended_flags;
                            name = (const char *)(flagsp + 2 * sizeof(uint16_t));
                    }
                    else
                            name = (const char *)(flagsp + sizeof(uint16_t));

                    if (expand_name_field) {
                            const unsigned char *cp = (const unsigned char *)name;
                            size_t strip_len, previous_len;

                            /* If we're at the beginning of a block, ignore the previous name */
                            strip_len = decode_varint(&cp);
                            if (previous_ce) {
                                    previous_len = previous_ce->ce_namelen;
                                    if (previous_len < strip_len)
                                            die(_("malformed name field in the index, near path '%s'"),
                                                    previous_ce->name);
                                    copy_len = previous_len - strip_len;
                            }
                            name = (const char *)cp;
                    }

                    if (len == CE_NAMEMASK) {
                            len = strlen(name);
                            if (expand_name_field)
                                    len += copy_len;
                    }

                    ce = mem_pool__ce_alloc(ce_mem_pool, len);

                    /*
                    * NEEDSWORK: using 'offsetof()' is cumbersome and should be replaced
                    * with something more akin to 'load_bitmap_entries_v1()'s use of
                    * 'read_be16'/'read_be32'. For consistency with the corresponding
                    * ondisk entry write function ('copy_cache_entry_to_ondisk()'), this
                    * should be done at the same time as removing references to
                    * 'ondisk_cache_entry' there.
                    */
                    ce->ce_stat_data.sd_ctime.sec = get_be32(ondisk + offsetof(struct ondisk_cache_entry, ctime)
                                                                    + offsetof(struct cache_time, sec));
                    ce->ce_stat_data.sd_mtime.sec = get_be32(ondisk + offsetof(struct ondisk_cache_entry, mtime)
                                                                    + offsetof(struct cache_time, sec));
                    ce->ce_stat_data.sd_ctime.nsec = get_be32(ondisk + offsetof(struct ondisk_cache_entry, ctime)
                                                                    + offsetof(struct cache_time, nsec));
                    ce->ce_stat_data.sd_mtime.nsec = get_be32(ondisk + offsetof(struct ondisk_cache_entry, mtime)
                                                                    + offsetof(struct cache_time, nsec));
                    ce->ce_stat_data.sd_dev   = get_be32(ondisk + offsetof(struct ondisk_cache_entry, dev));
                    ce->ce_stat_data.sd_ino   = get_be32(ondisk + offsetof(struct ondisk_cache_entry, ino));
                    ce->ce_mode  = get_be32(ondisk + offsetof(struct ondisk_cache_entry, mode));
                    ce->ce_stat_data.sd_uid   = get_be32(ondisk + offsetof(struct ondisk_cache_entry, uid));
                    ce->ce_stat_data.sd_gid   = get_be32(ondisk + offsetof(struct ondisk_cache_entry, gid));
                    ce->ce_stat_data.sd_size  = get_be32(ondisk + offsetof(struct ondisk_cache_entry, size));
                    ce->ce_flags = flags & ~CE_NAMEMASK;
                    ce->ce_namelen = len;
                    ce->index = 0;
                    oidread(&ce->oid, (const unsigned char *)ondisk + offsetof(struct ondisk_cache_entry, data),
                            the_repository->hash_algo);

                    if (expand_name_field) {
                            if (copy_len)
                                    memcpy(ce->name, previous_ce->name, copy_len);
                            memcpy(ce->name + copy_len, name, len + 1 - copy_len);
                            *ent_size = (name - ((char *)ondisk)) + len + 1 - copy_len;
                    } else {
                            memcpy(ce->name, name, len + 1);
                            *ent_size = ondisk_ce_size(ce);
                    }
                    return ce;
            }

            static void check_ce_order(struct index_state *istate)
            {
                    unsigned int i;

                    if (!verify_ce_order)
                            return;

                    for (i = 1; i < istate->cache_nr; i++) {
                            struct cache_entry *ce = istate->cache[i - 1];
                            struct cache_entry *next_ce = istate->cache[i];
                            int name_compare = strcmp(ce->name, next_ce->name);

                            if (0 < name_compare)
                                    die(_("unordered stage entries in index"));
                            if (!name_compare) {
                                    if (!ce_stage(ce))
                                            die(_("multiple stage entries for merged file '%s'"),
                                            ce->name);
                                    if (ce_stage(ce) > ce_stage(next_ce))
                                            die(_("unordered stage entries for '%s'"),
                                            ce->name);
                            }
                    }
            }

            static void tweak_untracked_cache(struct index_state *istate)
            {
                    struct repository *r = the_repository;

                    prepare_repo_settings(r);

                    switch (r->settings.core_untracked_cache) {
                    case UNTRACKED_CACHE_REMOVE:
                            remove_untracked_cache(istate);
                            break;
                    case UNTRACKED_CACHE_WRITE:
                            add_untracked_cache(istate);
                            break;
                    case UNTRACKED_CACHE_KEEP:
                            /*
                            * Either an explicit "core.untrackedCache=keep", the
                            * default if "core.untrackedCache" isn't configured,
                            * or a fallback on an unknown "core.untrackedCache"
                            * value.
                            */
                            break;
                    }
            }

            static void tweak_split_index(struct index_state *istate)
            {
                    switch (repo_config_get_split_index(the_repository)) {
                    case -1: /* unset: do nothing */
                            break;
                    case 0: /* false */
                            remove_split_index(istate);
                            break;
                    case 1: /* true */
                            add_split_index(istate);
                            break;
                    default: /* unknown value: do nothing */
                            break;
                    }
            }

            static void post_read_index_from(struct index_state *istate)
            {
                    check_ce_order(istate);
                    tweak_untracked_cache(istate);
                    tweak_split_index(istate);
                    tweak_fsmonitor(istate);
            }

            static size_t estimate_cache_size_from_compressed(unsigned int entries)
            {
                    return entries * (sizeof(struct cache_entry) + CACHE_ENTRY_PATH_LENGTH);
            }

            static size_t estimate_cache_size(size_t ondisk_size, unsigned int entries)
            {
                    long per_entry = sizeof(struct cache_entry) - sizeof(struct ondisk_cache_entry);

                    /*
                    * Account for potential alignment differences.
                    */
                    per_entry += align_padding_size(per_entry, 0);
                    return ondisk_size + entries * per_entry;
            }

            struct index_entry_offset
            {
                    /* starting byte offset into index file, count of index entries in this block */
                    int offset, nr;
            };

            struct index_entry_offset_table
            {
                    int nr;
                    struct index_entry_offset entries[FLEX_ARRAY];
            };

            static struct index_entry_offset_table *read_ieot_extension(const char *mmap, size_t mmap_size, size_t offset);
            static void write_ieot_extension(struct strbuf *sb, struct index_entry_offset_table *ieot);

            static size_t read_eoie_extension(const char *mmap, size_t mmap_size);
            static void write_eoie_extension(struct strbuf *sb, git_hash_ctx *eoie_context, size_t offset);

            struct load_index_extensions
            {
                    pthread_t pthread;
                    struct index_state *istate;
                    const char *mmap;
                    size_t mmap_size;
                    unsigned long src_offset;
            };

            static void *load_index_extensions(void *_data)
            {
                    struct load_index_extensions *p = _data;
                    unsigned long src_offset = p->src_offset;

                    while (src_offset <= p->mmap_size - the_hash_algo->rawsz - 8) {
                            /* After an array of active_nr index entries,
                            * there can be arbitrary number of extended
                            * sections, each of which is prefixed with
                            * extension name (4-byte) and section length
                            * in 4-byte network byte order.
                            */
                            uint32_t extsize = get_be32(p->mmap + src_offset + 4);
                            if (read_index_extension(p->istate,
                                                    p->mmap + src_offset,
                                                    p->mmap + src_offset + 8,
                                                    extsize) < 0) {
                                    munmap((void *)p->mmap, p->mmap_size);
                                    die(_("index file corrupt"));
                            }
                            src_offset += 8;
                            src_offset += extsize;
                    }

                    return NULL;
            }

            /*
            * A helper function that will load the specified range of cache entries
            * from the memory mapped file and add them to the given index.
            */
            static unsigned long load_cache_entry_block(struct index_state *istate,
                                    struct mem_pool *ce_mem_pool, int offset, int nr, const char *mmap,
                                    unsigned long start_offset, const struct cache_entry *previous_ce)
            {
                    int i;
                    unsigned long src_offset = start_offset;

                    for (i = offset; i < offset + nr; i++) {
                            struct cache_entry *ce;
                            unsigned long consumed;

                            ce = create_from_disk(ce_mem_pool, istate->version,
                                            mmap + src_offset,
                                            &consumed, previous_ce);
                            set_index_entry(istate, i, ce);

                            src_offset += consumed;
                            previous_ce = ce;
                    }
                    return src_offset - start_offset;
            }

            static unsigned long load_all_cache_entries(struct index_state *istate,
                                    const char *mmap, size_t mmap_size, unsigned long src_offset)
            {
                    unsigned long consumed;

                    istate->ce_mem_pool = xmalloc(sizeof(*istate->ce_mem_pool));
                    if (istate->version == 4) {
                            mem_pool_init(istate->ce_mem_pool,
                                            estimate_cache_size_from_compressed(istate->cache_nr));
                    } else {
                            mem_pool_init(istate->ce_mem_pool,
                                            estimate_cache_size(mmap_size, istate->cache_nr));
                    }

                    consumed = load_cache_entry_block(istate, istate->ce_mem_pool,
                                                    0, istate->cache_nr, mmap, src_offset, NULL);
                    return consumed;
            }

            /*
            * Mostly randomly chosen maximum thread counts: we
            * cap the parallelism to online_cpus() threads, and we want
            * to have at least 10000 cache entries per thread for it to
            * be worth starting a thread.
            */

            #define THREAD_COST             (10000)

            struct load_cache_entries_thread_data
            {
                    pthread_t pthread;
                    struct index_state *istate;
                    struct mem_pool *ce_mem_pool;
                    int offset;
                    const char *mmap;
                    struct index_entry_offset_table *ieot;
                    int ieot_start;         /* starting index into the ieot array */
                    int ieot_blocks;        /* count of ieot entries to process */
                    unsigned long consumed; /* return # of bytes in index file processed */
            };

            /*
            * A thread proc to run the load_cache_entries() computation
            * across multiple background threads.
            */
            static void *load_cache_entries_thread(void *_data)
            {
                    struct load_cache_entries_thread_data *p = _data;
                    int i;

                    /* iterate across all ieot blocks assigned to this thread */
                    for (i = p->ieot_start; i < p->ieot_start + p->ieot_blocks; i++) {
                            p->consumed += load_cache_entry_block(p->istate, p->ce_mem_pool,
                                    p->offset, p->ieot->entries[i].nr, p->mmap, p->ieot->entries[i].offset, NULL);
                            p->offset += p->ieot->entries[i].nr;
                    }
                    return NULL;
            }

            static unsigned long load_cache_entries_threaded(struct index_state *istate, const char *mmap, size_t mmap_size,
                                                            int nr_threads, struct index_entry_offset_table *ieot)
            {
                    int i, offset, ieot_blocks, ieot_start, err;
                    struct load_cache_entries_thread_data *data;
                    unsigned long consumed = 0;

                    /* a little sanity checking */
                    if (istate->name_hash_initialized)
                            BUG("the name hash isn't thread safe");

                    istate->ce_mem_pool = xmalloc(sizeof(*istate->ce_mem_pool));
                    mem_pool_init(istate->ce_mem_pool, 0);

                    /* ensure we have no more threads than we have blocks to process */
                    if (nr_threads > ieot->nr)
                            nr_threads = ieot->nr;
                    CALLOC_ARRAY(data, nr_threads);

                    offset = ieot_start = 0;
                    ieot_blocks = DIV_ROUND_UP(ieot->nr, nr_threads);
                    for (i = 0; i < nr_threads; i++) {
                            struct load_cache_entries_thread_data *p = &data[i];
                            int nr, j;

                            if (ieot_start + ieot_blocks > ieot->nr)
                                    ieot_blocks = ieot->nr - ieot_start;

                            p->istate = istate;
                            p->offset = offset;
                            p->mmap = mmap;
                            p->ieot = ieot;
                            p->ieot_start = ieot_start;
                            p->ieot_blocks = ieot_blocks;

                            /* create a mem_pool for each thread */
                            nr = 0;
                            for (j = p->ieot_start; j < p->ieot_start + p->ieot_blocks; j++)
                                    nr += p->ieot->entries[j].nr;
                            p->ce_mem_pool = xmalloc(sizeof(*istate->ce_mem_pool));
                            if (istate->version == 4) {
                                    mem_pool_init(p->ce_mem_pool,
                                            estimate_cache_size_from_compressed(nr));
                            } else {
                                    mem_pool_init(p->ce_mem_pool,
                                            estimate_cache_size(mmap_size, nr));
                            }

                            err = pthread_create(&p->pthread, NULL, load_cache_entries_thread, p);
                            if (err)
                                    die(_("unable to create load_cache_entries thread: %s"), strerror(err));

                            /* increment by the number of cache entries in the ieot block being processed */
                            for (j = 0; j < ieot_blocks; j++)
                                    offset += ieot->entries[ieot_start + j].nr;
                            ieot_start += ieot_blocks;
                    }

                    for (i = 0; i < nr_threads; i++) {
                            struct load_cache_entries_thread_data *p = &data[i];

                            err = pthread_join(p->pthread, NULL);
                            if (err)
                                    die(_("unable to join load_cache_entries thread: %s"), strerror(err));
                            mem_pool_combine(istate->ce_mem_pool, p->ce_mem_pool);
                            free(p->ce_mem_pool);
                            consumed += p->consumed;
                    }

                    free(data);

                    return consumed;
            }

            static void set_new_index_sparsity(struct index_state *istate)
            {
                    /*
                    * If the index's repo exists, mark it sparse according to
                    * repo settings.
                    */
                    prepare_repo_settings(istate->repo);
                    if (!istate->repo->settings.command_requires_full_index &&
                    is_sparse_index_allowed(istate, 0))
                            istate->sparse_index = 1;
            }

            /* remember to discard_cache() before reading a different cache! */
            int do_read_index(struct index_state *istate, const char *path, int must_exist)
            {
                    int fd;
                    struct stat st;
                    unsigned long src_offset;
                    const struct cache_header *hdr;
                    const char *mmap;
                    size_t mmap_size;
                    struct load_index_extensions p;
                    size_t extension_offset = 0;
                    int nr_threads, cpus;
                    struct index_entry_offset_table *ieot = NULL;

                    if (istate->initialized)
                            return istate->cache_nr;

                    istate->timestamp.sec = 0;
                    istate->timestamp.nsec = 0;
                    fd = open(path, O_RDONLY);
                    if (fd < 0) {
                            if (!must_exist && errno == ENOENT) {
                                    set_new_index_sparsity(istate);
                                    istate->initialized = 1;
                                    return 0;
                            }
                            die_errno(_("%s: index file open failed"), path);
                    }

                    if (fstat(fd, &st))
                            die_errno(_("%s: cannot stat the open index"), path);

                    mmap_size = xsize_t(st.st_size);
                    if (mmap_size < sizeof(struct cache_header) + the_hash_algo->rawsz)
                            die(_("%s: index file smaller than expected"), path);

                    mmap = xmmap_gently(NULL, mmap_size, PROT_READ, MAP_PRIVATE, fd, 0);
                    if (mmap == MAP_FAILED)
                            die_errno(_("%s: unable to map index file%s"), path,
                                    mmap_os_err());
                    close(fd);

                    hdr = (const struct cache_header *)mmap;
                    if (verify_hdr(hdr, mmap_size) < 0)
                            goto unmap;

                    oidread(&istate->oid, (const unsigned char *)hdr + mmap_size - the_hash_algo->rawsz,
                            the_repository->hash_algo);
                    istate->version = ntohl(hdr->hdr_version);
                    istate->cache_nr = ntohl(hdr->hdr_entries);
                    istate->cache_alloc = alloc_nr(istate->cache_nr);
                    CALLOC_ARRAY(istate->cache, istate->cache_alloc);
                    istate->initialized = 1;

                    p.istate = istate;
                    p.mmap = mmap;
                    p.mmap_size = mmap_size;

                    src_offset = sizeof(*hdr);

                    if (repo_config_get_index_threads(the_repository, &nr_threads))
                            nr_threads = 1;

                    /* TODO: does creating more threads than cores help? */
                    if (!nr_threads) {
                            nr_threads = istate->cache_nr / THREAD_COST;
                            cpus = online_cpus();
                            if (nr_threads > cpus)
                                    nr_threads = cpus;
                    }

                    if (!HAVE_THREADS)
                            nr_threads = 1;

                    if (nr_threads > 1) {
                            extension_offset = read_eoie_extension(mmap, mmap_size);
                            if (extension_offset) {
                                    int err;

                                    p.src_offset = extension_offset;
                                    err = pthread_create(&p.pthread, NULL, load_index_extensions, &p);
                                    if (err)
                                            die(_("unable to create load_index_extensions thread: %s"), strerror(err));

                                    nr_threads--;
                            }
                    }

                    /*
                    * Locate and read the index entry offset table so that we can use it
                    * to multi-thread the reading of the cache entries.
                    */
                    if (extension_offset && nr_threads > 1)
                            ieot = read_ieot_extension(mmap, mmap_size, extension_offset);

                    if (ieot) {
                            src_offset += load_cache_entries_threaded(istate, mmap, mmap_size, nr_threads, ieot);
                            free(ieot);
                    } else {
                            src_offset += load_all_cache_entries(istate, mmap, mmap_size, src_offset);
                    }

                    istate->timestamp.sec = st.st_mtime;
                    istate->timestamp.nsec = ST_MTIME_NSEC(st);

                    /* if we created a thread, join it otherwise load the extensions on the primary thread */
                    if (extension_offset) {
                            int ret = pthread_join(p.pthread, NULL);
                            if (ret)
                                    die(_("unable to join load_index_extensions thread: %s"), strerror(ret));
                    } else {
                            p.src_offset = src_offset;
                            load_index_extensions(&p);
                    }
                    munmap((void *)mmap, mmap_size);

                    /*
                    * TODO trace2: replace "the_repository" with the actual repo instance
                    * that is associated with the given "istate".
                    */
                    trace2_data_intmax("index", the_repository, "read/version",
                                    istate->version);
                    trace2_data_intmax("index", the_repository, "read/cache_nr",
                                    istate->cache_nr);

                    /*
                    * If the command explicitly requires a full index, force it
                    * to be full. Otherwise, correct the sparsity based on repository
                    * settings and other properties of the index (if necessary).
                    */
                    prepare_repo_settings(istate->repo);
                    if (istate->repo->settings.command_requires_full_index)
                            ensure_full_index(istate);
                    else
                            ensure_correct_sparsity(istate);

                    return istate->cache_nr;

            unmap:
                    munmap((void *)mmap, mmap_size);
                    die(_("index file corrupt"));
            }

            /*
            * Signal that the shared index is used by updating its mtime.
            *
            * This way, shared index can be removed if they have not been used
            * for some time.
            */
            static void freshen_shared_index(const char *shared_index, int warn)
            {
                    if (!check_and_freshen_file(shared_index, 1) && warn)
                            warning(_("could not freshen shared index '%s'"), shared_index);
            }

            int read_index_from(struct index_state *istate, const char *path,
                            const char *gitdir)
            {
                    struct split_index *split_index;
                    int ret;
                    char *base_oid_hex;
                    char *base_path;

                    /* istate->initialized covers both .git/index and .git/sharedindex.xxx */
                    if (istate->initialized)
                            return istate->cache_nr;

                    /*
                    * TODO trace2: replace "the_repository" with the actual repo instance
                    * that is associated with the given "istate".
                    */
                    trace2_region_enter_printf("index", "do_read_index", the_repository,
                                            "%s", path);
                    trace_performance_enter();
                    ret = do_read_index(istate, path, 0);
                    trace_performance_leave("read cache %s", path);
                    trace2_region_leave_printf("index", "do_read_index", the_repository,
                                            "%s", path);

                    split_index = istate->split_index;
                    if (!split_index || is_null_oid(&split_index->base_oid)) {
                            post_read_index_from(istate);
                            return ret;
                    }

                    trace_performance_enter();
                    if (split_index->base)
                            release_index(split_index->base);
                    else
                            ALLOC_ARRAY(split_index->base, 1);
                    index_state_init(split_index->base, istate->repo);

                    base_oid_hex = oid_to_hex(&split_index->base_oid);
                    base_path = xstrfmt("%s/sharedindex.%s", gitdir, base_oid_hex);
                    if (file_exists(base_path)) {
                            trace2_region_enter_printf("index", "shared/do_read_index",
                                                    the_repository, "%s", base_path);

                            ret = do_read_index(split_index->base, base_path, 0);
                            trace2_region_leave_printf("index", "shared/do_read_index",
                                                    the_repository, "%s", base_path);
                    } else {
                            char *path_copy = xstrdup(path);
                            char *base_path2 = xstrfmt("%s/sharedindex.%s",
                                                    dirname(path_copy), base_oid_hex);
                            free(path_copy);
                            trace2_region_enter_printf("index", "shared/do_read_index",
                                                    the_repository, "%s", base_path2);
                            ret = do_read_index(split_index->base, base_path2, 1);
                            trace2_region_leave_printf("index", "shared/do_read_index",
                                                    the_repository, "%s", base_path2);
                            free(base_path2);
                    }
                    if (!oideq(&split_index->base_oid, &split_index->base->oid))
                            die(_("broken index, expect %s in %s, got %s"),
                            base_oid_hex, base_path,
                            oid_to_hex(&split_index->base->oid));

                    freshen_shared_index(base_path, 0);
                    merge_base_index(istate);
                    post_read_index_from(istate);
                    trace_performance_leave("read cache %s", base_path);
                    free(base_path);
                    return ret;
            }

            int is_index_unborn(struct index_state *istate)
            {
                    return (!istate->cache_nr && !istate->timestamp.sec);
            }

            void index_state_init(struct index_state *istate, struct repository *r)
            {
                    struct index_state blank = INDEX_STATE_INIT(r);
                    memcpy(istate, &blank, sizeof(*istate));
            }

            void release_index(struct index_state *istate)
            {
                    /*
                    * Cache entries in istate->cache[] should have been allocated
                    * from the memory pool associated with this index, or from an
                    * associated split_index. There is no need to free individual
                    * cache entries. validate_cache_entries can detect when this
                    * assertion does not hold.
                    */
                    validate_cache_entries(istate);

                    resolve_undo_clear_index(istate);
                    free_name_hash(istate);
                    cache_tree_free(&(istate->cache_tree));
                    free(istate->fsmonitor_last_update);
                    free(istate->cache);
                    discard_split_index(istate);
                    free_untracked_cache(istate->untracked);

                    if (istate->sparse_checkout_patterns) {
                            clear_pattern_list(istate->sparse_checkout_patterns);
                            FREE_AND_NULL(istate->sparse_checkout_patterns);
                    }

                    if (istate->ce_mem_pool) {
                            mem_pool_discard(istate->ce_mem_pool, should_validate_cache_entries());
                            FREE_AND_NULL(istate->ce_mem_pool);
                    }
            }

            void discard_index(struct index_state *istate)
            {
                    release_index(istate);
                    index_state_init(istate, istate->repo);
            }

            /*
            * Validate the cache entries of this index.
            * All cache entries associated with this index
            * should have been allocated by the memory pool
            * associated with this index, or by a referenced
            * split index.
            */
            void validate_cache_entries(const struct index_state *istate)
            {
                    int i;

                    if (!should_validate_cache_entries() ||!istate || !istate->initialized)
                            return;

                    for (i = 0; i < istate->cache_nr; i++) {
                            if (!istate) {
                                    BUG("cache entry is not allocated from expected memory pool");
                            } else if (!istate->ce_mem_pool ||
                                    !mem_pool_contains(istate->ce_mem_pool, istate->cache[i])) {
                                    if (!istate->split_index ||
                                            !istate->split_index->base ||
                                            !istate->split_index->base->ce_mem_pool ||
                                            !mem_pool_contains(istate->split_index->base->ce_mem_pool, istate->cache[i])) {
                                            BUG("cache entry is not allocated from expected memory pool");
                                    }
                            }
                    }

                    if (istate->split_index)
                            validate_cache_entries(istate->split_index->base);
            }

            int unmerged_index(const struct index_state *istate)
            {
                    int i;
                    for (i = 0; i < istate->cache_nr; i++) {
                            if (ce_stage(istate->cache[i]))
                                    return 1;
                    }
                    return 0;
            }

            int repo_index_has_changes(struct repository *repo,
                                    struct tree *tree,
                                    struct strbuf *sb)
            {
                    struct index_state *istate = repo->index;
                    struct object_id cmp;
                    int i;

                    if (tree)
                            cmp = tree->object.oid;
                    if (tree || !repo_get_oid_tree(repo, "HEAD", &cmp)) {
                            struct diff_options opt;

                            repo_diff_setup(repo, &opt);
                            opt.flags.exit_with_status = 1;
                            if (!sb)
                                    opt.flags.quick = 1;
                            diff_setup_done(&opt);
                            do_diff_cache(&cmp, &opt);
                            diffcore_std(&opt);
                            for (i = 0; sb && i < diff_queued_diff.nr; i++) {
                                    if (i)
                                            strbuf_addch(sb, ' ');
                                    strbuf_addstr(sb, diff_queued_diff.queue[i]->two->path);
                            }
                            diff_flush(&opt);
                            return opt.flags.has_changes != 0;
                    } else {
                            /* TODO: audit for interaction with sparse-index. */
                            ensure_full_index(istate);
                            for (i = 0; sb && i < istate->cache_nr; i++) {
                                    if (i)
                                            strbuf_addch(sb, ' ');
                                    strbuf_addstr(sb, istate->cache[i]->name);
                            }
                            return !!istate->cache_nr;
                    }
            }

            static int write_index_ext_header(struct hashfile *f,
                                            git_hash_ctx *eoie_f,
                                            unsigned int ext,
                                            unsigned int sz)
            {
                    hashwrite_be32(f, ext);
                    hashwrite_be32(f, sz);

                    if (eoie_f) {
                            ext = htonl(ext);
                            sz = htonl(sz);
                            the_hash_algo->update_fn(eoie_f, &ext, sizeof(ext));
                            the_hash_algo->update_fn(eoie_f, &sz, sizeof(sz));
                    }
                    return 0;
            }

            static void ce_smudge_racily_clean_entry(struct index_state *istate,
                                                    struct cache_entry *ce)
            {
                    /*
                    * The only thing we care about in this function is to smudge the
                    * falsely clean entry due to touch-update-touch race, so we leave
                    * everything else as they are.  We are called for entries whose
                    * ce_stat_data.sd_mtime match the index file mtime.
                    *
                    * Note that this actually does not do much for gitlinks, for
                    * which ce_match_stat_basic() always goes to the actual
                    * contents.  The caller checks with is_racy_timestamp() which
                    * always says "no" for gitlinks, so we are not called for them ;-)
                    */
                    struct stat st;

                    if (lstat(ce->name, &st) < 0)
                            return;
                    if (ce_match_stat_basic(ce, &st))
                            return;
                    if (ce_modified_check_fs(istate, ce, &st)) {
                            /* This is "racily clean"; smudge it.  Note that this
                            * is a tricky code.  At first glance, it may appear
                            * that it can break with this sequence:
                            *
                            * $ echo xyzzy >frotz
                            * $ git-update-index --add frotz
                            * $ : >frotz
                            * $ sleep 3
                            * $ echo filfre >nitfol
                            * $ git-update-index --add nitfol
                            *
                            * but it does not.  When the second update-index runs,
                            * it notices that the entry "frotz" has the same timestamp
                            * as index, and if we were to smudge it by resetting its
                            * size to zero here, then the object name recorded
                            * in index is the 6-byte file but the cached stat information
                            * becomes zero --- which would then match what we would
                            * obtain from the filesystem next time we stat("frotz").
                            *
                            * However, the second update-index, before calling
                            * this function, notices that the cached size is 6
                            * bytes and what is on the filesystem is an empty
                            * file, and never calls us, so the cached size information
                            * for "frotz" stays 6 which does not match the filesystem.
                            */
                            ce->ce_stat_data.sd_size = 0;
                    }
            }

            /* Copy miscellaneous fields but not the name */
            static void copy_cache_entry_to_ondisk(struct ondisk_cache_entry *ondisk,
                                            struct cache_entry *ce)
            {
                    short flags;
                    const unsigned hashsz = the_hash_algo->rawsz;
                    uint16_t *flagsp = (uint16_t *)(ondisk->data + hashsz);

                    ondisk->ctime.sec = htonl(ce->ce_stat_data.sd_ctime.sec);
                    ondisk->mtime.sec = htonl(ce->ce_stat_data.sd_mtime.sec);
                    ondisk->ctime.nsec = htonl(ce->ce_stat_data.sd_ctime.nsec);
                    ondisk->mtime.nsec = htonl(ce->ce_stat_data.sd_mtime.nsec);
                    ondisk->dev  = htonl(ce->ce_stat_data.sd_dev);
                    ondisk->ino  = htonl(ce->ce_stat_data.sd_ino);
                    ondisk->mode = htonl(ce->ce_mode);
                    ondisk->uid  = htonl(ce->ce_stat_data.sd_uid);
                    ondisk->gid  = htonl(ce->ce_stat_data.sd_gid);
                    ondisk->size = htonl(ce->ce_stat_data.sd_size);
                    hashcpy(ondisk->data, ce->oid.hash, the_repository->hash_algo);

                    flags = ce->ce_flags & ~CE_NAMEMASK;
                    flags |= (ce_namelen(ce) >= CE_NAMEMASK ? CE_NAMEMASK : ce_namelen(ce));
                    flagsp[0] = htons(flags);
                    if (ce->ce_flags & CE_EXTENDED) {
                            flagsp[1] = htons((ce->ce_flags & CE_EXTENDED_FLAGS) >> 16);
                    }
            }

            static int ce_write_entry(struct hashfile *f, struct cache_entry *ce,
                                    struct strbuf *previous_name, struct ondisk_cache_entry *ondisk)
            {
                    int size;
                    unsigned int saved_namelen;
                    int stripped_name = 0;
                    static unsigned char padding[8] = { 0x00 };

                    if (ce->ce_flags & CE_STRIP_NAME) {
                            saved_namelen = ce_namelen(ce);
                            ce->ce_namelen = 0;
                            stripped_name = 1;
                    }

                    size = offsetof(struct ondisk_cache_entry,data) + ondisk_data_size(ce->ce_flags, 0);

                    if (!previous_name) {
                            int len = ce_namelen(ce);
                            copy_cache_entry_to_ondisk(ondisk, ce);
                            hashwrite(f, ondisk, size);
                            hashwrite(f, ce->name, len);
                            hashwrite(f, padding, align_padding_size(size, len));
                    } else {
                            int common, to_remove, prefix_size;
                            unsigned char to_remove_vi[16];
                            for (common = 0;
                            (ce->name[common] &&
                            common < previous_name->len &&
                            ce->name[common] == previous_name->buf[common]);
                            common++)
                                    ; /* still matching */
                            to_remove = previous_name->len - common;
                            prefix_size = encode_varint(to_remove, to_remove_vi);

                            copy_cache_entry_to_ondisk(ondisk, ce);
                            hashwrite(f, ondisk, size);
                            hashwrite(f, to_remove_vi, prefix_size);
                            hashwrite(f, ce->name + common, ce_namelen(ce) - common);
                            hashwrite(f, padding, 1);

                            strbuf_splice(previous_name, common, to_remove,
                                    ce->name + common, ce_namelen(ce) - common);
                    }
                    if (stripped_name) {
                            ce->ce_namelen = saved_namelen;
                            ce->ce_flags &= ~CE_STRIP_NAME;
                    }

                    return 0;
            }

            /*
            * This function verifies if index_state has the correct sha1 of the
            * index file.  Don't die if we have any other failure, just return 0.
            */
            static int verify_index_from(const struct index_state *istate, const char *path)
            {
                    int fd;
                    ssize_t n;
                    struct stat st;
                    unsigned char hash[GIT_MAX_RAWSZ];

                    if (!istate->initialized)
                            return 0;

                    fd = open(path, O_RDONLY);
                    if (fd < 0)
                            return 0;

                    if (fstat(fd, &st))
                            goto out;

                    if (st.st_size < sizeof(struct cache_header) + the_hash_algo->rawsz)
                            goto out;

                    n = pread_in_full(fd, hash, the_hash_algo->rawsz, st.st_size - the_hash_algo->rawsz);
                    if (n != the_hash_algo->rawsz)
                            goto out;

                    if (!hasheq(istate->oid.hash, hash, the_repository->hash_algo))
                            goto out;

                    close(fd);
                    return 1;

            out:
                    close(fd);
                    return 0;
            }

            static int repo_verify_index(struct repository *repo)
            {
                    return verify_index_from(repo->index, repo->index_file);
            }

            int has_racy_timestamp(struct index_state *istate)
            {
                    int entries = istate->cache_nr;
                    int i;

                    for (i = 0; i < entries; i++) {
                            struct cache_entry *ce = istate->cache[i];
                            if (is_racy_timestamp(istate, ce))
                                    return 1;
                    }
                    return 0;
            }

            void repo_update_index_if_able(struct repository *repo,
                                    struct lock_file *lockfile)
            {
                    if ((repo->index->cache_changed ||
                    has_racy_timestamp(repo->index)) &&
                    repo_verify_index(repo))
                            write_locked_index(repo->index, lockfile, COMMIT_LOCK);
                    else
                            rollback_lock_file(lockfile);
            }

            static int record_eoie(void)
            {
                    int val;

                    if (!git_config_get_bool("index.recordendofindexentries", &val))
                            return val;

                    /*
                    * As a convenience, the end of index entries extension
                    * used for threading is written by default if the user
                    * explicitly requested threaded index reads.
                    */
                    return !repo_config_get_index_threads(the_repository, &val) && val != 1;
            }

            static int record_ieot(void)
            {
                    int val;

                    if (!git_config_get_bool("index.recordoffsettable", &val))
                            return val;

                    /*
                    * As a convenience, the offset table used for threading is
                    * written by default if the user explicitly requested
                    * threaded index reads.
                    */
                    return !repo_config_get_index_threads(the_repository, &val) && val != 1;
            }

            enum write_extensions {
                    WRITE_NO_EXTENSION =              0,
                    WRITE_SPLIT_INDEX_EXTENSION =     1<<0,
                    WRITE_CACHE_TREE_EXTENSION =      1<<1,
                    WRITE_RESOLVE_UNDO_EXTENSION =    1<<2,
                    WRITE_UNTRACKED_CACHE_EXTENSION = 1<<3,
                    WRITE_FSMONITOR_EXTENSION =       1<<4,
            };
            #define WRITE_ALL_EXTENSIONS ((enum write_extensions)-1)

            /*
            * On success, `tempfile` is closed. If it is the temporary file
            * of a `struct lock_file`, we will therefore effectively perform
            * a 'close_lock_file_gently()`. Since that is an implementation
            * detail of lockfiles, callers of `do_write_index()` should not
            * rely on it.
            */
            static int do_write_index(struct index_state *istate, struct tempfile *tempfile,
                                    enum write_extensions write_extensions, unsigned flags)
            {
                    uint64_t start = getnanotime();
                    struct hashfile *f;
                    git_hash_ctx *eoie_c = NULL;
                    struct cache_header hdr;
                    int i, err = 0, removed, extended, hdr_version;
                    struct cache_entry **cache = istate->cache;
                    int entries = istate->cache_nr;
                    struct stat st;
                    struct ondisk_cache_entry ondisk;
                    struct strbuf previous_name_buf = STRBUF_INIT, *previous_name;
                    int drop_cache_tree = istate->drop_cache_tree;
                    off_t offset;
                    int csum_fsync_flag;
                    int ieot_entries = 1;
                    struct index_entry_offset_table *ieot = NULL;
                    struct repository *r = istate->repo;
                    struct strbuf sb = STRBUF_INIT;
                    int nr, nr_threads, ret;

                    f = hashfd(tempfile->fd, tempfile->filename.buf);

                    prepare_repo_settings(r);
                    f->skip_hash = r->settings.index_skip_hash;

                    for (i = removed = extended = 0; i < entries; i++) {
                            if (cache[i]->ce_flags & CE_REMOVE)
                                    removed++;

                            /* reduce extended entries if possible */
                            cache[i]->ce_flags &= ~CE_EXTENDED;
                            if (cache[i]->ce_flags & CE_EXTENDED_FLAGS) {
                                    extended++;
                                    cache[i]->ce_flags |= CE_EXTENDED;
                            }
                    }

                    if (!istate->version)
                            istate->version = get_index_format_default(r);

                    /* demote version 3 to version 2 when the latter suffices */
                    if (istate->version == 3 || istate->version == 2)
                            istate->version = extended ? 3 : 2;

                    hdr_version = istate->version;

                    hdr.hdr_signature = htonl(CACHE_SIGNATURE);
                    hdr.hdr_version = htonl(hdr_version);
                    hdr.hdr_entries = htonl(entries - removed);

                    hashwrite(f, &hdr, sizeof(hdr));

                    if (!HAVE_THREADS || repo_config_get_index_threads(the_repository, &nr_threads))
                            nr_threads = 1;

                    if (nr_threads != 1 && record_ieot()) {
                            int ieot_blocks, cpus;

                            /*
                            * ensure default number of ieot blocks maps evenly to the
                            * default number of threads that will process them leaving
                            * room for the thread to load the index extensions.
                            */
                            if (!nr_threads) {
                                    ieot_blocks = istate->cache_nr / THREAD_COST;
                                    cpus = online_cpus();
                                    if (ieot_blocks > cpus - 1)
                                            ieot_blocks = cpus - 1;
                            } else {
                                    ieot_blocks = nr_threads;
                                    if (ieot_blocks > istate->cache_nr)
                                            ieot_blocks = istate->cache_nr;
                            }

                            /*
                            * no reason to write out the IEOT extension if we don't
                            * have enough blocks to utilize multi-threading
                            */
                            if (ieot_blocks > 1) {
                                    ieot = xcalloc(1, sizeof(struct index_entry_offset_table)
                                            + (ieot_blocks * sizeof(struct index_entry_offset)));
                                    ieot_entries = DIV_ROUND_UP(entries, ieot_blocks);
                            }
                    }

                    offset = hashfile_total(f);

                    nr = 0;
                    previous_name = (hdr_version == 4) ? &previous_name_buf : NULL;

                    for (i = 0; i < entries; i++) {
                            struct cache_entry *ce = cache[i];
                            if (ce->ce_flags & CE_REMOVE)
                                    continue;
                            if (!ce_uptodate(ce) && is_racy_timestamp(istate, ce))
                                    ce_smudge_racily_clean_entry(istate, ce);
                            if (is_null_oid(&ce->oid)) {
                                    static const char msg[] = "cache entry has null sha1: %s";
                                    static int allow = -1;

                                    if (allow < 0)
                                            allow = git_env_bool("GIT_ALLOW_NULL_SHA1", 0);
                                    if (allow)
                                            warning(msg, ce->name);
                                    else
                                            err = error(msg, ce->name);

                                    drop_cache_tree = 1;
                            }
                            if (ieot && i && (i % ieot_entries == 0)) {
                                    ieot->entries[ieot->nr].nr = nr;
                                    ieot->entries[ieot->nr].offset = offset;
                                    ieot->nr++;
                                    /*
                                    * If we have a V4 index, set the first byte to an invalid
                                    * character to ensure there is nothing common with the previous
                                    * entry
                                    */
                                    if (previous_name)
                                            previous_name->buf[0] = 0;
                                    nr = 0;

                                    offset = hashfile_total(f);
                            }
                            if (ce_write_entry(f, ce, previous_name, (struct ondisk_cache_entry *)&ondisk) < 0)
                                    err = -1;

                            if (err)
                                    break;
                            nr++;
                    }
                    if (ieot && nr) {
                            ieot->entries[ieot->nr].nr = nr;
                            ieot->entries[ieot->nr].offset = offset;
                            ieot->nr++;
                    }
                    strbuf_release(&previous_name_buf);

                    if (err) {
                            ret = err;
                            goto out;
                    }

                    offset = hashfile_total(f);

                    /*
                    * The extension headers must be hashed on their own for the
                    * EOIE extension. Create a hashfile here to compute that hash.
                    */
                    if (offset && record_eoie()) {
                            CALLOC_ARRAY(eoie_c, 1);
                            the_hash_algo->init_fn(eoie_c);
                    }

                    /*
                    * Lets write out CACHE_EXT_INDEXENTRYOFFSETTABLE first so that we
                    * can minimize the number of extensions we have to scan through to
                    * find it during load.  Write it out regardless of the
                    * strip_extensions parameter as we need it when loading the shared
                    * index.
                    */
                    if (ieot) {
                            strbuf_reset(&sb);

                            write_ieot_extension(&sb, ieot);
                            err = write_index_ext_header(f, eoie_c, CACHE_EXT_INDEXENTRYOFFSETTABLE, sb.len) < 0;
                            hashwrite(f, sb.buf, sb.len);
                            if (err) {
                                    ret = -1;
                                    goto out;
                            }
                    }

                    if (write_extensions & WRITE_SPLIT_INDEX_EXTENSION &&
                    istate->split_index) {
                            strbuf_reset(&sb);

                            if (istate->sparse_index)
                                    die(_("cannot write split index for a sparse index"));

                            err = write_link_extension(&sb, istate) < 0 ||
                                    write_index_ext_header(f, eoie_c, CACHE_EXT_LINK,
                                                    sb.len) < 0;
                            hashwrite(f, sb.buf, sb.len);
                            if (err) {
                                    ret = -1;
                                    goto out;
                            }
                    }
                    if (write_extensions & WRITE_CACHE_TREE_EXTENSION &&
                    !drop_cache_tree && istate->cache_tree) {
                            strbuf_reset(&sb);

                            cache_tree_write(&sb, istate->cache_tree);
                            err = write_index_ext_header(f, eoie_c, CACHE_EXT_TREE, sb.len) < 0;
                            hashwrite(f, sb.buf, sb.len);
                            if (err) {
                                    ret = -1;
                                    goto out;
                            }
                    }
                    if (write_extensions & WRITE_RESOLVE_UNDO_EXTENSION &&
                    istate->resolve_undo) {
                            strbuf_reset(&sb);

                            resolve_undo_write(&sb, istate->resolve_undo);
                            err = write_index_ext_header(f, eoie_c, CACHE_EXT_RESOLVE_UNDO,
                                                    sb.len) < 0;
                            hashwrite(f, sb.buf, sb.len);
                            if (err) {
                                    ret = -1;
                                    goto out;
                            }
                    }
                    if (write_extensions & WRITE_UNTRACKED_CACHE_EXTENSION &&
                    istate->untracked) {
                            strbuf_reset(&sb);

                            write_untracked_extension(&sb, istate->untracked);
                            err = write_index_ext_header(f, eoie_c, CACHE_EXT_UNTRACKED,
                                                    sb.len) < 0;
                            hashwrite(f, sb.buf, sb.len);
                            if (err) {
                                    ret = -1;
                                    goto out;
                            }
                    }
                    if (write_extensions & WRITE_FSMONITOR_EXTENSION &&
                    istate->fsmonitor_last_update) {
                            strbuf_reset(&sb);

                            write_fsmonitor_extension(&sb, istate);
                            err = write_index_ext_header(f, eoie_c, CACHE_EXT_FSMONITOR, sb.len) < 0;
                            hashwrite(f, sb.buf, sb.len);
                            if (err) {
                                    ret = -1;
                                    goto out;
                            }
                    }
                    if (istate->sparse_index) {
                            if (write_index_ext_header(f, eoie_c, CACHE_EXT_SPARSE_DIRECTORIES, 0) < 0) {
                                    ret = -1;
                                    goto out;
                            }
                    }

                    /*
                    * CACHE_EXT_ENDOFINDEXENTRIES must be written as the last entry before the SHA1
                    * so that it can be found and processed before all the index entries are
                    * read.  Write it out regardless of the strip_extensions parameter as we need it
                    * when loading the shared index.
                    */
                    if (eoie_c) {
                            strbuf_reset(&sb);

                            write_eoie_extension(&sb, eoie_c, offset);
                            err = write_index_ext_header(f, NULL, CACHE_EXT_ENDOFINDEXENTRIES, sb.len) < 0;
                            hashwrite(f, sb.buf, sb.len);
                            if (err) {
                                    ret = -1;
                                    goto out;
                            }
                    }

                    csum_fsync_flag = 0;
                    if (!alternate_index_output && (flags & COMMIT_LOCK))
                            csum_fsync_flag = CSUM_FSYNC;

                    finalize_hashfile(f, istate->oid.hash, FSYNC_COMPONENT_INDEX,
                                    CSUM_HASH_IN_STREAM | csum_fsync_flag);
                    f = NULL;

                    if (close_tempfile_gently(tempfile)) {
                            ret = error(_("could not close '%s'"), get_tempfile_path(tempfile));
                            goto out;
                    }
                    if (stat(get_tempfile_path(tempfile), &st)) {
                            ret = -1;
                            goto out;
                    }
                    istate->timestamp.sec = (unsigned int)st.st_mtime;
                    istate->timestamp.nsec = ST_MTIME_NSEC(st);
                    trace_performance_since(start, "write index, changed mask = %x", istate->cache_changed);

                    /*
                    * TODO trace2: replace "the_repository" with the actual repo instance
                    * that is associated with the given "istate".
                    */
                    trace2_data_intmax("index", the_repository, "write/version",
                                    istate->version);
                    trace2_data_intmax("index", the_repository, "write/cache_nr",
                                    istate->cache_nr);

                    ret = 0;

            out:
                    if (f)
                            free_hashfile(f);
                    strbuf_release(&sb);
                    free(eoie_c);
                    free(ieot);
                    return ret;
            }

            void set_alternate_index_output(const char *name)
            {
                    alternate_index_output = name;
            }

            static int commit_locked_index(struct lock_file *lk)
            {
                    if (alternate_index_output)
                            return commit_lock_file_to(lk, alternate_index_output);
                    else
                            return commit_lock_file(lk);
            }

            static int do_write_locked_index(struct index_state *istate,
                                            struct lock_file *lock,
                                            unsigned flags,
                                            enum write_extensions write_extensions)
            {
                    int ret;
                    int was_full = istate->sparse_index == INDEX_EXPANDED;

                    ret = convert_to_sparse(istate, 0);

                    if (ret) {
                            warning(_("failed to convert to a sparse-index"));
                            return ret;
                    }

                    /*
                    * TODO trace2: replace "the_repository" with the actual repo instance
                    * that is associated with the given "istate".
                    */
                    trace2_region_enter_printf("index", "do_write_index", the_repository,
                                            "%s", get_lock_file_path(lock));
                    ret = do_write_index(istate, lock->tempfile, write_extensions, flags);
                    trace2_region_leave_printf("index", "do_write_index", the_repository,
                                            "%s", get_lock_file_path(lock));

                    if (was_full)
                            ensure_full_index(istate);

                    if (ret)
                            return ret;
                    if (flags & COMMIT_LOCK)
                            ret = commit_locked_index(lock);
                    else
                            ret = close_lock_file_gently(lock);

                    run_hooks_l(the_repository, "post-index-change",
                            istate->updated_workdir ? "1" : "0",
                            istate->updated_skipworktree ? "1" : "0", NULL);
                    istate->updated_workdir = 0;
                    istate->updated_skipworktree = 0;

                    return ret;
            }

            static int write_split_index(struct index_state *istate,
                                    struct lock_file *lock,
                                    unsigned flags)
            {
                    int ret;
                    prepare_to_write_split_index(istate);
                    ret = do_write_locked_index(istate, lock, flags, WRITE_ALL_EXTENSIONS);
                    finish_writing_split_index(istate);
                    return ret;
            }

            static unsigned long get_shared_index_expire_date(void)
            {
                    static unsigned long shared_index_expire_date;
                    static int shared_index_expire_date_prepared;

                    if (!shared_index_expire_date_prepared) {
                            const char *shared_index_expire = "2.weeks.ago";
                            char *value = NULL;

                            repo_config_get_expiry(the_repository, "splitindex.sharedindexexpire",
                                            &value);
                            if (value)
                                    shared_index_expire = value;

                            shared_index_expire_date = approxidate(shared_index_expire);
                            shared_index_expire_date_prepared = 1;

                            free(value);
                    }

                    return shared_index_expire_date;
            }

            static int should_delete_shared_index(const char *shared_index_path)
            {
                    struct stat st;
                    unsigned long expiration;

                    /* Check timestamp */
                    expiration = get_shared_index_expire_date();
                    if (!expiration)
                            return 0;
                    if (stat(shared_index_path, &st))
                            return error_errno(_("could not stat '%s'"), shared_index_path);
                    if (st.st_mtime > expiration)
                            return 0;

                    return 1;
            }

            static int clean_shared_index_files(const char *current_hex)
            {
                    struct dirent *de;
                    DIR *dir = opendir(repo_get_git_dir(the_repository));

                    if (!dir)
                            return error_errno(_("unable to open git dir: %s"),
                                            repo_get_git_dir(the_repository));

                    while ((de = readdir(dir)) != NULL) {
                            const char *sha1_hex;
                            const char *shared_index_path;
                            if (!skip_prefix(de->d_name, "sharedindex.", &sha1_hex))
                                    continue;
                            if (!strcmp(sha1_hex, current_hex))
                                    continue;
                            shared_index_path = git_path("%s", de->d_name);
                            if (should_delete_shared_index(shared_index_path) > 0 &&
                            unlink(shared_index_path))
                                    warning_errno(_("unable to unlink: %s"), shared_index_path);
                    }
                    closedir(dir);

                    return 0;
            }

            static int write_shared_index(struct index_state *istate,
                                    struct tempfile **temp, unsigned flags)
            {
                    struct split_index *si = istate->split_index;
                    int ret, was_full = !istate->sparse_index;

                    move_cache_to_base_index(istate);
                    convert_to_sparse(istate, 0);

                    trace2_region_enter_printf("index", "shared/do_write_index",
                                            the_repository, "%s", get_tempfile_path(*temp));
                    ret = do_write_index(si->base, *temp, WRITE_NO_EXTENSION, flags);
                    trace2_region_leave_printf("index", "shared/do_write_index",
                                            the_repository, "%s", get_tempfile_path(*temp));

                    if (was_full)
                            ensure_full_index(istate);

                    if (ret)
                            return ret;
                    ret = adjust_shared_perm(get_tempfile_path(*temp));
                    if (ret) {
                            error(_("cannot fix permission bits on '%s'"), get_tempfile_path(*temp));
                            return ret;
                    }
                    ret = rename_tempfile(temp,
                                    git_path("sharedindex.%s", oid_to_hex(&si->base->oid)));
                    if (!ret) {
                            oidcpy(&si->base_oid, &si->base->oid);
                            clean_shared_index_files(oid_to_hex(&si->base->oid));
                    }

                    return ret;
            }

            static const int default_max_percent_split_change = 20;

            static int too_many_not_shared_entries(struct index_state *istate)
            {
                    int i, not_shared = 0;
                    int max_split = repo_config_get_max_percent_split_change(the_repository);

                    switch (max_split) {
                    case -1:
                            /* not or badly configured: use the default value */
                            max_split = default_max_percent_split_change;
                            break;
                    case 0:
                            return 1; /* 0% means always write a new shared index */
                    case 100:
                            return 0; /* 100% means never write a new shared index */
                    default:
                            break; /* just use the configured value */
                    }

                    /* Count not shared entries */
                    for (i = 0; i < istate->cache_nr; i++) {
                            struct cache_entry *ce = istate->cache[i];
                            if (!ce->index)
                                    not_shared++;
                    }

                    return (int64_t)istate->cache_nr * max_split < (int64_t)not_shared * 100;
            }

            int write_locked_index(struct index_state *istate, struct lock_file *lock,
                            unsigned flags)
            {
                    int new_shared_index, ret, test_split_index_env;
                    struct split_index *si = istate->split_index;

                    if (git_env_bool("GIT_TEST_CHECK_CACHE_TREE", 0) &&
                    cache_tree_verify(the_repository, istate) < 0)
                            return -1;

                    if ((flags & SKIP_IF_UNCHANGED) && !istate->cache_changed) {
                            if (flags & COMMIT_LOCK)
                                    rollback_lock_file(lock);
                            return 0;
                    }

                    if (istate->fsmonitor_last_update)
                            fill_fsmonitor_bitmap(istate);

                    test_split_index_env = git_env_bool("GIT_TEST_SPLIT_INDEX", 0);

                    if ((!si && !test_split_index_env) ||
                    alternate_index_output ||
                    (istate->cache_changed & ~EXTMASK)) {
                            ret = do_write_locked_index(istate, lock, flags,
                                                    ~WRITE_SPLIT_INDEX_EXTENSION);
                            goto out;
                    }

                    if (test_split_index_env) {
                            if (!si) {
                                    si = init_split_index(istate);
                                    istate->cache_changed |= SPLIT_INDEX_ORDERED;
                            } else {
                                    int v = si->base_oid.hash[0];
                                    if ((v & 15) < 6)
                                            istate->cache_changed |= SPLIT_INDEX_ORDERED;
                            }
                    }
                    if (too_many_not_shared_entries(istate))
                            istate->cache_changed |= SPLIT_INDEX_ORDERED;

                    new_shared_index = istate->cache_changed & SPLIT_INDEX_ORDERED;

                    if (new_shared_index) {
                            struct tempfile *temp;
                            int saved_errno;

                            /* Same initial permissions as the main .git/index file */
                            temp = mks_tempfile_sm(git_path("sharedindex_XXXXXX"), 0, 0666);
                            if (!temp) {
                                    ret = do_write_locked_index(istate, lock, flags,
                                                            ~WRITE_SPLIT_INDEX_EXTENSION);
                                    goto out;
                            }
                            ret = write_shared_index(istate, &temp, flags);

                            saved_errno = errno;
                            if (is_tempfile_active(temp))
                                    delete_tempfile(&temp);
                            errno = saved_errno;

                            if (ret)
                                    goto out;
                    }

                    ret = write_split_index(istate, lock, flags);

                    /* Freshen the shared index only if the split-index was written */
                    if (!ret && !new_shared_index && !is_null_oid(&si->base_oid)) {
                            const char *shared_index = git_path("sharedindex.%s",
                                                            oid_to_hex(&si->base_oid));
                            freshen_shared_index(shared_index, 1);
                    }

            out:
                    if (flags & COMMIT_LOCK)
                            rollback_lock_file(lock);
                    return ret;
            }

            /*
            * Read the index file that is potentially unmerged into given
            * index_state, dropping any unmerged entries to stage #0 (potentially
            * resulting in a path appearing as both a file and a directory in the
            * index; the caller is responsible to clear out the extra entries
            * before writing the index to a tree).  Returns true if the index is
            * unmerged.  Callers who want to refuse to work from an unmerged
            * state can call this and check its return value, instead of calling
            * read_cache().
            */
            int repo_read_index_unmerged(struct repository *repo)
            {
                    struct index_state *istate;
                    int i;
                    int unmerged = 0;

                    repo_read_index(repo);
                    istate = repo->index;
                    for (i = 0; i < istate->cache_nr; i++) {
                            struct cache_entry *ce = istate->cache[i];
                            struct cache_entry *new_ce;
                            int len;

                            if (!ce_stage(ce))
                                    continue;
                            unmerged = 1;
                            len = ce_namelen(ce);
                            new_ce = make_empty_cache_entry(istate, len);
                            memcpy(new_ce->name, ce->name, len);
                            new_ce->ce_flags = create_ce_flags(0) | CE_CONFLICTED;
                            new_ce->ce_namelen = len;
                            new_ce->ce_mode = ce->ce_mode;
                            if (add_index_entry(istate, new_ce, ADD_CACHE_SKIP_DFCHECK))
                                    return error(_("%s: cannot drop to stage #0"),
                                            new_ce->name);
                    }
                    return unmerged;
            }

            /*
            * Returns 1 if the path is an "other" path with respect to
            * the index; that is, the path is not mentioned in the index at all,
            * either as a file, a directory with some files in the index,
            * or as an unmerged entry.
            *
            * We helpfully remove a trailing "/" from directories so that
            * the output of read_directory can be used as-is.
            */
            int index_name_is_other(struct index_state *istate, const char *name,
                                    int namelen)
            {
                    int pos;
                    if (namelen && name[namelen - 1] == '/')
                            namelen--;
                    pos = index_name_pos(istate, name, namelen);
                    if (0 <= pos)
                            return 0;       /* exact match */
                    pos = -pos - 1;
                    if (pos < istate->cache_nr) {
                            struct cache_entry *ce = istate->cache[pos];
                            if (ce_namelen(ce) == namelen &&
                            !memcmp(ce->name, name, namelen))
                                    return 0; /* Yup, this one exists unmerged */
                    }
                    return 1;
            }

            void *read_blob_data_from_index(struct index_state *istate,
                                            const char *path, unsigned long *size)
            {
                    int pos, len;
                    unsigned long sz;
                    enum object_type type;
                    void *data;

                    len = strlen(path);
                    pos = index_name_pos(istate, path, len);
                    if (pos < 0) {
                            /*
                            * We might be in the middle of a merge, in which
                            * case we would read stage #2 (ours).
                            */
                            int i;
                            for (i = -pos - 1;
                            (pos < 0 && i < istate->cache_nr &&
                            !strcmp(istate->cache[i]->name, path));
                            i++)
                                    if (ce_stage(istate->cache[i]) == 2)
                                            pos = i;
                    }
                    if (pos < 0)
                            return NULL;
                    data = repo_read_object_file(the_repository, &istate->cache[pos]->oid,
                                            &type, &sz);
                    if (!data || type != OBJ_BLOB) {
                            free(data);
                            return NULL;
                    }
                    if (size)
                            *size = sz;
                    return data;
            }

            void move_index_extensions(struct index_state *dst, struct index_state *src)
            {
                    dst->untracked = src->untracked;
                    src->untracked = NULL;
                    dst->cache_tree = src->cache_tree;
                    src->cache_tree = NULL;
            }

            struct cache_entry *dup_cache_entry(const struct cache_entry *ce,
                                            struct index_state *istate)
            {
                    unsigned int size = ce_size(ce);
                    int mem_pool_allocated;
                    struct cache_entry *new_entry = make_empty_cache_entry(istate, ce_namelen(ce));
                    mem_pool_allocated = new_entry->mem_pool_allocated;

                    memcpy(new_entry, ce, size);
                    new_entry->mem_pool_allocated = mem_pool_allocated;
                    return new_entry;
            }

            void discard_cache_entry(struct cache_entry *ce)
            {
                    if (ce && should_validate_cache_entries())
                            memset(ce, 0xCD, cache_entry_size(ce->ce_namelen));

                    if (ce && ce->mem_pool_allocated)
                            return;

                    free(ce);
            }

            int should_validate_cache_entries(void)
            {
                    static int validate_index_cache_entries = -1;

                    if (validate_index_cache_entries < 0) {
                            if (getenv("GIT_TEST_VALIDATE_INDEX_CACHE_ENTRIES"))
                                    validate_index_cache_entries = 1;
                            else
                                    validate_index_cache_entries = 0;
                    }

                    return validate_index_cache_entries;
            }

            #define EOIE_SIZE (4 + GIT_SHA1_RAWSZ) /* <4-byte offset> + <20-byte hash> */
            #define EOIE_SIZE_WITH_HEADER (4 + 4 + EOIE_SIZE) /* <4-byte signature> + <4-byte length> + EOIE_SIZE */

            static size_t read_eoie_extension(const char *mmap, size_t mmap_size)
            {
                    /*
                    * The end of index entries (EOIE) extension is guaranteed to be last
                    * so that it can be found by scanning backwards from the EOF.
                    *
                    * "EOIE"
                    * <4-byte length>
                    * <4-byte offset>
                    * <20-byte hash>
                    */
                    const char *index, *eoie;
                    uint32_t extsize;
                    size_t offset, src_offset;
                    unsigned char hash[GIT_MAX_RAWSZ];
                    git_hash_ctx c;

                    /* ensure we have an index big enough to contain an EOIE extension */
                    if (mmap_size < sizeof(struct cache_header) + EOIE_SIZE_WITH_HEADER + the_hash_algo->rawsz)
                            return 0;

                    /* validate the extension signature */
                    index = eoie = mmap + mmap_size - EOIE_SIZE_WITH_HEADER - the_hash_algo->rawsz;
                    if (CACHE_EXT(index) != CACHE_EXT_ENDOFINDEXENTRIES)
                            return 0;
                    index += sizeof(uint32_t);

                    /* validate the extension size */
                    extsize = get_be32(index);
                    if (extsize != EOIE_SIZE)
                            return 0;
                    index += sizeof(uint32_t);

                    /*
                    * Validate the offset we're going to look for the first extension
                    * signature is after the index header and before the eoie extension.
                    */
                    offset = get_be32(index);
                    if (mmap + offset < mmap + sizeof(struct cache_header))
                            return 0;
                    if (mmap + offset >= eoie)
                            return 0;
                    index += sizeof(uint32_t);

                    /*
                    * The hash is computed over extension types and their sizes (but not
                    * their contents).  E.g. if we have "TREE" extension that is N-bytes
                    * long, "REUC" extension that is M-bytes long, followed by "EOIE",
                    * then the hash would be:
                    *
                    * SHA-1("TREE" + <binary representation of N> +
                    *       "REUC" + <binary representation of M>)
                    */
                    src_offset = offset;
                    the_hash_algo->init_fn(&c);
                    while (src_offset < mmap_size - the_hash_algo->rawsz - EOIE_SIZE_WITH_HEADER) {
                            /* After an array of active_nr index entries,
                            * there can be arbitrary number of extended
                            * sections, each of which is prefixed with
                            * extension name (4-byte) and section length
                            * in 4-byte network byte order.
                            */
                            uint32_t extsize;
                            memcpy(&extsize, mmap + src_offset + 4, 4);
                            extsize = ntohl(extsize);

                            /* verify the extension size isn't so large it will wrap around */
                            if (src_offset + 8 + extsize < src_offset)
                                    return 0;

                            the_hash_algo->update_fn(&c, mmap + src_offset, 8);

                            src_offset += 8;
                            src_offset += extsize;
                    }
                    the_hash_algo->final_fn(hash, &c);
                    if (!hasheq(hash, (const unsigned char *)index, the_repository->hash_algo))
                            return 0;

                    /* Validate that the extension offsets returned us back to the eoie extension. */
                    if (src_offset != mmap_size - the_hash_algo->rawsz - EOIE_SIZE_WITH_HEADER)
                            return 0;

                    return offset;
            }

            static void write_eoie_extension(struct strbuf *sb, git_hash_ctx *eoie_context, size_t offset)
            {
                    uint32_t buffer;
                    unsigned char hash[GIT_MAX_RAWSZ];

                    /* offset */
                    put_be32(&buffer, offset);
                    strbuf_add(sb, &buffer, sizeof(uint32_t));

                    /* hash */
                    the_hash_algo->final_fn(hash, eoie_context);
                    strbuf_add(sb, hash, the_hash_algo->rawsz);
            }

            #define IEOT_VERSION    (1)

            static struct index_entry_offset_table *read_ieot_extension(const char *mmap, size_t mmap_size, size_t offset)
            {
                    const char *index = NULL;
                    uint32_t extsize, ext_version;
                    struct index_entry_offset_table *ieot;
                    int i, nr;

                    /* find the IEOT extension */
                    if (!offset)
                            return NULL;
                    while (offset <= mmap_size - the_hash_algo->rawsz - 8) {
                            extsize = get_be32(mmap + offset + 4);
                            if (CACHE_EXT((mmap + offset)) == CACHE_EXT_INDEXENTRYOFFSETTABLE) {
                                    index = mmap + offset + 4 + 4;
                                    break;
                            }
                            offset += 8;
                            offset += extsize;
                    }
                    if (!index)
                            return NULL;

                    /* validate the version is IEOT_VERSION */
                    ext_version = get_be32(index);
                    if (ext_version != IEOT_VERSION) {
                            error("invalid IEOT version %d", ext_version);
                            return NULL;
                    }
                    index += sizeof(uint32_t);

                    /* extension size - version bytes / bytes per entry */
                    nr = (extsize - sizeof(uint32_t)) / (sizeof(uint32_t) + sizeof(uint32_t));
                    if (!nr) {
                            error("invalid number of IEOT entries %d", nr);
                            return NULL;
                    }
                    ieot = xmalloc(sizeof(struct index_entry_offset_table)
                            + (nr * sizeof(struct index_entry_offset)));
                    ieot->nr = nr;
                    for (i = 0; i < nr; i++) {
                            ieot->entries[i].offset = get_be32(index);
                            index += sizeof(uint32_t);
                            ieot->entries[i].nr = get_be32(index);
                            index += sizeof(uint32_t);
                    }

                    return ieot;
            }

            static void write_ieot_extension(struct strbuf *sb, struct index_entry_offset_table *ieot)
            {
                    uint32_t buffer;
                    int i;

                    /* version */
                    put_be32(&buffer, IEOT_VERSION);
                    strbuf_add(sb, &buffer, sizeof(uint32_t));

                    /* ieot */
                    for (i = 0; i < ieot->nr; i++) {

                            /* offset */
                            put_be32(&buffer, ieot->entries[i].offset);
                            strbuf_add(sb, &buffer, sizeof(uint32_t));

                            /* count */
                            put_be32(&buffer, ieot->entries[i].nr);
                            strbuf_add(sb, &buffer, sizeof(uint32_t));
                    }
            }

            void prefetch_cache_entries(const struct index_state *istate,
                                    must_prefetch_predicate must_prefetch)
            {
                    int i;
                    struct oid_array to_fetch = OID_ARRAY_INIT;

                    for (i = 0; i < istate->cache_nr; i++) {
                            struct cache_entry *ce = istate->cache[i];

                            if (S_ISGITLINK(ce->ce_mode) || !must_prefetch(ce))
                                    continue;
                            if (!oid_object_info_extended(the_repository, &ce->oid,
                                                    NULL,
                                                    OBJECT_INFO_FOR_PREFETCH))
                                    continue;
                            oid_array_append(&to_fetch, &ce->oid);
                    }
                    promisor_remote_get_direct(the_repository,
                                            to_fetch.oid, to_fetch.nr);
                    oid_array_clear(&to_fetch);
            }

            static int read_one_entry_opt(struct index_state *istate,
                                    const struct object_id *oid,
                                    struct strbuf *base,
                                    const char *pathname,
                                    unsigned mode, int opt)
            {
                    int len;
                    struct cache_entry *ce;

                    if (S_ISDIR(mode))
                            return READ_TREE_RECURSIVE;

                    len = strlen(pathname);
                    ce = make_empty_cache_entry(istate, base->len + len);

                    ce->ce_mode = create_ce_mode(mode);
                    ce->ce_flags = create_ce_flags(1);
                    ce->ce_namelen = base->len + len;
                    memcpy(ce->name, base->buf, base->len);
                    memcpy(ce->name + base->len, pathname, len+1);
                    oidcpy(&ce->oid, oid);
                    return add_index_entry(istate, ce, opt);
            }

            static int read_one_entry(const struct object_id *oid, struct strbuf *base,
                                    const char *pathname, unsigned mode,
                                    void *context)
            {
                    struct index_state *istate = context;
                    return read_one_entry_opt(istate, oid, base, pathname,
                                            mode,
                                            ADD_CACHE_OK_TO_ADD|ADD_CACHE_SKIP_DFCHECK);
            }

            /*
            * This is used when the caller knows there is no existing entries at
            * the stage that will conflict with the entry being added.
            */
            static int read_one_entry_quick(const struct object_id *oid, struct strbuf *base,
                                            const char *pathname, unsigned mode,
                                            void *context)
            {
                    struct index_state *istate = context;
                    return read_one_entry_opt(istate, oid, base, pathname,
                                            mode, ADD_CACHE_JUST_APPEND);
            }

            /*
            * Read the tree specified with --with-tree option
            * (typically, HEAD) into stage #1 and then
            * squash them down to stage #0.  This is used for
            * --error-unmatch to list and check the path patterns
            * that were given from the command line.  We are not
            * going to write this index out.
            */
            void overlay_tree_on_index(struct index_state *istate,
                                    const char *tree_name, const char *prefix)
            {
                    struct tree *tree;
                    struct object_id oid;
                    struct pathspec pathspec;
                    struct cache_entry *last_stage0 = NULL;
                    int i;
                    read_tree_fn_t fn = NULL;
                    int err;

                    if (repo_get_oid(the_repository, tree_name, &oid))
                            die("tree-ish %s not found.", tree_name);
                    tree = parse_tree_indirect(&oid);
                    if (!tree)
                            die("bad tree-ish %s", tree_name);

                    /* Hoist the unmerged entries up to stage #3 to make room */
                    /* TODO: audit for interaction with sparse-index. */
                    ensure_full_index(istate);
                    for (i = 0; i < istate->cache_nr; i++) {
                            struct cache_entry *ce = istate->cache[i];
                            if (!ce_stage(ce))
                                    continue;
                            ce->ce_flags |= CE_STAGEMASK;
                    }

                    if (prefix) {
                            static const char *(matchbuf[1]);
                            matchbuf[0] = NULL;
                            parse_pathspec(&pathspec, PATHSPEC_ALL_MAGIC,
                                    PATHSPEC_PREFER_CWD, prefix, matchbuf);
                    } else
                            memset(&pathspec, 0, sizeof(pathspec));

                    /*
                    * See if we have cache entry at the stage.  If so,
                    * do it the original slow way, otherwise, append and then
                    * sort at the end.
                    */
                    for (i = 0; !fn && i < istate->cache_nr; i++) {
                            const struct cache_entry *ce = istate->cache[i];
                            if (ce_stage(ce) == 1)
                                    fn = read_one_entry;
                    }

                    if (!fn)
                            fn = read_one_entry_quick;
                    err = read_tree(the_repository, tree, &pathspec, fn, istate);
                    clear_pathspec(&pathspec);
                    if (err)
                            die("unable to read tree entries %s", tree_name);

                    /*
                    * Sort the cache entry -- we need to nuke the cache tree, though.
                    */
                    if (fn == read_one_entry_quick) {
                            cache_tree_free(&istate->cache_tree);
                            QSORT(istate->cache, istate->cache_nr, cmp_cache_name_compare);
                    }

                    for (i = 0; i < istate->cache_nr; i++) {
                            struct cache_entry *ce = istate->cache[i];
                            switch (ce_stage(ce)) {
                            case 0:
                                    last_stage0 = ce;
                                    /* fallthru */
                            default:
                                    continue;
                            case 1:
                                    /*
                                    * If there is stage #0 entry for this, we do not
                                    * need to show it.  We use CE_UPDATE bit to mark
                                    * such an entry.
                                    */
                                    if (last_stage0 &&
                                    !strcmp(last_stage0->name, ce->name))
                                            ce->ce_flags |= CE_UPDATE;
                            }
                    }
            }

            struct update_callback_data {
                    struct index_state *index;
                    int include_sparse;
                    int flags;
                    int add_errors;
            };

            static int fix_unmerged_status(struct diff_filepair *p,
                                    struct update_callback_data *data)
            {
                    if (p->status != DIFF_STATUS_UNMERGED)
                            return p->status;
                    if (!(data->flags & ADD_CACHE_IGNORE_REMOVAL) && !p->two->mode)
                            /*
                            * This is not an explicit add request, and the
                            * path is missing from the working tree (deleted)
                            */
                            return DIFF_STATUS_DELETED;
                    else
                            /*
                            * Either an explicit add request, or path exists
                            * in the working tree.  An attempt to explicitly
                            * add a path that does not exist in the working tree
                            * will be caught as an error by the caller immediately.
                            */
                            return DIFF_STATUS_MODIFIED;
            }

            static void update_callback(struct diff_queue_struct *q,
                                    struct diff_options *opt UNUSED, void *cbdata)
            {
                    int i;
                    struct update_callback_data *data = cbdata;

                    for (i = 0; i < q->nr; i++) {
                            struct diff_filepair *p = q->queue[i];
                            const char *path = p->one->path;

                            if (!data->include_sparse &&
                            !path_in_sparse_checkout(path, data->index))
                                    continue;

                            switch (fix_unmerged_status(p, data)) {
                            default:
                                    die(_("unexpected diff status %c"), p->status);
                            case DIFF_STATUS_MODIFIED:
                            case DIFF_STATUS_TYPE_CHANGED:
                                    if (add_file_to_index(data->index, path, data->flags)) {
                                            if (!(data->flags & ADD_CACHE_IGNORE_ERRORS))
                                                    die(_("updating files failed"));
                                            data->add_errors++;
                                    }
                                    break;
                            case DIFF_STATUS_DELETED:
                                    if (data->flags & ADD_CACHE_IGNORE_REMOVAL)
                                            break;
                                    if (!(data->flags & ADD_CACHE_PRETEND))
                                            remove_file_from_index(data->index, path);
                                    if (data->flags & (ADD_CACHE_PRETEND|ADD_CACHE_VERBOSE))
                                            printf(_("remove '%s'\n"), path);
                                    break;
                            }
                    }
            }

            int add_files_to_cache(struct repository *repo, const char *prefix,
                            const struct pathspec *pathspec, char *ps_matched,
                            int include_sparse, int flags)
            {
                    struct update_callback_data data;
                    struct rev_info rev;

                    memset(&data, 0, sizeof(data));
                    data.index = repo->index;
                    data.include_sparse = include_sparse;
                    data.flags = flags;

                    repo_init_revisions(repo, &rev, prefix);
                    setup_revisions(0, NULL, &rev, NULL);
                    if (pathspec) {
                            copy_pathspec(&rev.prune_data, pathspec);
                            rev.ps_matched = ps_matched;
                    }
                    rev.diffopt.output_format = DIFF_FORMAT_CALLBACK;
                    rev.diffopt.format_callback = update_callback;
                    rev.diffopt.format_callback_data = &data;
                    rev.diffopt.flags.override_submodule_config = 1;
                    rev.max_count = 0; /* do not compare unmerged paths with stage #2 */

                    /*
                    * Use an ODB transaction to optimize adding multiple objects.
                    * This function is invoked from commands other than 'add', which
                    * may not have their own transaction active.
                    */
                    begin_odb_transaction();
                    run_diff_files(&rev, DIFF_RACY_IS_MODIFIED);
                    end_odb_transaction();

                    release_revisions(&rev);
                    return !!data.add_errors;
            }



            """,
            "Patche":
            """
            diff --git a/read-cache.c b/read-cache.c
            index b09128b..7bc57dd 100644
            --- a/read-cache.c
            +++ b/read-cache.c
            @@ -244,6 +244,9 @@ static int ce_compare_data(struct index_state *istate,
                    int fd = git_open_cloexec(ce->name, O_RDONLY);

                    if (fd >= 0) {
            +#ifdef __MVS__
            +    __disableautocvt(fd);
            +#endif
                            struct object_id oid;
                            if (!index_fd(istate, &oid, fd, st, OBJ_BLOB, ce->name, 0))
                                    match = !oideq(&oid, &ce->oid);



            """,


    },

    {
            "Wrong Code":
            """
            # Test framework for git.  See t/README for usage.
            #
            # Copyright (c) 2005 Junio C Hamano
            #
            # This program is free software: you can redistribute it and/or modify
            # it under the terms of the GNU General Public License as published by
            # the Free Software Foundation, either version 2 of the License, or
            # (at your option) any later version.
            #
            # This program is distributed in the hope that it will be useful,
            # but WITHOUT ANY WARRANTY; without even the implied warranty of
            # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
            # GNU General Public License for more details.
            #
            # You should have received a copy of the GNU General Public License
            # along with this program.  If not, see https://www.gnu.org/licenses/ .

            # Test the binaries we have just built.  The tests are kept in
            # t/ subdirectory and are run in 'trash directory' subdirectory.
            if test -z "$TEST_DIRECTORY"
            then
                    # ensure that TEST_DIRECTORY is an absolute path so that it
                    # is valid even if the current working directory is changed
                    TEST_DIRECTORY=$(pwd)
            else
                    # The TEST_DIRECTORY will always be the path to the "t"
                    # directory in the git.git checkout. This is overridden by
                    # e.g. t/lib-subtest.sh, but only because its $(pwd) is
                    # different. Those tests still set "$TEST_DIRECTORY" to the
                    # same path.
                    #
                    # See use of "$GIT_BUILD_DIR" and "$TEST_DIRECTORY" below for
                    # hard assumptions about "$GIT_BUILD_DIR/t" existing and being
                    # the "$TEST_DIRECTORY", and e.g. "$TEST_DIRECTORY/helper"
                    # needing to exist.
                    TEST_DIRECTORY=$(cd "$TEST_DIRECTORY" && pwd) || exit 1
            fi
            GIT_BUILD_DIR="${GIT_BUILD_DIR:-${TEST_DIRECTORY%/t}}"
            if test "$TEST_DIRECTORY" = "$GIT_BUILD_DIR"
            then
                    echo "PANIC: Running in a $TEST_DIRECTORY that doesn't end in '/t'?" >&2
                    exit 1
            fi
            if test -f "$GIT_BUILD_DIR/GIT-BUILD-DIR"
            then
                    GIT_BUILD_DIR="$(cat "$GIT_BUILD_DIR/GIT-BUILD-DIR")" || exit 1
                    # On Windows, we must convert Windows paths lest they contain a colon
                    case "$(uname -s)" in
                    *MINGW*)
                            GIT_BUILD_DIR="$(cygpath -au "$GIT_BUILD_DIR")"
                            ;;
                    esac
            fi

            # Prepend a string to a VAR using an arbitrary ":" delimiter, not
            # adding the delimiter if VAR or VALUE is empty. I.e. a generalized:
            #
            #       VAR=$1${VAR:+${1:+$2}$VAR}
            #
            # Usage (using ":" as the $2 delimiter):
            #
            #       prepend_var VAR : VALUE
            prepend_var () {
                    eval "$1=\"$3\${$1:+${3:+$2}\$$1}\""
            }

            # If [AL]SAN is in effect we want to abort so that we notice
            # problems. The GIT_SAN_OPTIONS variable can be used to set common
            # defaults shared between [AL]SAN_OPTIONS.
            prepend_var GIT_SAN_OPTIONS : abort_on_error=1
            prepend_var GIT_SAN_OPTIONS : strip_path_prefix="$GIT_BUILD_DIR/"

            # If we were built with ASAN, it may complain about leaks
            # of program-lifetime variables. Disable it by default to lower
            # the noise level. This needs to happen at the start of the script,
            # before we even do our "did we build git yet" check (since we don't
            # want that one to complain to stderr).
            prepend_var ASAN_OPTIONS : $GIT_SAN_OPTIONS
            prepend_var ASAN_OPTIONS : detect_leaks=0
            export ASAN_OPTIONS

            prepend_var LSAN_OPTIONS : $GIT_SAN_OPTIONS
            prepend_var LSAN_OPTIONS : exitcode=0
            prepend_var LSAN_OPTIONS : fast_unwind_on_malloc=0
            export LSAN_OPTIONS

            prepend_var UBSAN_OPTIONS : $GIT_SAN_OPTIONS
            export UBSAN_OPTIONS

            # The TEST_OUTPUT_DIRECTORY will be overwritten via GIT-BUILD-OPTIONS. So in
            # case the caller has manually set up this variable via the environment we must
            # make sure to not overwrite that value, and thus we save it into
            # TEST_OUTPUT_DIRECTORY_OVERRIDE here.
            if test -n "$TEST_OUTPUT_DIRECTORY" && test -z "$TEST_OUTPUT_DIRECTORY_OVERRIDE"
            then
                    TEST_OUTPUT_DIRECTORY_OVERRIDE=$TEST_OUTPUT_DIRECTORY
            fi

            if test ! -f "$GIT_BUILD_DIR"/GIT-BUILD-OPTIONS
            then
                    echo >&2 'error: GIT-BUILD-OPTIONS missing (has Git been built?).'
                    exit 1
            fi
            . "$GIT_BUILD_DIR"/GIT-BUILD-OPTIONS
            export PERL_PATH SHELL_PATH

            if test -z "$TEST_OUTPUT_DIRECTORY"
            then
                    # Similarly, override this to store the test-results subdir
                    # elsewhere
                    TEST_OUTPUT_DIRECTORY=$TEST_DIRECTORY
            fi

            # In t0000, we need to override test directories of nested testcases. In case
            # the developer has TEST_OUTPUT_DIRECTORY part of his build options, then we'd
            # reset this value to instead contain what the developer has specified. We thus
            # have this knob to allow overriding the directory.
            if test -n "${TEST_OUTPUT_DIRECTORY_OVERRIDE}"
            then
                    TEST_OUTPUT_DIRECTORY="${TEST_OUTPUT_DIRECTORY_OVERRIDE}"
            fi

            # Disallow the use of abbreviated options in the test suite by default
            if test -z "${GIT_TEST_DISALLOW_ABBREVIATED_OPTIONS}"
            then
                    GIT_TEST_DISALLOW_ABBREVIATED_OPTIONS=true
                    export GIT_TEST_DISALLOW_ABBREVIATED_OPTIONS
            fi

            # Explicitly set the default branch name for testing, to avoid the
            # transitory "git init" warning under --verbose.
            : ${GIT_TEST_DEFAULT_INITIAL_BRANCH_NAME:=master}
            export GIT_TEST_DEFAULT_INITIAL_BRANCH_NAME

            ################################################################
            # It appears that people try to run tests without building...
            "${GIT_TEST_INSTALLED:-$GIT_BUILD_DIR}/git$X" >/dev/null
            if test $? != 1
            then
                    if test -n "$GIT_TEST_INSTALLED"
                    then
                            echo >&2 "error: there is no working Git at '$GIT_TEST_INSTALLED'"
                    else
                            echo >&2 'error: you do not seem to have built git yet.'
                    fi
                    exit 1
            fi

            store_arg_to=
            opt_required_arg=
            # $1: option string
            # $2: name of the var where the arg will be stored
            mark_option_requires_arg () {
                    if test -n "$opt_required_arg"
                    then
                            echo "error: options that require args cannot be bundled" \
                                    "together: '$opt_required_arg' and '$1'" >&2
                            exit 1
                    fi
                    opt_required_arg=$1
                    store_arg_to=$2
            }

            # These functions can be overridden e.g. to output JUnit XML
            start_test_output () { :; }
            start_test_case_output () { :; }
            finalize_test_case_output () { :; }
            finalize_test_output () { :; }

            parse_option () {
                    local opt="$1"

                    case "$opt" in
                    -d|--d|--de|--deb|--debu|--debug)
                            debug=t ;;
                    -i|--i|--im|--imm|--imme|--immed|--immedi|--immedia|--immediat|--immediate)
                            immediate=t ;;
                    -l|--l|--lo|--lon|--long|--long-|--long-t|--long-te|--long-tes|--long-test|--long-tests)
                            GIT_TEST_LONG=t; export GIT_TEST_LONG ;;
                    -r)
                            mark_option_requires_arg "$opt" run_list
                            ;;
                    --run=*)
                            run_list=${opt#--*=} ;;
                    -h|--h|--he|--hel|--help)
                            help=t ;;
                    -v|--v|--ve|--ver|--verb|--verbo|--verbos|--verbose)
                            verbose=t ;;
                    --verbose-only=*)
                            verbose_only=${opt#--*=}
                            ;;
                    -q|--q|--qu|--qui|--quie|--quiet)
                            # Ignore --quiet under a TAP::Harness. Saying how many tests
                            # passed without the ok/not ok details is always an error.
                            test -z "$HARNESS_ACTIVE" && quiet=t ;;
                    --with-dashes)
                            with_dashes=t ;;
                    --no-bin-wrappers)
                            no_bin_wrappers=t ;;
                    --no-color)
                            color= ;;
                    --va|--val|--valg|--valgr|--valgri|--valgrin|--valgrind)
                            valgrind=memcheck
                            tee=t
                            ;;
                    --valgrind=*)
                            valgrind=${opt#--*=}
                            tee=t
                            ;;
                    --valgrind-only=*)
                            valgrind_only=${opt#--*=}
                            tee=t
                            ;;
                    --tee)
                            tee=t ;;
                    --root=*)
                            root=${opt#--*=} ;;
                    --chain-lint)
                            GIT_TEST_CHAIN_LINT=1 ;;
                    --no-chain-lint)
                            GIT_TEST_CHAIN_LINT=0 ;;
                    -x)
                            trace=t ;;
                    -V|--verbose-log)
                            verbose_log=t
                            tee=t
                            ;;
                    --write-junit-xml)
                            . "$TEST_DIRECTORY/test-lib-junit.sh"
                            ;;
                    --github-workflow-markup)
                            . "$TEST_DIRECTORY/test-lib-github-workflow-markup.sh"
                            ;;
                    --stress)
                            stress=t ;;
                    --stress=*)
                            echo "error: --stress does not accept an argument: '$opt'" >&2
                            echo "did you mean --stress-jobs=${opt#*=} or --stress-limit=${opt#*=}?" >&2
                            exit 1
                            ;;
                    --stress-jobs=*)
                            stress=t;
                            stress_jobs=${opt#--*=}
                            case "$stress_jobs" in
                            *[!0-9]*|0*|"")
                                    echo "error: --stress-jobs=<N> requires the number of jobs to run" >&2
                                    exit 1
                                    ;;
                            *)      # Good.
                                    ;;
                            esac
                            ;;
                    --stress-limit=*)
                            stress=t;
                            stress_limit=${opt#--*=}
                            case "$stress_limit" in
                            *[!0-9]*|0*|"")
                                    echo "error: --stress-limit=<N> requires the number of repetitions" >&2
                                    exit 1
                                    ;;
                            *)      # Good.
                                    ;;
                            esac
                            ;;
                    --invert-exit-code)
                            invert_exit_code=t
                            ;;
                    *)
                            echo "error: unknown test option '$opt'" >&2; exit 1 ;;
                    esac
            }

            # Parse options while taking care to leave $@ intact, so we will still
            # have all the original command line options when executing the test
            # script again for '--tee' and '--verbose-log' later.
            for opt
            do
                    if test -n "$store_arg_to"
                    then
                            eval $store_arg_to=\$opt
                            store_arg_to=
                            opt_required_arg=
                            continue
                    fi

                    case "$opt" in
                    --*|-?)
                            parse_option "$opt" ;;
                    -?*)
                            # bundled short options must be fed separately to parse_option
                            opt=${opt#-}
                            while test -n "$opt"
                            do
                                    extra=${opt#?}
                                    this=${opt%$extra}
                                    opt=$extra
                                    parse_option "-$this"
                            done
                            ;;
                    *)
                            echo "error: unknown test option '$opt'" >&2; exit 1 ;;
                    esac
            done
            if test -n "$store_arg_to"
            then
                    echo "error: $opt_required_arg requires an argument" >&2
                    exit 1
            fi

            if test -n "$valgrind_only"
            then
                    test -z "$valgrind" && valgrind=memcheck
                    test -z "$verbose" && verbose_only="$valgrind_only"
            elif test -n "$valgrind"
            then
                    test -z "$verbose_log" && verbose=t
            fi

            if test -n "$stress"
            then
                    verbose=t
                    trace=t
                    immediate=t
            fi

            TEST_STRESS_JOB_SFX="${GIT_TEST_STRESS_JOB_NR:+.stress-$GIT_TEST_STRESS_JOB_NR}"
            TEST_NAME="$(basename "$0" .sh)"
            TEST_NUMBER="${TEST_NAME%%-*}"
            TEST_NUMBER="${TEST_NUMBER#t}"
            TEST_RESULTS_DIR="$TEST_OUTPUT_DIRECTORY/test-results"
            TEST_RESULTS_BASE="$TEST_RESULTS_DIR/$TEST_NAME$TEST_STRESS_JOB_SFX"
            TEST_RESULTS_SAN_FILE_PFX=trace
            TEST_RESULTS_SAN_DIR_SFX=leak
            TEST_RESULTS_SAN_FILE=
            TEST_RESULTS_SAN_DIR="$TEST_RESULTS_BASE.$TEST_RESULTS_SAN_DIR_SFX"
            TRASH_DIRECTORY="trash directory.$TEST_NAME$TEST_STRESS_JOB_SFX"
            test -n "$root" && TRASH_DIRECTORY="$root/$TRASH_DIRECTORY"
            case "$TRASH_DIRECTORY" in
            /*) ;; # absolute path is good
            *) TRASH_DIRECTORY="$TEST_OUTPUT_DIRECTORY/$TRASH_DIRECTORY" ;;
            esac

            # If --stress was passed, run this test repeatedly in several parallel loops.
            if test "$GIT_TEST_STRESS_STARTED" = "done"
            then
                    : # Don't stress test again.
            elif test -n "$stress"
            then
                    if test -n "$stress_jobs"
                    then
                            job_count=$stress_jobs
                    elif test -n "$GIT_TEST_STRESS_LOAD"
                    then
                            job_count="$GIT_TEST_STRESS_LOAD"
                    elif job_count=$(getconf _NPROCESSORS_ONLN 2>/dev/null) &&
                    test -n "$job_count"
                    then
                            job_count=$((2 * $job_count))
                    else
                            job_count=8
                    fi

                    mkdir -p "$TEST_RESULTS_DIR"
                    stressfail="$TEST_RESULTS_BASE.stress-failed"
                    rm -f "$stressfail"

                    stress_exit=0
                    trap '
                            kill $job_pids 2>/dev/null
                            wait
                            stress_exit=1
                    ' TERM INT HUP

                    job_pids=
                    job_nr=0
                    while test $job_nr -lt "$job_count"
                    do
                            (
                                    GIT_TEST_STRESS_STARTED=done
                                    GIT_TEST_STRESS_JOB_NR=$job_nr
                                    export GIT_TEST_STRESS_STARTED GIT_TEST_STRESS_JOB_NR

                                    trap '
                                            kill $test_pid 2>/dev/null
                                            wait
                                            exit 1
                                    ' TERM INT

                                    cnt=1
                                    while ! test -e "$stressfail" &&
                                    { test -z "$stress_limit" ||
                                            test $cnt -le $stress_limit ; }
                                    do
                                            $TEST_SHELL_PATH "$0" "$@" >"$TEST_RESULTS_BASE.stress-$job_nr.out" 2>&1 &
                                            test_pid=$!

                                            if wait $test_pid
                                            then
                                                    printf "OK   %2d.%d\n" $GIT_TEST_STRESS_JOB_NR $cnt
                                            else
                                                    echo $GIT_TEST_STRESS_JOB_NR >>"$stressfail"
                                                    printf "FAIL %2d.%d\n" $GIT_TEST_STRESS_JOB_NR $cnt
                                            fi
                                            cnt=$(($cnt + 1))
                                    done
                            ) &
                            job_pids="$job_pids $!"
                            job_nr=$(($job_nr + 1))
                    done

                    wait

                    if test -f "$stressfail"
                    then
                            stress_exit=1
                            echo "Log(s) of failed test run(s):"
                            for failed_job_nr in $(sort -n "$stressfail")
                            do
                                    echo "Contents of '$TEST_RESULTS_BASE.stress-$failed_job_nr.out':"
                                    cat "$TEST_RESULTS_BASE.stress-$failed_job_nr.out"
                            done
                            rm -rf "$TRASH_DIRECTORY.stress-failed"
                            # Move the last one.
                            mv "$TRASH_DIRECTORY.stress-$failed_job_nr" "$TRASH_DIRECTORY.stress-failed"
                    fi

                    exit $stress_exit
            fi

            # if --tee was passed, write the output not only to the terminal, but
            # additionally to the file test-results/$BASENAME.out, too.
            if test "$GIT_TEST_TEE_STARTED" = "done"
            then
                    : # do not redirect again
            elif test -n "$tee"
            then
                    mkdir -p "$TEST_RESULTS_DIR"

                    # Make this filename available to the sub-process in case it is using
                    # --verbose-log.
                    GIT_TEST_TEE_OUTPUT_FILE=$TEST_RESULTS_BASE.out
                    export GIT_TEST_TEE_OUTPUT_FILE

                    # Truncate before calling "tee -a" to get rid of the results
                    # from any previous runs.
                    >"$GIT_TEST_TEE_OUTPUT_FILE"

                    (GIT_TEST_TEE_STARTED=done ${TEST_SHELL_PATH} "$0" "$@" 2>&1;
                    echo $? >"$TEST_RESULTS_BASE.exit") | tee -a "$GIT_TEST_TEE_OUTPUT_FILE"
                    test "$(cat "$TEST_RESULTS_BASE.exit")" = 0
                    exit
            fi

            if test -n "$trace" && test -n "$test_untraceable"
            then
                    # '-x' tracing requested, but this test script can't be reliably
                    # traced, unless it is run with a Bash version supporting
                    # BASH_XTRACEFD (introduced in Bash v4.1).
                    #
                    # Perform this version check _after_ the test script was
                    # potentially re-executed with $TEST_SHELL_PATH for '--tee' or
                    # '--verbose-log', so the right shell is checked and the
                    # warning is issued only once.
                    if test -n "$BASH_VERSION" && eval '
                    test ${BASH_VERSINFO[0]} -gt 4 || {
                    test ${BASH_VERSINFO[0]} -eq 4 &&
                    test ${BASH_VERSINFO[1]} -ge 1
                    }
                    '
                    then
                            : Executed by a Bash version supporting BASH_XTRACEFD.  Good.
                    else
                            echo >&2 "warning: ignoring -x; '$0' is untraceable without BASH_XTRACEFD"
                            trace=
                    fi
            fi
            if test -n "$trace" && test -z "$verbose_log"
            then
                    verbose=t
            fi

            # Since bash 5.0, checkwinsize is enabled by default which does
            # update the COLUMNS variable every time a non-builtin command
            # completes, even for non-interactive shells.
            # Disable that since we are aiming for repeatability.
            test -n "$BASH_VERSION" && shopt -u checkwinsize 2>/dev/null

            # For repeatability, reset the environment to known value.
            # TERM is sanitized below, after saving color control sequences.
            LANG=C
            LC_ALL=C
            PAGER=cat
            TZ=UTC
            COLUMNS=80
            export LANG LC_ALL PAGER TZ COLUMNS
            EDITOR=:

            # A call to "unset" with no arguments causes at least Solaris 10
            # /usr/xpg4/bin/sh and /bin/ksh to bail out.  So keep the unsets
            # deriving from the command substitution clustered with the other
            # ones.
            unset VISUAL EMAIL LANGUAGE $("$PERL_PATH" -e '
                    my @env = keys %ENV;
                    my $ok = join("|", qw(
                            TRACE
                            DEBUG
                            TEST
                            .*_TEST
                            PROVE
                            VALGRIND
                            UNZIP
                            PERF_
                            CURL_VERBOSE
                            TRACE_CURL
                            BUILD_DIR
                    ));
                    my @vars = grep(/^GIT_/ && !/^GIT_($ok)/o, @env);
                    print join("\n", @vars);
            ')
            unset XDG_CACHE_HOME
            unset XDG_CONFIG_HOME
            unset GITPERLLIB
            unset GIT_TRACE2_PARENT_NAME
            unset GIT_TRACE2_PARENT_SID
            TEST_AUTHOR_LOCALNAME=author
            TEST_AUTHOR_DOMAIN=example.com
            GIT_AUTHOR_EMAIL=${TEST_AUTHOR_LOCALNAME}@${TEST_AUTHOR_DOMAIN}
            GIT_AUTHOR_NAME='A U Thor'
            GIT_AUTHOR_DATE='1112354055 +0200'
            TEST_COMMITTER_LOCALNAME=committer
            TEST_COMMITTER_DOMAIN=example.com
            GIT_COMMITTER_EMAIL=${TEST_COMMITTER_LOCALNAME}@${TEST_COMMITTER_DOMAIN}
            GIT_COMMITTER_NAME='C O Mitter'
            GIT_COMMITTER_DATE='1112354055 +0200'
            GIT_MERGE_VERBOSITY=5
            GIT_MERGE_AUTOEDIT=no
            export GIT_MERGE_VERBOSITY GIT_MERGE_AUTOEDIT
            export GIT_AUTHOR_EMAIL GIT_AUTHOR_NAME
            export GIT_COMMITTER_EMAIL GIT_COMMITTER_NAME
            export GIT_COMMITTER_DATE GIT_AUTHOR_DATE
            export EDITOR

            GIT_DEFAULT_HASH="${GIT_TEST_DEFAULT_HASH:-sha1}"
            export GIT_DEFAULT_HASH
            GIT_DEFAULT_REF_FORMAT="${GIT_TEST_DEFAULT_REF_FORMAT:-files}"
            export GIT_DEFAULT_REF_FORMAT
            GIT_TEST_MERGE_ALGORITHM="${GIT_TEST_MERGE_ALGORITHM:-ort}"
            export GIT_TEST_MERGE_ALGORITHM

            # Tests using GIT_TRACE typically don't want <timestamp> <file>:<line> output
            GIT_TRACE_BARE=1
            export GIT_TRACE_BARE

            # Some tests scan the GIT_TRACE2_EVENT feed for events, but the
            # default depth is 2, which frequently causes issues when the
            # events are wrapped in new regions. Set it to a sufficiently
            # large depth to avoid custom changes in the test suite.
            GIT_TRACE2_EVENT_NESTING=100
            export GIT_TRACE2_EVENT_NESTING

            # Use specific version of the index file format
            if test -n "${GIT_TEST_INDEX_VERSION:+isset}"
            then
                    GIT_INDEX_VERSION="$GIT_TEST_INDEX_VERSION"
                    export GIT_INDEX_VERSION
            fi

            if test -n "$GIT_TEST_PERL_FATAL_WARNINGS"
            then
                    GIT_PERL_FATAL_WARNINGS=1
                    export GIT_PERL_FATAL_WARNINGS
            fi

            case $GIT_TEST_FSYNC in
            '')
                    GIT_TEST_FSYNC=0
                    export GIT_TEST_FSYNC
                    ;;
            esac

            # Protect ourselves from common misconfiguration to export
            # CDPATH into the environment
            unset CDPATH

            unset GREP_OPTIONS
            unset UNZIP

            case $(echo $GIT_TRACE |tr "[A-Z]" "[a-z]") in
            1|2|true)
                    GIT_TRACE=4
                    ;;
            esac

            # Line feed
            LF='
            '

            # Single quote
            SQ=\'

            # UTF-8 ZERO WIDTH NON-JOINER, which HFS+ ignores
            # when case-folding filenames
            u200c=$(printf '\342\200\214')

            export _x05 _x35 LF u200c EMPTY_TREE EMPTY_BLOB ZERO_OID OID_REGEX

            test "x$TERM" != "xdumb" && (
                            test -t 1 &&
                            tput bold >/dev/null 2>&1 &&
                            tput setaf 1 >/dev/null 2>&1 &&
                            tput sgr0 >/dev/null 2>&1
                    ) &&
                    color=t

            if test -n "$color"
            then
                    # Save the color control sequences now rather than run tput
                    # each time say_color() is called.  This is done for two
                    # reasons:
                    #   * TERM will be changed to dumb
                    #   * HOME will be changed to a temporary directory and tput
                    #     might need to read ~/.terminfo from the original HOME
                    #     directory to get the control sequences
                    # Note:  This approach assumes the control sequences don't end
                    # in a newline for any terminal of interest (command
                    # substitutions strip trailing newlines).  Given that most
                    # (all?) terminals in common use are related to ECMA-48, this
                    # shouldn't be a problem.
                    say_color_error=$(tput bold; tput setaf 1) # bold red
                    say_color_skip=$(tput setaf 4) # blue
                    say_color_warn=$(tput setaf 3) # brown/yellow
                    say_color_pass=$(tput setaf 2) # green
                    say_color_info=$(tput setaf 6) # cyan
                    say_color_reset=$(tput sgr0)
                    say_color_="" # no formatting for normal text
                    say_color () {
                            test -z "$1" && test -n "$quiet" && return
                            eval "say_color_color=\$say_color_$1"
                            shift
                            printf "%s\\n" "$say_color_color$*$say_color_reset"
                    }
            else
                    say_color() {
                            test -z "$1" && test -n "$quiet" && return
                            shift
                            printf "%s\n" "$*"
                    }
            fi

            USER_TERM="$TERM"
            TERM=dumb
            export TERM USER_TERM

            # What is written by tests to stdout and stderr is sent to different places
            # depending on the test mode (e.g. /dev/null in non-verbose mode, piped to tee
            # with --tee option, etc.). We save the original stdin to FD #6 and stdout and
            # stderr to #5 and #7, so that the test framework can use them (e.g. for
            # printing errors within the test framework) independently of the test mode.
            exec 5>&1
            exec 6<&0
            exec 7>&2

            _error_exit () {
                    finalize_test_output
                    GIT_EXIT_OK=t
                    exit 1
            }

            error () {
                    say_color error "error: $*"
                    _error_exit
            }

            BUG () {
                    error >&7 "bug in the test script: $*"
            }

            BAIL_OUT () {
                    test $# -ne 1 && BUG "1 param"

                    # Do not change "Bail out! " string. It's part of TAP syntax:
                    # https://testanything.org/tap-specification.html
                    local bail_out="Bail out! "
                    local message="$1"

                    say_color >&5 error $bail_out "$message"
                    _error_exit
            }

            say () {
                    say_color info "$*"
            }

            if test -n "$HARNESS_ACTIVE"
            then
                    if test "$verbose" = t || test -n "$verbose_only"
                    then
                            BAIL_OUT 'verbose mode forbidden under TAP harness; try --verbose-log'
                    fi
            fi

            test "${test_description}" != "" ||
            error "Test script did not set test_description."

            if test "$help" = "t"
            then
                    printf '%s\n' "$test_description"
                    exit 0
            fi

            if test "$verbose_log" = "t"
            then
                    exec 3>>"$GIT_TEST_TEE_OUTPUT_FILE" 4>&3
            elif test "$verbose" = "t"
            then
                    exec 4>&2 3>&1
            else
                    exec 4>/dev/null 3>/dev/null
            fi

            # Send any "-x" output directly to stderr to avoid polluting tests
            # which capture stderr. We can do this unconditionally since it
            # has no effect if tracing isn't turned on.
            #
            # Note that this sets up the trace fd as soon as we assign the variable, so it
            # must come after the creation of descriptor 4 above. Likewise, we must never
            # unset this, as it has the side effect of closing descriptor 4, which we
            # use to show verbose tests to the user.
            #
            # Note also that we don't need or want to export it. The tracing is local to
            # this shell, and we would not want to influence any shells we exec.
            BASH_XTRACEFD=4

            test_failure=0
            test_count=0
            test_fixed=0
            test_broken=0
            test_success=0

            test_missing_prereq=

            test_external_has_tap=0

            die () {
                    code=$?
                    # This is responsible for running the atexit commands even when a
                    # test script run with '--immediate' fails, or when the user hits
                    # ctrl-C, i.e. when 'test_done' is not invoked at all.
                    test_atexit_handler || code=$?
                    if test -n "$GIT_EXIT_OK"
                    then
                            exit $code
                    else
                            echo >&5 "FATAL: Unexpected exit with code $code"
                            exit 1
                    fi
            }

            GIT_EXIT_OK=
            trap 'die' EXIT
            # Disable '-x' tracing, because with some shells, notably dash, it
            # prevents running the cleanup commands when a test script run with
            # '--verbose-log -x' is interrupted.
            trap '{ code=$?; set +x; } 2>/dev/null; exit $code' INT TERM HUP

            # The user-facing functions are loaded from a separate file so that
            # test_perf subshells can have them too
            . "$TEST_DIRECTORY/test-lib-functions.sh"

            # You are not expected to call test_ok_ and test_failure_ directly, use
            # the test_expect_* functions instead.

            test_ok_ () {
                    test_success=$(($test_success + 1))
                    say_color "" "ok $test_count - $@"
                    finalize_test_case_output ok "$@"
            }

            _invert_exit_code_failure_end_blurb () {
                    say_color warn "# faked up failures as TODO & now exiting with 0 due to --invert-exit-code"
            }

            test_failure_ () {
                    failure_label=$1
                    test_failure=$(($test_failure + 1))
                    local pfx=""
                    if test -n "$invert_exit_code" # && test -n "$HARNESS_ACTIVE"
                    then
                            pfx="# TODO induced breakage (--invert-exit-code):"
                    fi
                    say_color error "not ok $test_count - ${pfx:+$pfx }$1"
                    shift
                    printf '%s\n' "$*" | sed -e 's/^/#      /'
                    if test -n "$immediate"
                    then
                            say_color error "1..$test_count"
                            if test -n "$invert_exit_code"
                            then
                                    finalize_test_output
                                    _invert_exit_code_failure_end_blurb
                                    GIT_EXIT_OK=t
                                    exit 0
                            fi
                            check_test_results_san_file_ "$test_failure"
                            _error_exit
                    fi
                    finalize_test_case_output failure "$failure_label" "$@"
            }

            test_known_broken_ok_ () {
                    test_fixed=$(($test_fixed+1))
                    say_color error "ok $test_count - $1 # TODO known breakage vanished"
                    finalize_test_case_output fixed "$1"
            }

            test_known_broken_failure_ () {
                    test_broken=$(($test_broken+1))
                    say_color warn "not ok $test_count - $1 # TODO known breakage"
                    finalize_test_case_output broken "$1"
            }

            test_debug () {
                    test "$debug" = "" || eval "$1"
            }

            match_pattern_list () {
                    arg="$1"
                    shift
                    test -z "$*" && return 1
                    # We need to use "$*" to get field-splitting, but we want to
                    # disable globbing, since we are matching against an arbitrary
                    # $arg, not what's in the filesystem. Using "set -f" accomplishes
                    # that, but we must do it in a subshell to avoid impacting the
                    # rest of the script. The exit value of the subshell becomes
                    # the function's return value.
                    (
                            set -f
                            for pattern_ in $*
                            do
                                    case "$arg" in
                                    $pattern_)
                                            exit 0
                                            ;;
                                    esac
                            done
                            exit 1
                    )
            }

            match_test_selector_list () {
                    operation="$1"
                    shift
                    title="$1"
                    shift
                    arg="$1"
                    shift
                    test -z "$1" && return 0

                    # Commas are accepted as separators.
                    OLDIFS=$IFS
                    IFS=','
                    set -- $1
                    IFS=$OLDIFS

                    # If the first selector is negative we include by default.
                    include=
                    case "$1" in
                            !*) include=t ;;
                    esac

                    for selector
                    do
                            orig_selector=$selector

                            positive=t
                            case "$selector" in
                                    !*)
                                            positive=
                                            selector=${selector##?}
                                            ;;
                            esac

                            test -z "$selector" && continue

                            case "$selector" in
                                    *-*)
                                            if expr "z${selector%%-*}" : "z[0-9]*[^0-9]" >/dev/null
                                            then
                                                    echo "error: $operation: invalid non-numeric in range" \
                                                            "start: '$orig_selector'" >&2
                                                    exit 1
                                            fi
                                            if expr "z${selector#*-}" : "z[0-9]*[^0-9]" >/dev/null
                                            then
                                                    echo "error: $operation: invalid non-numeric in range" \
                                                            "end: '$orig_selector'" >&2
                                                    exit 1
                                            fi
                                            ;;
                                    *)
                                            if expr "z$selector" : "z[0-9]*[^0-9]" >/dev/null
                                            then
                                                    case "$title" in *${selector}*)
                                                            include=$positive
                                                            ;;
                                                    esac
                                                    continue
                                            fi
                            esac

                            # Short cut for "obvious" cases
                            test -z "$include" && test -z "$positive" && continue
                            test -n "$include" && test -n "$positive" && continue

                            case "$selector" in
                                    -*)
                                            if test $arg -le ${selector#-}
                                            then
                                                    include=$positive
                                            fi
                                            ;;
                                    *-)
                                            if test $arg -ge ${selector%-}
                                            then
                                                    include=$positive
                                            fi
                                            ;;
                                    *-*)
                                            if test ${selector%%-*} -le $arg \
                                                    && test $arg -le ${selector#*-}
                                            then
                                                    include=$positive
                                            fi
                                            ;;
                                    *)
                                            if test $arg -eq $selector
                                            then
                                                    include=$positive
                                            fi
                                            ;;
                            esac
                    done

                    test -n "$include"
            }

            maybe_teardown_verbose () {
                    test -z "$verbose_only" && return
                    exec 4>/dev/null 3>/dev/null
                    verbose=
            }

            last_verbose=t
            maybe_setup_verbose () {
                    test -z "$verbose_only" && return
                    if match_pattern_list $test_count "$verbose_only"
                    then
                            exec 4>&2 3>&1
                            # Emit a delimiting blank line when going from
                            # non-verbose to verbose.  Within verbose mode the
                            # delimiter is printed by test_expect_*.  The choice
                            # of the initial $last_verbose is such that before
                            # test 1, we do not print it.
                            test -z "$last_verbose" && echo >&3 ""
                            verbose=t
                    else
                            exec 4>/dev/null 3>/dev/null
                            verbose=
                    fi
                    last_verbose=$verbose
            }

            maybe_teardown_valgrind () {
                    test -z "$GIT_VALGRIND" && return
                    GIT_VALGRIND_ENABLED=
            }

            maybe_setup_valgrind () {
                    test -z "$GIT_VALGRIND" && return
                    if test -z "$valgrind_only"
                    then
                            GIT_VALGRIND_ENABLED=t
                            return
                    fi
                    GIT_VALGRIND_ENABLED=
                    if match_pattern_list $test_count "$valgrind_only"
                    then
                            GIT_VALGRIND_ENABLED=t
                    fi
            }

            trace_level_=0
            want_trace () {
                    test "$trace" = t && {
                            test "$verbose" = t || test "$verbose_log" = t
                    }
            }

            # This is a separate function because some tests use
            # "return" to end a test_expect_success block early
            # (and we want to make sure we run any cleanup like
            # "set +x").
            test_eval_inner_ () {
                    eval "$*"
            }

            test_eval_ () {
                    # If "-x" tracing is in effect, then we want to avoid polluting stderr
                    # with non-test commands. But once in "set -x" mode, we cannot prevent
                    # the shell from printing the "set +x" to turn it off (nor the saving
                    # of $? before that). But we can make sure that the output goes to
                    # /dev/null.
                    #
                    # There are a few subtleties here:
                    #
                    #   - we have to redirect descriptor 4 in addition to 2, to cover
                    #     BASH_XTRACEFD
                    #
                    #   - the actual eval has to come before the redirection block (since
                    #     it needs to see descriptor 4 to set up its stderr)
                    #
                    #   - likewise, any error message we print must be outside the block to
                    #     access descriptor 4
                    #
                    #   - checking $? has to come immediately after the eval, but it must
                    #     be _inside_ the block to avoid polluting the "set -x" output
                    #

                    # Do not add anything extra (including LF) after '$*'
                    test_eval_inner_ </dev/null >&3 2>&4 "
                            want_trace && trace_level_=$(($trace_level_+1)) && set -x
                            $*"
                    {
                            test_eval_ret_=$?
                            if want_trace
                            then
                                    test 1 = $trace_level_ && set +x
                                    trace_level_=$(($trace_level_-1))
                            fi
                    } 2>/dev/null 4>&2

                    if test "$test_eval_ret_" != 0 && want_trace
                    then
                            say_color error >&4 "error: last command exited with \$?=$test_eval_ret_"
                    fi
                    return $test_eval_ret_
            }

            fail_117 () {
                    return 117
            }

            test_run_ () {
                    test_cleanup=:
                    expecting_failure=$2

                    if test "${GIT_TEST_CHAIN_LINT:-1}" != 0; then
                            # 117 is magic because it is unlikely to match the exit
                            # code of other programs
                            test_eval_inner_ "fail_117 && $1" </dev/null >&3 2>&4
                            if test $? != 117
                            then
                                    BUG "broken &&-chain: $1"
                            fi
                    fi

                    setup_malloc_check
                    test_eval_ "$1"
                    eval_ret=$?
                    teardown_malloc_check

                    if test -z "$immediate" || test $eval_ret = 0 ||
                    test -n "$expecting_failure" && test "$test_cleanup" != ":"
                    then
                            setup_malloc_check
                            test_eval_ "$test_cleanup"
                            teardown_malloc_check
                    fi
                    if test "$verbose" = "t" && test -n "$HARNESS_ACTIVE"
                    then
                            echo ""
                    fi
                    return "$eval_ret"
            }

            test_start_ () {
                    test_count=$(($test_count+1))
                    maybe_setup_verbose
                    maybe_setup_valgrind
                    start_test_case_output "$@"
            }

            test_finish_ () {
                    echo >&3 ""
                    maybe_teardown_valgrind
                    maybe_teardown_verbose
                    if test -n "$GIT_TEST_TEE_OFFSET"
                    then
                            GIT_TEST_TEE_OFFSET=$(test-tool path-utils file-size \
                                    "$GIT_TEST_TEE_OUTPUT_FILE")
                    fi
            }

            test_skip () {
                    to_skip=
                    skipped_reason=
                    if match_pattern_list $this_test.$test_count "$GIT_SKIP_TESTS"
                    then
                            to_skip=t
                            skipped_reason="GIT_SKIP_TESTS"
                    fi
                    if test -z "$to_skip" && test -n "$run_list" &&
                    ! match_test_selector_list '--run' "$1" $test_count "$run_list"
                    then
                            to_skip=t
                            skipped_reason="--run"
                    fi
                    if test -z "$to_skip" && test -n "$test_prereq" &&
                    ! test_have_prereq "$test_prereq"
                    then
                            to_skip=t

                            of_prereq=
                            if test "$missing_prereq" != "$test_prereq"
                            then
                                    of_prereq=" of $test_prereq"
                            fi
                            skipped_reason="missing $missing_prereq${of_prereq}"

                            # Keep a list of all the missing prereq for result aggregation
                            if test -z "$missing_prereq"
                            then
                                    test_missing_prereq=$missing_prereq
                            else
                                    test_missing_prereq="$test_missing_prereq,$missing_prereq"
                            fi
                    fi

                    case "$to_skip" in
                    t)

                            say_color skip "ok $test_count # skip $1 ($skipped_reason)"
                            : true
                            finalize_test_case_output skip "$@"
                            ;;
                    *)
                            false
                            ;;
                    esac
            }

            # stub; perf-lib overrides it
            test_at_end_hook_ () {
                    :
            }

            test_atexit_cleanup=:
            test_atexit_handler () {
                    # In a succeeding test script 'test_atexit_handler' is invoked
                    # twice: first from 'test_done', then from 'die' in the trap on
                    # EXIT.
                    # This condition and resetting 'test_atexit_cleanup' below makes
                    # sure that the registered cleanup commands are run only once.
                    test : != "$test_atexit_cleanup" || return 0

                    setup_malloc_check
                    test_eval_ "$test_atexit_cleanup"
                    test_atexit_cleanup=:
                    teardown_malloc_check
            }

            check_test_results_san_file_empty_ () {
                    test -z "$TEST_RESULTS_SAN_FILE" && return 0

                    # stderr piped to /dev/null because the directory may have
                    # been "rmdir"'d already.
                    ! find "$TEST_RESULTS_SAN_DIR" \
                            -type f \
                            -name "$TEST_RESULTS_SAN_FILE_PFX.*" 2>/dev/null |
                    xargs grep ^DEDUP_TOKEN |
                    grep -qv sanitizer::GetThreadStackTopAndBottom
            }

            check_test_results_san_file_ () {
                    if check_test_results_san_file_empty_
                    then
                            return
                    fi &&
                    say_color error "$(cat "$TEST_RESULTS_SAN_FILE".*)" &&

                    if test "$test_failure" = 0
                    then
                            say "Our logs revealed a memory leak, exit non-zero!" &&
                            invert_exit_code=t
                    else
                            say "Our logs revealed a memory leak..."
                    fi
            }

            test_done () {
                    # Run the atexit commands _before_ the trash directory is
                    # removed, so the commands can access pidfiles and socket files.
                    test_atexit_handler

                    finalize_test_output

                    if test -z "$HARNESS_ACTIVE"
                    then
                            mkdir -p "$TEST_RESULTS_DIR"

                            cat >"$TEST_RESULTS_BASE.counts" <<-EOF
                            total $test_count
                            success $test_success
                            fixed $test_fixed
                            broken $test_broken
                            failed $test_failure
                            missing_prereq $test_missing_prereq

                            EOF
                    fi

                    if test "$test_fixed" != 0
                    then
                            say_color error "# $test_fixed known breakage(s) vanished; please update test(s)"
                    fi
                    if test "$test_broken" != 0
                    then
                            say_color warn "# still have $test_broken known breakage(s)"
                    fi
                    if test "$test_broken" != 0 || test "$test_fixed" != 0
                    then
                            test_remaining=$(( $test_count - $test_broken - $test_fixed ))
                            msg="remaining $test_remaining test(s)"
                    else
                            test_remaining=$test_count
                            msg="$test_count test(s)"
                    fi
                    case "$test_failure" in
                    0)
                            if test $test_remaining -gt 0
                            then
                                    say_color pass "# passed all $msg"
                            fi

                            # Maybe print SKIP message
                            test -z "$skip_all" || skip_all="# SKIP $skip_all"
                            case "$test_count" in
                            0)
                                    say "1..$test_count${skip_all:+ $skip_all}"
                                    ;;
                            *)
                                    test -z "$skip_all" ||
                                    say_color warn "$skip_all"
                                    say "1..$test_count"
                                    ;;
                            esac

                            if test -n "$stress" && test -n "$invert_exit_code"
                            then
                                    # We're about to move our "$TRASH_DIRECTORY"
                                    # to "$TRASH_DIRECTORY.stress-failed" if
                                    # --stress is combined with
                                    # --invert-exit-code.
                                    say "with --stress and --invert-exit-code we're not removing '$TRASH_DIRECTORY'"
                            elif test -z "$debug" && test -n "$remove_trash"
                            then
                                    test -d "$TRASH_DIRECTORY" ||
                                    error "Tests passed but trash directory already removed before test cleanup; aborting"

                                    cd "$TRASH_DIRECTORY/.." &&
                                    rm -fr "$TRASH_DIRECTORY" || {
                                            # try again in a bit
                                            sleep 5;
                                            rm -fr "$TRASH_DIRECTORY"
                                    } ||
                                    error "Tests passed but test cleanup failed; aborting"
                            fi

                            check_test_results_san_file_ "$test_failure"

                            if test -z "$skip_all" && test -n "$invert_exit_code"
                            then
                                    say_color warn "# faking up non-zero exit with --invert-exit-code"
                                    GIT_EXIT_OK=t
                                    exit 1
                            fi

                            test_at_end_hook_

                            GIT_EXIT_OK=t
                            exit 0 ;;

                    *)
                            say_color error "# failed $test_failure among $msg"
                            say "1..$test_count"

                            check_test_results_san_file_ "$test_failure"

                            if test -n "$invert_exit_code"
                            then
                                    _invert_exit_code_failure_end_blurb
                                    GIT_EXIT_OK=t
                                    exit 0
                            fi

                            GIT_EXIT_OK=t
                            exit 1 ;;

                    esac
            }

            if test -n "$valgrind"
            then
                    make_symlink () {
                            test -h "$2" &&
                            test "$1" = "$(readlink "$2")" || {
                                    # be super paranoid
                                    if mkdir "$2".lock
                                    then
                                            rm -f "$2" &&
                                            ln -s "$1" "$2" &&
                                            rm -r "$2".lock
                                    else
                                            while test -d "$2".lock
                                            do
                                                    say "Waiting for lock on $2."
                                                    sleep 1
                                            done
                                    fi
                            }
                    }

                    make_valgrind_symlink () {
                            # handle only executables, unless they are shell libraries that
                            # need to be in the exec-path.
                            test -x "$1" ||
                            test "# " = "$(test_copy_bytes 2 <"$1")" ||
                            return;

                            base=$(basename "$1")
                            case "$base" in
                            test-*)
                                    symlink_target="$GIT_BUILD_DIR/t/helper/$base"
                                    ;;
                            *)
                                    symlink_target="$GIT_BUILD_DIR/$base"
                                    ;;
                            esac
                            # do not override scripts
                            if test -x "$symlink_target" &&
                            test ! -d "$symlink_target" &&
                            test "#!" != "$(test_copy_bytes 2 <"$symlink_target")"
                            then
                                    symlink_target=../valgrind.sh
                            fi
                            case "$base" in
                            *.sh|*.perl)
                                    symlink_target=../unprocessed-script
                            esac
                            # create the link, or replace it if it is out of date
                            make_symlink "$symlink_target" "$GIT_VALGRIND/bin/$base" || exit
                    }

                    # override all git executables in TEST_DIRECTORY/..
                    GIT_VALGRIND=$TEST_DIRECTORY/valgrind
                    mkdir -p "$GIT_VALGRIND"/bin
                    for file in $GIT_BUILD_DIR/git* $GIT_BUILD_DIR/t/helper/test-*
                    do
                            make_valgrind_symlink $file
                    done
                    # special-case the mergetools loadables
                    make_symlink "$GIT_BUILD_DIR"/mergetools "$GIT_VALGRIND/bin/mergetools"
                    OLDIFS=$IFS
                    IFS=:
                    for path in $PATH
                    do
                            ls "$path"/git-* 2> /dev/null |
                            while read file
                            do
                                    make_valgrind_symlink "$file"
                            done
                    done
                    IFS=$OLDIFS
                    PATH=$GIT_VALGRIND/bin:$PATH
                    GIT_EXEC_PATH=$GIT_VALGRIND/bin
                    export GIT_VALGRIND
                    GIT_VALGRIND_MODE="$valgrind"
                    export GIT_VALGRIND_MODE
                    GIT_VALGRIND_ENABLED=t
                    test -n "$valgrind_only" && GIT_VALGRIND_ENABLED=
                    export GIT_VALGRIND_ENABLED
            elif test -n "$GIT_TEST_INSTALLED"
            then
                    GIT_EXEC_PATH=$($GIT_TEST_INSTALLED/git --exec-path)  ||
                    error "Cannot run git from $GIT_TEST_INSTALLED."
                    PATH=$GIT_TEST_INSTALLED:$GIT_BUILD_DIR/t/helper:$PATH
                    GIT_EXEC_PATH=${GIT_TEST_EXEC_PATH:-$GIT_EXEC_PATH}
            else # normal case, use ../bin-wrappers only unless $with_dashes:
                    if test -n "$no_bin_wrappers"
                    then
                            with_dashes=t
                    else
                            git_bin_dir="$GIT_BUILD_DIR/bin-wrappers"
                            if ! test -x "$git_bin_dir/git"
                            then
                                    if test -z "$with_dashes"
                                    then
                                            say "$git_bin_dir/git is not executable; using GIT_EXEC_PATH"
                                    fi
                                    with_dashes=t
                            fi
                            PATH="$git_bin_dir:$PATH"
                    fi
                    GIT_EXEC_PATH=$GIT_BUILD_DIR
                    if test -n "$with_dashes"
                    then
                            PATH="$GIT_BUILD_DIR:$GIT_BUILD_DIR/t/helper:$PATH"
                    fi
            fi
            GIT_TEMPLATE_DIR="$GIT_TEST_TEMPLATE_DIR"
            GIT_CONFIG_NOSYSTEM=1
            GIT_ATTR_NOSYSTEM=1
            GIT_CEILING_DIRECTORIES="$TRASH_DIRECTORY/.."
            export PATH GIT_EXEC_PATH GIT_TEMPLATE_DIR GIT_CONFIG_NOSYSTEM GIT_ATTR_NOSYSTEM GIT_CEILING_DIRECTORIES

            # Add libc MALLOC and MALLOC_PERTURB test only if we are not executing
            # the test with valgrind and have not compiled with conflict SANITIZE
            # options.
            if test -n "$valgrind" ||
            test -n "$SANITIZE_ADDRESS" ||
            test -n "$SANITIZE_LEAK" ||
            test -n "$TEST_NO_MALLOC_CHECK"
            then
                    setup_malloc_check () {
                            : nothing
                    }
                    teardown_malloc_check () {
                            : nothing
                    }
            else
                    _USE_GLIBC_TUNABLES=
                    _USE_GLIBC_PRELOAD=libc_malloc_debug.so.0
                    if _GLIBC_VERSION=$(getconf GNU_LIBC_VERSION 2>/dev/null) &&
                    _GLIBC_VERSION=${_GLIBC_VERSION#"glibc "} &&
                    expr 2.34 \<= "$_GLIBC_VERSION" >/dev/null &&
                    stderr=$(LD_PRELOAD=$_USE_GLIBC_PRELOAD git version 2>&1 >/dev/null) &&
                    test -z "$stderr"
                    then
                            _USE_GLIBC_TUNABLES=YesPlease
                    fi
                    setup_malloc_check () {
                            local g
                            local t
                            MALLOC_CHECK_=3 MALLOC_PERTURB_=165
                            export MALLOC_CHECK_ MALLOC_PERTURB_
                            if test -n "$_USE_GLIBC_TUNABLES"
                            then
                                    g=
                                    LD_PRELOAD=$_USE_GLIBC_PRELOAD
                                    for t in \
                                            glibc.malloc.check=1 \
                                            glibc.malloc.perturb=165
                                    do
                                            g="${g#:}:$t"
                                    done
                                    GLIBC_TUNABLES=$g
                                    export LD_PRELOAD GLIBC_TUNABLES
                            fi
                    }
                    teardown_malloc_check () {
                            unset MALLOC_CHECK_ MALLOC_PERTURB_
                            unset LD_PRELOAD GLIBC_TUNABLES
                    }
            fi

            if test -z "$GIT_TEST_CMP"
            then
                    if test -n "$GIT_TEST_CMP_USE_COPIED_CONTEXT"
                    then
                            GIT_TEST_CMP="$DIFF -c"
                    else
                            GIT_TEST_CMP="$DIFF -u"
                    fi
            fi

            GITPERLLIB="$GIT_TEST_GITPERLLIB"
            export GITPERLLIB
            test -d "$GIT_TEMPLATE_DIR" || {
                    BAIL_OUT "You haven't built things yet, have you?"
            }

            if ! test -x "$GIT_BUILD_DIR"/t/helper/test-tool$X
            then
                    BAIL_OUT 'You need to build test-tool; Run "make t/helper/test-tool" in the source (toplevel) directory'
            fi

            # Are we running this test at all?
            remove_trash=
            this_test=${0##*/}
            this_test=${this_test%%-*}
            if match_pattern_list "$this_test" "$GIT_SKIP_TESTS"
            then
                    say_color info >&3 "skipping test $this_test altogether"
                    skip_all="skip all tests in $this_test"
                    test_done
            fi

            if test -n "$SANITIZE_LEAK"
            then
                    rm -rf "$TEST_RESULTS_SAN_DIR"
                    if ! mkdir -p "$TEST_RESULTS_SAN_DIR"
                    then
                            BAIL_OUT "cannot create $TEST_RESULTS_SAN_DIR"
                    fi &&
                    TEST_RESULTS_SAN_FILE="$TEST_RESULTS_SAN_DIR/$TEST_RESULTS_SAN_FILE_PFX"

                    # Don't litter *.leak dirs if there was nothing to report
                    test_atexit "rmdir \"$TEST_RESULTS_SAN_DIR\" 2>/dev/null || :"

                    prepend_var LSAN_OPTIONS : dedup_token_length=9999
                    prepend_var LSAN_OPTIONS : log_exe_name=1
                    prepend_var LSAN_OPTIONS : log_path="'$TEST_RESULTS_SAN_FILE'"
                    export LSAN_OPTIONS
            fi

            if test "${GIT_TEST_CHAIN_LINT:-1}" != 0 &&
            test "${GIT_TEST_EXT_CHAIN_LINT:-1}" != 0
            then
                    "$PERL_PATH" "$TEST_DIRECTORY/chainlint.pl" "$0" ||
                            BUG "lint error (see 'LINT' annotations above)"
            fi

            # Last-minute variable setup
            USER_HOME="$HOME"
            HOME="$TRASH_DIRECTORY"
            GNUPGHOME="$HOME/gnupg-home-not-used"
            export HOME GNUPGHOME USER_HOME

            # "rm -rf" existing trash directory, even if a previous run left it
            # with bad permissions.
            remove_trash_directory () {
                    dir="$1"
                    if ! rm -rf "$dir" 2>/dev/null
                    then
                            chmod -R u+rwx "$dir"
                            rm -rf "$dir"
                    fi
                    ! test -d "$dir"
            }

            # Test repository
            remove_trash_directory "$TRASH_DIRECTORY" || {
                    BAIL_OUT 'cannot prepare test area'
            }

            remove_trash=t
            if test -z "$TEST_NO_CREATE_REPO"
            then
                    git init \
                    ${TEST_CREATE_REPO_NO_TEMPLATE:+--template=} \
                    "$TRASH_DIRECTORY" >&3 2>&4 ||
                    error "cannot run git init"
            else
                    mkdir -p "$TRASH_DIRECTORY"
            fi

            # Use -P to resolve symlinks in our working directory so that the cwd
            # in subprocesses like git equals our $PWD (for pathname comparisons).
            cd -P "$TRASH_DIRECTORY" || BAIL_OUT "cannot cd -P to \"$TRASH_DIRECTORY\""

            start_test_output "$0"

            # Convenience
            # A regexp to match 5 and 35 hexdigits
            _x05='[0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f]'
            _x35="$_x05$_x05$_x05$_x05$_x05$_x05$_x05"

            test_oid_init

            ZERO_OID=$(test_oid zero)
            OID_REGEX=$(echo $ZERO_OID | sed -e 's/0/[0-9a-f]/g')
            OIDPATH_REGEX=$(test_oid_to_path $ZERO_OID | sed -e 's/0/[0-9a-f]/g')
            EMPTY_TREE=$(test_oid empty_tree)
            EMPTY_BLOB=$(test_oid empty_blob)

            # Provide an implementation of the 'yes' utility; the upper bound
            # limit is there to help Windows that cannot stop this loop from
            # wasting cycles when the downstream stops reading, so do not be
            # tempted to turn it into an infinite loop. cf. 6129c930 ("test-lib:
            # limit the output of the yes utility", 2016-02-02)
            yes () {
                    if test $# = 0
                    then
                            y=y
                    else
                            y="$*"
                    fi

                    i=0
                    while test $i -lt 99
                    do
                            echo "$y"
                            i=$(($i+1))
                    done
            }

            # The GIT_TEST_FAIL_PREREQS code hooks into test_set_prereq(), and
            # thus needs to be set up really early, and set an internal variable
            # for convenience so the hot test_set_prereq() codepath doesn't need
            # to call "test-tool env-helper" (via test_bool_env). Only do that work
            # if needed by seeing if GIT_TEST_FAIL_PREREQS is set at all.
            GIT_TEST_FAIL_PREREQS_INTERNAL=
            if test -n "$GIT_TEST_FAIL_PREREQS"
            then
                    if test_bool_env GIT_TEST_FAIL_PREREQS false
                    then
                            GIT_TEST_FAIL_PREREQS_INTERNAL=true
                            test_set_prereq FAIL_PREREQS
                    fi
            else
                    test_lazy_prereq FAIL_PREREQS '
                            test_bool_env GIT_TEST_FAIL_PREREQS false
                    '
            fi

            # Fix some commands on Windows, and other OS-specific things
            uname_s=$(uname -s)
            case $uname_s in
            *MINGW*)
                    # Windows has its own (incompatible) sort and find
                    sort () {
                            /usr/bin/sort "$@"
                    }
                    find () {
                            /usr/bin/find "$@"
                    }
                    # git sees Windows-style pwd
                    pwd () {
                            builtin pwd -W
                    }
                    # no POSIX permissions
                    # backslashes in pathspec are converted to '/'
                    # exec does not inherit the PID
                    test_set_prereq MINGW
                    test_set_prereq NATIVE_CRLF
                    test_set_prereq SED_STRIPS_CR
                    test_set_prereq GREP_STRIPS_CR
                    test_set_prereq WINDOWS
                    GIT_TEST_CMP="GIT_DIR=/dev/null git diff --no-index --ignore-cr-at-eol --"
                    ;;
            *CYGWIN*)
                    test_set_prereq POSIXPERM
                    test_set_prereq EXECKEEPSPID
                    test_set_prereq CYGWIN
                    test_set_prereq SED_STRIPS_CR
                    test_set_prereq GREP_STRIPS_CR
                    test_set_prereq WINDOWS
                    ;;
            *)
                    test_set_prereq POSIXPERM
                    test_set_prereq BSLASHPSPEC
                    test_set_prereq EXECKEEPSPID
                    ;;
            esac

            # Detect arches where a few things don't work
            uname_m=$(uname -m)
            case $uname_m in
            parisc* | hppa*)
                    test_set_prereq HPPA
                    ;;
            esac

            case "$GIT_DEFAULT_REF_FORMAT" in
            files)
                    test_set_prereq REFFILES;;
            reftable)
                    test_set_prereq REFTABLE;;
            *)
                    echo 2>&1 "error: unknown ref format $GIT_DEFAULT_REF_FORMAT"
                    exit 1
                    ;;
            esac

            ( COLUMNS=1 && test $COLUMNS = 1 ) && test_set_prereq COLUMNS_CAN_BE_1
            test -z "$NO_CURL" && test_set_prereq LIBCURL
            test -z "$NO_GITWEB" && test_set_prereq GITWEB
            test -z "$NO_ICONV" && test_set_prereq ICONV
            test -z "$NO_PERL" && test_set_prereq PERL
            test -z "$NO_PTHREADS" && test_set_prereq PTHREADS
            test -z "$NO_PYTHON" && test_set_prereq PYTHON
            test -n "$USE_LIBPCRE2" && test_set_prereq PCRE
            test -n "$USE_LIBPCRE2" && test_set_prereq LIBPCRE2
            test -z "$NO_GETTEXT" && test_set_prereq GETTEXT
            test -n "$SANITIZE_LEAK" && test_set_prereq SANITIZE_LEAK
            test -n "$GIT_VALGRIND_ENABLED" && test_set_prereq VALGRIND

            if test -z "$GIT_TEST_CHECK_CACHE_TREE"
            then
                    GIT_TEST_CHECK_CACHE_TREE=true
                    export GIT_TEST_CHECK_CACHE_TREE
            fi

            test_lazy_prereq PIPE '
                    # test whether the filesystem supports FIFOs
                    test_have_prereq !MINGW,!CYGWIN &&
                    rm -f testfifo && mkfifo testfifo
            '

            test_lazy_prereq SYMLINKS '
                    # test whether the filesystem supports symbolic links
                    ln -s x y && test -h y
            '

            test_lazy_prereq SYMLINKS_WINDOWS '
                    # test whether symbolic links are enabled on Windows
                    test_have_prereq MINGW &&
                    cmd //c "mklink y x" &> /dev/null && test -h y
            '

            test_lazy_prereq FILEMODE '
                    test "$(git config --bool core.filemode)" = true
            '

            test_lazy_prereq CASE_INSENSITIVE_FS '
                    echo good >CamelCase &&
                    echo bad >camelcase &&
                    test "$(cat CamelCase)" != good
            '

            test_lazy_prereq FUNNYNAMES '
                    test_have_prereq !MINGW &&
                    touch -- \
                            "FUNNYNAMES tab embedded" \
                            "FUNNYNAMES \"quote embedded\"" \
                            "FUNNYNAMES newline
            embedded" 2>/dev/null &&
                    rm -- \
                            "FUNNYNAMES tab embedded" \
                            "FUNNYNAMES \"quote embedded\"" \
                            "FUNNYNAMES newline
            embedded" 2>/dev/null
            '

            test_lazy_prereq UTF8_NFD_TO_NFC '
                    # check whether FS converts nfd unicode to nfc
                    auml=$(printf "\303\244")
                    aumlcdiar=$(printf "\141\314\210")
                    >"$auml" &&
                    test -f "$aumlcdiar"
            '

            test_lazy_prereq AUTOIDENT '
                    sane_unset GIT_AUTHOR_NAME &&
                    sane_unset GIT_AUTHOR_EMAIL &&
                    git var GIT_AUTHOR_IDENT
            '

            test_lazy_prereq EXPENSIVE '
                    test -n "$GIT_TEST_LONG"
            '

            test_lazy_prereq EXPENSIVE_ON_WINDOWS '
                    test_have_prereq EXPENSIVE || test_have_prereq !MINGW,!CYGWIN
            '

            test_lazy_prereq USR_BIN_TIME '
                    test -x /usr/bin/time
            '

            test_lazy_prereq NOT_ROOT '
                    uid=$(id -u) &&
                    test "$uid" != 0
            '

            test_lazy_prereq JGIT '
                    jgit --version
            '

            # SANITY is about "can you correctly predict what the filesystem would
            # do by only looking at the permission bits of the files and
            # directories?"  A typical example of !SANITY is running the test
            # suite as root, where a test may expect "chmod -r file && cat file"
            # to fail because file is supposed to be unreadable after a successful
            # chmod.  In an environment (i.e. combination of what filesystem is
            # being used and who is running the tests) that lacks SANITY, you may
            # be able to delete or create a file when the containing directory
            # doesn't have write permissions, or access a file even if the
            # containing directory doesn't have read or execute permissions.

            test_lazy_prereq SANITY '
                    mkdir SANETESTD.1 SANETESTD.2 &&

                    chmod +w SANETESTD.1 SANETESTD.2 &&
                    >SANETESTD.1/x 2>SANETESTD.2/x &&
                    chmod -w SANETESTD.1 &&
                    chmod -r SANETESTD.1/x &&
                    chmod -rx SANETESTD.2 ||
                    BUG "cannot prepare SANETESTD"

                    ! test -r SANETESTD.1/x &&
                    ! rm SANETESTD.1/x && ! test -f SANETESTD.2/x
                    status=$?

                    chmod +rwx SANETESTD.1 SANETESTD.2 &&
                    rm -rf SANETESTD.1 SANETESTD.2 ||
                    BUG "cannot clean SANETESTD"
                    return $status
            '

            test FreeBSD != $uname_s || GIT_UNZIP=${GIT_UNZIP:-/usr/local/bin/unzip}
            GIT_UNZIP=${GIT_UNZIP:-unzip}
            test_lazy_prereq UNZIP '
                    "$GIT_UNZIP" -v
                    test $? -ne 127
            '

            run_with_limited_cmdline () {
                    (ulimit -s 128 && "$@")
            }

            test_lazy_prereq CMDLINE_LIMIT '
                    test_have_prereq !HPPA,!MINGW,!CYGWIN &&
                    run_with_limited_cmdline true
            '

            run_with_limited_stack () {
                    (ulimit -s 128 && "$@")
            }

            test_lazy_prereq ULIMIT_STACK_SIZE '
                    test_have_prereq !HPPA,!MINGW,!CYGWIN &&
                    run_with_limited_stack true
            '

            run_with_limited_open_files () {
                    (ulimit -n 32 && "$@")
            }

            test_lazy_prereq ULIMIT_FILE_DESCRIPTORS '
                    test_have_prereq !MINGW,!CYGWIN &&
                    run_with_limited_open_files true
            '

            build_option () {
                    git version --build-options |
                    sed -ne "s/^$1: //p"
            }

            test_lazy_prereq SIZE_T_IS_64BIT '
                    test 8 -eq "$(build_option sizeof-size_t)"
            '

            test_lazy_prereq LONG_IS_64BIT '
                    test 8 -le "$(build_option sizeof-long)"
            '

            test_lazy_prereq TIME_IS_64BIT 'test-tool date is64bit'
            test_lazy_prereq TIME_T_IS_64BIT 'test-tool date time_t-is64bit'

            test_lazy_prereq CURL '
                    curl --version
            '

            # SHA1 is a test if the hash algorithm in use is SHA-1.  This is both for tests
            # which will not work with other hash algorithms and tests that work but don't
            # test anything meaningful (e.g. special values which cause short collisions).
            test_lazy_prereq SHA1 '
                    case "$GIT_DEFAULT_HASH" in
                    sha1) true ;;
                    "") test $(git hash-object /dev/null) = e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 ;;
                    *) false ;;
                    esac
            '

            test_lazy_prereq DEFAULT_REPO_FORMAT '
                    test_have_prereq SHA1,REFFILES
            '

            # Ensure that no test accidentally triggers a Git command
            # that runs the actual maintenance scheduler, affecting a user's
            # system permanently.
            # Tests that verify the scheduler integration must set this locally
            # to avoid errors.
            GIT_TEST_MAINT_SCHEDULER="none:exit 1"
            export GIT_TEST_MAINT_SCHEDULER

            # Does this platform support `git fsmonitor--daemon`
            #
            test_lazy_prereq FSMONITOR_DAEMON '
                    git version --build-options >output &&
                    grep "feature: fsmonitor--daemon" output


            """,
            "Error":"The script uses the logical path to navigate to TRASH_DIRECTORY, ensuring consistent behavior across platforms.
                    The test suite becomes more robust and reliable, as it avoids potential issues with symlink resolution.",

            "Error Category":"Functionality Patche",

            "Corrected Code":
            """
            # Test framework for git.  See t/README for usage.
            #
            # Copyright (c) 2005 Junio C Hamano
            #
            # This program is free software: you can redistribute it and/or modify
            # it under the terms of the GNU General Public License as published by
            # the Free Software Foundation, either version 2 of the License, or
            # (at your option) any later version.
            #
            # This program is distributed in the hope that it will be useful,
            # but WITHOUT ANY WARRANTY; without even the implied warranty of
            # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
            # GNU General Public License for more details.
            #
            # You should have received a copy of the GNU General Public License
            # along with this program.  If not, see https://www.gnu.org/licenses/ .

            # Test the binaries we have just built.  The tests are kept in
            # t/ subdirectory and are run in 'trash directory' subdirectory.
            if test -z "$TEST_DIRECTORY"
            then
                    # ensure that TEST_DIRECTORY is an absolute path so that it
                    # is valid even if the current working directory is changed
                    TEST_DIRECTORY=$(pwd)
            else
                    # The TEST_DIRECTORY will always be the path to the "t"
                    # directory in the git.git checkout. This is overridden by
                    # e.g. t/lib-subtest.sh, but only because its $(pwd) is
                    # different. Those tests still set "$TEST_DIRECTORY" to the
                    # same path.
                    #
                    # See use of "$GIT_BUILD_DIR" and "$TEST_DIRECTORY" below for
                    # hard assumptions about "$GIT_BUILD_DIR/t" existing and being
                    # the "$TEST_DIRECTORY", and e.g. "$TEST_DIRECTORY/helper"
                    # needing to exist.
                    TEST_DIRECTORY=$(cd "$TEST_DIRECTORY" && pwd) || exit 1
            fi
            GIT_BUILD_DIR="${GIT_BUILD_DIR:-${TEST_DIRECTORY%/t}}"
            if test "$TEST_DIRECTORY" = "$GIT_BUILD_DIR"
            then
                    echo "PANIC: Running in a $TEST_DIRECTORY that doesn't end in '/t'?" >&2
                    exit 1
            fi
            if test -f "$GIT_BUILD_DIR/GIT-BUILD-DIR"
            then
                    GIT_BUILD_DIR="$(cat "$GIT_BUILD_DIR/GIT-BUILD-DIR")" || exit 1
                    # On Windows, we must convert Windows paths lest they contain a colon
                    case "$(uname -s)" in
                    *MINGW*)
                            GIT_BUILD_DIR="$(cygpath -au "$GIT_BUILD_DIR")"
                            ;;
                    esac
            fi

            # Prepend a string to a VAR using an arbitrary ":" delimiter, not
            # adding the delimiter if VAR or VALUE is empty. I.e. a generalized:
            #
            #       VAR=$1${VAR:+${1:+$2}$VAR}
            #
            # Usage (using ":" as the $2 delimiter):
            #
            #       prepend_var VAR : VALUE
            prepend_var () {
                    eval "$1=\"$3\${$1:+${3:+$2}\$$1}\""
            }

            # If [AL]SAN is in effect we want to abort so that we notice
            # problems. The GIT_SAN_OPTIONS variable can be used to set common
            # defaults shared between [AL]SAN_OPTIONS.
            prepend_var GIT_SAN_OPTIONS : abort_on_error=1
            prepend_var GIT_SAN_OPTIONS : strip_path_prefix="$GIT_BUILD_DIR/"

            # If we were built with ASAN, it may complain about leaks
            # of program-lifetime variables. Disable it by default to lower
            # the noise level. This needs to happen at the start of the script,
            # before we even do our "did we build git yet" check (since we don't
            # want that one to complain to stderr).
            prepend_var ASAN_OPTIONS : $GIT_SAN_OPTIONS
            prepend_var ASAN_OPTIONS : detect_leaks=0
            export ASAN_OPTIONS

            prepend_var LSAN_OPTIONS : $GIT_SAN_OPTIONS
            prepend_var LSAN_OPTIONS : exitcode=0
            prepend_var LSAN_OPTIONS : fast_unwind_on_malloc=0
            export LSAN_OPTIONS

            prepend_var UBSAN_OPTIONS : $GIT_SAN_OPTIONS
            export UBSAN_OPTIONS

            # The TEST_OUTPUT_DIRECTORY will be overwritten via GIT-BUILD-OPTIONS. So in
            # case the caller has manually set up this variable via the environment we must
            # make sure to not overwrite that value, and thus we save it into
            # TEST_OUTPUT_DIRECTORY_OVERRIDE here.
            if test -n "$TEST_OUTPUT_DIRECTORY" && test -z "$TEST_OUTPUT_DIRECTORY_OVERRIDE"
            then
                    TEST_OUTPUT_DIRECTORY_OVERRIDE=$TEST_OUTPUT_DIRECTORY
            fi

            if test ! -f "$GIT_BUILD_DIR"/GIT-BUILD-OPTIONS
            then
                    echo >&2 'error: GIT-BUILD-OPTIONS missing (has Git been built?).'
                    exit 1
            fi
            . "$GIT_BUILD_DIR"/GIT-BUILD-OPTIONS
            export PERL_PATH SHELL_PATH

            if test -z "$TEST_OUTPUT_DIRECTORY"
            then
                    # Similarly, override this to store the test-results subdir
                    # elsewhere
                    TEST_OUTPUT_DIRECTORY=$TEST_DIRECTORY
            fi

            # In t0000, we need to override test directories of nested testcases. In case
            # the developer has TEST_OUTPUT_DIRECTORY part of his build options, then we'd
            # reset this value to instead contain what the developer has specified. We thus
            # have this knob to allow overriding the directory.
            if test -n "${TEST_OUTPUT_DIRECTORY_OVERRIDE}"
            then
                    TEST_OUTPUT_DIRECTORY="${TEST_OUTPUT_DIRECTORY_OVERRIDE}"
            fi

            # Disallow the use of abbreviated options in the test suite by default
            if test -z "${GIT_TEST_DISALLOW_ABBREVIATED_OPTIONS}"
            then
                    GIT_TEST_DISALLOW_ABBREVIATED_OPTIONS=true
                    export GIT_TEST_DISALLOW_ABBREVIATED_OPTIONS
            fi

            # Explicitly set the default branch name for testing, to avoid the
            # transitory "git init" warning under --verbose.
            : ${GIT_TEST_DEFAULT_INITIAL_BRANCH_NAME:=master}
            export GIT_TEST_DEFAULT_INITIAL_BRANCH_NAME

            ################################################################
            # It appears that people try to run tests without building...
            "${GIT_TEST_INSTALLED:-$GIT_BUILD_DIR}/git$X" >/dev/null
            if test $? != 1
            then
                    if test -n "$GIT_TEST_INSTALLED"
                    then
                            echo >&2 "error: there is no working Git at '$GIT_TEST_INSTALLED'"
                    else
                            echo >&2 'error: you do not seem to have built git yet.'
                    fi
                    exit 1
            fi

            store_arg_to=
            opt_required_arg=
            # $1: option string
            # $2: name of the var where the arg will be stored
            mark_option_requires_arg () {
                    if test -n "$opt_required_arg"
                    then
                            echo "error: options that require args cannot be bundled" \
                                    "together: '$opt_required_arg' and '$1'" >&2
                            exit 1
                    fi
                    opt_required_arg=$1
                    store_arg_to=$2
            }

            # These functions can be overridden e.g. to output JUnit XML
            start_test_output () { :; }
            start_test_case_output () { :; }
            finalize_test_case_output () { :; }
            finalize_test_output () { :; }

            parse_option () {
                    local opt="$1"

                    case "$opt" in
                    -d|--d|--de|--deb|--debu|--debug)
                            debug=t ;;
                    -i|--i|--im|--imm|--imme|--immed|--immedi|--immedia|--immediat|--immediate)
                            immediate=t ;;
                    -l|--l|--lo|--lon|--long|--long-|--long-t|--long-te|--long-tes|--long-test|--long-tests)
                            GIT_TEST_LONG=t; export GIT_TEST_LONG ;;
                    -r)
                            mark_option_requires_arg "$opt" run_list
                            ;;
                    --run=*)
                            run_list=${opt#--*=} ;;
                    -h|--h|--he|--hel|--help)
                            help=t ;;
                    -v|--v|--ve|--ver|--verb|--verbo|--verbos|--verbose)
                            verbose=t ;;
                    --verbose-only=*)
                            verbose_only=${opt#--*=}
                            ;;
                    -q|--q|--qu|--qui|--quie|--quiet)
                            # Ignore --quiet under a TAP::Harness. Saying how many tests
                            # passed without the ok/not ok details is always an error.
                            test -z "$HARNESS_ACTIVE" && quiet=t ;;
                    --with-dashes)
                            with_dashes=t ;;
                    --no-bin-wrappers)
                            no_bin_wrappers=t ;;
                    --no-color)
                            color= ;;
                    --va|--val|--valg|--valgr|--valgri|--valgrin|--valgrind)
                            valgrind=memcheck
                            tee=t
                            ;;
                    --valgrind=*)
                            valgrind=${opt#--*=}
                            tee=t
                            ;;
                    --valgrind-only=*)
                            valgrind_only=${opt#--*=}
                            tee=t
                            ;;
                    --tee)
                            tee=t ;;
                    --root=*)
                            root=${opt#--*=} ;;
                    --chain-lint)
                            GIT_TEST_CHAIN_LINT=1 ;;
                    --no-chain-lint)
                            GIT_TEST_CHAIN_LINT=0 ;;
                    -x)
                            trace=t ;;
                    -V|--verbose-log)
                            verbose_log=t
                            tee=t
                            ;;
                    --write-junit-xml)
                            . "$TEST_DIRECTORY/test-lib-junit.sh"
                            ;;
                    --github-workflow-markup)
                            . "$TEST_DIRECTORY/test-lib-github-workflow-markup.sh"
                            ;;
                    --stress)
                            stress=t ;;
                    --stress=*)
                            echo "error: --stress does not accept an argument: '$opt'" >&2
                            echo "did you mean --stress-jobs=${opt#*=} or --stress-limit=${opt#*=}?" >&2
                            exit 1
                            ;;
                    --stress-jobs=*)
                            stress=t;
                            stress_jobs=${opt#--*=}
                            case "$stress_jobs" in
                            *[!0-9]*|0*|"")
                                    echo "error: --stress-jobs=<N> requires the number of jobs to run" >&2
                                    exit 1
                                    ;;
                            *)      # Good.
                                    ;;
                            esac
                            ;;
                    --stress-limit=*)
                            stress=t;
                            stress_limit=${opt#--*=}
                            case "$stress_limit" in
                            *[!0-9]*|0*|"")
                                    echo "error: --stress-limit=<N> requires the number of repetitions" >&2
                                    exit 1
                                    ;;
                            *)      # Good.
                                    ;;
                            esac
                            ;;
                    --invert-exit-code)
                            invert_exit_code=t
                            ;;
                    *)
                            echo "error: unknown test option '$opt'" >&2; exit 1 ;;
                    esac
            }

            # Parse options while taking care to leave $@ intact, so we will still
            # have all the original command line options when executing the test
            # script again for '--tee' and '--verbose-log' later.
            for opt
            do
                    if test -n "$store_arg_to"
                    then
                            eval $store_arg_to=\$opt
                            store_arg_to=
                            opt_required_arg=
                            continue
                    fi

                    case "$opt" in
                    --*|-?)
                            parse_option "$opt" ;;
                    -?*)
                            # bundled short options must be fed separately to parse_option
                            opt=${opt#-}
                            while test -n "$opt"
                            do
                                    extra=${opt#?}
                                    this=${opt%$extra}
                                    opt=$extra
                                    parse_option "-$this"
                            done
                            ;;
                    *)
                            echo "error: unknown test option '$opt'" >&2; exit 1 ;;
                    esac
            done
            if test -n "$store_arg_to"
            then
                    echo "error: $opt_required_arg requires an argument" >&2
                    exit 1
            fi

            if test -n "$valgrind_only"
            then
                    test -z "$valgrind" && valgrind=memcheck
                    test -z "$verbose" && verbose_only="$valgrind_only"
            elif test -n "$valgrind"
            then
                    test -z "$verbose_log" && verbose=t
            fi

            if test -n "$stress"
            then
                    verbose=t
                    trace=t
                    immediate=t
            fi

            TEST_STRESS_JOB_SFX="${GIT_TEST_STRESS_JOB_NR:+.stress-$GIT_TEST_STRESS_JOB_NR}"
            TEST_NAME="$(basename "$0" .sh)"
            TEST_NUMBER="${TEST_NAME%%-*}"
            TEST_NUMBER="${TEST_NUMBER#t}"
            TEST_RESULTS_DIR="$TEST_OUTPUT_DIRECTORY/test-results"
            TEST_RESULTS_BASE="$TEST_RESULTS_DIR/$TEST_NAME$TEST_STRESS_JOB_SFX"
            TEST_RESULTS_SAN_FILE_PFX=trace
            TEST_RESULTS_SAN_DIR_SFX=leak
            TEST_RESULTS_SAN_FILE=
            TEST_RESULTS_SAN_DIR="$TEST_RESULTS_BASE.$TEST_RESULTS_SAN_DIR_SFX"
            TRASH_DIRECTORY="trash directory.$TEST_NAME$TEST_STRESS_JOB_SFX"
            test -n "$root" && TRASH_DIRECTORY="$root/$TRASH_DIRECTORY"
            case "$TRASH_DIRECTORY" in
            /*) ;; # absolute path is good
            *) TRASH_DIRECTORY="$TEST_OUTPUT_DIRECTORY/$TRASH_DIRECTORY" ;;
            esac

            # If --stress was passed, run this test repeatedly in several parallel loops.
            if test "$GIT_TEST_STRESS_STARTED" = "done"
            then
                    : # Don't stress test again.
            elif test -n "$stress"
            then
                    if test -n "$stress_jobs"
                    then
                            job_count=$stress_jobs
                    elif test -n "$GIT_TEST_STRESS_LOAD"
                    then
                            job_count="$GIT_TEST_STRESS_LOAD"
                    elif job_count=$(getconf _NPROCESSORS_ONLN 2>/dev/null) &&
                    test -n "$job_count"
                    then
                            job_count=$((2 * $job_count))
                    else
                            job_count=8
                    fi

                    mkdir -p "$TEST_RESULTS_DIR"
                    stressfail="$TEST_RESULTS_BASE.stress-failed"
                    rm -f "$stressfail"

                    stress_exit=0
                    trap '
                            kill $job_pids 2>/dev/null
                            wait
                            stress_exit=1
                    ' TERM INT HUP

                    job_pids=
                    job_nr=0
                    while test $job_nr -lt "$job_count"
                    do
                            (
                                    GIT_TEST_STRESS_STARTED=done
                                    GIT_TEST_STRESS_JOB_NR=$job_nr
                                    export GIT_TEST_STRESS_STARTED GIT_TEST_STRESS_JOB_NR

                                    trap '
                                            kill $test_pid 2>/dev/null
                                            wait
                                            exit 1
                                    ' TERM INT

                                    cnt=1
                                    while ! test -e "$stressfail" &&
                                    { test -z "$stress_limit" ||
                                            test $cnt -le $stress_limit ; }
                                    do
                                            $TEST_SHELL_PATH "$0" "$@" >"$TEST_RESULTS_BASE.stress-$job_nr.out" 2>&1 &
                                            test_pid=$!

                                            if wait $test_pid
                                            then
                                                    printf "OK   %2d.%d\n" $GIT_TEST_STRESS_JOB_NR $cnt
                                            else
                                                    echo $GIT_TEST_STRESS_JOB_NR >>"$stressfail"
                                                    printf "FAIL %2d.%d\n" $GIT_TEST_STRESS_JOB_NR $cnt
                                            fi
                                            cnt=$(($cnt + 1))
                                    done
                            ) &
                            job_pids="$job_pids $!"
                            job_nr=$(($job_nr + 1))
                    done

                    wait

                    if test -f "$stressfail"
                    then
                            stress_exit=1
                            echo "Log(s) of failed test run(s):"
                            for failed_job_nr in $(sort -n "$stressfail")
                            do
                                    echo "Contents of '$TEST_RESULTS_BASE.stress-$failed_job_nr.out':"
                                    cat "$TEST_RESULTS_BASE.stress-$failed_job_nr.out"
                            done
                            rm -rf "$TRASH_DIRECTORY.stress-failed"
                            # Move the last one.
                            mv "$TRASH_DIRECTORY.stress-$failed_job_nr" "$TRASH_DIRECTORY.stress-failed"
                    fi

                    exit $stress_exit
            fi

            # if --tee was passed, write the output not only to the terminal, but
            # additionally to the file test-results/$BASENAME.out, too.
            if test "$GIT_TEST_TEE_STARTED" = "done"
            then
                    : # do not redirect again
            elif test -n "$tee"
            then
                    mkdir -p "$TEST_RESULTS_DIR"

                    # Make this filename available to the sub-process in case it is using
                    # --verbose-log.
                    GIT_TEST_TEE_OUTPUT_FILE=$TEST_RESULTS_BASE.out
                    export GIT_TEST_TEE_OUTPUT_FILE

                    # Truncate before calling "tee -a" to get rid of the results
                    # from any previous runs.
                    >"$GIT_TEST_TEE_OUTPUT_FILE"

                    (GIT_TEST_TEE_STARTED=done ${TEST_SHELL_PATH} "$0" "$@" 2>&1;
                    echo $? >"$TEST_RESULTS_BASE.exit") | tee -a "$GIT_TEST_TEE_OUTPUT_FILE"
                    test "$(cat "$TEST_RESULTS_BASE.exit")" = 0
                    exit
            fi

            if test -n "$trace" && test -n "$test_untraceable"
            then
                    # '-x' tracing requested, but this test script can't be reliably
                    # traced, unless it is run with a Bash version supporting
                    # BASH_XTRACEFD (introduced in Bash v4.1).
                    #
                    # Perform this version check _after_ the test script was
                    # potentially re-executed with $TEST_SHELL_PATH for '--tee' or
                    # '--verbose-log', so the right shell is checked and the
                    # warning is issued only once.
                    if test -n "$BASH_VERSION" && eval '
                    test ${BASH_VERSINFO[0]} -gt 4 || {
                    test ${BASH_VERSINFO[0]} -eq 4 &&
                    test ${BASH_VERSINFO[1]} -ge 1
                    }
                    '
                    then
                            : Executed by a Bash version supporting BASH_XTRACEFD.  Good.
                    else
                            echo >&2 "warning: ignoring -x; '$0' is untraceable without BASH_XTRACEFD"
                            trace=
                    fi
            fi
            if test -n "$trace" && test -z "$verbose_log"
            then
                    verbose=t
            fi

            # Since bash 5.0, checkwinsize is enabled by default which does
            # update the COLUMNS variable every time a non-builtin command
            # completes, even for non-interactive shells.
            # Disable that since we are aiming for repeatability.
            test -n "$BASH_VERSION" && shopt -u checkwinsize 2>/dev/null

            # For repeatability, reset the environment to known value.
            # TERM is sanitized below, after saving color control sequences.
            LANG=C
            LC_ALL=C
            PAGER=cat
            TZ=UTC
            COLUMNS=80
            export LANG LC_ALL PAGER TZ COLUMNS
            EDITOR=:

            # A call to "unset" with no arguments causes at least Solaris 10
            # /usr/xpg4/bin/sh and /bin/ksh to bail out.  So keep the unsets
            # deriving from the command substitution clustered with the other
            # ones.
            unset VISUAL EMAIL LANGUAGE $("$PERL_PATH" -e '
                    my @env = keys %ENV;
                    my $ok = join("|", qw(
                            TRACE
                            DEBUG
                            TEST
                            .*_TEST
                            PROVE
                            VALGRIND
                            UNZIP
                            PERF_
                            CURL_VERBOSE
                            TRACE_CURL
                            BUILD_DIR
                    ));
                    my @vars = grep(/^GIT_/ && !/^GIT_($ok)/o, @env);
                    print join("\n", @vars);
            ')
            unset XDG_CACHE_HOME
            unset XDG_CONFIG_HOME
            unset GITPERLLIB
            unset GIT_TRACE2_PARENT_NAME
            unset GIT_TRACE2_PARENT_SID
            TEST_AUTHOR_LOCALNAME=author
            TEST_AUTHOR_DOMAIN=example.com
            GIT_AUTHOR_EMAIL=${TEST_AUTHOR_LOCALNAME}@${TEST_AUTHOR_DOMAIN}
            GIT_AUTHOR_NAME='A U Thor'
            GIT_AUTHOR_DATE='1112354055 +0200'
            TEST_COMMITTER_LOCALNAME=committer
            TEST_COMMITTER_DOMAIN=example.com
            GIT_COMMITTER_EMAIL=${TEST_COMMITTER_LOCALNAME}@${TEST_COMMITTER_DOMAIN}
            GIT_COMMITTER_NAME='C O Mitter'
            GIT_COMMITTER_DATE='1112354055 +0200'
            GIT_MERGE_VERBOSITY=5
            GIT_MERGE_AUTOEDIT=no
            export GIT_MERGE_VERBOSITY GIT_MERGE_AUTOEDIT
            export GIT_AUTHOR_EMAIL GIT_AUTHOR_NAME
            export GIT_COMMITTER_EMAIL GIT_COMMITTER_NAME
            export GIT_COMMITTER_DATE GIT_AUTHOR_DATE
            export EDITOR

            GIT_DEFAULT_HASH="${GIT_TEST_DEFAULT_HASH:-sha1}"
            export GIT_DEFAULT_HASH
            GIT_DEFAULT_REF_FORMAT="${GIT_TEST_DEFAULT_REF_FORMAT:-files}"
            export GIT_DEFAULT_REF_FORMAT
            GIT_TEST_MERGE_ALGORITHM="${GIT_TEST_MERGE_ALGORITHM:-ort}"
            export GIT_TEST_MERGE_ALGORITHM

            # Tests using GIT_TRACE typically don't want <timestamp> <file>:<line> output
            GIT_TRACE_BARE=1
            export GIT_TRACE_BARE

            # Some tests scan the GIT_TRACE2_EVENT feed for events, but the
            # default depth is 2, which frequently causes issues when the
            # events are wrapped in new regions. Set it to a sufficiently
            # large depth to avoid custom changes in the test suite.
            GIT_TRACE2_EVENT_NESTING=100
            export GIT_TRACE2_EVENT_NESTING

            # Use specific version of the index file format
            if test -n "${GIT_TEST_INDEX_VERSION:+isset}"
            then
                    GIT_INDEX_VERSION="$GIT_TEST_INDEX_VERSION"
                    export GIT_INDEX_VERSION
            fi

            if test -n "$GIT_TEST_PERL_FATAL_WARNINGS"
            then
                    GIT_PERL_FATAL_WARNINGS=1
                    export GIT_PERL_FATAL_WARNINGS
            fi

            case $GIT_TEST_FSYNC in
            '')
                    GIT_TEST_FSYNC=0
                    export GIT_TEST_FSYNC
                    ;;
            esac

            # Protect ourselves from common misconfiguration to export
            # CDPATH into the environment
            unset CDPATH

            unset GREP_OPTIONS
            unset UNZIP

            case $(echo $GIT_TRACE |tr "[A-Z]" "[a-z]") in
            1|2|true)
                    GIT_TRACE=4
                    ;;
            esac

            # Line feed
            LF='
            '

            # Single quote
            SQ=\'

            # UTF-8 ZERO WIDTH NON-JOINER, which HFS+ ignores
            # when case-folding filenames
            u200c=$(printf '\342\200\214')

            export _x05 _x35 LF u200c EMPTY_TREE EMPTY_BLOB ZERO_OID OID_REGEX

            test "x$TERM" != "xdumb" && (
                            test -t 1 &&
                            tput bold >/dev/null 2>&1 &&
                            tput setaf 1 >/dev/null 2>&1 &&
                            tput sgr0 >/dev/null 2>&1
                    ) &&
                    color=t

            if test -n "$color"
            then
                    # Save the color control sequences now rather than run tput
                    # each time say_color() is called.  This is done for two
                    # reasons:
                    #   * TERM will be changed to dumb
                    #   * HOME will be changed to a temporary directory and tput
                    #     might need to read ~/.terminfo from the original HOME
                    #     directory to get the control sequences
                    # Note:  This approach assumes the control sequences don't end
                    # in a newline for any terminal of interest (command
                    # substitutions strip trailing newlines).  Given that most
                    # (all?) terminals in common use are related to ECMA-48, this
                    # shouldn't be a problem.
                    say_color_error=$(tput bold; tput setaf 1) # bold red
                    say_color_skip=$(tput setaf 4) # blue
                    say_color_warn=$(tput setaf 3) # brown/yellow
                    say_color_pass=$(tput setaf 2) # green
                    say_color_info=$(tput setaf 6) # cyan
                    say_color_reset=$(tput sgr0)
                    say_color_="" # no formatting for normal text
                    say_color () {
                            test -z "$1" && test -n "$quiet" && return
                            eval "say_color_color=\$say_color_$1"
                            shift
                            printf "%s\\n" "$say_color_color$*$say_color_reset"
                    }
            else
                    say_color() {
                            test -z "$1" && test -n "$quiet" && return
                            shift
                            printf "%s\n" "$*"
                    }
            fi

            USER_TERM="$TERM"
            TERM=dumb
            export TERM USER_TERM

            # What is written by tests to stdout and stderr is sent to different places
            # depending on the test mode (e.g. /dev/null in non-verbose mode, piped to tee
            # with --tee option, etc.). We save the original stdin to FD #6 and stdout and
            # stderr to #5 and #7, so that the test framework can use them (e.g. for
            # printing errors within the test framework) independently of the test mode.
            exec 5>&1
            exec 6<&0
            exec 7>&2

            _error_exit () {
                    finalize_test_output
                    GIT_EXIT_OK=t
                    exit 1
            }

            error () {
                    say_color error "error: $*"
                    _error_exit
            }

            BUG () {
                    error >&7 "bug in the test script: $*"
            }

            BAIL_OUT () {
                    test $# -ne 1 && BUG "1 param"

                    # Do not change "Bail out! " string. It's part of TAP syntax:
                    # https://testanything.org/tap-specification.html
                    local bail_out="Bail out! "
                    local message="$1"

                    say_color >&5 error $bail_out "$message"
                    _error_exit
            }

            say () {
                    say_color info "$*"
            }

            if test -n "$HARNESS_ACTIVE"
            then
                    if test "$verbose" = t || test -n "$verbose_only"
                    then
                            BAIL_OUT 'verbose mode forbidden under TAP harness; try --verbose-log'
                    fi
            fi

            test "${test_description}" != "" ||
            error "Test script did not set test_description."

            if test "$help" = "t"
            then
                    printf '%s\n' "$test_description"
                    exit 0
            fi

            if test "$verbose_log" = "t"
            then
                    exec 3>>"$GIT_TEST_TEE_OUTPUT_FILE" 4>&3
            elif test "$verbose" = "t"
            then
                    exec 4>&2 3>&1
            else
                    exec 4>/dev/null 3>/dev/null
            fi

            # Send any "-x" output directly to stderr to avoid polluting tests
            # which capture stderr. We can do this unconditionally since it
            # has no effect if tracing isn't turned on.
            #
            # Note that this sets up the trace fd as soon as we assign the variable, so it
            # must come after the creation of descriptor 4 above. Likewise, we must never
            # unset this, as it has the side effect of closing descriptor 4, which we
            # use to show verbose tests to the user.
            #
            # Note also that we don't need or want to export it. The tracing is local to
            # this shell, and we would not want to influence any shells we exec.
            BASH_XTRACEFD=4

            test_failure=0
            test_count=0
            test_fixed=0
            test_broken=0
            test_success=0

            test_missing_prereq=

            test_external_has_tap=0

            die () {
                    code=$?
                    # This is responsible for running the atexit commands even when a
                    # test script run with '--immediate' fails, or when the user hits
                    # ctrl-C, i.e. when 'test_done' is not invoked at all.
                    test_atexit_handler || code=$?
                    if test -n "$GIT_EXIT_OK"
                    then
                            exit $code
                    else
                            echo >&5 "FATAL: Unexpected exit with code $code"
                            exit 1
                    fi
            }

            GIT_EXIT_OK=
            trap 'die' EXIT
            # Disable '-x' tracing, because with some shells, notably dash, it
            # prevents running the cleanup commands when a test script run with
            # '--verbose-log -x' is interrupted.
            trap '{ code=$?; set +x; } 2>/dev/null; exit $code' INT TERM HUP

            # The user-facing functions are loaded from a separate file so that
            # test_perf subshells can have them too
            . "$TEST_DIRECTORY/test-lib-functions.sh"

            # You are not expected to call test_ok_ and test_failure_ directly, use
            # the test_expect_* functions instead.

            test_ok_ () {
                    test_success=$(($test_success + 1))
                    say_color "" "ok $test_count - $@"
                    finalize_test_case_output ok "$@"
            }

            _invert_exit_code_failure_end_blurb () {
                    say_color warn "# faked up failures as TODO & now exiting with 0 due to --invert-exit-code"
            }

            test_failure_ () {
                    failure_label=$1
                    test_failure=$(($test_failure + 1))
                    local pfx=""
                    if test -n "$invert_exit_code" # && test -n "$HARNESS_ACTIVE"
                    then
                            pfx="# TODO induced breakage (--invert-exit-code):"
                    fi
                    say_color error "not ok $test_count - ${pfx:+$pfx }$1"
                    shift
                    printf '%s\n' "$*" | sed -e 's/^/#      /'
                    if test -n "$immediate"
                    then
                            say_color error "1..$test_count"
                            if test -n "$invert_exit_code"
                            then
                                    finalize_test_output
                                    _invert_exit_code_failure_end_blurb
                                    GIT_EXIT_OK=t
                                    exit 0
                            fi
                            check_test_results_san_file_ "$test_failure"
                            _error_exit
                    fi
                    finalize_test_case_output failure "$failure_label" "$@"
            }

            test_known_broken_ok_ () {
                    test_fixed=$(($test_fixed+1))
                    say_color error "ok $test_count - $1 # TODO known breakage vanished"
                    finalize_test_case_output fixed "$1"
            }

            test_known_broken_failure_ () {
                    test_broken=$(($test_broken+1))
                    say_color warn "not ok $test_count - $1 # TODO known breakage"
                    finalize_test_case_output broken "$1"
            }

            test_debug () {
                    test "$debug" = "" || eval "$1"
            }

            match_pattern_list () {
                    arg="$1"
                    shift
                    test -z "$*" && return 1
                    # We need to use "$*" to get field-splitting, but we want to
                    # disable globbing, since we are matching against an arbitrary
                    # $arg, not what's in the filesystem. Using "set -f" accomplishes
                    # that, but we must do it in a subshell to avoid impacting the
                    # rest of the script. The exit value of the subshell becomes
                    # the function's return value.
                    (
                            set -f
                            for pattern_ in $*
                            do
                                    case "$arg" in
                                    $pattern_)
                                            exit 0
                                            ;;
                                    esac
                            done
                            exit 1
                    )
            }

            match_test_selector_list () {
                    operation="$1"
                    shift
                    title="$1"
                    shift
                    arg="$1"
                    shift
                    test -z "$1" && return 0

                    # Commas are accepted as separators.
                    OLDIFS=$IFS
                    IFS=','
                    set -- $1
                    IFS=$OLDIFS

                    # If the first selector is negative we include by default.
                    include=
                    case "$1" in
                            !*) include=t ;;
                    esac

                    for selector
                    do
                            orig_selector=$selector

                            positive=t
                            case "$selector" in
                                    !*)
                                            positive=
                                            selector=${selector##?}
                                            ;;
                            esac

                            test -z "$selector" && continue

                            case "$selector" in
                                    *-*)
                                            if expr "z${selector%%-*}" : "z[0-9]*[^0-9]" >/dev/null
                                            then
                                                    echo "error: $operation: invalid non-numeric in range" \
                                                            "start: '$orig_selector'" >&2
                                                    exit 1
                                            fi
                                            if expr "z${selector#*-}" : "z[0-9]*[^0-9]" >/dev/null
                                            then
                                                    echo "error: $operation: invalid non-numeric in range" \
                                                            "end: '$orig_selector'" >&2
                                                    exit 1
                                            fi
                                            ;;
                                    *)
                                            if expr "z$selector" : "z[0-9]*[^0-9]" >/dev/null
                                            then
                                                    case "$title" in *${selector}*)
                                                            include=$positive
                                                            ;;
                                                    esac
                                                    continue
                                            fi
                            esac

                            # Short cut for "obvious" cases
                            test -z "$include" && test -z "$positive" && continue
                            test -n "$include" && test -n "$positive" && continue

                            case "$selector" in
                                    -*)
                                            if test $arg -le ${selector#-}
                                            then
                                                    include=$positive
                                            fi
                                            ;;
                                    *-)
                                            if test $arg -ge ${selector%-}
                                            then
                                                    include=$positive
                                            fi
                                            ;;
                                    *-*)
                                            if test ${selector%%-*} -le $arg \
                                                    && test $arg -le ${selector#*-}
                                            then
                                                    include=$positive
                                            fi
                                            ;;
                                    *)
                                            if test $arg -eq $selector
                                            then
                                                    include=$positive
                                            fi
                                            ;;
                            esac
                    done

                    test -n "$include"
            }

            maybe_teardown_verbose () {
                    test -z "$verbose_only" && return
                    exec 4>/dev/null 3>/dev/null
                    verbose=
            }

            last_verbose=t
            maybe_setup_verbose () {
                    test -z "$verbose_only" && return
                    if match_pattern_list $test_count "$verbose_only"
                    then
                            exec 4>&2 3>&1
                            # Emit a delimiting blank line when going from
                            # non-verbose to verbose.  Within verbose mode the
                            # delimiter is printed by test_expect_*.  The choice
                            # of the initial $last_verbose is such that before
                            # test 1, we do not print it.
                            test -z "$last_verbose" && echo >&3 ""
                            verbose=t
                    else
                            exec 4>/dev/null 3>/dev/null
                            verbose=
                    fi
                    last_verbose=$verbose
            }

            maybe_teardown_valgrind () {
                    test -z "$GIT_VALGRIND" && return
                    GIT_VALGRIND_ENABLED=
            }

            maybe_setup_valgrind () {
                    test -z "$GIT_VALGRIND" && return
                    if test -z "$valgrind_only"
                    then
                            GIT_VALGRIND_ENABLED=t
                            return
                    fi
                    GIT_VALGRIND_ENABLED=
                    if match_pattern_list $test_count "$valgrind_only"
                    then
                            GIT_VALGRIND_ENABLED=t
                    fi
            }

            trace_level_=0
            want_trace () {
                    test "$trace" = t && {
                            test "$verbose" = t || test "$verbose_log" = t
                    }
            }

            # This is a separate function because some tests use
            # "return" to end a test_expect_success block early
            # (and we want to make sure we run any cleanup like
            # "set +x").
            test_eval_inner_ () {
                    eval "$*"
            }

            test_eval_ () {
                    # If "-x" tracing is in effect, then we want to avoid polluting stderr
                    # with non-test commands. But once in "set -x" mode, we cannot prevent
                    # the shell from printing the "set +x" to turn it off (nor the saving
                    # of $? before that). But we can make sure that the output goes to
                    # /dev/null.
                    #
                    # There are a few subtleties here:
                    #
                    #   - we have to redirect descriptor 4 in addition to 2, to cover
                    #     BASH_XTRACEFD
                    #
                    #   - the actual eval has to come before the redirection block (since
                    #     it needs to see descriptor 4 to set up its stderr)
                    #
                    #   - likewise, any error message we print must be outside the block to
                    #     access descriptor 4
                    #
                    #   - checking $? has to come immediately after the eval, but it must
                    #     be _inside_ the block to avoid polluting the "set -x" output
                    #

                    # Do not add anything extra (including LF) after '$*'
                    test_eval_inner_ </dev/null >&3 2>&4 "
                            want_trace && trace_level_=$(($trace_level_+1)) && set -x
                            $*"
                    {
                            test_eval_ret_=$?
                            if want_trace
                            then
                                    test 1 = $trace_level_ && set +x
                                    trace_level_=$(($trace_level_-1))
                            fi
                    } 2>/dev/null 4>&2

                    if test "$test_eval_ret_" != 0 && want_trace
                    then
                            say_color error >&4 "error: last command exited with \$?=$test_eval_ret_"
                    fi
                    return $test_eval_ret_
            }

            fail_117 () {
                    return 117
            }

            test_run_ () {
                    test_cleanup=:
                    expecting_failure=$2

                    if test "${GIT_TEST_CHAIN_LINT:-1}" != 0; then
                            # 117 is magic because it is unlikely to match the exit
                            # code of other programs
                            test_eval_inner_ "fail_117 && $1" </dev/null >&3 2>&4
                            if test $? != 117
                            then
                                    BUG "broken &&-chain: $1"
                            fi
                    fi

                    setup_malloc_check
                    test_eval_ "$1"
                    eval_ret=$?
                    teardown_malloc_check

                    if test -z "$immediate" || test $eval_ret = 0 ||
                    test -n "$expecting_failure" && test "$test_cleanup" != ":"
                    then
                            setup_malloc_check
                            test_eval_ "$test_cleanup"
                            teardown_malloc_check
                    fi
                    if test "$verbose" = "t" && test -n "$HARNESS_ACTIVE"
                    then
                            echo ""
                    fi
                    return "$eval_ret"
            }

            test_start_ () {
                    test_count=$(($test_count+1))
                    maybe_setup_verbose
                    maybe_setup_valgrind
                    start_test_case_output "$@"
            }

            test_finish_ () {
                    echo >&3 ""
                    maybe_teardown_valgrind
                    maybe_teardown_verbose
                    if test -n "$GIT_TEST_TEE_OFFSET"
                    then
                            GIT_TEST_TEE_OFFSET=$(test-tool path-utils file-size \
                                    "$GIT_TEST_TEE_OUTPUT_FILE")
                    fi
            }

            test_skip () {
                    to_skip=
                    skipped_reason=
                    if match_pattern_list $this_test.$test_count "$GIT_SKIP_TESTS"
                    then
                            to_skip=t
                            skipped_reason="GIT_SKIP_TESTS"
                    fi
                    if test -z "$to_skip" && test -n "$run_list" &&
                    ! match_test_selector_list '--run' "$1" $test_count "$run_list"
                    then
                            to_skip=t
                            skipped_reason="--run"
                    fi
                    if test -z "$to_skip" && test -n "$test_prereq" &&
                    ! test_have_prereq "$test_prereq"
                    then
                            to_skip=t

                            of_prereq=
                            if test "$missing_prereq" != "$test_prereq"
                            then
                                    of_prereq=" of $test_prereq"
                            fi
                            skipped_reason="missing $missing_prereq${of_prereq}"

                            # Keep a list of all the missing prereq for result aggregation
                            if test -z "$missing_prereq"
                            then
                                    test_missing_prereq=$missing_prereq
                            else
                                    test_missing_prereq="$test_missing_prereq,$missing_prereq"
                            fi
                    fi

                    case "$to_skip" in
                    t)

                            say_color skip "ok $test_count # skip $1 ($skipped_reason)"
                            : true
                            finalize_test_case_output skip "$@"
                            ;;
                    *)
                            false
                            ;;
                    esac
            }

            # stub; perf-lib overrides it
            test_at_end_hook_ () {
                    :
            }

            test_atexit_cleanup=:
            test_atexit_handler () {
                    # In a succeeding test script 'test_atexit_handler' is invoked
                    # twice: first from 'test_done', then from 'die' in the trap on
                    # EXIT.
                    # This condition and resetting 'test_atexit_cleanup' below makes
                    # sure that the registered cleanup commands are run only once.
                    test : != "$test_atexit_cleanup" || return 0

                    setup_malloc_check
                    test_eval_ "$test_atexit_cleanup"
                    test_atexit_cleanup=:
                    teardown_malloc_check
            }

            check_test_results_san_file_empty_ () {
                    test -z "$TEST_RESULTS_SAN_FILE" && return 0

                    # stderr piped to /dev/null because the directory may have
                    # been "rmdir"'d already.
                    ! find "$TEST_RESULTS_SAN_DIR" \
                            -type f \
                            -name "$TEST_RESULTS_SAN_FILE_PFX.*" 2>/dev/null |
                    xargs grep ^DEDUP_TOKEN |
                    grep -qv sanitizer::GetThreadStackTopAndBottom
            }

            check_test_results_san_file_ () {
                    if check_test_results_san_file_empty_
                    then
                            return
                    fi &&
                    say_color error "$(cat "$TEST_RESULTS_SAN_FILE".*)" &&

                    if test "$test_failure" = 0
                    then
                            say "Our logs revealed a memory leak, exit non-zero!" &&
                            invert_exit_code=t
                    else
                            say "Our logs revealed a memory leak..."
                    fi
            }

            test_done () {
                    # Run the atexit commands _before_ the trash directory is
                    # removed, so the commands can access pidfiles and socket files.
                    test_atexit_handler

                    finalize_test_output

                    if test -z "$HARNESS_ACTIVE"
                    then
                            mkdir -p "$TEST_RESULTS_DIR"

                            cat >"$TEST_RESULTS_BASE.counts" <<-EOF
                            total $test_count
                            success $test_success
                            fixed $test_fixed
                            broken $test_broken
                            failed $test_failure
                            missing_prereq $test_missing_prereq

                            EOF
                    fi

                    if test "$test_fixed" != 0
                    then
                            say_color error "# $test_fixed known breakage(s) vanished; please update test(s)"
                    fi
                    if test "$test_broken" != 0
                    then
                            say_color warn "# still have $test_broken known breakage(s)"
                    fi
                    if test "$test_broken" != 0 || test "$test_fixed" != 0
                    then
                            test_remaining=$(( $test_count - $test_broken - $test_fixed ))
                            msg="remaining $test_remaining test(s)"
                    else
                            test_remaining=$test_count
                            msg="$test_count test(s)"
                    fi
                    case "$test_failure" in
                    0)
                            if test $test_remaining -gt 0
                            then
                                    say_color pass "# passed all $msg"
                            fi

                            # Maybe print SKIP message
                            test -z "$skip_all" || skip_all="# SKIP $skip_all"
                            case "$test_count" in
                            0)
                                    say "1..$test_count${skip_all:+ $skip_all}"
                                    ;;
                            *)
                                    test -z "$skip_all" ||
                                    say_color warn "$skip_all"
                                    say "1..$test_count"
                                    ;;
                            esac

                            if test -n "$stress" && test -n "$invert_exit_code"
                            then
                                    # We're about to move our "$TRASH_DIRECTORY"
                                    # to "$TRASH_DIRECTORY.stress-failed" if
                                    # --stress is combined with
                                    # --invert-exit-code.
                                    say "with --stress and --invert-exit-code we're not removing '$TRASH_DIRECTORY'"
                            elif test -z "$debug" && test -n "$remove_trash"
                            then
                                    test -d "$TRASH_DIRECTORY" ||
                                    error "Tests passed but trash directory already removed before test cleanup; aborting"

                                    cd "$TRASH_DIRECTORY/.." &&
                                    rm -fr "$TRASH_DIRECTORY" || {
                                            # try again in a bit
                                            sleep 5;
                                            rm -fr "$TRASH_DIRECTORY"
                                    } ||
                                    error "Tests passed but test cleanup failed; aborting"
                            fi

                            check_test_results_san_file_ "$test_failure"

                            if test -z "$skip_all" && test -n "$invert_exit_code"
                            then
                                    say_color warn "# faking up non-zero exit with --invert-exit-code"
                                    GIT_EXIT_OK=t
                                    exit 1
                            fi

                            test_at_end_hook_

                            GIT_EXIT_OK=t
                            exit 0 ;;

                    *)
                            say_color error "# failed $test_failure among $msg"
                            say "1..$test_count"

                            check_test_results_san_file_ "$test_failure"

                            if test -n "$invert_exit_code"
                            then
                                    _invert_exit_code_failure_end_blurb
                                    GIT_EXIT_OK=t
                                    exit 0
                            fi

                            GIT_EXIT_OK=t
                            exit 1 ;;

                    esac
            }

            if test -n "$valgrind"
            then
                    make_symlink () {
                            test -h "$2" &&
                            test "$1" = "$(readlink "$2")" || {
                                    # be super paranoid
                                    if mkdir "$2".lock
                                    then
                                            rm -f "$2" &&
                                            ln -s "$1" "$2" &&
                                            rm -r "$2".lock
                                    else
                                            while test -d "$2".lock
                                            do
                                                    say "Waiting for lock on $2."
                                                    sleep 1
                                            done
                                    fi
                            }
                    }

                    make_valgrind_symlink () {
                            # handle only executables, unless they are shell libraries that
                            # need to be in the exec-path.
                            test -x "$1" ||
                            test "# " = "$(test_copy_bytes 2 <"$1")" ||
                            return;

                            base=$(basename "$1")
                            case "$base" in
                            test-*)
                                    symlink_target="$GIT_BUILD_DIR/t/helper/$base"
                                    ;;
                            *)
                                    symlink_target="$GIT_BUILD_DIR/$base"
                                    ;;
                            esac
                            # do not override scripts
                            if test -x "$symlink_target" &&
                            test ! -d "$symlink_target" &&
                            test "#!" != "$(test_copy_bytes 2 <"$symlink_target")"
                            then
                                    symlink_target=../valgrind.sh
                            fi
                            case "$base" in
                            *.sh|*.perl)
                                    symlink_target=../unprocessed-script
                            esac
                            # create the link, or replace it if it is out of date
                            make_symlink "$symlink_target" "$GIT_VALGRIND/bin/$base" || exit
                    }

                    # override all git executables in TEST_DIRECTORY/..
                    GIT_VALGRIND=$TEST_DIRECTORY/valgrind
                    mkdir -p "$GIT_VALGRIND"/bin
                    for file in $GIT_BUILD_DIR/git* $GIT_BUILD_DIR/t/helper/test-*
                    do
                            make_valgrind_symlink $file
                    done
                    # special-case the mergetools loadables
                    make_symlink "$GIT_BUILD_DIR"/mergetools "$GIT_VALGRIND/bin/mergetools"
                    OLDIFS=$IFS
                    IFS=:
                    for path in $PATH
                    do
                            ls "$path"/git-* 2> /dev/null |
                            while read file
                            do
                                    make_valgrind_symlink "$file"
                            done
                    done
                    IFS=$OLDIFS
                    PATH=$GIT_VALGRIND/bin:$PATH
                    GIT_EXEC_PATH=$GIT_VALGRIND/bin
                    export GIT_VALGRIND
                    GIT_VALGRIND_MODE="$valgrind"
                    export GIT_VALGRIND_MODE
                    GIT_VALGRIND_ENABLED=t
                    test -n "$valgrind_only" && GIT_VALGRIND_ENABLED=
                    export GIT_VALGRIND_ENABLED
            elif test -n "$GIT_TEST_INSTALLED"
            then
                    GIT_EXEC_PATH=$($GIT_TEST_INSTALLED/git --exec-path)  ||
                    error "Cannot run git from $GIT_TEST_INSTALLED."
                    PATH=$GIT_TEST_INSTALLED:$GIT_BUILD_DIR/t/helper:$PATH
                    GIT_EXEC_PATH=${GIT_TEST_EXEC_PATH:-$GIT_EXEC_PATH}
            else # normal case, use ../bin-wrappers only unless $with_dashes:
                    if test -n "$no_bin_wrappers"
                    then
                            with_dashes=t
                    else
                            git_bin_dir="$GIT_BUILD_DIR/bin-wrappers"
                            if ! test -x "$git_bin_dir/git"
                            then
                                    if test -z "$with_dashes"
                                    then
                                            say "$git_bin_dir/git is not executable; using GIT_EXEC_PATH"
                                    fi
                                    with_dashes=t
                            fi
                            PATH="$git_bin_dir:$PATH"
                    fi
                    GIT_EXEC_PATH=$GIT_BUILD_DIR
                    if test -n "$with_dashes"
                    then
                            PATH="$GIT_BUILD_DIR:$GIT_BUILD_DIR/t/helper:$PATH"
                    fi
            fi
            GIT_TEMPLATE_DIR="$GIT_TEST_TEMPLATE_DIR"
            GIT_CONFIG_NOSYSTEM=1
            GIT_ATTR_NOSYSTEM=1
            GIT_CEILING_DIRECTORIES="$TRASH_DIRECTORY/.."
            export PATH GIT_EXEC_PATH GIT_TEMPLATE_DIR GIT_CONFIG_NOSYSTEM GIT_ATTR_NOSYSTEM GIT_CEILING_DIRECTORIES

            # Add libc MALLOC and MALLOC_PERTURB test only if we are not executing
            # the test with valgrind and have not compiled with conflict SANITIZE
            # options.
            if test -n "$valgrind" ||
            test -n "$SANITIZE_ADDRESS" ||
            test -n "$SANITIZE_LEAK" ||
            test -n "$TEST_NO_MALLOC_CHECK"
            then
                    setup_malloc_check () {
                            : nothing
                    }
                    teardown_malloc_check () {
                            : nothing
                    }
            else
                    _USE_GLIBC_TUNABLES=
                    _USE_GLIBC_PRELOAD=libc_malloc_debug.so.0
                    if _GLIBC_VERSION=$(getconf GNU_LIBC_VERSION 2>/dev/null) &&
                    _GLIBC_VERSION=${_GLIBC_VERSION#"glibc "} &&
                    expr 2.34 \<= "$_GLIBC_VERSION" >/dev/null &&
                    stderr=$(LD_PRELOAD=$_USE_GLIBC_PRELOAD git version 2>&1 >/dev/null) &&
                    test -z "$stderr"
                    then
                            _USE_GLIBC_TUNABLES=YesPlease
                    fi
                    setup_malloc_check () {
                            local g
                            local t
                            MALLOC_CHECK_=3 MALLOC_PERTURB_=165
                            export MALLOC_CHECK_ MALLOC_PERTURB_
                            if test -n "$_USE_GLIBC_TUNABLES"
                            then
                                    g=
                                    LD_PRELOAD=$_USE_GLIBC_PRELOAD
                                    for t in \
                                            glibc.malloc.check=1 \
                                            glibc.malloc.perturb=165
                                    do
                                            g="${g#:}:$t"
                                    done
                                    GLIBC_TUNABLES=$g
                                    export LD_PRELOAD GLIBC_TUNABLES
                            fi
                    }
                    teardown_malloc_check () {
                            unset MALLOC_CHECK_ MALLOC_PERTURB_
                            unset LD_PRELOAD GLIBC_TUNABLES
                    }
            fi

            if test -z "$GIT_TEST_CMP"
            then
                    if test -n "$GIT_TEST_CMP_USE_COPIED_CONTEXT"
                    then
                            GIT_TEST_CMP="$DIFF -c"
                    else
                            GIT_TEST_CMP="$DIFF -u"
                    fi
            fi

            GITPERLLIB="$GIT_TEST_GITPERLLIB"
            export GITPERLLIB
            test -d "$GIT_TEMPLATE_DIR" || {
                    BAIL_OUT "You haven't built things yet, have you?"
            }

            if ! test -x "$GIT_BUILD_DIR"/t/helper/test-tool$X
            then
                    BAIL_OUT 'You need to build test-tool; Run "make t/helper/test-tool" in the source (toplevel) directory'
            fi

            # Are we running this test at all?
            remove_trash=
            this_test=${0##*/}
            this_test=${this_test%%-*}
            if match_pattern_list "$this_test" "$GIT_SKIP_TESTS"
            then
                    say_color info >&3 "skipping test $this_test altogether"
                    skip_all="skip all tests in $this_test"
                    test_done
            fi

            if test -n "$SANITIZE_LEAK"
            then
                    rm -rf "$TEST_RESULTS_SAN_DIR"
                    if ! mkdir -p "$TEST_RESULTS_SAN_DIR"
                    then
                            BAIL_OUT "cannot create $TEST_RESULTS_SAN_DIR"
                    fi &&
                    TEST_RESULTS_SAN_FILE="$TEST_RESULTS_SAN_DIR/$TEST_RESULTS_SAN_FILE_PFX"

                    # Don't litter *.leak dirs if there was nothing to report
                    test_atexit "rmdir \"$TEST_RESULTS_SAN_DIR\" 2>/dev/null || :"

                    prepend_var LSAN_OPTIONS : dedup_token_length=9999
                    prepend_var LSAN_OPTIONS : log_exe_name=1
                    prepend_var LSAN_OPTIONS : log_path="'$TEST_RESULTS_SAN_FILE'"
                    export LSAN_OPTIONS
            fi

            if test "${GIT_TEST_CHAIN_LINT:-1}" != 0 &&
            test "${GIT_TEST_EXT_CHAIN_LINT:-1}" != 0
            then
                    "$PERL_PATH" "$TEST_DIRECTORY/chainlint.pl" "$0" ||
                            BUG "lint error (see 'LINT' annotations above)"
            fi

            # Last-minute variable setup
            USER_HOME="$HOME"
            HOME="$TRASH_DIRECTORY"
            GNUPGHOME="$HOME/gnupg-home-not-used"
            export HOME GNUPGHOME USER_HOME

            # "rm -rf" existing trash directory, even if a previous run left it
            # with bad permissions.
            remove_trash_directory () {
                    dir="$1"
                    if ! rm -rf "$dir" 2>/dev/null
                    then
                            chmod -R u+rwx "$dir"
                            rm -rf "$dir"
                    fi
                    ! test -d "$dir"
            }

            # Test repository
            remove_trash_directory "$TRASH_DIRECTORY" || {
                    BAIL_OUT 'cannot prepare test area'
            }

            remove_trash=t
            if test -z "$TEST_NO_CREATE_REPO"
            then
                    git init \
                    ${TEST_CREATE_REPO_NO_TEMPLATE:+--template=} \
                    "$TRASH_DIRECTORY" >&3 2>&4 ||
                    error "cannot run git init"
            else
                    mkdir -p "$TRASH_DIRECTORY"
            fi

            # Use -P to resolve symlinks in our working directory so that the cwd
            # in subprocesses like git equals our $PWD (for pathname comparisons).
            cd "$TRASH_DIRECTORY" || BAIL_OUT "cannot cd -P to \"$TRASH_DIRECTORY\""

            start_test_output "$0"

            # Convenience
            # A regexp to match 5 and 35 hexdigits
            _x05='[0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f]'
            _x35="$_x05$_x05$_x05$_x05$_x05$_x05$_x05"

            test_oid_init

            ZERO_OID=$(test_oid zero)
            OID_REGEX=$(echo $ZERO_OID | sed -e 's/0/[0-9a-f]/g')
            OIDPATH_REGEX=$(test_oid_to_path $ZERO_OID | sed -e 's/0/[0-9a-f]/g')
            EMPTY_TREE=$(test_oid empty_tree)
            EMPTY_BLOB=$(test_oid empty_blob)

            # Provide an implementation of the 'yes' utility; the upper bound
            # limit is there to help Windows that cannot stop this loop from
            # wasting cycles when the downstream stops reading, so do not be
            # tempted to turn it into an infinite loop. cf. 6129c930 ("test-lib:
            # limit the output of the yes utility", 2016-02-02)
            yes () {
                    if test $# = 0
                    then
                            y=y
                    else
                            y="$*"
                    fi

                    i=0
                    while test $i -lt 99
                    do
                            echo "$y"
                            i=$(($i+1))
                    done
            }

            # The GIT_TEST_FAIL_PREREQS code hooks into test_set_prereq(), and
            # thus needs to be set up really early, and set an internal variable
            # for convenience so the hot test_set_prereq() codepath doesn't need
            # to call "test-tool env-helper" (via test_bool_env). Only do that work
            # if needed by seeing if GIT_TEST_FAIL_PREREQS is set at all.
            GIT_TEST_FAIL_PREREQS_INTERNAL=
            if test -n "$GIT_TEST_FAIL_PREREQS"
            then
                    if test_bool_env GIT_TEST_FAIL_PREREQS false
                    then
                            GIT_TEST_FAIL_PREREQS_INTERNAL=true
                            test_set_prereq FAIL_PREREQS
                    fi
            else
                    test_lazy_prereq FAIL_PREREQS '
                            test_bool_env GIT_TEST_FAIL_PREREQS false
                    '
            fi

            # Fix some commands on Windows, and other OS-specific things
            uname_s=$(uname -s)
            case $uname_s in
            *MINGW*)
                    # Windows has its own (incompatible) sort and find
                    sort () {
                            /usr/bin/sort "$@"
                    }
                    find () {
                            /usr/bin/find "$@"
                    }
                    # git sees Windows-style pwd
                    pwd () {
                            builtin pwd -W
                    }
                    # no POSIX permissions
                    # backslashes in pathspec are converted to '/'
                    # exec does not inherit the PID
                    test_set_prereq MINGW
                    test_set_prereq NATIVE_CRLF
                    test_set_prereq SED_STRIPS_CR
                    test_set_prereq GREP_STRIPS_CR
                    test_set_prereq WINDOWS
                    GIT_TEST_CMP="GIT_DIR=/dev/null git diff --no-index --ignore-cr-at-eol --"
                    ;;
            *CYGWIN*)
                    test_set_prereq POSIXPERM
                    test_set_prereq EXECKEEPSPID
                    test_set_prereq CYGWIN
                    test_set_prereq SED_STRIPS_CR
                    test_set_prereq GREP_STRIPS_CR
                    test_set_prereq WINDOWS
                    ;;
            *)
                    test_set_prereq POSIXPERM
                    test_set_prereq BSLASHPSPEC
                    test_set_prereq EXECKEEPSPID
                    ;;
            esac

            # Detect arches where a few things don't work
            uname_m=$(uname -m)
            case $uname_m in
            parisc* | hppa*)
                    test_set_prereq HPPA
                    ;;
            esac

            case "$GIT_DEFAULT_REF_FORMAT" in
            files)
                    test_set_prereq REFFILES;;
            reftable)
                    test_set_prereq REFTABLE;;
            *)
                    echo 2>&1 "error: unknown ref format $GIT_DEFAULT_REF_FORMAT"
                    exit 1
                    ;;
            esac

            ( COLUMNS=1 && test $COLUMNS = 1 ) && test_set_prereq COLUMNS_CAN_BE_1
            test -z "$NO_CURL" && test_set_prereq LIBCURL
            test -z "$NO_GITWEB" && test_set_prereq GITWEB
            test -z "$NO_ICONV" && test_set_prereq ICONV
            test -z "$NO_PERL" && test_set_prereq PERL
            test -z "$NO_PTHREADS" && test_set_prereq PTHREADS
            test -z "$NO_PYTHON" && test_set_prereq PYTHON
            test -n "$USE_LIBPCRE2" && test_set_prereq PCRE
            test -n "$USE_LIBPCRE2" && test_set_prereq LIBPCRE2
            test -z "$NO_GETTEXT" && test_set_prereq GETTEXT
            test -n "$SANITIZE_LEAK" && test_set_prereq SANITIZE_LEAK
            test -n "$GIT_VALGRIND_ENABLED" && test_set_prereq VALGRIND

            if test -z "$GIT_TEST_CHECK_CACHE_TREE"
            then
                    GIT_TEST_CHECK_CACHE_TREE=true
                    export GIT_TEST_CHECK_CACHE_TREE
            fi

            test_lazy_prereq PIPE '
                    # test whether the filesystem supports FIFOs
                    test_have_prereq !MINGW,!CYGWIN &&
                    rm -f testfifo && mkfifo testfifo
            '

            test_lazy_prereq SYMLINKS '
                    # test whether the filesystem supports symbolic links
                    ln -s x y && test -h y
            '

            test_lazy_prereq SYMLINKS_WINDOWS '
                    # test whether symbolic links are enabled on Windows
                    test_have_prereq MINGW &&
                    cmd //c "mklink y x" &> /dev/null && test -h y
            '

            test_lazy_prereq FILEMODE '
                    test "$(git config --bool core.filemode)" = true
            '

            test_lazy_prereq CASE_INSENSITIVE_FS '
                    echo good >CamelCase &&
                    echo bad >camelcase &&
                    test "$(cat CamelCase)" != good
            '

            test_lazy_prereq FUNNYNAMES '
                    test_have_prereq !MINGW &&
                    touch -- \
                            "FUNNYNAMES tab embedded" \
                            "FUNNYNAMES \"quote embedded\"" \
                            "FUNNYNAMES newline
            embedded" 2>/dev/null &&
                    rm -- \
                            "FUNNYNAMES tab embedded" \
                            "FUNNYNAMES \"quote embedded\"" \
                            "FUNNYNAMES newline
            embedded" 2>/dev/null
            '

            test_lazy_prereq UTF8_NFD_TO_NFC '
                    # check whether FS converts nfd unicode to nfc
                    auml=$(printf "\303\244")
                    aumlcdiar=$(printf "\141\314\210")
                    >"$auml" &&
                    test -f "$aumlcdiar"
            '

            test_lazy_prereq AUTOIDENT '
                    sane_unset GIT_AUTHOR_NAME &&
                    sane_unset GIT_AUTHOR_EMAIL &&
                    git var GIT_AUTHOR_IDENT
            '

            test_lazy_prereq EXPENSIVE '
                    test -n "$GIT_TEST_LONG"
            '

            test_lazy_prereq EXPENSIVE_ON_WINDOWS '
                    test_have_prereq EXPENSIVE || test_have_prereq !MINGW,!CYGWIN
            '

            test_lazy_prereq USR_BIN_TIME '
                    test -x /usr/bin/time
            '

            test_lazy_prereq NOT_ROOT '
                    uid=$(id -u) &&
                    test "$uid" != 0
            '

            test_lazy_prereq JGIT '
                    jgit --version
            '

            # SANITY is about "can you correctly predict what the filesystem would
            # do by only looking at the permission bits of the files and
            # directories?"  A typical example of !SANITY is running the test
            # suite as root, where a test may expect "chmod -r file && cat file"
            # to fail because file is supposed to be unreadable after a successful
            # chmod.  In an environment (i.e. combination of what filesystem is
            # being used and who is running the tests) that lacks SANITY, you may
            # be able to delete or create a file when the containing directory
            # doesn't have write permissions, or access a file even if the
            # containing directory doesn't have read or execute permissions.

            test_lazy_prereq SANITY '
                    mkdir SANETESTD.1 SANETESTD.2 &&

                    chmod +w SANETESTD.1 SANETESTD.2 &&
                    >SANETESTD.1/x 2>SANETESTD.2/x &&
                    chmod -w SANETESTD.1 &&
                    chmod -r SANETESTD.1/x &&
                    chmod -rx SANETESTD.2 ||
                    BUG "cannot prepare SANETESTD"

                    ! test -r SANETESTD.1/x &&
                    ! rm SANETESTD.1/x && ! test -f SANETESTD.2/x
                    status=$?

                    chmod +rwx SANETESTD.1 SANETESTD.2 &&
                    rm -rf SANETESTD.1 SANETESTD.2 ||
                    BUG "cannot clean SANETESTD"
                    return $status
            '

            test FreeBSD != $uname_s || GIT_UNZIP=${GIT_UNZIP:-/usr/local/bin/unzip}
            GIT_UNZIP=${GIT_UNZIP:-unzip}
            test_lazy_prereq UNZIP '
                    "$GIT_UNZIP" -v
                    test $? -ne 127
            '

            run_with_limited_cmdline () {
                    (ulimit -s 128 && "$@")
            }

            test_lazy_prereq CMDLINE_LIMIT '
                    test_have_prereq !HPPA,!MINGW,!CYGWIN &&
                    run_with_limited_cmdline true
            '

            run_with_limited_stack () {
                    (ulimit -s 128 && "$@")
            }

            test_lazy_prereq ULIMIT_STACK_SIZE '
                    test_have_prereq !HPPA,!MINGW,!CYGWIN &&
                    run_with_limited_stack true
            '

            run_with_limited_open_files () {
                    (ulimit -n 32 && "$@")
            }

            test_lazy_prereq ULIMIT_FILE_DESCRIPTORS '
                    test_have_prereq !MINGW,!CYGWIN &&
                    run_with_limited_open_files true
            '

            build_option () {
                    git version --build-options |
                    sed -ne "s/^$1: //p"
            }

            test_lazy_prereq SIZE_T_IS_64BIT '
                    test 8 -eq "$(build_option sizeof-size_t)"
            '

            test_lazy_prereq LONG_IS_64BIT '
                    test 8 -le "$(build_option sizeof-long)"
            '

            test_lazy_prereq TIME_IS_64BIT 'test-tool date is64bit'
            test_lazy_prereq TIME_T_IS_64BIT 'test-tool date time_t-is64bit'

            test_lazy_prereq CURL '
                    curl --version
            '

            # SHA1 is a test if the hash algorithm in use is SHA-1.  This is both for tests
            # which will not work with other hash algorithms and tests that work but don't
            # test anything meaningful (e.g. special values which cause short collisions).
            test_lazy_prereq SHA1 '
                    case "$GIT_DEFAULT_HASH" in
                    sha1) true ;;
                    "") test $(git hash-object /dev/null) = e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 ;;
                    *) false ;;
                    esac
            '

            test_lazy_prereq DEFAULT_REPO_FORMAT '
                    test_have_prereq SHA1,REFFILES
            '

            # Ensure that no test accidentally triggers a Git command
            # that runs the actual maintenance scheduler, affecting a user's
            # system permanently.
            # Tests that verify the scheduler integration must set this locally
            # to avoid errors.
            GIT_TEST_MAINT_SCHEDULER="none:exit 1"
            export GIT_TEST_MAINT_SCHEDULER

            # Does this platform support `git fsmonitor--daemon`
            #
            test_lazy_prereq FSMONITOR_DAEMON '
                    git version --build-options >output &&
                    grep "feature: fsmonitor--daemon" output
            '



            """,


            "Patche":
            """
                            diff --git a/t/test-lib.sh b/t/test-lib.sh
            index a65df2f..99c6d57 100644
            --- a/t/test-lib.sh
            +++ b/t/test-lib.sh
            @@ -1629,7 +1629,7 @@ fi

            # Use -P to resolve symlinks in our working directory so that the cwd
            # in subprocesses like git equals our $PWD (for pathname comparisons).
            -cd -P "$TRASH_DIRECTORY" || BAIL_OUT "cannot cd -P to \"$TRASH_DIRECTORY\""
            +cd "$TRASH_DIRECTORY" || BAIL_OUT "cannot cd -P to \"$TRASH_DIRECTORY\""

            start_test_output "$0"

            """,

    }

    {

            "Wrong Code":
                            """
            #define DISABLE_SIGN_COMPARE_WARNINGS

            #include "git-compat-util.h"
            #include "strbuf.h"
            #include "utf8.h"

            /* This code is originally from https://www.cl.cam.ac.uk/~mgk25/ucs/ */

            static const char utf16_be_bom[] = {'\xFE', '\xFF'};
            static const char utf16_le_bom[] = {'\xFF', '\xFE'};
            static const char utf32_be_bom[] = {'\0', '\0', '\xFE', '\xFF'};
            static const char utf32_le_bom[] = {'\xFF', '\xFE', '\0', '\0'};

            struct interval {
                    ucs_char_t first;
                    ucs_char_t last;
            };

            size_t display_mode_esc_sequence_len(const char *s)
            {
                    const char *p = s;
                    if (*p++ != '\033')
                            return 0;
                    if (*p++ != '[')
                            return 0;
                    while (isdigit(*p) || *p == ';')
                            p++;
                    if (*p++ != 'm')
                            return 0;
                    return p - s;
            }

            /* auxiliary function for binary search in interval table */
            static int bisearch(ucs_char_t ucs, const struct interval *table, int max)
            {
                    int min = 0;
                    int mid;

                    if (ucs < table[0].first || ucs > table[max].last)
                            return 0;
                    while (max >= min) {
                            mid = min + (max - min) / 2;
                            if (ucs > table[mid].last)
                                    min = mid + 1;
                            else if (ucs < table[mid].first)
                                    max = mid - 1;
                            else
                                    return 1;
                    }

                    return 0;
            }

            /* The following two functions define the column width of an ISO 10646
            * character as follows:
            *
            *    - The null character (U+0000) has a column width of 0.
            *
            *    - Other C0/C1 control characters and DEL will lead to a return
            *      value of -1.
            *
            *    - Non-spacing and enclosing combining characters (general
            *      category code Mn or Me in the Unicode database) have a
            *      column width of 0.
            *
            *    - SOFT HYPHEN (U+00AD) has a column width of 1.
            *
            *    - Other format characters (general category code Cf in the Unicode
            *      database) and ZERO WIDTH SPACE (U+200B) have a column width of 0.
            *
            *    - Hangul Jamo medial vowels and final consonants (U+1160-U+11FF)
            *      have a column width of 0.
            *
            *    - Spacing characters in the East Asian Wide (W) or East Asian
            *      Full-width (F) category as defined in Unicode Technical
            *      Report #11 have a column width of 2.
            *
            *    - All remaining characters (including all printable
            *      ISO 8859-1 and WGL4 characters, Unicode control characters,
            *      etc.) have a column width of 1.
            *
            * This implementation assumes that ucs_char_t characters are encoded
            * in ISO 10646.
            */

            static int git_wcwidth(ucs_char_t ch)
            {
                    /*
                    * Sorted list of non-overlapping intervals of non-spacing characters,
                    */
            #include "unicode-width.h"

                    /* test for 8-bit control characters */
                    if (ch == 0)
                            return 0;
                    if (ch < 32 || (ch >= 0x7f && ch < 0xa0))
                            return -1;

                    /* binary search in table of non-spacing characters */
                    if (bisearch(ch, zero_width, ARRAY_SIZE(zero_width) - 1))
                            return 0;

                    /* binary search in table of double width characters */
                    if (bisearch(ch, double_width, ARRAY_SIZE(double_width) - 1))
                            return 2;

                    return 1;
            }

            /*
            * Pick one ucs character starting from the location *start points at,
            * and return it, while updating the *start pointer to point at the
            * end of that character.  When remainder_p is not NULL, the location
            * holds the number of bytes remaining in the string that we are allowed
            * to pick from.  Otherwise we are allowed to pick up to the NUL that
            * would eventually appear in the string.  *remainder_p is also reduced
            * by the number of bytes we have consumed.
            *
            * If the string was not a valid UTF-8, *start pointer is set to NULL
            * and the return value is undefined.
            */
            static ucs_char_t pick_one_utf8_char(const char **start, size_t *remainder_p)
            {
                    unsigned char *s = (unsigned char *)*start;
                    ucs_char_t ch;
                    size_t remainder, incr;

                    /*
                    * A caller that assumes NUL terminated text can choose
                    * not to bother with the remainder length.  We will
                    * stop at the first NUL.
                    */
                    remainder = (remainder_p ? *remainder_p : 999);

                    if (remainder < 1) {
                            goto invalid;
                    } else if (*s < 0x80) {
                            /* 0xxxxxxx */
                            ch = *s;
                            incr = 1;
                    } else if ((s[0] & 0xe0) == 0xc0) {
                            /* 110XXXXx 10xxxxxx */
                            if (remainder < 2 ||
                            (s[1] & 0xc0) != 0x80 ||
                            (s[0] & 0xfe) == 0xc0)
                                    goto invalid;
                            ch = ((s[0] & 0x1f) << 6) | (s[1] & 0x3f);
                            incr = 2;
                    } else if ((s[0] & 0xf0) == 0xe0) {
                            /* 1110XXXX 10Xxxxxx 10xxxxxx */
                            if (remainder < 3 ||
                            (s[1] & 0xc0) != 0x80 ||
                            (s[2] & 0xc0) != 0x80 ||
                            /* overlong? */
                            (s[0] == 0xe0 && (s[1] & 0xe0) == 0x80) ||
                            /* surrogate? */
                            (s[0] == 0xed && (s[1] & 0xe0) == 0xa0) ||
                            /* U+FFFE or U+FFFF? */
                            (s[0] == 0xef && s[1] == 0xbf &&
                            (s[2] & 0xfe) == 0xbe))
                                    goto invalid;
                            ch = ((s[0] & 0x0f) << 12) |
                                    ((s[1] & 0x3f) << 6) | (s[2] & 0x3f);
                            incr = 3;
                    } else if ((s[0] & 0xf8) == 0xf0) {
                            /* 11110XXX 10XXxxxx 10xxxxxx 10xxxxxx */
                            if (remainder < 4 ||
                            (s[1] & 0xc0) != 0x80 ||
                            (s[2] & 0xc0) != 0x80 ||
                            (s[3] & 0xc0) != 0x80 ||
                            /* overlong? */
                            (s[0] == 0xf0 && (s[1] & 0xf0) == 0x80) ||
                            /* > U+10FFFF? */
                            (s[0] == 0xf4 && s[1] > 0x8f) || s[0] > 0xf4)
                                    goto invalid;
                            ch = ((s[0] & 0x07) << 18) | ((s[1] & 0x3f) << 12) |
                                    ((s[2] & 0x3f) << 6) | (s[3] & 0x3f);
                            incr = 4;
                    } else {
            invalid:
                            *start = NULL;
                            return 0;
                    }

                    *start += incr;
                    if (remainder_p)
                            *remainder_p = remainder - incr;
                    return ch;
            }

            /*
            * This function returns the number of columns occupied by the character
            * pointed to by the variable start. The pointer is updated to point at
            * the next character. When remainder_p is not NULL, it points at the
            * location that stores the number of remaining bytes we can use to pick
            * a character (see pick_one_utf8_char() above).
            */
            int utf8_width(const char **start, size_t *remainder_p)
            {
                    ucs_char_t ch = pick_one_utf8_char(start, remainder_p);
                    if (!*start)
                            return 0;
                    return git_wcwidth(ch);
            }

            /*
            * Returns the total number of columns required by a null-terminated
            * string, assuming that the string is utf8.  Returns strlen() instead
            * if the string does not look like a valid utf8 string.
            */
            int utf8_strnwidth(const char *string, size_t len, int skip_ansi)
            {
                    const char *orig = string;
                    size_t width = 0;

                    while (string && string < orig + len) {
                            int glyph_width;
                            size_t skip;

                            while (skip_ansi &&
                            (skip = display_mode_esc_sequence_len(string)) != 0)
                                    string += skip;

                            glyph_width = utf8_width(&string, NULL);
                            if (glyph_width > 0)
                                    width += glyph_width;
                    }

                    /*
                    * TODO: fix the interface of this function and `utf8_strwidth()` to
                    * return `size_t` instead of `int`.
                    */
                    return cast_size_t_to_int(string ? width : len);
            }

            int utf8_strwidth(const char *string)
            {
                    return utf8_strnwidth(string, strlen(string), 0);
            }

            int is_utf8(const char *text)
            {
                    while (*text) {
                            if (*text == '\n' || *text == '\t' || *text == '\r') {
                                    text++;
                                    continue;
                            }
                            utf8_width(&text, NULL);
                            if (!text)
                                    return 0;
                    }
                    return 1;
            }

            static void strbuf_add_indented_text(struct strbuf *buf, const char *text,
                                            int indent, int indent2)
            {
                    if (indent < 0)
                            indent = 0;
                    while (*text) {
                            const char *eol = strchrnul(text, '\n');
                            if (*eol == '\n')
                                    eol++;
                            strbuf_addchars(buf, ' ', indent);
                            strbuf_add(buf, text, eol - text);
                            text = eol;
                            indent = indent2;
                    }
            }

            /*
            * Wrap the text, if necessary. The variable indent is the indent for the
            * first line, indent2 is the indent for all other lines.
            * If indent is negative, assume that already -indent columns have been
            * consumed (and no extra indent is necessary for the first line).
            */
            void strbuf_add_wrapped_text(struct strbuf *buf,
                            const char *text, int indent1, int indent2, int width)
            {
                    int indent, w, assume_utf8 = 1;
                    const char *bol, *space, *start = text;
                    size_t orig_len = buf->len;

                    if (width <= 0) {
                            strbuf_add_indented_text(buf, text, indent1, indent2);
                            return;
                    }

            retry:
                    bol = text;
                    w = indent = indent1;
                    space = NULL;
                    if (indent < 0) {
                            w = -indent;
                            space = text;
                    }

                    for (;;) {
                            char c;
                            size_t skip;

                            while ((skip = display_mode_esc_sequence_len(text)))
                                    text += skip;

                            c = *text;
                            if (!c || isspace(c)) {
                                    if (w <= width || !space) {
                                            const char *start = bol;
                                            if (!c && text == start)
                                                    return;
                                            if (space)
                                                    start = space;
                                            else
                                                    strbuf_addchars(buf, ' ', indent);
                                            strbuf_add(buf, start, text - start);
                                            if (!c)
                                                    return;
                                            space = text;
                                            if (c == '\t')
                                                    w |= 0x07;
                                            else if (c == '\n') {
                                                    space++;
                                                    if (*space == '\n') {
                                                            strbuf_addch(buf, '\n');
                                                            goto new_line;
                                                    }
                                                    else if (!isalnum(*space))
                                                            goto new_line;
                                                    else
                                                            strbuf_addch(buf, ' ');
                                            }
                                            w++;
                                            text++;
                                    }
                                    else {
            new_line:
                                            strbuf_addch(buf, '\n');
                                            text = bol = space + isspace(*space);
                                            space = NULL;
                                            w = indent = indent2;
                                    }
                                    continue;
                            }
                            if (assume_utf8) {
                                    w += utf8_width(&text, NULL);
                                    if (!text) {
                                            assume_utf8 = 0;
                                            text = start;
                                            strbuf_setlen(buf, orig_len);
                                            goto retry;
                                    }
                            } else {
                                    w++;
                                    text++;
                            }
                    }
            }

            void strbuf_add_wrapped_bytes(struct strbuf *buf, const char *data, int len,
                                    int indent, int indent2, int width)
            {
                    char *tmp = xstrndup(data, len);
                    strbuf_add_wrapped_text(buf, tmp, indent, indent2, width);
                    free(tmp);
            }

            void strbuf_utf8_replace(struct strbuf *sb_src, int pos, int width,
                                    const char *subst)
            {
                    const char *src = sb_src->buf, *end = sb_src->buf + sb_src->len;
                    struct strbuf dst;
                    int w = 0;

                    strbuf_init(&dst, sb_src->len);

                    while (src < end) {
                            const char *old;
                            int glyph_width;
                            size_t n;

                            while ((n = display_mode_esc_sequence_len(src))) {
                                    strbuf_add(&dst, src, n);
                                    src += n;
                            }

                            if (src >= end)
                                    break;

                            old = src;
                            glyph_width = utf8_width((const char**)&src, NULL);
                            if (!src) /* broken utf-8, do nothing */
                                    goto out;

                            /*
                            * In case we see a control character we copy it into the
                            * buffer, but don't add it to the width.
                            */
                            if (glyph_width < 0)
                                    glyph_width = 0;

                            if (glyph_width && w >= pos && w < pos + width) {
                                    if (subst) {
                                            strbuf_addstr(&dst, subst);
                                            subst = NULL;
                                    }
                            } else {
                                    strbuf_add(&dst, old, src - old);
                            }

                            w += glyph_width;
                    }

                    strbuf_swap(sb_src, &dst);
            out:
                    strbuf_release(&dst);
            }

            /*
            * Returns true (1) if the src encoding name matches the dst encoding
            * name directly or one of its alternative names. E.g. UTF-16BE is the
            * same as UTF16BE.
            */
            static int same_utf_encoding(const char *src, const char *dst)
            {
                    if (skip_iprefix(src, "utf", &src) && skip_iprefix(dst, "utf", &dst)) {
                            skip_prefix(src, "-", &src);
                            skip_prefix(dst, "-", &dst);
                            return !strcasecmp(src, dst);
                    }
                    return 0;
            }

            int is_encoding_utf8(const char *name)
            {
                    if (!name)
                            return 1;
                    if (same_utf_encoding("utf-8", name))
                            return 1;
                    return 0;
            }

            int same_encoding(const char *src, const char *dst)
            {
                    static const char utf8[] = "UTF-8";

                    if (!src)
                            src = utf8;
                    if (!dst)
                            dst = utf8;
                    if (same_utf_encoding(src, dst))
                            return 1;
                    return !strcasecmp(src, dst);
            }

            /*
            * Wrapper for fprintf and returns the total number of columns required
            * for the printed string, assuming that the string is utf8.
            */
            int utf8_fprintf(FILE *stream, const char *format, ...)
            {
                    struct strbuf buf = STRBUF_INIT;
                    va_list arg;
                    int columns;

                    va_start(arg, format);
                    strbuf_vaddf(&buf, format, arg);
                    va_end(arg);

                    columns = fputs(buf.buf, stream);
                    if (0 <= columns) /* keep the error from the I/O */
                            columns = utf8_strwidth(buf.buf);
                    strbuf_release(&buf);
                    return columns;
            }

            /*
            * Given a buffer and its encoding, return it re-encoded
            * with iconv.  If the conversion fails, returns NULL.
            */
            #ifndef NO_ICONV
            #if defined(OLD_ICONV) || (defined(__sun__) && !defined(_XPG6))
                    typedef const char * iconv_ibp;
            #else
                    typedef char * iconv_ibp;
            #endif
            char *reencode_string_iconv(const char *in, size_t insz, iconv_t conv,
                                    size_t bom_len, size_t *outsz_p)
            {
                    size_t outsz, outalloc;
                    char *out, *outpos;
                    iconv_ibp cp;

                    outsz = insz;
                    outalloc = st_add(outsz, 1 + bom_len); /* for terminating NUL */
                    out = xmalloc(outalloc);
                    outpos = out + bom_len;
                    cp = (iconv_ibp)in;

                    while (1) {
                            size_t cnt = iconv(conv, &cp, &insz, &outpos, &outsz);

                            if (cnt == (size_t) -1) {
                                    size_t sofar;
                                    if (errno != E2BIG) {
                                            free(out);
                                            return NULL;
                                    }
                                    /* insz has remaining number of bytes.
                                    * since we started outsz the same as insz,
                                    * it is likely that insz is not enough for
                                    * converting the rest.
                                    */
                                    sofar = outpos - out;
                                    outalloc = st_add3(sofar, st_mult(insz, 2), 32);
                                    out = xrealloc(out, outalloc);
                                    outpos = out + sofar;
                                    outsz = outalloc - sofar - 1;
                            }
                            else {
                                    *outpos = '\0';
                                    if (outsz_p)
                                            *outsz_p = outpos - out;
                                    break;
                            }
                    }
                    return out;
            }

            static const char *fallback_encoding(const char *name)
            {
                    /*
                    * Some platforms do not have the variously spelled variants of
                    * UTF-8, so let's fall back to trying the most official
                    * spelling. We do so only as a fallback in case the platform
                    * does understand the user's spelling, but not our official
                    * one.
                    */
                    if (is_encoding_utf8(name))
                            return "UTF-8";

                    /*
                    * Even though latin-1 is still seen in e-mail
                    * headers, some platforms only install ISO-8859-1.
                    */
                    if (!strcasecmp(name, "latin-1"))
                            return "ISO-8859-1";

                    return name;
            }

            char *reencode_string_len(const char *in, size_t insz,
                                    const char *out_encoding, const char *in_encoding,
                                    size_t *outsz)
            {
                    iconv_t conv;
                    char *out;
                    const char *bom_str = NULL;
                    size_t bom_len = 0;

                    if (!in_encoding)
                            return NULL;

                    /* UTF-16LE-BOM is the same as UTF-16 for reading */
                    if (same_utf_encoding("UTF-16LE-BOM", in_encoding))
                            in_encoding = "UTF-16";

                    /*
                    * For writing, UTF-16 iconv typically creates "UTF-16BE-BOM"
                    * Some users under Windows want the little endian version
                    *
                    * We handle UTF-16 and UTF-32 ourselves only if the platform does not
                    * provide a BOM (which we require), since we want to match the behavior
                    * of the system tools and libc as much as possible.
                    */
                    if (same_utf_encoding("UTF-16LE-BOM", out_encoding)) {
                            bom_str = utf16_le_bom;
                            bom_len = sizeof(utf16_le_bom);
                            out_encoding = "UTF-16LE";
                    } else if (same_utf_encoding("UTF-16BE-BOM", out_encoding)) {
                            bom_str = utf16_be_bom;
                            bom_len = sizeof(utf16_be_bom);
                            out_encoding = "UTF-16BE";
            #ifdef ICONV_OMITS_BOM
                    } else if (same_utf_encoding("UTF-16", out_encoding)) {
                            bom_str = utf16_be_bom;
                            bom_len = sizeof(utf16_be_bom);
                            out_encoding = "UTF-16BE";
                    } else if (same_utf_encoding("UTF-32", out_encoding)) {
                            bom_str = utf32_be_bom;
                            bom_len = sizeof(utf32_be_bom);
                            out_encoding = "UTF-32BE";
            #endif
                    }

                    conv = iconv_open(out_encoding, in_encoding);
                    if (conv == (iconv_t) -1) {
                            in_encoding = fallback_encoding(in_encoding);
                            out_encoding = fallback_encoding(out_encoding);

                            conv = iconv_open(out_encoding, in_encoding);
                            if (conv == (iconv_t) -1)
                                    return NULL;
                    }
                    out = reencode_string_iconv(in, insz, conv, bom_len, outsz);
                    iconv_close(conv);
                    if (out && bom_str && bom_len)
                            memcpy(out, bom_str, bom_len);
                    return out;
            }
            #endif

            static int has_bom_prefix(const char *data, size_t len,
                                    const char *bom, size_t bom_len)
            {
                    return data && bom && (len >= bom_len) && !memcmp(data, bom, bom_len);
            }

            int has_prohibited_utf_bom(const char *enc, const char *data, size_t len)
            {
                    return (
                    (same_utf_encoding("UTF-16BE", enc) ||
                    same_utf_encoding("UTF-16LE", enc)) &&
                    (has_bom_prefix(data, len, utf16_be_bom, sizeof(utf16_be_bom)) ||
                    has_bom_prefix(data, len, utf16_le_bom, sizeof(utf16_le_bom)))
                    ) || (
                    (same_utf_encoding("UTF-32BE",  enc) ||
                    same_utf_encoding("UTF-32LE", enc)) &&
                    (has_bom_prefix(data, len, utf32_be_bom, sizeof(utf32_be_bom)) ||
                    has_bom_prefix(data, len, utf32_le_bom, sizeof(utf32_le_bom)))
                    );
            }

            int is_missing_required_utf_bom(const char *enc, const char *data, size_t len)
            {
                    return (
                    (same_utf_encoding(enc, "UTF-16")) &&
                    !(has_bom_prefix(data, len, utf16_be_bom, sizeof(utf16_be_bom)) ||
                    has_bom_prefix(data, len, utf16_le_bom, sizeof(utf16_le_bom)))
                    ) || (
                    (same_utf_encoding(enc, "UTF-32")) &&
                    !(has_bom_prefix(data, len, utf32_be_bom, sizeof(utf32_be_bom)) ||
                    has_bom_prefix(data, len, utf32_le_bom, sizeof(utf32_le_bom)))
                    );
            }

            /*
            * Returns first character length in bytes for multi-byte `text` according to
            * `encoding`.
            *
            * - The `text` pointer is updated to point at the next character.
            * - When `remainder_p` is not NULL, on entry `*remainder_p` is how much bytes
            *   we can consume from text, and on exit `*remainder_p` is reduced by returned
            *   character length. Otherwise `text` is treated as limited by NUL.
            */
            int mbs_chrlen(const char **text, size_t *remainder_p, const char *encoding)
            {
                    int chrlen;
                    const char *p = *text;
                    size_t r = (remainder_p ? *remainder_p : SIZE_MAX);

                    if (r < 1)
                            return 0;

                    if (is_encoding_utf8(encoding)) {
                            pick_one_utf8_char(&p, &r);

                            chrlen = p ? (p - *text)
                                    : 1 /* not valid UTF-8 -> raw byte sequence */;
                    }
                    else {
                            /*
                            * TODO use iconv to decode one char and obtain its chrlen
                            * for now, let's treat encodings != UTF-8 as one-byte
                            */
                            chrlen = 1;
                    }

                    *text += chrlen;
                    if (remainder_p)
                            *remainder_p -= chrlen;

                    return chrlen;
            }

            /*
            * Pick the next char from the stream, ignoring codepoints an HFS+ would.
            * Note that this is _not_ complete by any means. It's just enough
            * to make is_hfs_dotgit() work, and should not be used otherwise.
            */
            static ucs_char_t next_hfs_char(const char **in)
            {
                    while (1) {
                            ucs_char_t out = pick_one_utf8_char(in, NULL);
                            /*
                            * check for malformed utf8. Technically this
                            * gets converted to a percent-sequence, but
                            * returning 0 is good enough for is_hfs_dotgit
                            * to realize it cannot be .git
                            */
                            if (!*in)
                                    return 0;

                            /* these code points are ignored completely */
                            switch (out) {
                            case 0x200c: /* ZERO WIDTH NON-JOINER */
                            case 0x200d: /* ZERO WIDTH JOINER */
                            case 0x200e: /* LEFT-TO-RIGHT MARK */
                            case 0x200f: /* RIGHT-TO-LEFT MARK */
                            case 0x202a: /* LEFT-TO-RIGHT EMBEDDING */
                            case 0x202b: /* RIGHT-TO-LEFT EMBEDDING */
                            case 0x202c: /* POP DIRECTIONAL FORMATTING */
                            case 0x202d: /* LEFT-TO-RIGHT OVERRIDE */
                            case 0x202e: /* RIGHT-TO-LEFT OVERRIDE */
                            case 0x206a: /* INHIBIT SYMMETRIC SWAPPING */
                            case 0x206b: /* ACTIVATE SYMMETRIC SWAPPING */
                            case 0x206c: /* INHIBIT ARABIC FORM SHAPING */
                            case 0x206d: /* ACTIVATE ARABIC FORM SHAPING */
                            case 0x206e: /* NATIONAL DIGIT SHAPES */
                            case 0x206f: /* NOMINAL DIGIT SHAPES */
                            case 0xfeff: /* ZERO WIDTH NO-BREAK SPACE */
                                    continue;
                            }

                            return out;
                    }
            }

            static int is_hfs_dot_generic(const char *path,
                                    const char *needle, size_t needle_len)
            {
                    ucs_char_t c;

                    c = next_hfs_char(&path);
                    if (c != '.')
                            return 0;

                    /*
                    * there's a great deal of other case-folding that occurs
                    * in HFS+, but this is enough to catch our fairly vanilla
                    * hard-coded needles.
                    */
                    for (; needle_len > 0; needle++, needle_len--) {
                            c = next_hfs_char(&path);

                            /*
                            * We know our needles contain only ASCII, so we clamp here to
                            * make the results of tolower() sane.
                            */
                            if (c > 127)
                                    return 0;
                            if (tolower(c) != *needle)
                                    return 0;
                    }

                    c = next_hfs_char(&path);
                    if (c && !is_dir_sep(c))
                            return 0;

                    return 1;
            }

            /*
            * Inline wrapper to make sure the compiler resolves strlen() on literals at
            * compile time.
            */
            static inline int is_hfs_dot_str(const char *path, const char *needle)
            {
                    return is_hfs_dot_generic(path, needle, strlen(needle));
            }

            int is_hfs_dotgit(const char *path)
            {
                    return is_hfs_dot_str(path, "git");
            }

            int is_hfs_dotgitmodules(const char *path)
            {
                    return is_hfs_dot_str(path, "gitmodules");
            }

            int is_hfs_dotgitignore(const char *path)
            {
                    return is_hfs_dot_str(path, "gitignore");
            }

            int is_hfs_dotgitattributes(const char *path)
            {
                    return is_hfs_dot_str(path, "gitattributes");
            }

            int is_hfs_dotmailmap(const char *path)
            {
                    return is_hfs_dot_str(path, "mailmap");
            }

            const char utf8_bom[] = "\357\273\277";

            int skip_utf8_bom(char **text, size_t len)
            {
                    if (len < strlen(utf8_bom) ||
                    memcmp(*text, utf8_bom, strlen(utf8_bom)))
                            return 0;
                    *text += strlen(utf8_bom);
                    return 1;
            }

            void strbuf_utf8_align(struct strbuf *buf, align_type position, unsigned int width,
                            const char *s)
            {
                    size_t slen = strlen(s);
                    int display_len = utf8_strnwidth(s, slen, 0);
                    int utf8_compensation = slen - display_len;

                    if (display_len >= width) {
                            strbuf_addstr(buf, s);
                            return;
                    }

                    if (position == ALIGN_LEFT)
                            strbuf_addf(buf, "%-*s", width + utf8_compensation, s);
                    else if (position == ALIGN_MIDDLE) {
                            int left = (width - display_len) / 2;
                            strbuf_addf(buf, "%*s%-*s", left, "", width - left + utf8_compensation, s);
                    } else if (position == ALIGN_RIGHT)
                            strbuf_addf(buf, "%*s", width + utf8_compensation, s);
            }



            """,
            "Error":"The patch ensures that ISO8859-1 is reinterpreted as UTF-8 on z/OS, aligning with the platform's historical usage and expectations.
                    Encoding conversions behave consistently and reliably, reducing errors and improving compatibility.
                    The change is limited to z/OS (__MVS__), so behavior on other platforms remains unaffected.",

            "Error Category":"Functionality Pache",
            "Corrected Code":
            """
            #define DISABLE_SIGN_COMPARE_WARNINGS

            #include "git-compat-util.h"
            #include "strbuf.h"
            #include "utf8.h"
            #ifdef __MVS__
            extern int utf8_ccsid;
            #endif

            /* This code is originally from https://www.cl.cam.ac.uk/~mgk25/ucs/ */

            static const char utf16_be_bom[] = {'\xFE', '\xFF'};
            static const char utf16_le_bom[] = {'\xFF', '\xFE'};
            static const char utf32_be_bom[] = {'\0', '\0', '\xFE', '\xFF'};
            static const char utf32_le_bom[] = {'\xFF', '\xFE', '\0', '\0'};

            struct interval {
                    ucs_char_t first;
                    ucs_char_t last;
            };

            size_t display_mode_esc_sequence_len(const char *s)
            {
                    const char *p = s;
                    if (*p++ != '\033')
                            return 0;
                    if (*p++ != '[')
                            return 0;
                    while (isdigit(*p) || *p == ';')
                            p++;
                    if (*p++ != 'm')
                            return 0;
                    return p - s;
            }

            /* auxiliary function for binary search in interval table */
            static int bisearch(ucs_char_t ucs, const struct interval *table, int max)
            {
                    int min = 0;
                    int mid;

                    if (ucs < table[0].first || ucs > table[max].last)
                            return 0;
                    while (max >= min) {
                            mid = min + (max - min) / 2;
                            if (ucs > table[mid].last)
                                    min = mid + 1;
                            else if (ucs < table[mid].first)
                                    max = mid - 1;
                            else
                                    return 1;
                    }

                    return 0;
            }

            /* The following two functions define the column width of an ISO 10646
            * character as follows:
            *
            *    - The null character (U+0000) has a column width of 0.
            *
            *    - Other C0/C1 control characters and DEL will lead to a return
            *      value of -1.
            *
            *    - Non-spacing and enclosing combining characters (general
            *      category code Mn or Me in the Unicode database) have a
            *      column width of 0.
            *
            *    - SOFT HYPHEN (U+00AD) has a column width of 1.
            *
            *    - Other format characters (general category code Cf in the Unicode
            *      database) and ZERO WIDTH SPACE (U+200B) have a column width of 0.
            *
            *    - Hangul Jamo medial vowels and final consonants (U+1160-U+11FF)
            *      have a column width of 0.
            *
            *    - Spacing characters in the East Asian Wide (W) or East Asian
            *      Full-width (F) category as defined in Unicode Technical
            *      Report #11 have a column width of 2.
            *
            *    - All remaining characters (including all printable
            *      ISO 8859-1 and WGL4 characters, Unicode control characters,
            *      etc.) have a column width of 1.
            *
            * This implementation assumes that ucs_char_t characters are encoded
            * in ISO 10646.
            */

            static int git_wcwidth(ucs_char_t ch)
            {
                    /*
                    * Sorted list of non-overlapping intervals of non-spacing characters,
                    */
            #include "unicode-width.h"

                    /* test for 8-bit control characters */
                    if (ch == 0)
                            return 0;
                    if (ch < 32 || (ch >= 0x7f && ch < 0xa0))
                            return -1;

                    /* binary search in table of non-spacing characters */
                    if (bisearch(ch, zero_width, ARRAY_SIZE(zero_width) - 1))
                            return 0;

                    /* binary search in table of double width characters */
                    if (bisearch(ch, double_width, ARRAY_SIZE(double_width) - 1))
                            return 2;

                    return 1;
            }

            /*
            * Pick one ucs character starting from the location *start points at,
            * and return it, while updating the *start pointer to point at the
            * end of that character.  When remainder_p is not NULL, the location
            * holds the number of bytes remaining in the string that we are allowed
            * to pick from.  Otherwise we are allowed to pick up to the NUL that
            * would eventually appear in the string.  *remainder_p is also reduced
            * by the number of bytes we have consumed.
            *
            * If the string was not a valid UTF-8, *start pointer is set to NULL
            * and the return value is undefined.
            */
            static ucs_char_t pick_one_utf8_char(const char **start, size_t *remainder_p)
            {
                    unsigned char *s = (unsigned char *)*start;
                    ucs_char_t ch;
                    size_t remainder, incr;

                    /*
                    * A caller that assumes NUL terminated text can choose
                    * not to bother with the remainder length.  We will
                    * stop at the first NUL.
                    */
                    remainder = (remainder_p ? *remainder_p : 999);

                    if (remainder < 1) {
                            goto invalid;
                    } else if (*s < 0x80) {
                            /* 0xxxxxxx */
                            ch = *s;
                            incr = 1;
                    } else if ((s[0] & 0xe0) == 0xc0) {
                            /* 110XXXXx 10xxxxxx */
                            if (remainder < 2 ||
                            (s[1] & 0xc0) != 0x80 ||
                            (s[0] & 0xfe) == 0xc0)
                                    goto invalid;
                            ch = ((s[0] & 0x1f) << 6) | (s[1] & 0x3f);
                            incr = 2;
                    } else if ((s[0] & 0xf0) == 0xe0) {
                            /* 1110XXXX 10Xxxxxx 10xxxxxx */
                            if (remainder < 3 ||
                            (s[1] & 0xc0) != 0x80 ||
                            (s[2] & 0xc0) != 0x80 ||
                            /* overlong? */
                            (s[0] == 0xe0 && (s[1] & 0xe0) == 0x80) ||
                            /* surrogate? */
                            (s[0] == 0xed && (s[1] & 0xe0) == 0xa0) ||
                            /* U+FFFE or U+FFFF? */
                            (s[0] == 0xef && s[1] == 0xbf &&
                            (s[2] & 0xfe) == 0xbe))
                                    goto invalid;
                            ch = ((s[0] & 0x0f) << 12) |
                                    ((s[1] & 0x3f) << 6) | (s[2] & 0x3f);
                            incr = 3;
                    } else if ((s[0] & 0xf8) == 0xf0) {
                            /* 11110XXX 10XXxxxx 10xxxxxx 10xxxxxx */
                            if (remainder < 4 ||
                            (s[1] & 0xc0) != 0x80 ||
                            (s[2] & 0xc0) != 0x80 ||
                            (s[3] & 0xc0) != 0x80 ||
                            /* overlong? */
                            (s[0] == 0xf0 && (s[1] & 0xf0) == 0x80) ||
                            /* > U+10FFFF? */
                            (s[0] == 0xf4 && s[1] > 0x8f) || s[0] > 0xf4)
                                    goto invalid;
                            ch = ((s[0] & 0x07) << 18) | ((s[1] & 0x3f) << 12) |
                                    ((s[2] & 0x3f) << 6) | (s[3] & 0x3f);
                            incr = 4;
                    } else {
            invalid:
                            *start = NULL;
                            return 0;
                    }

                    *start += incr;
                    if (remainder_p)
                            *remainder_p = remainder - incr;
                    return ch;
            }

            /*
            * This function returns the number of columns occupied by the character
            * pointed to by the variable start. The pointer is updated to point at
            * the next character. When remainder_p is not NULL, it points at the
            * location that stores the number of remaining bytes we can use to pick
            * a character (see pick_one_utf8_char() above).
            */
            int utf8_width(const char **start, size_t *remainder_p)
            {
                    ucs_char_t ch = pick_one_utf8_char(start, remainder_p);
                    if (!*start)
                            return 0;
                    return git_wcwidth(ch);
            }

            /*
            * Returns the total number of columns required by a null-terminated
            * string, assuming that the string is utf8.  Returns strlen() instead
            * if the string does not look like a valid utf8 string.
            */
            int utf8_strnwidth(const char *string, size_t len, int skip_ansi)
            {
                    const char *orig = string;
                    size_t width = 0;

                    while (string && string < orig + len) {
                            int glyph_width;
                            size_t skip;

                            while (skip_ansi &&
                            (skip = display_mode_esc_sequence_len(string)) != 0)
                                    string += skip;

                            glyph_width = utf8_width(&string, NULL);
                            if (glyph_width > 0)
                                    width += glyph_width;
                    }

                    /*
                    * TODO: fix the interface of this function and `utf8_strwidth()` to
                    * return `size_t` instead of `int`.
                    */
                    return cast_size_t_to_int(string ? width : len);
            }

            int utf8_strwidth(const char *string)
            {
                    return utf8_strnwidth(string, strlen(string), 0);
            }

            int is_utf8(const char *text)
            {
                    while (*text) {
                            if (*text == '\n' || *text == '\t' || *text == '\r') {
                                    text++;
                                    continue;
                            }
                            utf8_width(&text, NULL);
                            if (!text)
                                    return 0;
                    }
                    return 1;
            }

            static void strbuf_add_indented_text(struct strbuf *buf, const char *text,
                                            int indent, int indent2)
            {
                    if (indent < 0)
                            indent = 0;
                    while (*text) {
                            const char *eol = strchrnul(text, '\n');
                            if (*eol == '\n')
                                    eol++;
                            strbuf_addchars(buf, ' ', indent);
                            strbuf_add(buf, text, eol - text);
                            text = eol;
                            indent = indent2;
                    }
            }

            /*
            * Wrap the text, if necessary. The variable indent is the indent for the
            * first line, indent2 is the indent for all other lines.
            * If indent is negative, assume that already -indent columns have been
            * consumed (and no extra indent is necessary for the first line).
            */
            void strbuf_add_wrapped_text(struct strbuf *buf,
                            const char *text, int indent1, int indent2, int width)
            {
                    int indent, w, assume_utf8 = 1;
                    const char *bol, *space, *start = text;
                    size_t orig_len = buf->len;

                    if (width <= 0) {
                            strbuf_add_indented_text(buf, text, indent1, indent2);
                            return;
                    }

            retry:
                    bol = text;
                    w = indent = indent1;
                    space = NULL;
                    if (indent < 0) {
                            w = -indent;
                            space = text;
                    }

                    for (;;) {
                            char c;
                            size_t skip;

                            while ((skip = display_mode_esc_sequence_len(text)))
                                    text += skip;

                            c = *text;
                            if (!c || isspace(c)) {
                                    if (w <= width || !space) {
                                            const char *start = bol;
                                            if (!c && text == start)
                                                    return;
                                            if (space)
                                                    start = space;
                                            else
                                                    strbuf_addchars(buf, ' ', indent);
                                            strbuf_add(buf, start, text - start);
                                            if (!c)
                                                    return;
                                            space = text;
                                            if (c == '\t')
                                                    w |= 0x07;
                                            else if (c == '\n') {
                                                    space++;
                                                    if (*space == '\n') {
                                                            strbuf_addch(buf, '\n');
                                                            goto new_line;
                                                    }
                                                    else if (!isalnum(*space))
                                                            goto new_line;
                                                    else
                                                            strbuf_addch(buf, ' ');
                                            }
                                            w++;
                                            text++;
                                    }
                                    else {
            new_line:
                                            strbuf_addch(buf, '\n');
                                            text = bol = space + isspace(*space);
                                            space = NULL;
                                            w = indent = indent2;
                                    }
                                    continue;
                            }
                            if (assume_utf8) {
                                    w += utf8_width(&text, NULL);
                                    if (!text) {
                                            assume_utf8 = 0;
                                            text = start;
                                            strbuf_setlen(buf, orig_len);
                                            goto retry;
                                    }
                            } else {
                                    w++;
                                    text++;
                            }
                    }
            }

            void strbuf_add_wrapped_bytes(struct strbuf *buf, const char *data, int len,
                                    int indent, int indent2, int width)
            {
                    char *tmp = xstrndup(data, len);
                    strbuf_add_wrapped_text(buf, tmp, indent, indent2, width);
                    free(tmp);
            }

            void strbuf_utf8_replace(struct strbuf *sb_src, int pos, int width,
                                    const char *subst)
            {
                    const char *src = sb_src->buf, *end = sb_src->buf + sb_src->len;
                    struct strbuf dst;
                    int w = 0;

                    strbuf_init(&dst, sb_src->len);

                    while (src < end) {
                            const char *old;
                            int glyph_width;
                            size_t n;

                            while ((n = display_mode_esc_sequence_len(src))) {
                                    strbuf_add(&dst, src, n);
                                    src += n;
                            }

                            if (src >= end)
                                    break;

                            old = src;
                            glyph_width = utf8_width((const char**)&src, NULL);
                            if (!src) /* broken utf-8, do nothing */
                                    goto out;

                            /*
                            * In case we see a control character we copy it into the
                            * buffer, but don't add it to the width.
                            */
                            if (glyph_width < 0)
                                    glyph_width = 0;

                            if (glyph_width && w >= pos && w < pos + width) {
                                    if (subst) {
                                            strbuf_addstr(&dst, subst);
                                            subst = NULL;
                                    }
                            } else {
                                    strbuf_add(&dst, old, src - old);
                            }

                            w += glyph_width;
                    }

                    strbuf_swap(sb_src, &dst);
            out:
                    strbuf_release(&dst);
            }

            /*
            * Returns true (1) if the src encoding name matches the dst encoding
            * name directly or one of its alternative names. E.g. UTF-16BE is the
            * same as UTF16BE.
            */
            static int same_utf_encoding(const char *src, const char *dst)
            {
                    if (skip_iprefix(src, "utf", &src) && skip_iprefix(dst, "utf", &dst)) {
                            skip_prefix(src, "-", &src);
                            skip_prefix(dst, "-", &dst);
                            return !strcasecmp(src, dst);
                    }
                    return 0;
            }

            int is_encoding_utf8(const char *name)
            {
                    if (!name)
                            return 1;
                    if (same_utf_encoding("utf-8", name))
                            return 1;
                    return 0;
            }

            int same_encoding(const char *src, const char *dst)
            {
                    static const char utf8[] = "UTF-8";

                    if (!src)
                            src = utf8;
                    if (!dst)
                            dst = utf8;
                    if (same_utf_encoding(src, dst))
                            return 1;
                    return !strcasecmp(src, dst);
            }

            /*
            * Wrapper for fprintf and returns the total number of columns required
            * for the printed string, assuming that the string is utf8.
            */
            int utf8_fprintf(FILE *stream, const char *format, ...)
            {
                    struct strbuf buf = STRBUF_INIT;
                    va_list arg;
                    int columns;

                    va_start(arg, format);
                    strbuf_vaddf(&buf, format, arg);
                    va_end(arg);

                    columns = fputs(buf.buf, stream);
                    if (0 <= columns) /* keep the error from the I/O */
                            columns = utf8_strwidth(buf.buf);
                    strbuf_release(&buf);
                    return columns;
            }

            /*
            * Given a buffer and its encoding, return it re-encoded
            * with iconv.  If the conversion fails, returns NULL.
            */
            #ifndef NO_ICONV
            #if defined(OLD_ICONV) || (defined(__sun__) && !defined(_XPG6))
                    typedef const char * iconv_ibp;
            #else
                    typedef char * iconv_ibp;
            #endif
            char *reencode_string_iconv(const char *in, size_t insz, iconv_t conv,
                                    size_t bom_len, size_t *outsz_p)
            {
                    size_t outsz, outalloc;
                    char *out, *outpos;
                    iconv_ibp cp;

                    outsz = insz;
                    outalloc = st_add(outsz, 1 + bom_len); /* for terminating NUL */
                    out = xmalloc(outalloc);
                    outpos = out + bom_len;
                    cp = (iconv_ibp)in;

                    while (1) {
                            size_t cnt = iconv(conv, &cp, &insz, &outpos, &outsz);

                            if (cnt == (size_t) -1) {
                                    size_t sofar;
                                    if (errno != E2BIG) {
                                            free(out);
                                            return NULL;
                                    }
                                    /* insz has remaining number of bytes.
                                    * since we started outsz the same as insz,
                                    * it is likely that insz is not enough for
                                    * converting the rest.
                                    */
                                    sofar = outpos - out;
                                    outalloc = st_add3(sofar, st_mult(insz, 2), 32);
                                    out = xrealloc(out, outalloc);
                                    outpos = out + sofar;
                                    outsz = outalloc - sofar - 1;
                            }
                            else {
                                    *outpos = '\0';
                                    if (outsz_p)
                                            *outsz_p = outpos - out;
                                    break;
                            }
                    }
                    return out;
            }

            static const char *fallback_encoding(const char *name)
            {
                    /*
                    * Some platforms do not have the variously spelled variants of
                    * UTF-8, so let's fall back to trying the most official
                    * spelling. We do so only as a fallback in case the platform
                    * does understand the user's spelling, but not our official
                    * one.
                    */
                    if (is_encoding_utf8(name))
                            return "UTF-8";

                    /*
                    * Even though latin-1 is still seen in e-mail
                    * headers, some platforms only install ISO-8859-1.
                    */
                    if (!strcasecmp(name, "latin-1"))
                            return "ISO-8859-1";

                    return name;
            }

            char *reencode_string_len(const char *in, size_t insz,
                                    const char *out_encoding, const char *in_encoding,
                                    size_t *outsz)
            {
                    iconv_t conv;
                    char *out;
                    const char *bom_str = NULL;
                    size_t bom_len = 0;

                    if (!in_encoding)
                            return NULL;

                    /* UTF-16LE-BOM is the same as UTF-16 for reading */
                    if (same_utf_encoding("UTF-16LE-BOM", in_encoding))
                            in_encoding = "UTF-16";

                    /*
                    * For writing, UTF-16 iconv typically creates "UTF-16BE-BOM"
                    * Some users under Windows want the little endian version
                    *
                    * We handle UTF-16 and UTF-32 ourselves only if the platform does not
                    * provide a BOM (which we require), since we want to match the behavior
                    * of the system tools and libc as much as possible.
                    */
                    if (same_utf_encoding("UTF-16LE-BOM", out_encoding)) {
                            bom_str = utf16_le_bom;
                            bom_len = sizeof(utf16_le_bom);
                            out_encoding = "UTF-16LE";
                    } else if (same_utf_encoding("UTF-16BE-BOM", out_encoding)) {
                            bom_str = utf16_be_bom;
                            bom_len = sizeof(utf16_be_bom);
                            out_encoding = "UTF-16BE";
            #ifdef ICONV_OMITS_BOM
                    } else if (same_utf_encoding("UTF-16", out_encoding)) {
                            bom_str = utf16_be_bom;
                            bom_len = sizeof(utf16_be_bom);
                            out_encoding = "UTF-16BE";
                    } else if (same_utf_encoding("UTF-32", out_encoding)) {
                            bom_str = utf32_be_bom;
                            bom_len = sizeof(utf32_be_bom);
                            out_encoding = "UTF-32BE";
            #endif
                    }

            #ifdef __MVS__
            if (utf8_ccsid == 819) {
            //HACK: For backwards compat UTF CCSID=819, ISO8859-1 really means utf-8 in the z/OS world
            if (strcasecmp("ISO8859-1", in_encoding) == 0) {
            in_encoding = "UTF-8";
            out_encoding = "UTF-8";
            }
            if (strcasecmp("ISO8859-1", out_encoding) == 0) {
            in_encoding = "UTF-8";
            out_encoding = "UTF-8";
            }
            }
            #endif

                    conv = iconv_open(out_encoding, in_encoding);
                    if (conv == (iconv_t) -1) {
                            in_encoding = fallback_encoding(in_encoding);
                            out_encoding = fallback_encoding(out_encoding);

                            conv = iconv_open(out_encoding, in_encoding);
                            if (conv == (iconv_t) -1)
                                    return NULL;
                    }
                    out = reencode_string_iconv(in, insz, conv, bom_len, outsz);
                    iconv_close(conv);
                    if (out && bom_str && bom_len)
                            memcpy(out, bom_str, bom_len);
                    return out;
            }
            #endif

            static int has_bom_prefix(const char *data, size_t len,
                                    const char *bom, size_t bom_len)
            {
                    return data && bom && (len >= bom_len) && !memcmp(data, bom, bom_len);
            }

            int has_prohibited_utf_bom(const char *enc, const char *data, size_t len)
            {
                    return (
                    (same_utf_encoding("UTF-16BE", enc) ||
                    same_utf_encoding("UTF-16LE", enc)) &&
                    (has_bom_prefix(data, len, utf16_be_bom, sizeof(utf16_be_bom)) ||
                    has_bom_prefix(data, len, utf16_le_bom, sizeof(utf16_le_bom)))
                    ) || (
                    (same_utf_encoding("UTF-32BE",  enc) ||
                    same_utf_encoding("UTF-32LE", enc)) &&
                    (has_bom_prefix(data, len, utf32_be_bom, sizeof(utf32_be_bom)) ||
                    has_bom_prefix(data, len, utf32_le_bom, sizeof(utf32_le_bom)))
                    );
            }

            int is_missing_required_utf_bom(const char *enc, const char *data, size_t len)
            {
                    return (
                    (same_utf_encoding(enc, "UTF-16")) &&
                    !(has_bom_prefix(data, len, utf16_be_bom, sizeof(utf16_be_bom)) ||
                    has_bom_prefix(data, len, utf16_le_bom, sizeof(utf16_le_bom)))
                    ) || (
                    (same_utf_encoding(enc, "UTF-32")) &&
                    !(has_bom_prefix(data, len, utf32_be_bom, sizeof(utf32_be_bom)) ||
                    has_bom_prefix(data, len, utf32_le_bom, sizeof(utf32_le_bom)))
                    );
            }

            /*
            * Returns first character length in bytes for multi-byte `text` according to
            * `encoding`.
            *
            * - The `text` pointer is updated to point at the next character.
            * - When `remainder_p` is not NULL, on entry `*remainder_p` is how much bytes
            *   we can consume from text, and on exit `*remainder_p` is reduced by returned
            *   character length. Otherwise `text` is treated as limited by NUL.
            */
            int mbs_chrlen(const char **text, size_t *remainder_p, const char *encoding)
            {
                    int chrlen;
                    const char *p = *text;
                    size_t r = (remainder_p ? *remainder_p : SIZE_MAX);

                    if (r < 1)
                            return 0;

                    if (is_encoding_utf8(encoding)) {
                            pick_one_utf8_char(&p, &r);

                            chrlen = p ? (p - *text)
                                    : 1 /* not valid UTF-8 -> raw byte sequence */;
                    }
                    else {
                            /*
                            * TODO use iconv to decode one char and obtain its chrlen
                            * for now, let's treat encodings != UTF-8 as one-byte
                            */
                            chrlen = 1;
                    }

                    *text += chrlen;
                    if (remainder_p)
                            *remainder_p -= chrlen;

                    return chrlen;
            }

            /*
            * Pick the next char from the stream, ignoring codepoints an HFS+ would.
            * Note that this is _not_ complete by any means. It's just enough
            * to make is_hfs_dotgit() work, and should not be used otherwise.
            */
            static ucs_char_t next_hfs_char(const char **in)
            {
                    while (1) {
                            ucs_char_t out = pick_one_utf8_char(in, NULL);
                            /*
                            * check for malformed utf8. Technically this
                            * gets converted to a percent-sequence, but
                            * returning 0 is good enough for is_hfs_dotgit
                            * to realize it cannot be .git
                            */
                            if (!*in)
                                    return 0;

                            /* these code points are ignored completely */
                            switch (out) {
                            case 0x200c: /* ZERO WIDTH NON-JOINER */
                            case 0x200d: /* ZERO WIDTH JOINER */
                            case 0x200e: /* LEFT-TO-RIGHT MARK */
                            case 0x200f: /* RIGHT-TO-LEFT MARK */
                            case 0x202a: /* LEFT-TO-RIGHT EMBEDDING */
                            case 0x202b: /* RIGHT-TO-LEFT EMBEDDING */
                            case 0x202c: /* POP DIRECTIONAL FORMATTING */
                            case 0x202d: /* LEFT-TO-RIGHT OVERRIDE */
                            case 0x202e: /* RIGHT-TO-LEFT OVERRIDE */
                            case 0x206a: /* INHIBIT SYMMETRIC SWAPPING */
                            case 0x206b: /* ACTIVATE SYMMETRIC SWAPPING */
                            case 0x206c: /* INHIBIT ARABIC FORM SHAPING */
                            case 0x206d: /* ACTIVATE ARABIC FORM SHAPING */
                            case 0x206e: /* NATIONAL DIGIT SHAPES */
                            case 0x206f: /* NOMINAL DIGIT SHAPES */
                            case 0xfeff: /* ZERO WIDTH NO-BREAK SPACE */
                                    continue;
                            }

                            return out;
                    }
            }

            static int is_hfs_dot_generic(const char *path,
                                    const char *needle, size_t needle_len)
            {
                    ucs_char_t c;

                    c = next_hfs_char(&path);
                    if (c != '.')
                            return 0;

                    /*
                    * there's a great deal of other case-folding that occurs
                    * in HFS+, but this is enough to catch our fairly vanilla
                    * hard-coded needles.
                    */
                    for (; needle_len > 0; needle++, needle_len--) {
                            c = next_hfs_char(&path);

                            /*
                            * We know our needles contain only ASCII, so we clamp here to
                            * make the results of tolower() sane.
                            */
                            if (c > 127)
                                    return 0;
                            if (tolower(c) != *needle)
                                    return 0;
                    }

                    c = next_hfs_char(&path);
                    if (c && !is_dir_sep(c))
                            return 0;

                    return 1;
            }

            /*
            * Inline wrapper to make sure the compiler resolves strlen() on literals at
            * compile time.
            */
            static inline int is_hfs_dot_str(const char *path, const char *needle)
            {
                    return is_hfs_dot_generic(path, needle, strlen(needle));
            }

            int is_hfs_dotgit(const char *path)
            {
                    return is_hfs_dot_str(path, "git");
            }

            int is_hfs_dotgitmodules(const char *path)
            {
                    return is_hfs_dot_str(path, "gitmodules");
            }

            int is_hfs_dotgitignore(const char *path)
            {
                    return is_hfs_dot_str(path, "gitignore");
            }

            int is_hfs_dotgitattributes(const char *path)
            {
                    return is_hfs_dot_str(path, "gitattributes");
            }

            int is_hfs_dotmailmap(const char *path)
            {
                    return is_hfs_dot_str(path, "mailmap");
            }

            const char utf8_bom[] = "\357\273\277";

            int skip_utf8_bom(char **text, size_t len)
            {
                    if (len < strlen(utf8_bom) ||
                    memcmp(*text, utf8_bom, strlen(utf8_bom)))
                            return 0;
                    *text += strlen(utf8_bom);
                    return 1;
            }

            void strbuf_utf8_align(struct strbuf *buf, align_type position, unsigned int width,
                            const char *s)
            {
                    size_t slen = strlen(s);
                    int display_len = utf8_strnwidth(s, slen, 0);
                    int utf8_compensation = slen - display_len;

                    if (display_len >= width) {
                            strbuf_addstr(buf, s);
                            return;
                    }

                    if (position == ALIGN_LEFT)
                            strbuf_addf(buf, "%-*s", width + utf8_compensation, s);
                    else if (position == ALIGN_MIDDLE) {
                            int left = (width - display_len) / 2;
                            strbuf_addf(buf, "%*s%-*s", left, "", width - left + utf8_compensation, s);
                    } else if (position == ALIGN_RIGHT)
                            strbuf_addf(buf, "%*s", width + utf8_compensation, s);
            }


            """,
            "Patche":
            """
                            diff --git a/utf8.c b/utf8.c
            index 35a0251939..b5877f22f0 100644
            --- a/utf8.c
            +++ b/utf8.c
            @@ -3,6 +3,9 @@
            #include "git-compat-util.h"
            #include "strbuf.h"
            #include "utf8.h"
            +#ifdef __MVS__
            +extern int utf8_ccsid;
            +#endif

            /* This code is originally from https://www.cl.cam.ac.uk/~mgk25/ucs/ */

            @@ -592,6 +595,20 @@ char *reencode_string_len(const char *in, size_t insz,
            #endif
                    }

            +#ifdef __MVS__
            +  if (utf8_ccsid == 819) {
            +    //HACK: For backwards compat UTF CCSID=819, ISO8859-1 really means utf-8 in the z/OS world
            +    if (strcasecmp("ISO8859-1", in_encoding) == 0) {
            +      in_encoding = "UTF-8";
            +      out_encoding = "UTF-8";
            +    }
            +    if (strcasecmp("ISO8859-1", out_encoding) == 0) {
            +      in_encoding = "UTF-8";
            +      out_encoding = "UTF-8";
            +    }
            +  }
            +#endif
            +
                    conv = iconv_open(out_encoding, in_encoding);
                    if (conv == (iconv_t) -1) {
                            in_encoding = fallback_encoding(in_encoding);



            """,
                    },
```

\]
